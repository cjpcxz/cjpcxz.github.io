<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图元</title>
    <url>/2024/02/20/OpenGL/%E5%9B%BE%E5%85%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="图元"><a href="#图元" class="headerlink" title="图元"></a>图元</h1><blockquote>
<ul>
<li>像素是计算机屏幕上显示的最小元素，以下是最简单额计算机图形；在计算机屏幕绘制一个点，并将它设置一个特点的颜色。在这个简单的基础上慢慢学会创建线，多边形，圆和其他性质和图形。</li>
<li>OpenGl在计算机屏幕上进行绘图则完全不同，不关心物理屏幕坐标和像素，关注的是视景体中的位置坐标。将这些点，线和三角形从创建3D空间投影到计算机屏幕上的2D图形则是着色器程序和光栅化硬件所要完成的工作。</li>
</ul>
</blockquote>
<h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><blockquote>
<p>点是最简单的图像，每个特定的顶点在屏幕上都仅仅是一个单独的点。默认的情况下，点的大小是一个像素的大小</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">GLfloat vCoast[<span class="hljs-number">24</span>][<span class="hljs-number">3</span>];<span class="hljs-comment">// 点集</span><br><br>GLBatch		pointBatch;<br>pointBatch.<span class="hljs-built_in">CopyVertexData3f</span>(vCoast);<br>pointBatch.<span class="hljs-built_in">End</span>();<br><br><span class="hljs-comment">// 修改点的大小为4.0f</span><br><span class="hljs-built_in">glPointSize</span>(<span class="hljs-number">4.0f</span>);<br><span class="hljs-comment">// 设置点的大小范围和点与点之间的间隔</span><br>GLfloat sizes[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">2.0f</span>,<span class="hljs-number">4.0f</span>&#125;; <br>GLfloat step = <span class="hljs-number">1.0f</span>;<br><span class="hljs-built_in">glGetFloatv</span>(GL_POINT_SIZE_RANGE, size);<br><span class="hljs-built_in">glGetFloatv</span>(GL_POINT_SIZE_GRANULARITY, &amp;step);<br><br>... <span class="hljs-comment">//使用平面着色器</span><br><br><span class="hljs-comment">// 绘制</span><br> pointBatch.<span class="hljs-built_in">Draw</span>();<br></code></pre></td></tr></table></figure>

<h2 id="线"><a href="#线" class="headerlink" title="线"></a>线</h2><blockquote>
<p>比点更进一步的就是独立线段了。一个线段就是2个顶点之间绘制的。默认情况下，线段的宽度是一个像素，改变线段唯一的方式</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">GLBatch	lineBatch;<br>lineBatch.<span class="hljs-built_in">Begin</span>(GL_LINES, <span class="hljs-number">24</span>);<br>lineBatch.<span class="hljs-built_in">CopyVertexData3f</span>(vCoast);<br>lineBatch.<span class="hljs-built_in">End</span>();<br><br><span class="hljs-comment">//设置线的宽度 2.5f</span><br><span class="hljs-built_in">glLineWidth</span>(<span class="hljs-number">2.0f</span>);<br><br>... <span class="hljs-comment">//使用平面着色器</span><br><br><span class="hljs-comment">// 绘制</span><br>lineBatch.<span class="hljs-built_in">Draw</span>();<br></code></pre></td></tr></table></figure>

<h2 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h2><blockquote>
<p>线段连续从一个顶点到下一个顶点绘制的线段，以形成一个真正链接的点的线段。（为了把图形连接起来，每个连接的顶点会被选定2次。一次作为线段的终点，一次作为下一个线段的起点）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">GLBatch	lineStripBatch;<br>lineStripBatch.<span class="hljs-built_in">Begin</span>(GL_LINE_STRIP, <span class="hljs-number">24</span>);<br>lineStripBatch.<span class="hljs-built_in">CopyVertexData3f</span>(vCoast);<br>lineStripBatch.<span class="hljs-built_in">End</span>();<br><br><span class="hljs-built_in">glLineWidth</span>(<span class="hljs-number">2.0f</span>);<br><br>... <span class="hljs-comment">//使用平面着色器</span><br><span class="hljs-comment">// 绘制</span><br>lineStripBatch.<span class="hljs-built_in">Draw</span>();<br></code></pre></td></tr></table></figure>

<h2 id="线环"><a href="#线环" class="headerlink" title="线环"></a>线环</h2><blockquote>
<p>线环是线段的扩展。在现代的基础上额外增加一条将线段闭合的线</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">GLBatch	lineLoopBatch;<br>lineLoopBatch.<span class="hljs-built_in">Begin</span>(GL_LINE_LOOP, <span class="hljs-number">24</span>);<br>lineLoopBatch.<span class="hljs-built_in">CopyVertexData3f</span>(vCoast);<br>lineLoopBatch.<span class="hljs-built_in">End</span>();<br><br><span class="hljs-built_in">glLineWidth</span>(<span class="hljs-number">2.0f</span>);<br><br>... <span class="hljs-comment">//使用平面着色器</span><br><span class="hljs-comment">// 绘制</span><br>lineStripBatch.<span class="hljs-built_in">Draw</span>();<br></code></pre></td></tr></table></figure>

<h2 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h2>]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title>存储着色器</title>
    <url>/2024/02/20/OpenGL/%E5%AD%98%E5%82%A8%E7%9D%80%E8%89%B2%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="存储着色器"><a href="#存储着色器" class="headerlink" title="存储着色器"></a>存储着色器</h1><blockquote>
<ul>
<li>在<code>OpenGL</code>核心框架中，并没有提供任何内建渲染管线，在提交一个⼏何图形进行渲染之前，必须实现一个着色器</li>
<li>图形进⾏渲染之前，必须实现⼀个着⾊器。 可以使⽤存储着⾊器。这些存储着色器由<code>GLTools</code>的<code>C++</code>类<code>GLShaderManager</code>管理。它们能够满足进行基本渲染的基本要求。要求不高的程序员，这些存储着⾊器已经⾜以满⾜他们的需求。但是，随着时间和经验的提升，⼤部分开发者可能不满足于此。 会开始⾃己着手去写着色器</li>
</ul>
</blockquote>
<h2 id="存储着色器的使用"><a href="#存储着色器的使用" class="headerlink" title="存储着色器的使用"></a>存储着色器的使用</h2><ol>
<li><code>GLShaderManager</code>的初始化 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">GLShaderManager	shaderManager;<br>shaderManager.<span class="hljs-built_in">InitializeStockShaders</span>();<br></code></pre></td></tr></table></figure>
</li>
<li>着色器的使用<ul>
<li>⼀般情况，要对⼏何图形进行渲染，我们需要给对象递交属性矩阵，⾸先要绑定我们想要使⽤的着⾊程序上，并提供程序的<code>uniform</code>值。但是<code>GLShanderManager</code>类可以暂时为我们完成工作</li>
<li><code>UseStockShader</code>函数会选择⼀个存储着⾊器并提供这个着⾊器的<code>uniform</code>值。  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">GLShaderManager::<span class="hljs-built_in">UserStockShader</span>(GLeunm shader...);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="单位着色器"><a href="#单位着色器" class="headerlink" title="单位着色器"></a>单位着色器</h3><blockquote>
<p>只是简单地使用默认笛卡尔坐标系（坐标范围（-1.0，1.0））。所有的片段都应用同一种颜色，几何图形为实心和未渲染的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">GLfloat vRed[] = &#123; <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>shaderManager.<span class="hljs-built_in">UseStockShader</span>(GLT_SHADER_IDENTITY,vRed);<br></code></pre></td></tr></table></figure>

<h3 id="平面着色器"><a href="#平面着色器" class="headerlink" title="平面着色器"></a>平面着色器</h3><blockquote>
<p>绘制图形时，可以应用变换（模型/投影变化）</p>
</blockquote>
<ul>
<li>参数1: 平面着色器</li>
<li>参数2: 允许变化的<code>4*4</code>矩阵</li>
<li>参数3: 颜色<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">GLfloat vRed[] = &#123; <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>M3DMatrix44f mFinalTransform;<br>shaderManager.<span class="hljs-built_in">UseStockShader</span>(GLT_SHADER_FLAT, mFinalTransform, vRed);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="上色着色器"><a href="#上色着色器" class="headerlink" title="上色着色器"></a>上色着色器</h3><blockquote>
<p>绘图时，可以应用变换（模型/投影变化）颜色平滑的插入顶点之间称为平滑着色</p>
</blockquote>
<ul>
<li>参数1: 上色着色器</li>
<li>参数2: 允许变化的<code>4*4</code>矩阵</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">M3DMatrix44f mFinalTransform;<br>shaderManager.<span class="hljs-built_in">UseStockShader</span>(GLT_SHADER_SHADED, mFinalTransform);<br></code></pre></td></tr></table></figure>

<h3 id="默认光源着色器"><a href="#默认光源着色器" class="headerlink" title="默认光源着色器"></a>默认光源着色器</h3><blockquote>
<p>绘制图形时，可以应用变换（模型/投影变化）。这种着色器会使绘制的图形产生阴影和光照的效果.</p>
</blockquote>
<ul>
<li>参数1: 默认光源着色器</li>
<li>参数2: 模型<code>4*4</code>矩阵</li>
<li>参数3: 投影<code>4*4</code>矩阵</li>
<li>参数3: 颜色</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">shaderManager.<span class="hljs-built_in">UseStockShader</span>(GLT_SHADER_DEFAULT_LIGHT, GLfloat mvMatrix[<span class="hljs-number">16</span>], GLfloat pMatrix[<span class="hljs-number">16</span>], GLfloat vColor[<span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure>

<h3 id="点光源着色器"><a href="#点光源着色器" class="headerlink" title="点光源着色器"></a>点光源着色器</h3><blockquote>
<p>绘制图形时，可以应用变换（模型/投影变化）。这种着色器会使绘制的图形产生阴影和光照的效果，光照的位置是固定的。</p>
</blockquote>
<ul>
<li>参数1: 点光源着色器</li>
<li>参数2: 模型<code>4*4</code>矩阵</li>
<li>参数3: 投影<code>4*4</code>矩阵</li>
<li>参数4: 光源位置</li>
<li>参数5: 颜色</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">shaderManager.<span class="hljs-built_in">UseStockShader</span>(GLT_SHADER_POINT_LIGHT_DIFF, GLfloat mvMatrix[<span class="hljs-number">16</span>], GLfloat pMatrix[<span class="hljs-number">16</span>], GLfloat vLightPos[<span class="hljs-number">3</span>], GLfloat vColor[<span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure>

<h3 id="纹理替换矩阵着色器"><a href="#纹理替换矩阵着色器" class="headerlink" title="纹理替换矩阵着色器"></a>纹理替换矩阵着色器</h3><blockquote>
<p>绘制图形时, 可以应用变换(模型/投影变化)这种着色器通过给定的模型视图投影矩阵.使⽤纹理单元来进行颜色填充.其中每个像素点的颜⾊都是从纹理中获取的。</p>
</blockquote>
<ul>
<li>参数1: 纹理替换矩阵着色器</li>
<li>参数2: 模型<code>4*4</code>矩阵</li>
<li>参数3: 纹理单元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">shaderManager.<span class="hljs-built_in">UseStockShader</span>(GLT_SHADER_TEXTURE_REPLACE, mvMatrix[<span class="hljs-number">16</span>], GLint nTextureUnit);<br></code></pre></td></tr></table></figure>

<h3 id="纹理调整着色器"><a href="#纹理调整着色器" class="headerlink" title="纹理调整着色器"></a>纹理调整着色器</h3><blockquote>
<p>绘制图形时, 可以应用变换(模型/投影变化)这种着色器通过给定的模型视图投影矩阵。着色器器将一个基本⾊乘以⼀个取自纹理单元<code>nTextureUnit</code>的纹理.将颜色与纹理进行颜色混合后才填充到⽚段中。</p>
</blockquote>
<ul>
<li>参数1: 纹理替换矩阵着色器</li>
<li>参数2: 模型<code>4*4</code>矩阵</li>
<li>参数3: 颜色</li>
<li>参数4: 纹理单元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">shaderManager.<span class="hljs-built_in">UseStockShader</span>(GLT_SHADER_TEXTURE_MODULATE, mvMatrix[<span class="hljs-number">16</span>], GLfloat vColor[<span class="hljs-number">4</span>], GLint nTextureUnit);<br></code></pre></td></tr></table></figure>

<h3 id="纹理光源着色器"><a href="#纹理光源着色器" class="headerlink" title="纹理光源着色器"></a>纹理光源着色器</h3><blockquote>
<p>绘制图形时, 可以应用变换(模型/投影变化)这种着色器通过给定的模型视图投影矩阵。着⾊器将一个纹理通过漫反射照明计算进行调整(相乘)。</p>
</blockquote>
<ul>
<li>参数1: 纹理光源着色器</li>
<li>参数2: 模型<code>4*4</code>矩阵</li>
<li>参数3: 投影<code>4*4</code>矩阵</li>
<li>参数4: 光源位置</li>
<li>参数5: 颜色</li>
<li>参数6: 纹理单元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">shaderManager.<span class="hljs-built_in">UseStockShader</span>(GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF, GLfloat mvMatrix[<span class="hljs-number">16</span>], GLfloat pMatrix[<span class="hljs-number">16</span>], GLfloat vLightPos[<span class="hljs-number">3</span>], GLfloat vColor[<span class="hljs-number">4</span>], GLint nTextureUnit);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title>基础语法</title>
    <url>/2024/02/15/OpenGL/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenGL简介"><a href="#OpenGL简介" class="headerlink" title="OpenGL简介"></a><code>OpenGL</code>简介</h1><ul>
<li><code>OpenGL</code>发展⾄至今,已经有<code>20</code>余年,作为⼀个成熟并久负盛名的跨平台计算机图形应用程序接口规范,它被⼴泛使⽤用在游戏,影视,军事,航空航天,地理,医学,机械设计,以及各类科学数据可视化等领域</li>
<li><code>OpenGL</code>是一种图形应用程序编程接⼝(<code>Application Programming Interface</code>, <code>API</code>).简单理解就是开发的图形库</li>
<li><code>OpenGL</code> 可以⽤用来做什什么? <ul>
<li>视频,图形,图⽚片处理理</li>
<li><code>2D/3D</code> 游戏引擎开发</li>
<li>科学可视化</li>
<li>医学软件开发</li>
<li><code>CAD</code>(计算机辅助技术)</li>
<li>虚拟实境(<code>AR</code>,<code>VR</code>)</li>
<li><code>AI</code>人⼯工智能</li>
</ul>
</li>
</ul>
<h1 id="3D基础术语"><a href="#3D基础术语" class="headerlink" title="3D基础术语"></a><code>3D</code>基础术语</h1><ul>
<li><code>光栅化</code>：实际绘制或填充每个顶点之间的像素形成线程</li>
<li><code>着色</code>: 沿着顶点之间改变颜色值,能够轻松创建光照照射到⼀个⽴⽅方体的效果.</li>
<li><code>纹理贴图</code>: 将纹理理图片附着到你绘图的图像上.</li>
<li><code>混合</code>: 颜⾊混合效果.</li>
</ul>
<h1 id="OpenGL客户端-服务端"><a href="#OpenGL客户端-服务端" class="headerlink" title="OpenGL客户端/服务端"></a>OpenGL客户端/服务端</h1><p><img src="4.png"></p>
<h1 id="着⾊器"><a href="#着⾊器" class="headerlink" title="着⾊器"></a>着⾊器</h1><ul>
<li>图元: 组成图像的基本单元</li>
<li><code>OpenGL</code> 渲染管线: ⼀系列有序的处理阶段的序列,⽤于把我们应用中的数据转化到<code>OpenGL</code> ⽣成一个最终的图像的⼀一个过程</li>
<li><code>GLSL</code>: 专⻔为图形开发设计的编程语言</li>
</ul>
<ul>
<li>图片</li>
</ul>
<h2 id="着⾊器的渲染"><a href="#着⾊器的渲染" class="headerlink" title="着⾊器的渲染"></a>着⾊器的渲染</h2><ul>
<li>顶点着色器 (必要)</li>
<li>细分着色器 (可选) </li>
<li>⼏何着色器 (可选)</li>
<li>⽚元着色器 (必选)</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>属性: 就是对⼀一个顶点都要作出改变的数据元素.实际上,顶点位置本身就是⼀一个属性. 属性可以是浮点类型,整型,布尔类 型等.</li>
</ul>
<h1 id="图元"><a href="#图元" class="headerlink" title="图元"></a>图元</h1><h2 id="OpenGL与色器"><a href="#OpenGL与色器" class="headerlink" title="OpenGL与色器"></a><code>OpenGL</code>与色器</h2><ul>
<li>在<code>OpenGL 3.0</code>之前，<code>OpenGL</code> 包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。在<code>3.1</code>版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作。</li>
<li>使用<code>OpenGL</code>来说，会使用<code>GLSL</code>.（<code>OpenGL Shading Langruage</code>，它是在<code>OpenGL 2.0</code>版本发布的）。语法与“<code>C</code>、<code>C++</code>“类似</li>
</ul>
<h2 id="基础图形管线"><a href="#基础图形管线" class="headerlink" title="基础图形管线"></a>基础图形管线</h2><ul>
<li><code>OpenGL</code>中的图元只是顶点的集合以及预定义的方式结合在⼀起（例如：一个单独的点就是一个图元。它只需要一个顶点）</li>
</ul>
<h3 id="OpenGL渲染管线简化版本"><a href="#OpenGL渲染管线简化版本" class="headerlink" title="OpenGL渲染管线简化版本"></a>OpenGL渲染管线简化版本</h3><ul>
<li>管线分为<code>2</code>个部分,上半部分是<code>客户端</code>,下半部分为<code>服务器端</code>.</li>
<li>服务器端和客户端是功能和运行上都是异步,它们是各自独立的软件块和硬件块.</li>
<li>渲染过程,必备<code>2</code>个<code>着⾊器</code>,分别是”<code>顶点着⾊器</code>”和”<code>⽚元着色器</code>”</li>
</ul>
<p><img src="3.jpg"></p>
<h4 id="客户机、服务器"><a href="#客户机、服务器" class="headerlink" title="客户机、服务器"></a>客户机、服务器</h4><ul>
<li>管线分为上下<code>2</code>部分，上部分是客户端，而下半部分则是服务端。</li>
<li>客户端是存储在<code>CPU</code>存储器中的，并且在应用程序中执行，或者在主系统内存的驱动程序中执行。驱动程序会将渲染命令和数组组合起来，发送给服务器执行！（在一台典型的个人计算机上，服务器就是实际上就是图形加速卡上的硬件和内存）</li>
<li>服务器和客户机在功能上也是异步的。它们是各自独立的软件块或硬件块。我们是希望它们<code>2</code>个端都尽量在不停的工作。客户端不断的把数据块和命令块组合在一起输送到缓冲区，然后缓冲区就会发送到服务器执行。</li>
<li>如果服务器停止工作等待客户机，或者客户机停止工作来等待服务器做好接受更多的命令和准备，我们把这种情况成为管线停滞</li>
</ul>
<h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><ul>
<li>上图的<code>Vertex Shader</code>（顶点着色器）和 <code>Fragment Shader</code>（片段着色器）。<ul>
<li>着色器是使用<code>GLSL</code>编写的程序，看起来与<code>C</code>语言非常类似。着色器必须从源代码中编译和链接在一起。最终准备就绪的着色器程序</li>
<li>顶点着色器-&gt;处理从客户端输入的数据、应用变换、进行其他的类型的数学运算来计算光照效果、位移、颜色值等等。（为了渲染共有<code>3</code>个顶点的三角形，顶点着色器将执行<code>3</code>次，也就是为了每个顶点执行一次）在目前的硬件上有多个执行单元同时运行，就意味着所有的<code>3</code>个顶点可以同时进行处理</li>
<li>图上（<code>primitive Assembly</code> 说明的是：<code>3</code>个顶点已经组合在一起，而三角形已经逐个片段的进行了光栅化。每个片段通过执行片元着色器进行填充。片元着色器会输出我们将屏幕上看到的最终颜色值。</li>
</ul>
</li>
<li><strong>注意</strong>！<ul>
<li>必须在这之前为着色器提供数据，否则什么都无法实现！有<code>3</code>种向<code>OpenGL</code>着色器传递渲染数据的方法可供我们选择<ul>
<li>属性</li>
<li><code>uniform</code>值</li>
<li>纹理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="着⾊器传递渲染数据的方法"><a href="#着⾊器传递渲染数据的方法" class="headerlink" title="着⾊器传递渲染数据的方法"></a>着⾊器传递渲染数据的方法</h2><ul>
<li>属性</li>
<li><code>Uniform</code></li>
<li>纹理</li>
<li>输出</li>
</ul>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><blockquote>
<ul>
<li>就是对⼀个顶点都要作出改变的数据元素.实际上,顶点位置本身就是⼀个属性. 属性可以是浮点类型,整型,布尔类型等.</li>
</ul>
</blockquote>
<ul>
<li>属性总是以四维向量的形式进行内部存储的，即使我们不会使用所有的<code>4</code>个分量。一个顶点位置可能存储（<code>x</code>,<code>y</code>,<code>z</code>），将占有<code>4</code>个分量中的<code>3</code>个。</li>
<li>实际上如果是在平面情况下：只要在<code>xy</code>平面上就能绘制，那么<code>z</code>分量就会自动设置为<code>O</code>；</li>
<li>属性还可以是：纹理坐标、颜色值、关照计算表面法线</li>
<li>在顶点程序（<code>shader</code>渲染）可以代表你想要的任何意义。因为都是你设定的。</li>
<li>属性会从本地客户机内存中复制存储在图形硬件中的一个缓冲区上。这些属性只提供给顶点着色器使用，对于片元着色器木有太大意义。</li>
<li>声明：这些属性对每个顶点都要做改变，但并不意味着它们的值不能重复。通常情况下，它们都是不一样的，但有可能整个数组都是同一值的情况。</li>
</ul>
<h3 id="Uniform值"><a href="#Uniform值" class="headerlink" title="Uniform值"></a><code>Uniform</code>值</h3><blockquote>
<ul>
<li>属性是一种对整个批次属性都取统一值的单一值。它是不变的。通过设置<code>uniform</code>变量就紧接着发送一个图元批次命令，<code>Uniform</code>变量实际上可以无数次限制地使用，设置一个应用于整个表面的单个颜色值，还可以设置一个时间值。在每次渲染某种类型的顶点动画时修改它。</li>
</ul>
</blockquote>
<ul>
<li>注意：这里的<code>uniform</code> 变量每个批次改变一次，而不是每个顶点改变一次。</li>
<li><code>uniform</code>变量最常见的应用是在顶点渲染中设置变换矩阵</li>
<li>与属性相同点：可以是浮点值、整数、布尔值</li>
<li>与属性不同点：顶点着色器和片元着色器都可以使用<code>uniform</code>变量。<code>uniform</code>变量还可以是标量类型、矢量类型、<code>uniform</code>矩阵。</li>
</ul>
<h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><blockquote>
<ul>
<li>传递给着色器的第三种数据类型：纹理数据</li>
</ul>
</blockquote>
<ul>
<li>在顶点着色器、片段着色器中都可以对纹理数据进行采样和筛选。</li>
<li>典型的应用场景：片段着色器对一个纹理值进行采样，然后在一个三角形表面应用渲染纹理数据。</li>
<li>纹理数据，不仅仅表现在图形，很多图形文件格式都是以无符号字节（每个颜色通道<code>8</code>位）形式对颜色分量进行存储的。</li>
</ul>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>在图表中第四种数据类型是输出（<code>out</code>）；输出数据是作为一个阶段着色器的输出定义的，二后续阶段的着色器则作为输入定义。</p>
</blockquote>
<ul>
<li>输出数据可以简单的从一个阶段传递到下一个阶段，也可以用不同的方式插入。</li>
<li>客户端的代码接触不到这些内部变量我们的<code>OpenGL</code>开发暂时接触不到。</li>
</ul>
<h1 id="创建坐标系"><a href="#创建坐标系" class="headerlink" title="创建坐标系"></a>创建坐标系</h1><p><img src="2.jpg"></p>
<ul>
<li>这就是一个正投影的例子，在所在<code>3</code>个轴（<code>X</code>,<code>Y</code>,<code>Z</code>）中，它们的范围都是从<code>-100</code>到<code>+100</code>。这个视景体将包括所有的几何图形。</li>
<li>如果你指定了视景体外的几何图形，就会被裁减掉！（它将沿着视景体的边界进行剪切）</li>
<li>在正投影中，所有在这个空间范围内的所有东西都将被呈现在屏幕上。而不存在照相机或视点坐标系的概念。</li>
</ul>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><ul>
<li><code>setPerspective(float fFov,float fNear,float fFar)</code><br><img src="1.jpg"></li>
<li>透视投影会进行透视除法对距离观察者很远的对象进行缩短和收缩。在投影到屏幕之后，视景体背面与视景体正面的宽度测量标准不同。</li>
<li>上图所示：平截头体（<code>frustum</code>）的几何体，它的观察方向是从金字塔的尖端到宽阔端。观察者的视点与金字塔的尖端拉开一定距离。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// GLFrustum类通过SetPerspective方法构建一个平载头体</span><br><span class="hljs-comment">// - fFov : 垂直方向上的市场角度</span><br><span class="hljs-comment">// - fAspect : 窗口的宽度与高度的纵横比</span><br><span class="hljs-comment">// - fNear : 近裁剪面距离</span><br><span class="hljs-comment">// - fFar : 远裁剪面距离</span><br>GLFrustum::<span class="hljs-built_in">SetPerspective</span>(<span class="hljs-keyword">float</span> fFov, <span class="hljs-keyword">float</span> fAspect, <span class="hljs-keyword">float</span> fNear, <span class="hljs-keyword">float</span> fFar)<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title>其他协议</title>
    <url>/2024/01/31/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><code>WebSocket</code></h1><ul>
<li><code>HTTP</code>请求的特点：通信只能由客户端发起(<code>HTTP/2.0</code>的推送特性，也是有客户端发起的，服务器可以给客户端连续发送多条数据，但只能是静态资源)。所以，早期很多网站为了实现推送技术，所用的技术都是轮询<ul>
<li>轮询是指由浏览器每隔一段时间（如每秒）向服务器发出<code>HTTP</code>请求，然后服务器返回最新的数据给客户端</li>
<li>为了能更好的节省服务器资源和带宽，并且能够更实时地进行通讯，<code>HTML5</code>规范中出现了<code>WebSocket</code>协议</li>
</ul>
</li>
</ul>
<p><img src="1.jpg"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p><code>WebSocket</code>，是基于<code>TCP</code>的支持全双工通信的应用层协议</p>
<ul>
<li>在<code>2011</code>年由<code>IETF</code>标准化为<a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>，后由<a href="https://datatracker.ietf.org/doc/html/rfc7936">RFC 7936</a>补充规范</li>
<li>客户端、服务器，任何一方都可以主动发消息给对方</li>
</ul>
</li>
<li><p><code>WebSocket</code>的应用场景很多</p>
<ul>
<li>社交订阅、股票基金报价、体育实况更新、多媒体聊天、多玩家游戏等</li>
</ul>
</li>
</ul>
<h2 id="HTTP-vs-webSocket"><a href="#HTTP-vs-webSocket" class="headerlink" title="HTTP vs webSocket"></a><code>HTTP vs webSocket</code></h2><ul>
<li><p><code>WebSocket</code>和<code>HTTP</code>属于平级关系，都是应用层的协议</p>
<ul>
<li>其实<code>TCP</code>本身就是支持全双工通信的（客户端、服务器均可主动发消息给对方）</li>
<li>只是<code>HTTP</code>的“<strong>请求-应答模式</strong>”限制了<code>TCP</code>的能力</li>
</ul>
</li>
<li><p><code>WebSocket</code>使用<code>80（ws://）</code>、<code>443（wss://）</code>端口，可以绕过大多数防火墙的限制</p>
<ul>
<li><code>ws://example.com/wsapi</code></li>
<li><code>wss://secure.example.com/wsapi</code></li>
</ul>
</li>
<li><p>与<code>HTTP</code>不同的是，<code>WebSocket</code>需要先建立连接</p>
<ul>
<li>这就使得<code>WebSocket</code>成为一种有状态的协议，之后通信时可以省略部分状态信息</li>
<li>而<code>HTTP</code>请求可能需要在每个请求都额外携带状态信息（如身份认证等）</li>
</ul>
</li>
</ul>
<h2 id="WebSocket-建立连接"><a href="#WebSocket-建立连接" class="headerlink" title="WebSocket - 建立连接"></a><code>WebSocket</code> - 建立连接</h2><ul>
<li><code>WebSocket</code>需要借助<code>HTTP</code>协议来建立连接（也叫作握手，<a href="https://datatracker.ietf.org/doc/html/rfc6455#section-1.3">Handshake</a>）<ul>
<li>由客户端（浏览器）主动发出握手请求</li>
</ul>
</li>
<li>客户端<code>Http</code>请求<ul>
<li><code>Connection</code>必须设置<code>Upgrade</code><ul>
<li>表示客户端希望连接升级</li>
</ul>
</li>
<li><code>Upgrade</code>必须设置<code>websocket</code><ul>
<li>表示希望升级到<code>WebSocket</code>协议</li>
</ul>
</li>
<li><code>Sec-WebSocket-Version</code><ul>
<li>表示支持的<code>Websocket</code>版本</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>要求使用的版本是<code>13</code></li>
</ul>
</li>
<li><code>Sec-WebSocket-Key</code>是客户端生成的随机字符串</li>
</ul>
</li>
</ul>
<p><img src="10.png"></p>
<ul>
<li>服务器响应<ul>
<li><code>服务器</code>接收到<code>客户端</code>的<code>Sec-WebSocket-Key</code>后，会进行以下操作<ol>
<li><code>Sec-WebSocket-Key</code>加上一个固定的<a href="https://datatracker.ietf.org/doc/html/rfc4122">GUID</a>值（<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>）</li>
<li>将<code>1</code>的结果进行<a href="http://encode.chahuo.com/">SHA-1摘要计算</a></li>
<li>将<code>2</code>的结果进行<a href="https://base64.guru/converter/encode/hex">Hex To Base64编码</a></li>
<li>将<code>3</code>的结果做为<code>Sec-WebSocket-Accept</code>响应头的值，返回给客户端</li>
</ol>
</li>
<li>如此操作，可以尽量避免普通<code>HTTP</code>请求被误认为<code>WebSocket</code>协议</li>
</ul>
</li>
</ul>
<p><img src="11.png"></p>
<ul>
<li><a href="https://www.websocket.org/echo.html">WebSocket体验和演示</a></li>
</ul>
<h1 id="webService"><a href="#webService" class="headerlink" title="webService"></a><code>webService</code></h1><ul>
<li><code>WebService</code>，译为：<code>Web</code>服务，是一种跨编程语言和跨操作系统平台的远程调用技术标准</li>
<li><code>WebService</code>使用场景举例<ul>
<li>天气预报、手机归属地查询、航班信息查询、物流信息查询等</li>
<li>比如天气预报，是气象局把自己的服务以<code>WebService</code>形式暴露出来，让第三方程序可以调用这些服务功能</li>
<li><a href="http://www.webxml.com.cn/zh_cn/index.aspx">http://www.webxml.com.cn/zh_cn/index.aspx</a></li>
</ul>
</li>
<li>事实上，<code>WebService</code>完全可以用普通的<code>Web API</code>取代（比如<code>HTTP + JSON</code>）<ul>
<li>现在很多企业的开放平台都是直接采用<code>Web API</code></li>
</ul>
</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><code>SOAP</code>（<code>Simple Object Access Protocol</code>），译为：简单对象访问协议<ul>
<li>很多时候，<code>SOAP = HTTP + XML</code></li>
<li><code>WebService</code>使用<code>SOAP</code>协议来封装传递数据</li>
</ul>
</li>
</ul>
<p><img src="2.jpg"></p>
<ul>
<li><code>WSDL</code>（<code>Web Services Description Language</code>），译为：<code>Web</code>服务描述语言<ul>
<li>一个<code>XML</code>文档，用以描述<code>WebService</code>接口的细节（比如参数、返回值等）</li>
<li>一般在<code>WebService</code>的<code>URL</code>后面跟上<code>?wsdl</code>获取<code>WSDL</code>信息<ul>
<li>比如：<a href="http://ws.webxml.com.cn/WebServices/WeatherWS.asmx?wsdl">http://ws.webxml.com.cn/WebServices/WeatherWS.asmx?wsdl</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a><code>HTTPDNS</code></h1><ul>
<li><p><code>HTTPDNS</code>是基于<code>HTTP</code>协议向<code>DNS</code>服务器发送域名解析请求</p>
<ul>
<li>替代了基于<code>DNS</code>协议向运营商<code>Local DNS</code>发起解析请求的传统方式</li>
<li>可以避免<code>Local DNS</code>造成的域名劫持和跨网访问问题</li>
<li>常用在移动互联网中（比如在<code>Android</code>、<code>iOS</code>开发中）</li>
</ul>
</li>
<li><p>市面上已经有现成的解决方案</p>
<ul>
<li><a href="https://cloud.tencent.com/product/httpdns">腾讯云</a></li>
<li><a href="https://help.aliyun.com/product/30100.html">阿里云</a></li>
</ul>
</li>
<li><p>移动端集成相关的<code>SDK</code>即可使用<code>HTTPDNS</code>服务</p>
</li>
</ul>
<h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a><code>FTP</code></h1><ul>
<li><code>FTP</code>（<code>File Transport Protocol</code>），译为：文件传输协议，<a href="https://datatracker.ietf.org/doc/html/rfc959">RFC 959</a>定义了此规范，是基于<code>TCP</code>的应用层协议<ul>
<li>在<a href="https://datatracker.ietf.org/doc/html/rfc1738">RFC 1738</a>中有定义，<code>FTP</code>的<code>URL</code>格式为：<code>ftp://[user[:password]@]host[:port]/url-path</code></li>
</ul>
</li>
</ul>
<p><img src="3.jpg"></p>
<h2 id="连接模式"><a href="#连接模式" class="headerlink" title="连接模式"></a>连接模式</h2><ul>
<li><code>FTP</code>有<code>2</code>种连接模式：主动（<code>Active</code>）和被动（<code>Passive</code>）</li>
<li>不管是哪种模式，都需要客户端和服务器建立<code>2</code>个连接<ol>
<li>控制连接：用于传输状态信息（命令，<code>cmd</code>）</li>
<li>数据连接：用于传输文件和目录信息（<code>data</code>）</li>
</ol>
</li>
</ul>
<p><img src="4.jpg"></p>
<h3 id="主动模式"><a href="#主动模式" class="headerlink" title="主动模式"></a>主动模式</h3><p><img src="5.jpg"></p>
<ol>
<li>客户端打开一个随机的命令端口<ul>
<li>端口号大于<code>1024</code>，假设为N</li>
<li>同时连接至服务器的命令端口<code>21</code>(固定<code>21</code>)</li>
</ul>
</li>
<li>客户端开始监听<code>N+1</code>数据端口<ul>
<li>同时向服务器发送一个<code>Port</code>命令给服务器的命令端口<code>21</code></li>
<li>此命令告诉服务器<ul>
<li>客户端正在监听的数据端口<code>N+1</code></li>
<li>并且已准备好从此端口接收数据</li>
</ul>
</li>
</ul>
</li>
<li>服务器打开<code>20</code>号数据端口，并且创建和客户端数据端口（<code>N+1</code>）的连接</li>
</ol>
<h3 id="被动模式"><a href="#被动模式" class="headerlink" title="被动模式"></a>被动模式</h3><p><img src="6.jpg"></p>
<ol>
<li>客户端的<code>命令端口N</code>用于连接服务器的命令端口<code>21</code></li>
<li>客户端通过<code>命令端口N</code>发送<code>PASV</code>命令给服务器的<code>命令端口21</code></li>
<li>服务器打开一个随机的<code>数据端口P</code>，并告知客户端该<code>端口号P</code></li>
<li>客户端<code>数据端口N+1</code>发起与服务器数据<code>端口P</code>的连接</li>
</ol>
<h1 id="邮件的相关协议"><a href="#邮件的相关协议" class="headerlink" title="邮件的相关协议"></a>邮件的相关协议</h1><ul>
<li>发邮件使用的协议<ul>
<li><code>SMTP</code>（<code>Simple Mail Transfer Protocol</code>），译为：简单邮件传输协议<ul>
<li>基于TCP，标准参考<a href="https://datatracker.ietf.org/doc/html/rfc5321">RFC 5321</a></li>
<li>服务器默认使用<code>25</code>端口，<code>SSL/TLS</code>使用<code>465</code>端口</li>
</ul>
</li>
</ul>
</li>
<li>收邮件使用的协议<ul>
<li><code>POP</code>（<code>Post Office Protocol</code>），译为：邮局协议<ul>
<li>基于<code>TCP</code>，最新版是<code>POP3</code>，标准参考<a href="https://datatracker.ietf.org/doc/html/rfc1939">RFC 1939</a></li>
<li>服务器默认使用<code>110</code>端口，<code>SSL/TLS</code>使用<code>995</code>端口</li>
</ul>
</li>
</ul>
</li>
<li><code>IMAP</code>（<code>Internet Message Access Protocol</code>），译为：因特网信息访问协议<ul>
<li>基于<code>TCP</code>，最新版是<code>IMAP4</code>，标准参考<a href="https://datatracker.ietf.org/doc/html/rfc3501">RFC 3501</a></li>
<li>服务器默认使用<code>143</code>端口，<code>SSL</code>/<code>TLS</code>使用<code>993</code>端口</li>
</ul>
</li>
</ul>
<p><img src="7.jpg"></p>
<h2 id="POP-vs-IMAP"><a href="#POP-vs-IMAP" class="headerlink" title="POP vs IMAP"></a><code>POP vs IMAP</code></h2><p><img src="8.jpg"></p>
<ul>
<li><code>POP</code>的特点<ul>
<li>客户端连接服务器时，将会从服务器下载所有邮件<ul>
<li>可以设置下载完后，立即或一段时间后删除服务器邮件</li>
</ul>
</li>
<li>客户端的操作（比如删除邮件、移动到文件夹）不会跟服务器同步</li>
<li>每个客户端都是独立的，都可以获得其自己的电子邮件副本</li>
</ul>
</li>
</ul>
<p><img src="9.jpg"></p>
<ul>
<li>IMAP的特点<ul>
<li>客户端连接服务器时，获取的是服务器上邮件的基本信息，并不会下载邮件<ul>
<li>等打开邮件时，才开始下载邮件</li>
</ul>
</li>
<li>客户端的操作（比如删除邮件、移动到文件夹）会跟服务器同步</li>
<li>所有客户端始终会看到相同的邮件和相同的文件夹</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>http的升级改进</title>
    <url>/2024/01/29/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E5%8D%87%E7%BA%A7%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP-1-1协议的不足"><a href="#HTTP-1-1协议的不足" class="headerlink" title="HTTP/1.1协议的不足"></a><code>HTTP/1.1</code>协议的不足</h1><ul>
<li><p>同一时间，一个连接只能对应一个请求</p>
<ul>
<li>针对同一个域名，大多数浏览器允许同时最多<code>6</code>个并发连接。(<code>ios</code>的<code>NSURLSession</code>最多可以建立<code>4</code>个<code>tcp</code>连接,<code>OSX</code>中最多<code>6</code>个)</li>
</ul>
</li>
<li><p>只允许客户端主动发起请求</p>
<ul>
<li>一个请求只能对应一个响应</li>
</ul>
</li>
<li><p>同一个会话的多次请求中，头信息会被重复传输</p>
<ul>
<li>通常会给每个传输增加<code>500~800</code>字节的开销</li>
<li>如果使用<code>Cookie</code>，增加的开销有时会达到上千字节</li>
</ul>
</li>
</ul>
<h1 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a><code>SPDY</code></h1><ul>
<li><p><code>SPDY</code>（<code>speedy</code>的缩写），是基于<code>TCP</code>的应用层协议，它强制要求使用<code>SSL/TLS</code></p>
<ul>
<li><code>2009</code>年<code>11</code>月，<code>Google</code>宣布将<code>SPDY</code>作为提高网络速度的内部项目</li>
</ul>
</li>
<li><p><code>SPDY</code>与<code>HTTP</code>的关系</p>
<ul>
<li><code>SPDY</code>并不用于取代<code>HTTP</code>，它只是修改了<code>HTTP</code>请求与响应的传输方式</li>
<li>只需增加一个<code>SPDY</code>层，现有的所有服务端应用均不用做任何修改</li>
<li><code>SPDY</code>是<code>HTTP/2</code>的前身<ul>
<li><code>2015</code>年<code>9</code>月，<code>Google</code>宣布移除对<code>SPDY</code>的支持，拥抱<code>HTTP/2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="1.jpg"></p>
<h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a><code>HTTP/2</code></h1><ul>
<li><p><code>HTTP/2</code>，于<code>2015</code>年<code>5</code>月以<a href>RFC 7540</a>正式发表</p>
<ul>
<li>根据<code>W3Techs</code>的数据，截至<code>2021</code>年<code>10</code>月，全球有<code>46.5%</code>的网站支持了<code>HTTP/2</code></li>
</ul>
</li>
<li><p><code>HTTP/1.1</code>和<code>HTTP/2</code>速度对比</p>
<ul>
<li><a href="http://www.http2demo.io/">http://www.http2demo.io/</a></li>
<li><a href="https://http2.akamai.com/demo">https://http2.akamai.com/demo</a></li>
</ul>
</li>
<li><p><code>HTTP/2</code>在底层传输做了很多的改进和优化，但在语意上完全与<code>HTTP/1.1</code>兼容</p>
<ul>
<li>比如请求方法（如<code>GET</code>、<code>POST</code>）、<code>Status Code</code>、各种<code>Headers</code>等都没有改变</li>
<li>因此，要想升级到<code>HTTP/2</code><ul>
<li>开发者不需要修改任何代码</li>
<li>只需要升级服务器配置、升级浏览器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息</p>
<ul>
<li>所有通信都在一个<code>TCP</code>连接上完成，此连接可以承载任意数量的双向数据流</li>
</ul>
</li>
<li><p>消息：与逻辑<code>HTTP</code>请求或响应消息对应，由一系列帧组成</p>
</li>
<li><p>帧：<code>HTTP/2</code>通信的最小单位，每个帧都包含帧头（会标识出当前帧所属的数据流）</p>
<ul>
<li>来自不同数据流的帧可以<code>交错发送</code>，然后再根据每个帧头的数据流标识符重新组装</li>
</ul>
</li>
</ul>
<h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3><p><img src="2.jpg"></p>
<ul>
<li><code>HTTP/2</code>采用二进制格式传输数据，而非<code>HTTP/1.1</code>的文本格式</li>
<li>二进制格式在协议的解析和优化扩展上带来更多的优势和可能</li>
</ul>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><img src="3.jpg"></p>
<ol>
<li>客户端和服务器可以将<code>HTTP</code>消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来</li>
<li>并行交错地发送多个请求，请求之间互不影响</li>
<li>并行交错地发送多个响应，响应之间互不干扰</li>
<li>使用一个连接并行发送多个请求和响应</li>
<li>不必再为绕过<code>HTTP/1.1</code>限制而做很多工作<ul>
<li>比如<code>image sprites</code>、合并<code>CSS\JS</code>、内嵌<code>CSS\JS\Base64</code>图片、域名分片等<ul>
<li><code>image sprites</code>（也叫做<code>CSS Sprites</code>），将多张小图合并成一张大图<ul>
<li> 最后通过<code>CSS</code>结合小图的位置、尺寸进行精准定位</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>并行交错的发送多个请求，只用一个连接<br><img src="4.jpg"></p>
</li>
<li><p>无需等待上一次发送完成，在接着发送下一个<br><img src="5.jpg"></p>
</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul>
<li><p><code>HTTP/2</code> 标准允许每个数据流都有一个关联的权重和依赖关系</p>
<ul>
<li>可以向每个数据流分配一个介于<code>1</code>至<code>256</code>之间的整数</li>
<li>每个数据流与其他数据流之间可以存在显式依赖关系</li>
</ul>
</li>
<li><p>客户端可以构建和传递“优先级树”，表明它倾向于如何接收响应</p>
</li>
<li><p>服务器可以使用此信息通过控制<code>CPU</code>、内存和其他资源的分配设定数据流处理的优先级</p>
<ul>
<li>在资源数据可用之后，确保将高优先级响应以最优方式传输至客户端</li>
</ul>
</li>
<li><p>应尽可能先给父数据流分配资源</p>
</li>
<li><p>同级数据流（共享相同父项）应按其权重比例分配资源</p>
</li>
<li><p><img src="6.jpg"></p>
</li>
</ul>
<ol>
<li><code>A</code>、<code>B</code>依赖于隐式“根数据流”，<code>A</code>获得的资源比例是<code>12/16</code>，<code>B</code>获得的资源比例是<code>4/16</code></li>
<li><code>D</code>依赖于根数据流，<code>C</code>依赖于<code>D</code>，<code>D</code>应先于<code>C</code>获得完整资源分</li>
<li><code>D</code>应先于<code>C</code>获得完整资源分配，<code>C</code>应先于<code>A</code>和<code>B</code>获得完整资源分配，<code>B</code>获得的资源是<code>A</code>所获资源的<code>1/3</code></li>
<li><code>D</code>应先于<code>E</code>和<code>C</code>获得完整资源分配，<code>E</code>和<code>C</code>应先于<code>A</code>和<code>B</code>获得相同的资源分配，<code>B</code>获得的资源是<code>A</code>所获资源的<code>1/3</code></li>
</ol>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p><img src="7.jpg"></p>
<ul>
<li><p><code>HTTP/2</code>使用<code>HPACK</code>压缩请求头和响应头</p>
<ul>
<li>可以极大减少头部开销，进而提高性能</li>
</ul>
</li>
<li><p>早期版本的<code>HTTP/2</code>和<code>SPDY</code>使用 <code>zlib</code>压缩</p>
<ul>
<li>可以将所传输头数据的大小减小<code>85%~88%</code></li>
<li>但在<code>2012</code>年夏天，被攻击导致会话劫持</li>
<li>后被更安全的<code>HPACK</code>取代</li>
</ul>
</li>
<li><p>其原理实际上是客户端和服务器中，都保存了一张表。如果本次请求的头部数据，在表中是存在的，则，新的请求，只用其表的索引即可。</p>
</li>
</ul>
<p><img src="8.jpg"></p>
<h3 id="服务器推送（非后台推送）"><a href="#服务器推送（非后台推送）" class="headerlink" title="服务器推送（非后台推送）"></a>服务器推送（非后台推送）</h3><ul>
<li>服务器可以对一个<code>客户端</code>请求发送<code>多个响应</code>.(一个请求，多个响应)<ul>
<li>除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端额外明确地请求（只能是静态资源，不能推送自定义数据）</li>
</ul>
</li>
</ul>
<p><img src="9.jpg"></p>
<h1 id="HTTP-2存在的问题"><a href="#HTTP-2存在的问题" class="headerlink" title="HTTP/2存在的问题"></a><code>HTTP/2</code>存在的问题</h1><h2 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h2><ul>
<li><p>因为<code>TCP</code>的可靠传输，如果队头元素丢失，需要重发，重发成功，后续的数据，才能发送。<br><img src="10.jpg"></p>
</li>
<li><p>而<code>QUIC</code>可以实现，在中间数据丢失的情况下，不会阻塞后续数据发送。(且丢失的数据，可以通过已经发送数据中的冗余数据，推断出来)</p>
</li>
</ul>
<p><img src="11.jpg"></p>
<h2 id="握手延迟"><a href="#握手延迟" class="headerlink" title="握手延迟"></a>握手延迟</h2><p><img src="12.jpg"></p>
<h1 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a><code>HTTP/3</code></h1><ul>
<li><code>Google</code>觉得<code>HTTP/2</code>仍然不够快，于是就有了<code>HTTP/3</code><ul>
<li><code>HTTP/3</code>由<code>Google</code>开发，弃用<code>TCP</code>协议，改为使用基于<code>UDP</code>协议的<code>QUIC</code>协议实现</li>
<li><code>QUIC</code>（<code>Quick UDP Internet Connections</code>），译为：快速<code>UDP</code>网络连接，由<code>Google</code>开发，在<code>2013</code>年实现</li>
<li>于<code>2018</code>年从<code>HTTP-over-QUIC</code>改为<code>HTTP/3</code></li>
</ul>
</li>
</ul>
<p><img src="13.jpg"></p>
<ul>
<li><p><code>HTTP/3</code>基于<code>UDP</code>，如何保证可靠传输</p>
<ul>
<li>由<code>QUIC</code>来保证</li>
</ul>
</li>
<li><p>为何<code>Google</code>不开发一个新的不同于<code>TCP</code>、<code>UDP</code>的传输层协议？</p>
<ul>
<li>目前世界上的网络设备基本只认<code>TCP</code>、<code>UDP</code></li>
<li>如果要修改传输层，意味着操作系统的内核也要修改</li>
<li>另外，由<code>IETF</code>标准化的许多<code>TCP</code>新特性都因缺乏广泛支持而没有得到广泛的部署或使用</li>
<li>因此，要想开发并应用一个新的传输层协议，是极其困难的一件事情</li>
</ul>
</li>
</ul>
<h2 id="特性-连接迁移"><a href="#特性-连接迁移" class="headerlink" title="特性 - 连接迁移"></a>特性 - 连接迁移</h2><ul>
<li><p><code>TCP</code>基于<code>4</code>要素（<code>源IP</code>、<code>源端口</code>、<code>目标IP</code>、<code>目标端口</code>）</p>
<ul>
<li>切换网络时至少会有一个要素发生变化，导致连接发生变化</li>
<li>当连接发生变化时，如果还使用原来的<code>TCP</code>连接，则会导致连接失败，就得等原来的连接超时后重新建立连接</li>
<li>所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久</li>
<li>如果实现得好，当检测到网络变化时立刻建立新的<code>TCP</code>连接，即使这样，建立新的连接还是需要几百毫秒的时间</li>
</ul>
</li>
<li><p><code>QUIC</code>的连接不受<code>4</code>要素的影响，当<code>4</code>要素发生变化时，原连接依然维持</p>
<ul>
<li><code>QUIC</code>连接不以<code>4</code>要素作为标识，而是使用一组<code>Connection ID</code>（连接<code>ID</code>）来标识一个连接</li>
<li>即使<code>IP</code>或者端口发生变化，只要<code>Connection ID</code>没有变化，那么连接依然可以维持</li>
<li>比如<ul>
<li>当设备连接到<code>Wi-Fi</code>时，将进行中的下载从蜂窝网络连接转移到更快速的<code>Wi-Fi</code>连接</li>
<li>当<code>Wi-Fi</code>连接不再可用时，将连接转移到蜂窝网络连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul>
<li>据<code>Google</code>和<code>Facebook</code>称，与基于<code>TLS</code>的<code>HTTP/2</code>相比，它们大规模部署的<code>QUIC</code>需要近<code>2</code>倍的<code>CPU</code>使用量<ul>
<li><code>Linux</code>内核的<code>UDP</code>部分没有得到像<code>TCP</code>那样的优化，因为传统上没有使用<code>UDP</code>进行如此高速的信息传输</li>
<li><code>TCP</code>和<code>TLS</code>有硬件加速，而这对于<code>UDP</code>很罕见，对于<code>QUIC</code>则基本不存在</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>https</title>
    <url>/2024/01/28/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Http_s/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><ul>
<li><p><code>HTTPS</code>（<code>HyperText Transfer Protocol Secure</code>），译为：超文本传输安全协议</p>
<ul>
<li>常称为<code>HTTP over TLS</code>、<code>HTTP over SSL</code>、<code>HTTP Secure</code></li>
<li>由网景公司于<code>1994</code>年首次提出</li>
</ul>
</li>
<li><p><code>HTTPS</code>的默认端口号是<code>443</code>（<code>HTTP</code>是<code>80</code>）</p>
</li>
</ul>
<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a><code>SSL/TLS</code></h2><ul>
<li><p><code>HTTPS</code>是在<code>HTTP</code>的基础上使用<code>SSL/TLS</code>来加密报文，对窃听和中间人攻击提供合理的防护</p>
</li>
<li><p><code>SSL/TLS</code>也可以用在其他协议上，比如</p>
<ul>
<li><code>FTP → FTPS</code></li>
<li><code>SMTP → SMTPS</code></li>
</ul>
</li>
<li><p><code>TLS</code>（<code>Transport Layer Security</code>），译为：传输层安全性协议</p>
<ul>
<li>前身是<code>SSL</code>（<code>Secure Sockets Layer</code>），译为：安全套接层</li>
</ul>
</li>
<li><p>历史版本信息</p>
<ul>
<li><code>SSL 1.0</code>：因存在严重的安全漏洞，从未公开过</li>
<li><code>SSL 2.0</code>：<code>1995</code>年，已于<code>2011</code>年弃用（<a href="https://tools.ietf.org/html/rfc6176">RFC 6176</a>）</li>
<li><code>SSL 3.0</code>：<code>1996</code>年，已于<code>2015</code>年弃用（<a href="https://tools.ietf.org/html/rfc7568">RFC 7568</a>）</li>
<li><code>TLS 1.0</code>：<code>1999</code>年（<a href="https://tools.ietf.org/html/rfc2246">RFC 2246</a>）</li>
<li><code>TLS 1.1</code>：<code>2006</code>年（<a href="https://tools.ietf.org/html/rfc4346">RFC 4346</a>）</li>
<li><code>TLS 1.2</code>：<code>2008</code>年（<a href="https://tools.ietf.org/html/rfc5246">RFC 5246</a>）</li>
<li><code>TLS 1.3</code>：<code>2018</code>年（<a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a>）</li>
</ul>
</li>
</ul>
<h2 id="SSL-TLS工作在应用层"><a href="#SSL-TLS工作在应用层" class="headerlink" title="SSL/TLS工作在应用层"></a><code>SSL/TLS</code>工作在应用层</h2><p><img src="1.jpg"></p>
<h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a><code>OpenSSL</code></h2><ul>
<li><code>OpenSSL</code>是<code>SSL/TLS</code>协议的开源实现，始于<code>1998</code>年，支持<code>Windows</code>、<code>Mac</code>、<code>Linux</code>等平台<ul>
<li><code>Linux</code>、<code>Mac</code>一般自带<code>OpenSSL</code></li>
<li><code>Windows</code><a href="https://slproweb.com/products/Win32OpenSSL.html">下载安装OpenSSL</a></li>
</ul>
</li>
<li>常用命令<ul>
<li>生成私钥：<code>openssl genrsa -out mj.key</code></li>
<li>生成公钥：<code>openssl rsa -in mj.key -pubout -out mj.pem</code></li>
</ul>
</li>
<li>可以使用<code>OpenSSL</code>构建一套属于自己的<code>CA</code>，自己给自己颁发证书，称为“自签名证书”</li>
</ul>
<h2 id="Https的通信过程"><a href="#Https的通信过程" class="headerlink" title="Https的通信过程"></a><code>Https</code>的通信过程</h2><p><img src="13.png"></p>
<ul>
<li>总的可以分为<code>3</code>大阶段<ul>
<li><code>TCP</code>的<code>3</code>次握手</li>
<li><code>TLS</code>的连接</li>
<li><code>HTTP</code>请求和响应</li>
</ul>
</li>
</ul>
<h2 id="TLS-1-2的连接"><a href="#TLS-1-2的连接" class="headerlink" title="TLS 1.2的连接"></a><code>TLS 1.2</code>的连接</h2><ul>
<li>大概是有<code>10</code>大步骤</li>
<li>图片中省略了中间产生的一些<code>ACK</code>确认</li>
</ul>
<p><img src="2.jpg"></p>
<h3 id="TLS-1-2的连接-Client-Hello"><a href="#TLS-1-2的连接-Client-Hello" class="headerlink" title="TLS 1.2的连接 - Client Hello"></a><code>TLS 1.2</code>的连接 - <code>Client Hello</code></h3><ul>
<li><code>Client Hello</code><ul>
<li>TLS的版本号</li>
<li>支持的加密组件（<code>Cipher Suite</code>）列表<ul>
<li>加密组件是指所使用的加密算法及密钥长度等</li>
</ul>
</li>
<li>一个随机数（<code>Client Random</code>）</li>
</ul>
</li>
</ul>
<p><img src="3.jpg"></p>
<h3 id="TLS-1-2的连接-Server-Hello"><a href="#TLS-1-2的连接-Server-Hello" class="headerlink" title="TLS 1.2的连接 - Server Hello"></a><code>TLS 1.2</code>的连接 - <code>Server Hello</code></h3><ul>
<li><p><code>Server Hello</code></p>
<ul>
<li>TLS的版本号</li>
<li>选择的加密组件<ul>
<li>是从接收到的客户端加密组件列表中挑选出来的</li>
</ul>
</li>
<li>一个随机数（<code>Server Random</code>)</li>
</ul>
<p>  <img src="4.jpg"></p>
</li>
</ul>
<h3 id="TLS-1-2的连接-Certificate"><a href="#TLS-1-2的连接-Certificate" class="headerlink" title="TLS 1.2的连接 - Certificate"></a><code>TLS 1.2</code>的连接 - <code>Certificate</code></h3><ul>
<li><code>Certificate</code><ul>
<li>服务器的公钥证书（被<code>CA</code>签名过的）</li>
</ul>
</li>
</ul>
<p><img src="5.jpg"></p>
<h3 id="TLS-1-2的连接-Server-Key-Exchange"><a href="#TLS-1-2的连接-Server-Key-Exchange" class="headerlink" title="TLS 1.2的连接 - Server Key Exchange"></a><code>TLS 1.2</code>的连接 - <code>Server Key Exchange</code></h3><ul>
<li><code>Server Key Exchange</code><ul>
<li>用以实现<code>ECDHE</code>算法的其中一个参数（<code>Server Params</code>）<ul>
<li><code>ECDHE</code>是一种密钥交换算法</li>
<li>为了防止伪造，<code>Server Params</code>经过了服务器私钥签名</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="6.jpg"></p>
<h3 id="TLS-1-2的连接-Server-Hello-Done"><a href="#TLS-1-2的连接-Server-Hello-Done" class="headerlink" title="TLS 1.2的连接 - Server Hello Done"></a><code>TLS 1.2</code>的连接 - <code>Server Hello Done</code></h3><ul>
<li><p><code>Server Hello Done</code></p>
<ul>
<li>告知客户端：协商部分结束</li>
</ul>
<p>  <img src="7.jpg"></p>
</li>
<li><p>目前为止，客户端和服务器之间通过明文共享了</p>
<ul>
<li><code>Client Random</code>、<code>Server Random</code>、<code>Server Params</code></li>
</ul>
</li>
<li><p>而且，客户端也已经拿到了服务器的公钥证书，接下来，客户端会验证证书的真实有效性</p>
</li>
</ul>
<h3 id="TLS-1-2的连接-Client-Key-Exchange"><a href="#TLS-1-2的连接-Client-Key-Exchange" class="headerlink" title="TLS 1.2的连接 - Client Key Exchange"></a><code>TLS 1.2</code>的连接 - <code>Client Key Exchange</code></h3><ul>
<li><code>Client Key Exchange</code><ul>
<li>用以实现<code>ECDHE</code>算法的另一个参数（<code>Client Params</code>）</li>
</ul>
</li>
</ul>
<p><img src="8.jpg"></p>
<ul>
<li>目前为止，客户端和服务器都拥有了<code>ECDHE</code>算法需要的<code>2</code>个参数：<code>Server Params</code>、<code>Client Params</code></li>
<li>客户端、服务器都可以<ul>
<li>使用<code>ECDHE</code>算法根据<code>Server Params</code>、<code>Client Params</code>计算出一个新的随机密钥串：<code>Pre-master secret</code></li>
<li>然后结合<code>Client Random</code>、<code>Server Random</code>、<code>Pre-master secret</code>生成一个<code>主密钥</code></li>
<li>最后利用<code>主密钥</code>衍生出其他密钥：客户端发送用的<code>会话密钥</code>、服务器发送用的<code>会话密钥</code>等</li>
</ul>
</li>
</ul>
<h3 id="TLS-1-2的连接-客户端发送的Change-Cipher-Spec"><a href="#TLS-1-2的连接-客户端发送的Change-Cipher-Spec" class="headerlink" title="TLS 1.2的连接 - 客户端发送的Change Cipher Spec"></a><code>TLS 1.2</code>的连接 - 客户端发送的<code>Change Cipher Spec</code></h3><ul>
<li><code>Change Cipher Spec</code><ul>
<li>告知服务器：之后的通信会采用计算出来的会话密钥进行加密</li>
</ul>
  <img src="9.jpg"></li>
</ul>
<h3 id="TLS-1-2的连接-客户端发送的Finished"><a href="#TLS-1-2的连接-客户端发送的Finished" class="headerlink" title="TLS 1.2的连接 -  客户端发送的Finished"></a><code>TLS 1.2</code>的连接 -  客户端发送的<code>Finished</code></h3><ul>
<li><code>Finished</code><ul>
<li>包含连接至今全部报文的整体校验值（摘要），<code>加密</code>之后发送给服务器</li>
<li>这次握手协商是否成功，要以服务器是否能够正确解密该报文作为判定标准</li>
</ul>
</li>
</ul>
<p><img src="10.jpg"></p>
<h3 id="TLS-1-2的连接-服务器发送的Change-Cipher-Spec-Finished"><a href="#TLS-1-2的连接-服务器发送的Change-Cipher-Spec-Finished" class="headerlink" title="TLS 1.2的连接 - 服务器发送的Change Cipher Spec,Finished"></a><code>TLS 1.2</code>的连接 - 服务器发送的<code>Change Cipher Spec</code>,<code>Finished</code></h3><ul>
<li>服务器发送的<code>Change Cipher Spec</code></li>
<li>服务器发送的<code>Finished</code><ul>
<li>到此为止，客户端服务器都验证加密解密没问题，握手正式结束</li>
<li>后面开始传输加密的<code>HTTP</code>请求和响应</li>
</ul>
</li>
</ul>
<p><img src="11.jpg"></p>
<p><img src="12.jpg"></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>网络安全</title>
    <url>/2024/01/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络安全威胁"><a href="#网络安全威胁" class="headerlink" title="网络安全威胁"></a>网络安全威胁</h1><ul>
<li>网络通信中面临的 种安全威胁<ul>
<li>截获：窃听通信内容</li>
<li>中断：中断网络通信</li>
<li>篡改：篡改通信内容</li>
<li>伪造：伪造通信内容</li>
</ul>
</li>
</ul>
<p><img src="1.jpg"></p>
<h1 id="网络层安全问题"><a href="#网络层安全问题" class="headerlink" title="网络层安全问题"></a>网络层安全问题</h1><h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a><code>ARP</code>欺骗</h2><ul>
<li><code>ARP</code>欺骗（<code>ARP spoofing</code>），又称<code>ARP</code>毒化（<code>ARP poisonin</code>g）、<code>ARP</code>病毒、<code>ARP</code>攻击</li>
<li><code>ARP</code>欺骗可以造成的效果<ul>
<li>可让攻击者获取局域网上的数据包甚至可篡改数据包</li>
<li>可让网络上特定电脑之间无法正常通信（例如网络执法官这样的软件）</li>
<li>让送至特定<code>IP</code>地址的流量被错误送到攻击者所取代的地方</li>
</ul>
</li>
</ul>
<h2 id="步骤举例"><a href="#步骤举例" class="headerlink" title="步骤举例"></a>步骤举例</h2><ul>
<li>假设主机<code>C</code>是攻击者，主机<code>A</code>、<code>B</code>是被攻击者<ul>
<li><code>C</code>只要收到过<code>A</code>、<code>B</code>发送的<code>ARP</code>请求，就会拥有<code>A</code>、<code>B</code>的<code>IP</code>、<code>MAC</code>地址，就可以进行欺骗活动</li>
<li><code>C</code>发送一个<code>ARP</code>响应给<code>B</code>，把响应包里的源<code>IP</code>设为<code>A</code>的<code>IP</code>地址，源<code>MAC</code>设为<code>C</code>的<code>MAC</code>地址</li>
<li><code>B</code>收到<code>ARP</code>响应后，更新它的<code>ARP</code>表，把<code>A</code>的<code>MAC</code>地址（<code>IP_A</code>, <code>MAC_A</code>）改为（<code>IP_A</code>, <code>MAC_C</code>）</li>
<li>当<code>B</code>要发送数据包给<code>A</code>时，它根据<code>ARP</code>表来封装数据包的头部，把目标<code>MAC</code>地址设为<code>MAC_C</code>，而非<code>MAC_A</code></li>
<li>当交换机收到<code>B</code>发送给<code>A</code>的数据包时，根据此包的目标<code>MAC地址</code>（<code>MAC_C</code>）而把数据包转发给<code>C</code></li>
<li><code>C</code>收到数据包后，可以把它存起来后再发送给<code>A</code>，达到窃听效果。<code>C</code>也可以篡改数据后才发送数据包给<code>A</code></li>
</ul>
</li>
</ul>
<h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><ul>
<li>静态<code>ARP</code></li>
<li><code>DHCP Snooping</code><ul>
<li>网络设备可借由<code>DHCP</code>保留网络上各电脑的<code>MAC</code>地址，在伪造的<code>ARP</code>数据包发出时即可侦测到</li>
</ul>
</li>
<li>利用一些软件监听<code>ARP</code>的不正常变动</li>
<li>…</li>
</ul>
<h1 id="DoS、DDoS"><a href="#DoS、DDoS" class="headerlink" title="DoS、DDoS"></a><code>DoS</code>、<code>DDoS</code></h1><ul>
<li><p><code>DoS</code>攻击（拒绝服务攻击，<code>Denial-of-Service attack</code>）</p>
<ul>
<li>使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问</li>
</ul>
</li>
<li><p><code>DDoS</code>攻击（分布式拒绝服务攻击，<code>Distributed Denial-of-Service attack</code>）</p>
<ul>
<li>黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动<code>DoS</code>攻击</li>
<li><code>2018</code>年<code>3</code>月，<code>GitHub</code>遭到迄今为止规模最大的<code>DDoS</code>攻击</li>
</ul>
</li>
<li><p><code>DoS</code>攻击可以分为<code>2</code>大类</p>
<ul>
<li>带宽消耗型：<code>UDP</code>洪水攻击、<code>ICMP</code>洪水攻击</li>
<li>资源消耗型：<code>SYN</code>洪水攻击、<code>LAND</code>攻击</li>
</ul>
</li>
</ul>
<h2 id="DoS、DDoS防御"><a href="#DoS、DDoS防御" class="headerlink" title="DoS、DDoS防御"></a><code>DoS</code>、<code>DDoS</code>防御</h2><ul>
<li><p>防御方式通常为：入侵检测、流量过滤、和多重验证</p>
<ul>
<li>堵塞网络带宽的流量将被过滤，而正常的流量可正常通过</li>
</ul>
</li>
<li><p>防火墙</p>
<ul>
<li>防火墙可以设置规则，例如允许或拒绝特定通讯协议，端口或<code>IP</code>地址</li>
<li>当攻击从少数不正常的<code>IP</code>地址发出时，可以简单的使用拒绝规则阻止一切从攻击源<code>IP</code>发出的通信</li>
<li>复杂攻击难以用简单规则来阻止，例如<code>80</code>端口遭受攻击时不可能拒绝端口所有的通信，因为同时会阻止合法流量</li>
<li>防火墙可能处于网络架构中过后的位置，路由器可能在恶意流量达到防火墙前即被攻击影响</li>
</ul>
</li>
<li><p>交换机：大多数交换机有一定的速度限制和访问控制能力</p>
</li>
<li><p>路由器：和交换机类似，路由器也有一定的速度限制和访问控制能力</p>
</li>
<li><p>黑洞引导</p>
<ul>
<li>将所有受攻击计算机的通信全部发送至一个“黑洞”（空接口或不存在的计算机地址）或者有足够能力处理洪流的网络设备商，以避免网络受到较大影响</li>
</ul>
</li>
<li><p>流量清洗</p>
<ul>
<li>当流量被送到<code>DDoS</code>防护清洗中心时，通过采用抗<code>DDoS</code>软件处理，将正常流量和恶意流量区分开</li>
<li>正常的流量则回注回客户网站</li>
</ul>
</li>
</ul>
<h1 id="传输层安全问题"><a href="#传输层安全问题" class="headerlink" title="传输层安全问题"></a>传输层安全问题</h1><h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a><code>SYN</code>洪水攻击</h2><ul>
<li><code>SYN</code>洪水攻击（<code>SYN flooding attack</code>）<ul>
<li>攻击者发送一系列的<code>SYN</code>请求到目标，然后让目标因收不到<code>ACK</code>（第<code>3</code>次握手）而进行等待、消耗资源</li>
</ul>
</li>
<li>攻击方法<ul>
<li>跳过发送最后的<code>ACK</code>信息</li>
<li>修改源<code>IP</code>地址，让目标送<code>SYN-ACK</code>到伪造的<code>IP</code>地址，因此目标永不可能收到<code>ACK</code>（第3次握手）</li>
</ul>
</li>
<li>防护<ul>
<li>参考：<a href="https://datatracker.ietf.org/doc/html/rfc4987">RFC 4987</a></li>
</ul>
</li>
</ul>
<h2 id="LAND攻击"><a href="#LAND攻击" class="headerlink" title="LAND攻击"></a><code>LAND</code>攻击</h2><ul>
<li><code>LAND</code>攻击（局域网拒绝服务攻击，<code>Local Area Network Denial attack</code>）<ul>
<li>通过持续发送相同源地址和目标地址的欺骗数据包，使目标试图与自己建立连接，消耗系统资源直至崩溃</li>
</ul>
</li>
<li>有些系统存在设计上的缺陷，允许设备接受并响应来自网络、却宣称来自于设备自身的数据包，导致循环应答</li>
<li>防护<ul>
<li>大多数防火墙都能拦截类似的攻击包，以保护系统</li>
<li>部分操作系统通过发布安全补丁修复了这一漏洞</li>
<li>路由器应同时配置上行与下行筛选器，屏蔽所有源地址与目标地址相同的数据包</li>
</ul>
</li>
</ul>
<h1 id="应用层安全问题"><a href="#应用层安全问题" class="headerlink" title="应用层安全问题"></a>应用层安全问题</h1><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><ul>
<li><p><code>DNS</code>劫持，又称为域名劫持</p>
<ul>
<li>攻击者篡改了某个域名的解析结果，使得指向该域名的<code>IP</code>变成了另一个<code>IP</code></li>
<li>导致对相应网址的访问被劫持到另一个不可达的或者假冒的网址</li>
<li>从而实现非法窃取用户信息或者破坏正常网络服务的目的</li>
</ul>
</li>
<li><p>为防止<code>DNS</code>劫持，可以考虑使用更靠谱的<code>DNS</code>服务器，比如：<code>114.114.114.114</code></p>
<ul>
<li>谷歌：<code>8.8.8.8</code>、<code>8.8.4.4</code></li>
<li>微软：<code>4.2.2.1</code>、<code>4.2.2.2</code></li>
<li>百度：<code>180.76.76.76</code></li>
<li>阿里：<code>223.5.5.5</code>、<code>223.6.6.6</code></li>
</ul>
</li>
</ul>
<h2 id="Http的安全问题"><a href="#Http的安全问题" class="headerlink" title="Http的安全问题"></a>Http的安全问题</h2><ul>
<li><p><code>HTTP</code>劫持：对<code>HTTP</code>数据包进行拦截处理，比如插入<code>JS</code>代码</p>
<ul>
<li>比如你访问某些网站时，在右下角多了个莫名其妙的弹窗广</li>
</ul>
</li>
<li><p><code>HTTP</code>协议默认是采取明文传输的，因此会有很大的安全隐患</p>
<ul>
<li>常见的提高安全性的方法是：对通信内容进行加密后，再进行传输</li>
</ul>
</li>
</ul>
<h1 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h1><ul>
<li>常见的加密方式有<ul>
<li>不可逆<ul>
<li>单向散列函数：<code>MD5</code>、<code>SHA</code>等</li>
</ul>
</li>
<li>可逆<ul>
<li>对称加密：<code>DES</code>、<code>3DES</code>、<code>AES</code>等</li>
<li>非对称加密：<code>RSA</code>等</li>
</ul>
</li>
<li>其它<ul>
<li>混合密码系统</li>
<li>数字签名</li>
<li>证书</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h2><ul>
<li>单向散列函数，可以根据根据消息内容计算出散列值</li>
<li>散列值的长度和消息的长度无关，无论消息是<code>1bit</code>、<code>10M</code>、<code>100G</code>，单向散列函数都会计算出固定长度的散列值</li>
</ul>
<p><img src="2.jpg"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>根据任意长度的消息，计算出固定长度的散列值</li>
<li>计算速度快，能快速计算出散列值</li>
<li>消息不同，散列值也不同</li>
<li>具备单向性</li>
</ul>
<p><img src="3.jpg"></p>
<h3 id="称呼"><a href="#称呼" class="headerlink" title="称呼"></a>称呼</h3><ul>
<li>单向散列函数，也被称为<ul>
<li>消息摘要函数</li>
<li>哈希函数</li>
</ul>
</li>
<li>输出的散列值，也被称为<ul>
<li>消息摘要</li>
<li>指纹</li>
</ul>
</li>
</ul>
<h3 id="常见的单向散列函数"><a href="#常见的单向散列函数" class="headerlink" title="常见的单向散列函数"></a>常见的单向散列函数</h3><ul>
<li><p><code>MD4</code>、<code>MD5</code></p>
<ul>
<li>产生<code>128bit</code>的散列值,<code>MD</code>就是<code>Message Digest</code>的缩写</li>
</ul>
</li>
<li><p><code>SHA-1</code></p>
<ul>
<li>产生<code>160bit</code>的散列值</li>
</ul>
</li>
<li><p><code>SHA-2</code></p>
<ul>
<li><code>SHA-265</code>、<code>SHA-384</code>、<code>SHA-512</code>，散列值长度分别是<code>256bit</code>、<code>384bit</code>、<code>512bit</code></li>
</ul>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>防止数据被篡改<br><img src="4.jpg"></li>
<li>保密用户密码（服务器数据库中是保存单向散列的值，而非密码，因此是无法获取原密码的）</li>
</ol>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ul>
<li>在对称加密中，加密、解密时使用的是同一个密钥</li>
<li>常见的对称加密算法有<ul>
<li><code>DES</code></li>
<li><code>3DES</code></li>
<li><code>AES</code></li>
</ul>
</li>
</ul>
<p><img src="5.jpg"></p>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a><code>DES</code></h3><p><img src="6.jpg"></p>
<ul>
<li><code>DES</code>是一种将<code>64bit</code>明文加密成<code>64bit</code>密文的对称加密算法，密钥长度是<code>56bit</code></li>
<li>规格上来说，密钥长度是<code>64bit</code>，但每隔<code>7bit</code>会设置一个用于错误检查的 ，因此密钥长度实质上是<code>56bit</code></li>
<li>由于<code>DES</code>每次只能加密<code>64bit</code>的数据，遇到比较大的数据，需要对<code>DES</code>加密进行迭代（反复）</li>
<li>目前已经可以在短时间内被破解，所以不建议使用</li>
</ul>
<h3 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a><code>3DES</code></h3><ul>
<li><code>3DES</code>,将<code>DES</code>重复<code>3</code>次所得到的一种密码算法，也叫做<code>3</code>重<code>DES</code><ul>
<li>三重<code>DES</code>并不是进行三次<code>DES</code>加密（加密-&gt;加密-&gt;加密）</li>
<li>而是加密（<code>Encryption</code>） 解密（<code>Decryption</code>） 加密（<code>Encryption</code>）的过程</li>
</ul>
</li>
</ul>
<p><img src="7.jpg"></p>
<ul>
<li><code>3</code>个密钥都是不同的，也称为<code>DES-EDE3</code></li>
<li>如果所有密钥都使用同一个，则结果与普通的<code>DES</code>是等价的</li>
<li>如果密钥<code>1</code>、密钥<code>3</code>相同，密钥<code>2</code>不同，称为<code>DES-EDE2</code></li>
</ul>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a><code>AES</code></h3><ul>
<li>取代<code>DES</code>成为新标准的一种对称加密算法，又称<code>Rijndael</code>加密</li>
<li><code>AES</code>的密钥长度有<code>128</code>、<code>192</code>、<code>256bit</code> 三种</li>
<li>目前<code>AES</code>，已经逐步取代<code>DES</code>、<code>#DES</code>，成为首选的对称加密算法</li>
<li>一般来说，我们也不应该去使用任何自制的密码算法，而是应该使用<code>AES</code><ul>
<li>它经过了全世界密码学家所进行的高品质验证工作</li>
</ul>
</li>
</ul>
<h3 id="密钥配送问题"><a href="#密钥配送问题" class="headerlink" title="密钥配送问题"></a>密钥配送问题</h3><ul>
<li><p>在使用对称加密时，一定会遇到密钥配送问题<br><img src="8.jpg"></p>
</li>
<li><p>如果<code>Alice</code>将使用对称加密过的消息发给了<code>Bob</code></p>
<ul>
<li>只有将密钥发送给<code>Bob</code>,<code>Bob</code>才能完成解密</li>
<li>在发送密钥过程中<ul>
<li>可能会被<code>Eve</code>窃取密钥</li>
<li>最后<code>Eve</code>也能完成解密</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何解决密钥配送问题"><a href="#如何解决密钥配送问题" class="headerlink" title="如何解决密钥配送问题"></a>如何解决密钥配送问题</h3><ul>
<li>有以下几种解决密钥配送的方法<ul>
<li>事先共享密钥（比如私下共享）</li>
<li>密钥分配中心（<code>Key Distribution Center</code>，简称<code>KDC</code>）</li>
<li><code>Diffie-Hellman</code>密钥交换</li>
<li>非对称加密</li>
</ul>
</li>
</ul>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ul>
<li>在非对称加密中，密钥分为加密密钥、解密密钥<code>2</code>种，它们并不是同一个密钥</li>
<li>加密密钥：一般是公开的，因此该密钥称为公钥（<code>public key</code>）<ul>
<li>因此，非对称加密也被称为公钥密码（<code>Public-key Cryptography</code>）</li>
</ul>
</li>
<li>解密密钥：由消息接收者自己保管的，不能公开，因此也称为私钥(<code>Private key</code>)</li>
</ul>
<p><img src="9.jpg"></p>
<h3 id="公钥、私钥"><a href="#公钥、私钥" class="headerlink" title="公钥、私钥"></a>公钥、私钥</h3><ul>
<li>公钥和私钥是一一对应的，不能单独生成<ul>
<li>一对公钥和私钥统称为密钥对（<code>key pair</code>）</li>
</ul>
</li>
<li>由公钥加密的密文，必须使用与该公钥对应的私钥才能解密</li>
<li>由私钥加密的密文，必须使用与该私钥对应的公钥才能解密</li>
</ul>
<p><img src="10.jpg"></p>
<h3 id="解决密钥配送问题"><a href="#解决密钥配送问题" class="headerlink" title="解决密钥配送问题"></a>解决密钥配送问题</h3><ul>
<li>由消息的接收者，生成一对公钥、私钥</li>
<li>将公钥发给消息的发送者</li>
<li>消息的发送者使用公钥加密消息</li>
<li>非对称加密的加密解密速度比对称加密要慢</li>
</ul>
<p><img src="11.jpg"></p>
<h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><ul>
<li>对称加密的缺点<ul>
<li>不能很好地解决密钥配送问题（密钥会被窃听）</li>
</ul>
</li>
<li>非对称加密的缺点<ul>
<li>加密解密速度比较慢</li>
</ul>
</li>
<li>混合密码系统：是将对称加密和非对称加密的优势相结合的方法<ul>
<li>解决了非对称加密速度慢的问题</li>
<li>并通过非对称加密解决了对称加密的密钥配送问题</li>
</ul>
</li>
<li>网络上的密码通信所用的 都运用了混合密码系统</li>
</ul>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul>
<li>会话密钥（<code>session key</code>）<ul>
<li>为本次通信随机生成的临时密钥</li>
<li>作为对称加密的密钥，用于加密消息，提高速度</li>
</ul>
</li>
</ul>
<p><img src="12.jpg"></p>
<ul>
<li><p>加密步骤（发送消息）</p>
<ol>
<li>首先，消息发送者要拥有消息接收者的公钥</li>
<li>生成会话密钥，作为对称加密的密钥，加密消息</li>
<li>用消息接收者的公钥，加密会话密钥</li>
<li>将前<code>2</code>步生成的加密结果，一并发给消息接收者</li>
</ol>
</li>
<li><p>发送出去的内容包括</p>
<ul>
<li>用会话密钥加密的消息（加密方法：对称加密）</li>
<li>用公钥加密的会话密钥（加密方法：非对称加密）</li>
</ul>
</li>
</ul>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p><img src="13.jpg"></p>
<ul>
<li>解密步骤（收到消息）<ol>
<li>消息接收者用自己的私钥解密出会话密钥</li>
<li>再用第1步解密出来的会话密钥，解密消息</li>
</ol>
</li>
</ul>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><ul>
<li>在数字签名技术中，有以下2种行为<ul>
<li>生成签名<ul>
<li>由消息的发送者完成，通过“签名密钥”生成</li>
</ul>
</li>
<li>验证签名<ul>
<li>由消息的接收者完成，通过“验证密钥”验证</li>
</ul>
</li>
</ul>
</li>
<li>如何能保证这个签名是消息发送者自己签的？<ul>
<li>用消息发送者的私钥进行签名</li>
</ul>
</li>
</ul>
<p><img src="14.jpg"></p>
<h3 id="数字签名的问题"><a href="#数字签名的问题" class="headerlink" title="数字签名的问题"></a>数字签名的问题</h3><ul>
<li><p>如果有人篡改了消息内容或签名内容，会是什么结果？</p>
<ul>
<li>签名验证失败，证明内容被篡改了</li>
</ul>
</li>
<li><p>数字签名不能保证机密性？</p>
<ul>
<li>数字签名的作用不是为了保证机密性，仅仅是为了能够识别内容有没有被<code>篡改</code></li>
</ul>
</li>
<li><p>数字签名的作用</p>
<ul>
<li>确认消息的完整性</li>
<li>识别消息是否被篡改</li>
<li>防止消息发送人否认</li>
</ul>
</li>
</ul>
<h2 id="非对称加密-公钥的问题"><a href="#非对称加密-公钥的问题" class="headerlink" title="非对称加密 - 公钥的问题"></a>非对称加密 - 公钥的问题</h2><ul>
<li><p>在非对称加密中，任何人都可以使用公钥进行加密<br><img src="15.jpg"></p>
</li>
<li><p>在数字签名中，任何人都可以使用公钥验证签名<br><img src="16.jpg"></p>
</li>
<li><p>数字签名，其实就是将非对称加密反过来使用</p>
</li>
<li><p>对于加密而言，那肯定是不希望别人知道我的消息，所以只有我才能解密</p>
<ul>
<li>公钥负责加密，私钥负责解密</li>
</ul>
</li>
<li><p>对于签名而言，那肯定是不希望有人冒充我发消息，所以只有我才能签名</p>
<ul>
<li>私钥负责签名，公钥负责验签</li>
</ul>
</li>
</ul>
<h3 id="公钥的合法性"><a href="#公钥的合法性" class="headerlink" title="公钥的合法性"></a>公钥的合法性</h3><p><img src="17.jpg"></p>
<ul>
<li><p>如果遭遇了中间人攻击，那么</p>
<ul>
<li>公钥将可能是伪造的</li>
</ul>
</li>
<li><p>如何验证公钥的合法性？</p>
<ul>
<li>证书</li>
</ul>
</li>
</ul>
<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><ul>
<li><p>密码学中的证书，全称叫公钥证书（<code>Public-key Certificate，PKC</code>），跟驾驶证类似</p>
<ul>
<li>里面有姓名、邮箱等个人信息，以及此人的公钥</li>
<li>并由认证机构（<code>Certificate Authority，CA</code>）施加数字签名</li>
</ul>
</li>
<li><p><code>CA</code>就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织</p>
<ul>
<li>有国际性组织、政府设立的组织</li>
<li>有通过提供认证服务来盈利的企业</li>
<li>个人也可以成立认证机构</li>
</ul>
</li>
</ul>
<h3 id="证书的使用"><a href="#证书的使用" class="headerlink" title="证书的使用"></a>证书的使用</h3><p><img src="18.jpg"></p>
<ul>
<li>各大<code>CA</code>的公钥，默认已经内置在浏览器和操作系统中。</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>应用层（http）</title>
    <url>/2024/01/25/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Http_/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Http"><a href="#Http" class="headerlink" title="Http"></a><code>Http</code></h1><ul>
<li><code>HTTP</code>（<code>Hyper Text Transfer Protocol</code>），译为超文本传输协议<ul>
<li>是互联网中应用最广泛的应用层协议之一</li>
<li>设计<code>HTTP</code>最初的目的是：提供一种发布和接收<code>HTML</code>页面的方法，由<code>URI</code>来标识具体的资源</li>
<li>后面用<code>HTTP</code>来传递的数据格式不仅仅是<code>HTML</code>，应用非常广泛</li>
</ul>
</li>
<li><code>HTML</code>（ <code>Hyper Text Markup Language</code>）：超文本标记语言<ul>
<li>用以编写网页</li>
</ul>
</li>
</ul>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li><code>1991</code>年，<code>HTTP/0.9</code><ul>
<li>只支持<code>GET</code>请求方法获取文本数据（比如<code>HTML</code>文档），且不支持请求头、响应头等，无法向服务器传递太多信息</li>
</ul>
</li>
<li><code>1996年，HTTP/1.0</code><ul>
<li>支持<code>POST</code>、<code>HEAD</code>等请求方法，支持请求头、响应头等，支持更多种数据类型（不再局限于文本数据）</li>
<li>浏览器的每次请求都需要与服务器建立一个<code>TCP</code>连接，请求处理完成后立即断开<code>TCP</code>连接</li>
</ul>
</li>
<li><code>1997</code>年，<code>HTTP/1.1</code>（最经典、使用最广泛的版本）<ul>
<li>支持<code>PUT</code>、<code>DELETE</code>等请求方法</li>
<li>采用持久连接（<code>Connection: keep-alive</code>），多个请求可以共用同一个<code>TCP</code>连接</li>
</ul>
</li>
<li><code>2015</code>年，<code>HTTP/2.0</code></li>
<li><code>2018</code>年，<code>HTTP/3.0</code></li>
</ul>
<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><ul>
<li><code>HTTP</code>的标准<ul>
<li>由万维网协会（<code>W3C</code>）、互联网工程任务组（<code>IETF</code>）协调制定，最终发布了一系列的<code>RFC</code></li>
</ul>
</li>
<li><a href="https://www.rfc-editor.org/standards">RFC</a>（<code>Request For Comments</code>，可以译为：请求意见稿）<ul>
<li><code>HTTP/1.1</code>最早是在<code>1997</code>年的<a href="https://datatracker.ietf.org/doc/html/rfc2068">RFC 2068</a>中记录的<ul>
<li>该规范在<code>1999</code>年的<a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC 2616</a>中已作废</li>
<li><code>2014</code>年又由<a href="https://datatracker.ietf.org/doc/html/rfc7230">RFC 7230</a>系列的<code>RFC</code>取代</li>
</ul>
</li>
</ul>
</li>
<li><code>HTTP/2</code>标准于<code>2015</code>年<code>5</code>月以<a href="https://datatracker.ietf.org/doc/html/rfc7540">RFC 7540</a>正式发表，取代<code>HTTP/1.1</code>成为<code>HTTP</code>的实现标准</li>
<li>中国的<code>RFC</code><ul>
<li><code>1996</code>年<code>3</code>月，清华大学提交的适应不同国家和地区中文编码的汉字统一传输标准被<code>IETF</code>通过为<a href="https://datatracker.ietf.org/doc/html/rfc1922">RFC 1922</a><ul>
<li>成为中国大陆第一个被<code>认可</code>为<code>RFC</code>文件的提交协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><ul>
<li>一般<code>Http</code>的报文格式如下。其格式实际遵守<code>ABNF</code></li>
</ul>
<p><img src="1.jpg"><br><img src="2.jpg"></p>
<h2 id="ABNF"><a href="#ABNF" class="headerlink" title="ABNF"></a><code>ABNF</code></h2><ul>
<li><code>ABNF</code>（<code>Augmented BNF</code>）<ul>
<li>是<code>BNF</code>（<code>Backus-Naur Form</code>，译为：巴科斯-瑙尔范式）的修改、增强版</li>
<li>在<a href="https://datatracker.ietf.org/doc/html/rfc5234">RFC 5234</a>中表明：<code>ABNF</code>用作<code>internet</code>中通信协议的定义语言</li>
<li><code>ABNF是</code>最严谨的<code>HTTP</code>报文格式描述形式</li>
</ul>
</li>
<li>关于<code>HTTP</code>报文格式的定义<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc2616#section-4">RFC 2616 4.HTTP Message</a>（旧）</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3">RFC 7230 3.Message Format</a>（新）</li>
</ul>
</li>
</ul>
<h3 id="核心规则"><a href="#核心规则" class="headerlink" title="核心规则"></a>核心规则</h3><table>
<thead>
<tr>
<th align="center">规则</th>
<th align="center">形式定义</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ALPHA</code></td>
<td align="center"><code>%x41-5A</code> / <code>%x61-7A</code></td>
<td align="center">大写和小写 字母（ <code>A-Z</code>、<code>a-z</code>）</td>
</tr>
<tr>
<td align="center"><code>DIGIT</code></td>
<td align="center"><code>%x30-39</code></td>
<td align="center">数字（<code>0-9</code>）</td>
</tr>
<tr>
<td align="center"><code>HEXDIG</code></td>
<td align="center"><code>DIGIT</code> / <code>&quot;A&quot;</code>  / <code>&quot;B&quot;</code>  / <code>&quot;C&quot;</code>  / <code>&quot;D&quot;</code>  / <code>&quot;E&quot;</code>  / <code>&quot;F&quot;</code></td>
<td align="center">十六进制数字(<code>0-9</code>、<code>A-F</code>、<code>a-f</code>)</td>
</tr>
<tr>
<td align="center"><code>DQUOTE</code></td>
<td align="center"><code>%x22</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>SP</code></td>
<td align="center"><code>%x20</code></td>
<td align="center">空格</td>
</tr>
<tr>
<td align="center"><code>HTAB</code></td>
<td align="center"><code>%x09</code></td>
<td align="center">横向制表符</td>
</tr>
<tr>
<td align="center"><code>WSP</code></td>
<td align="center"><code>SP</code> / <code>HTAB</code></td>
<td align="center">空格或横向制表符</td>
</tr>
<tr>
<td align="center"><code>LWSP</code></td>
<td align="center">*(<code>WSP</code> / <code>CRLF</code> <code>WSP</code>)</td>
<td align="center">直线空白（晚于换行）</td>
</tr>
<tr>
<td align="center"><code>VCHAR</code></td>
<td align="center"><code>%x21-7E</code></td>
<td align="center">可见（打印）字符</td>
</tr>
<tr>
<td align="center"><code>CHAR</code></td>
<td align="center"><code>%x01-7F</code></td>
<td align="center">任何<code>7</code>位<code>US-ASCII</code>字符，不包括 <code>NULL</code>（ <code>%x00</code>）</td>
</tr>
<tr>
<td align="center"><code>OCTET</code></td>
<td align="center"><code>%x00-FF</code></td>
<td align="center"><code>8</code>位数据</td>
</tr>
<tr>
<td align="center"><code>CTL</code></td>
<td align="center"><code>%x00-1F</code> / <code>%x7F</code></td>
<td align="center">控制字符</td>
</tr>
<tr>
<td align="center"><code>CR</code></td>
<td align="center"><code>%x0D</code></td>
<td align="center">回车</td>
</tr>
<tr>
<td align="center"><code>LF</code></td>
<td align="center"><code>%x0A</code></td>
<td align="center">换行</td>
</tr>
<tr>
<td align="center"><code>CRLF</code></td>
<td align="center"><code>CR LF</code></td>
<td align="center">互联网标准换行（<code>%x0D</code> 、<code>%x0A</code>）</td>
</tr>
<tr>
<td align="center"><code>BIT</code></td>
<td align="center"><code>0</code> / <code>1</code></td>
<td align="center">二进制数字</td>
</tr>
</tbody></table>
<h3 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="4.png"></p>
<ul>
<li><code>/</code> : 任选一个</li>
<li><code>*</code> : <code>0</code>个或多个。<code>2*</code>表示至少<code>2</code>个，<code>3*6</code>表示<code>3</code>到<code>6</code>个</li>
<li><code>()</code> : 组成一个整体</li>
<li><code>[]</code> : 可选（可有可无）</li>
</ul>
<h4 id="start-line"><a href="#start-line" class="headerlink" title="start-line"></a><code>start-line</code></h4><ul>
<li><code>;HTTP</code>是<code>ABNF</code>格式中的注释<br><img src="5.png"></li>
</ul>
<h4 id="header-filed、message-body"><a href="#header-filed、message-body" class="headerlink" title="header - filed、message-body"></a><code>header - filed</code>、<code>message-body</code></h4><p><img src="6.png"></p>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><ul>
<li> 可以直接面向<code>HTTP</code>报文与服务器交互</li>
<li> 可以更清晰、直观地看到请求报文、响应报文的内容<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">$ telnet localhost <span class="hljs-number">8080</span><br># 建立三次握手<br><span class="hljs-attr">Trying</span> ::<span class="hljs-number">1.</span>..<br>Connected to localhost.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>^]  <br>telnet&gt;<br># 发送报文<br>GET /hello/ HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Host</span>: localhost:<span class="hljs-number">8080</span><br><br># 响应结果<br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span><br><span class="hljs-built_in">Set</span>-Cookie: JSESSIONID=74D0161CA8819EDB183B97C8611B0741; Path=/hello; HttpOnly<br>Content-Type: text/html;charset=UTF-<span class="hljs-number">8</span><br>Content-Length: <span class="hljs-number">90</span><br><span class="hljs-attr">Date</span>: Sat, <span class="hljs-number">27</span> Jan <span class="hljs-number">2024</span> <span class="hljs-number">09</span>:<span class="hljs-number">56</span>:<span class="hljs-number">43</span> GMT<br><br><br>## 回的messageBody<br>&lt;html&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>$Title$<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  $END$</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="URL的编码"><a href="#URL的编码" class="headerlink" title="URL的编码"></a><code>URL</code>的编码</h2><ul>
<li><code>URL</code>中一旦出现了一些特殊字符（比如中文、空格），需要进行编码<ul>
<li>在浏览器地址栏输入<code>URL</code>时，是采用<code>UTF-8</code>进行编码</li>
</ul>
</li>
</ul>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4">RFC 7231, section 4: Request methods</a>：描述了<code>8</code>种请求方法<ul>
<li><code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>CONNECT</code>、<code>OPTIONS</code>、<code>TRACE</code></li>
</ul>
</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5789#section-2">RFC 5789, section 2: Patch method</a>：描述了<code>PATCH</code>方法</li>
</ul>
<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><ul>
<li><p><code>GET</code>：常用于读取的操作，请求参数直接拼接在<code>URL</code>的后面（浏览器对<code>URL</code>是有长度限制的）</p>
</li>
<li><p><code>POST</code>：常用于添加、修改、删除的操作，请求参数可以放到请求体中（没有大小限制）</p>
</li>
<li><p><code>HEAD</code>：请求得到与<code>GET</code>请求相同的响应，但没有响应体</p>
<ul>
<li>使用场景举例：在下载一个大文件前，先获取其大小，再决定是否要下载。以此可以节约带宽资源</li>
</ul>
</li>
<li><p><code>OPTIONS</code>：用于获取目的资源所支持的通信选项，比如服务器支持的请求方法</p>
<ul>
<li><code>OPTIONS * HTTP/1.1</code></li>
</ul>
</li>
<li><p><code>PUT</code>：用于对已存在的资源进行整体覆盖</p>
</li>
<li><p><code>PATCH</code>：用于对资源进行部分修改（资源不存在，会创建新的资源）</p>
</li>
<li><p><code>DELETE</code>：用于删除指定的资源</p>
</li>
<li><p><code>TRACE</code>：请求服务器回显其收到的请求信息，主要用于HTTP请求的测试或诊断</p>
</li>
<li><p><code>CONNECT</code>：可以开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道（<code>tunnel</code>）</p>
<ul>
<li>可以用来访问采用了<code>SSL</code>(<code>HTTPS</code>) 协议的站点</li>
</ul>
</li>
<li><p><strong>注意</strong>，一般情况下会禁止使用不安全的<code>HTTP</code>方法，例如 <code>PUT</code>、<code>DELETE</code> 等.(主要由于历史原因导致的)</p>
<ol>
<li><p><code>Tomcat PUT</code> 的上传漏洞，受影响的版本：<code>Apache Tomcat 7.0.0 to 7.0.79</code></p>
<ul>
<li>当 <code>Tomcat</code> 运行在 <code>Windows</code>操作系统时，且启用了 <code>HTTP PUT</code> 请求方法（例如，将 <code>readonly</code> 初始化参数由默认值设置为 <code>false</code>），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 <code>JSP</code> 文件，<code>JSP</code> 文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。</li>
</ul>
</li>
<li><p><code>Nginx</code> 在开启 <code>WebDAV</code> 模式下，如果未配置认证模式，攻击者可以通过自由上传文件方法上传木马攻击服务器。</p>
<ul>
<li><code>WebDAV</code>（<code>Web-based Distributed Authoring and Versioning</code>）是基于 <code>HTTP/1.1</code> 的增强协议。该协议使用户可以直接对 <code>Web</code> 服务器进行文件读写，并支持对文件的版本控制和写文件的加锁及解锁等操作。说白了，<code>Nginx</code> 就是开启 <code>WebDAV</code> 这个协议后，可以当做一个文件服务器，允许用户在远端向本地一样进行读写操作，当然也包括上传文件。</li>
<li>由于 <code>Nginx</code> 在设计时，或许是为了减轻小白的上手难度，在开启 <code>WebDAV</code> 时没有强制要求用户必须配置访问认证，这导致了某些用户在公网上开启了 <code>WebDAV</code> 而没有进行认证配置，从而导致了安全问题。而且由于 <code>WebDAV</code> 支持的协议有 <code>PUT</code>、<code>DELETE</code>、<code>MKCOL</code>、<code>COPY</code> 和 <code>MOVE</code> 等，其中 <code>PUT</code>、<code>DELETE </code>与 <code>HTTP</code> 方法中的 <code>PUT</code>、<code>DELETE</code> 协议重合，便被安全部门给一刀切了。</li>
<li><code>WebDAV</code> 安全风险<ul>
<li><code>PUT</code>：由于 <code>PUT</code> 方法自身不带验证机制（<code>PUT</code>是幂等的，只是简单的更新，不会像<code>POST</code>在请求的时候，服务器每次都会创建一个文件），利用 <code>PUT</code> 方法可以向服务器上传文件，所以恶意攻击者可以上传木马等恶意文件。</li>
<li><code>DELETE</code>：利用 <code>DELETE</code> 方法可以删除服务器上特定的资源文件，造成恶意攻击。</li>
<li><code>OPTIONS</code>：将会造成服务器信息暴露，如中间件版本、支持的 <code>HTTP</code> 方法等。</li>
<li><code>TRACE</code>：可以回显服务器收到的请求，主要用于测试或诊断，一般都会存在反射型跨站漏洞。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a><a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">头部字段</a></h2><ul>
<li>头部字段可以分为<code>4</code>种类型<ul>
<li>请求头字段（<code>Request Header Fields</code>）<ul>
<li>有关要获取的资源或客户端本身信息的消息头</li>
</ul>
</li>
<li>响应头字段（<code>Response Header Fields</code>）<ul>
<li>有关响应的补充信息，比如服务器本身（名称和版本等）的消息头</li>
</ul>
</li>
<li>实体头字段（<code>Entity Header Fields</code>）<ul>
<li>有关实体主体的更多信息，比如主体长度（<code>Content-Length</code>）或其<code>MIME</code>类型</li>
</ul>
</li>
<li>通用头字段（<code>General Header Fields</code>）<ul>
<li>同时适用于请求和响应消息，但与消息主体无关的消息头</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="请求头字段"><a href="#请求头字段" class="headerlink" title="请求头字段"></a>请求头字段</h3><table>
<thead>
<tr>
<th align="center">头字段名</th>
<th align="center">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>User-Agent</code></td>
<td align="center">浏览器的身份标识字符串</td>
<td align="center"><code>User-Agent: Mozilla/5.0(X11；Linux x86_64；rv: 12.0)Gecko/20100101 FireFox/21.0</code></td>
</tr>
<tr>
<td align="center"><code>Host</code></td>
<td align="center">服务器的域名、端口号</td>
<td align="center"><code>Host: localhost:80</code></td>
</tr>
<tr>
<td align="center"><code>Date</code></td>
<td align="center">发送该消息的日期和时间</td>
<td align="center"><code>Date: Tue, 15 Nov 1994 08:12:31</code></td>
</tr>
<tr>
<td align="center"><code>Referer</code></td>
<td align="center">表示浏览器所访问的前一个页面正是前一个页面的某个链接将浏览器带到了当前这个页面</td>
<td align="center"><code>Referer: https://www.baidu.com</code></td>
</tr>
<tr>
<td align="center"><code>Content - Type</code></td>
<td align="center">请求体的类型</td>
<td align="center"><code>Content-Type: multipart/form-data</code></td>
</tr>
<tr>
<td align="center"><code>Content - Length</code></td>
<td align="center">请求体的长度（字节为单位）</td>
<td align="center"><code>Content-Length: 348</code></td>
</tr>
<tr>
<td align="center"><code>Accept</code></td>
<td align="center">能接受的响应内容类型（<code>Content-Types</code>）</td>
<td align="center"><code>Accept: text/plain</code></td>
</tr>
<tr>
<td align="center"><code>Accept-Charset</code></td>
<td align="center">能够接受的字符集</td>
<td align="center"><code>Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7</code>(q值越大，表示优先级越高)</td>
</tr>
<tr>
<td align="center"><code>Accept-Encoding</code></td>
<td align="center">能够接受的编码方式列表</td>
<td align="center"><code>Accept-Encoding: gzip，deflate</code></td>
</tr>
<tr>
<td align="center"><code>Accept-Language</code></td>
<td align="center">能够接受的响应内容的自然语言列表</td>
<td align="center"><code>Accept-Language: en-US</code></td>
</tr>
<tr>
<td align="center"><code>Range</code></td>
<td align="center">仅请求某个实体的一部分。字节偏移以 开始（实现断点续传）</td>
<td align="center"><code>Range: bytes=500-999</code></td>
</tr>
<tr>
<td align="center"><code>Origin</code></td>
<td align="center">发起一个针对跨域资源共享的请求</td>
<td align="center"><code>Origin: https://www.baidu.com</code></td>
</tr>
<tr>
<td align="center"><code>Cookie</code></td>
<td align="center">之前由服务器通过<code>Set-Cookie</code>发送<code>Cookie</code></td>
<td align="center"><code>Cookie: $Version = 1; SKin=new;</code></td>
</tr>
<tr>
<td align="center"><code>Connection</code></td>
<td align="center">该浏览器想要优先使用的连接类型</td>
<td align="center"><code>Connection: keep-alive</code></td>
</tr>
<tr>
<td align="center"><code>Cache-Control</code></td>
<td align="center">用来指定在这次的请求/响应链中的所有缓存机制用来指定在这次的请求 响应链中的所有缓存机制都必须遵守的指令</td>
<td align="center"><code>Cache-Control: no-cache</code></td>
</tr>
</tbody></table>
<h3 id="响应头字段"><a href="#响应头字段" class="headerlink" title="响应头字段"></a>响应头字段</h3><table>
<thead>
<tr>
<th align="center">头字段</th>
<th align="center">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Date</code></td>
<td align="center">发送该消息的日期和时间</td>
<td align="center"><code>Date: Tue, 15 Nov 1994 08:12:31</code></td>
</tr>
<tr>
<td align="center"><code>Last-Modified</code></td>
<td align="center">所请求的对象的最后修改日期</td>
<td align="center"><code>Last-Modified: Tue, 15 Nov 1994 08:12:31</code></td>
</tr>
<tr>
<td align="center"><code>Server</code></td>
<td align="center">服务器的名字</td>
<td align="center"><code>Server: Apache/2.4.1(Unix)</code></td>
</tr>
<tr>
<td align="center"><code>Expires</code></td>
<td align="center">指定一个时间，超过该时间则认为此响应已经过期</td>
<td align="center"><code>Expires: Tue, 15 Dec 1994 08:12:31</code></td>
</tr>
<tr>
<td align="center"><code>Content-Type</code></td>
<td align="center">响应体的类型</td>
<td align="center"><code>Content-Type: text/html; charset=utf-8</code></td>
</tr>
<tr>
<td align="center"><code>Content-Encoding</code></td>
<td align="center">内容所使用的编码类型</td>
<td align="center"><code>Content-Encoding: gzip</code></td>
</tr>
<tr>
<td align="center"><code>Content-Length</code></td>
<td align="center">响应体的长度（字节为单位）</td>
<td align="center"><code>Content-Length: 348</code></td>
</tr>
<tr>
<td align="center"><code>Content-Disposition</code></td>
<td align="center">一个可以让客户端下载文件并建议文件名的头部</td>
<td align="center"><code>Content-Disposition: attachment; filename=&quot;fname.text&quot;</code></td>
</tr>
<tr>
<td align="center"><code>Accept-Ranges</code></td>
<td align="center">服务器支持哪些种类的部分内容范围</td>
<td align="center"><code>Accept-Ranges: bytes</code></td>
</tr>
<tr>
<td align="center"><code>Content-Ranges</code></td>
<td align="center">这条部分消息是属于完整消息的哪部分</td>
<td align="center"><code>Content-Ranges: bytes 21010-47021/47022</code></td>
</tr>
<tr>
<td align="center"><code>Access-Control-Allow-Origin</code></td>
<td align="center">指定哪些网站可参与到跨来源资源共享过程中</td>
<td align="center"><code>Access-Control-Allow-Origin: *</code></td>
</tr>
<tr>
<td align="center"><code>Location</code></td>
<td align="center">用来进行重定向，或者在创建了某个新资源时使用</td>
<td align="center"><code>Location: http://www.w3.org</code></td>
</tr>
<tr>
<td align="center"><code>Set-Cookie</code></td>
<td align="center">返回一个<code>Cookie</code>让客户端去保存</td>
<td align="center"><code>Set-Cookie: UserID=:JohnDoe; Max-Age=3600; Version=1</code></td>
</tr>
<tr>
<td align="center"><code>Connection</code></td>
<td align="center">针对该连接所预期的选项</td>
<td align="center"><code>Connection : close</code></td>
</tr>
<tr>
<td align="center"><code>Cache-Control</code></td>
<td align="center">向从服务器直到客户端在内的所有缓存机制告知，它们是否可以缓存这个对象。单位为秒</td>
<td align="center"><code>Cache-Control: max-age=3600</code></td>
</tr>
</tbody></table>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul>
<li>在<a href>RFC 2616 10.Status Code Definitions</a>规范中定义<ul>
<li>状态码指示<code>HTTP</code>请求是否已成功完成</li>
</ul>
</li>
<li>状态码可以分为<code>5</code>类<ul>
<li>信息响应：<code>100~199</code></li>
<li>成功响应：<code>200~299</code></li>
<li>重定向：<code>300~399</code></li>
<li>客户端错误：<code>400~499</code></li>
<li>服务器错误 ：<code>500~599</code></li>
</ul>
</li>
</ul>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><ul>
<li><code>100 Continue</code><ul>
<li>请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应</li>
<li>允许客户端发送带请求体的请求前，判断服务器是否愿意接收请求（服务器通过请求头判断）</li>
<li>在某些情况下，如果服务器在不看请求体就拒绝请求时，客户端就发送请求体是不恰当的或低效的</li>
</ul>
</li>
<li><code>200 OK</code>：请求成功</li>
<li><code>302 Found</code>：请求的资源被暂时的移动到了由<code>Location</code>头部指定的<code>URL</code>上</li>
<li><code>304 Not Modified</code>：说明无需再次传输请求的内容，也就是说可以使用缓存的内容</li>
<li><code>400 Bad Request</code>：由于语法无效，服务器无法理解该请求</li>
<li><code>401 Unauthorized</code>：由于缺乏目标资源要求的身份验证凭证</li>
<li><code>403 Forbidden</code>：服务器端有能力处理该请求，但是拒绝授权访问</li>
<li><code>404 Not Found</code>：服务器端无法找到所请求的资源</li>
<li><code>405 Method Not Allowed</code>：服务器禁止了使用当前<code>HTTP</code>方法的请求</li>
<li><code>406 Not Acceptable</code>：服务器端无法提供与<code>Accept-Charset</code>以及<code>Accept-Language</code>指定的值相匹配的响应</li>
<li><code>408 Request Timeout</code>：服务器想要将没有在使用的连接关闭<ul>
<li>一些服务器会在空闲连接上发送此信息，即便是在客户端没有发送任何请求的情况下</li>
</ul>
</li>
<li><code>500 Internal Server Error</code>：所请求的服务器遇到意外的情况并阻止其执行请求</li>
<li><code>501 Not Implemented</code>：请求的方法不被服务器支持，因此无法被处理<ul>
<li>服务器必须支持的方法（即不会返回这个状态码的方法）只有<code>GET</code>和<code>HEAD</code></li>
</ul>
</li>
<li><code>502 Bad Gateway</code>：作为网关或代理角色的服务器，从上游服务器（如<code>tomcat</code>）中接收到的响应是无效的</li>
<li><code>503 Service Unavailable</code>：服务器尚未处于可以接受请求的状态<ul>
<li>通常造成这种情况的原因是由于服务器停机维护或者已超载</li>
</ul>
</li>
</ul>
<h2 id="请求体Message-Body数据格式"><a href="#请求体Message-Body数据格式" class="headerlink" title="请求体Message-Body数据格式"></a>请求体<code>Message-Body</code>数据格式</h2><ul>
<li>设置<code>Content-Type</code>，可以确定<code>post</code>请求中<code>Message-Body</code>中的数据格式，常见的有<ul>
<li><code>application/x-www-form-urlencoded</code>（默认值）<ul>
<li>用<code>&amp;</code>分隔参数，用<code>=</code>分隔键和值，字符用<code>URL</code>编码方式进行编码</li>
</ul>
</li>
<li><code>application/json</code>，采用<code>json</code>的格式</li>
<li><code>multipart/form-data</code><ul>
<li>文件上传时必须使用这种编码方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="multipart-form-data格式"><a href="#multipart-form-data格式" class="headerlink" title="multipart/form-data格式"></a><code>multipart/form-data</code>格式</h3><ul>
<li>参考<a href="https://datatracker.ietf.org/doc/html/rfc1521">RFC 1521</a></li>
<li>请求头<ul>
<li><code>Content-Type: multipart/form-data; boundary=xxx</code></li>
</ul>
</li>
</ul>
<p><img src="7.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">POST /hello/form HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Host</span>: localhost:<span class="hljs-number">8080</span><br><span class="hljs-attr">Connection</span>: keep-alive<br>Content-Length: <span class="hljs-number">592540</span><br>Cache-Control: max-age=<span class="hljs-number">0</span><br>sec-ch-ua: <span class="hljs-string">&quot;Not A(Brand&quot;</span>;v=<span class="hljs-string">&quot;99&quot;</span>, <span class="hljs-string">&quot;Google Chrome&quot;</span>;v=<span class="hljs-string">&quot;121&quot;</span>, <span class="hljs-string">&quot;Chromium&quot;</span>;v=<span class="hljs-string">&quot;121&quot;</span><br>sec-ch-ua-mobile: ?<span class="hljs-number">0</span><br>sec-ch-ua-platform: <span class="hljs-string">&quot;macOS&quot;</span><br>Upgrade-Insecure-Requests: <span class="hljs-number">1</span><br><span class="hljs-attr">Origin</span>: http:<span class="hljs-comment">//localhost:8080</span><br><span class="hljs-comment">// boundary</span><br>Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXejOnYSFafBNlI0w<br>User-Agent: Mozilla/<span class="hljs-number">5.0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10_15_7</span>) AppleWebKit/<span class="hljs-number">537.36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">121.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> Safari/<span class="hljs-number">537.36</span><br><span class="hljs-attr">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0.9</span>,image/avif,image/webp,image/apng,*<span class="hljs-comment">/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="hljs-comment">Sec-Fetch-Site: same-origin</span><br><span class="hljs-comment">Sec-Fetch-Mode: navigate</span><br><span class="hljs-comment">Sec-Fetch-User: ?1</span><br><span class="hljs-comment">Sec-Fetch-Dest: document</span><br><span class="hljs-comment">Referer: http://localhost:8080/hello/html/form.html</span><br><span class="hljs-comment">Accept-Encoding: gzip, deflate, br</span><br><span class="hljs-comment">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="hljs-comment">Cookie: JSESSIONID=0B1068472562269E7E2E76604E96B4B8; Webstorm-c5be0d49=04e69f37-ac09-4674-89cc-4120f5cebd97</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">------WebKitFormBoundaryXejOnYSFafBNlI0w</span><br><span class="hljs-comment">// body-part</span><br><span class="hljs-comment">Content-Disposition: form-data; name=&quot;name&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1222</span><br><span class="hljs-comment">------WebKitFormBoundaryXejOnYSFafBNlI0w</span><br><span class="hljs-comment">Content-Disposition: form-data; name=&quot;age&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3333</span><br><span class="hljs-comment">------WebKitFormBoundaryXejOnYSFafBNlI0w</span><br><span class="hljs-comment">Content-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;......2024-01-27 19.59.06.png&quot;</span><br><span class="hljs-comment">Content-Type: image/png</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">.PNG</span><br><span class="hljs-comment">.</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">.......</span><br><span class="hljs-comment">//数据结束的标志</span><br><span class="hljs-comment">------WebKitFormBoundaryXejOnYSFafBNlI0w--</span><br></code></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><ul>
<li><code>Pragma</code>：作用类似于<code>Cache-Control</code>，<code>HTTP/1.0</code>的产物</li>
<li><code>Expires</code>：缓存的过期时间（<code>GMT</code>格式时间），<code>HTTP/1.0</code>的产物</li>
<li><code>Cache-Control</code>：设置缓存策略<ul>
<li><code>no-storage</code>：不缓存数据到本地</li>
<li><code>public</code>：允许用户、代理服务器缓存数据到本地</li>
<li><code>private</code>：只允许用户缓存数据到本地</li>
<li><code>max-age</code>：缓存的有效时间（多长时间不过期），单位秒</li>
<li><code>no-cache</code>：每次需要发请求给服务器询问缓存是否有变化，再来决定如何使用缓存</li>
</ul>
</li>
<li>优先级：<code>Pragma</code> &gt; <code>Cache-Control</code> &gt; <code>Expires</code></li>
</ul>
<h4 id="是否更新资源的判断"><a href="#是否更新资源的判断" class="headerlink" title="是否更新资源的判断"></a>是否更新资源的判断</h4><ul>
<li><code>Last-Modified</code>：资源的最后一次修改时间</li>
<li><code>ETag</code>：资源的唯一标识（根据文件内容计算出来的摘要值）</li>
<li>优先级：<code>ETag</code> &gt; <code>Last-Modified</code></li>
</ul>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><ul>
<li><code>If-None-Match</code><ul>
<li>如果上一次的响应头中有<code>ETag</code>，就会将<code>ETag</code>的值作为请求头的值</li>
<li>如果服务器发现资源的最新摘要值跟<code>If-None-Match</code>不匹配，就会返回新的资源（<code>200 OK</code>）</li>
<li>否则，就不会返回资源的具体数据（<code>304 Not Modified</code>）</li>
</ul>
</li>
<li><code>If-Modified-Since</code><ul>
<li>如果上一次的响应头中没有<code>ETag</code>，有<code>Last-Modified</code>，就会将<code>Last-Modified</code>的值作为请求头的值</li>
<li>如果服务器发现资源的最后一次修改时间晚于<code>If-Modified-Since</code>，就会返回新的资源（<code>200 OK</code>）</li>
<li>否则，就不会返回资源的具体数据（<code>304 Not Modified</code>）</li>
</ul>
</li>
</ul>
<h3 id="缓存对比Last-Modified-VS-ETag"><a href="#缓存对比Last-Modified-VS-ETag" class="headerlink" title="缓存对比Last-Modified VS ETag"></a>缓存对比<code>Last-Modified</code> VS <code>ETag</code></h3><ul>
<li><p><code>Last-Modified</code>的缺陷</p>
<ul>
<li>只能精确到秒级别，如果资源在<code>1秒</code>内被修改了，客户端将无法获取最新的资源数据</li>
<li>如果某些资源被修改了（最后一次修改时间发生了变化），但是内容并没有任何变化<ul>
<li>会导致相同数据重复传输，没有使用到缓存</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ETag</code>可以办到</p>
<ul>
<li>只要资源的内容没有变化，就不会重复传输资源数据</li>
<li>只要资源的内容发生了变化，就会返回最新的资源数据给客户端</li>
</ul>
</li>
</ul>
<h3 id="缓存使用流程"><a href="#缓存使用流程" class="headerlink" title="缓存使用流程"></a>缓存使用流程</h3><p><img src="3.jpg"></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>应用层（DNS和DHCP）</title>
    <url>/2024/01/23/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88DNS%E5%92%8CDHCP%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用层的常见协议"><a href="#应用层的常见协议" class="headerlink" title="应用层的常见协议"></a>应用层的常见协议</h1><ul>
<li>超文本传输：<code>HTTP</code>、<code>HTTPS</code></li>
<li>文件传输：<code>FTP</code></li>
<li>电子邮件：<code>SMTP</code>、<code>POP3</code>、<code>IMAP</code></li>
<li>动态主机配置：<code>DHCP</code></li>
<li>域名系统：<code>DNS</code></li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a><code>DNS</code></h1><ul>
<li><code>DNS</code>的全称是：<code>Domain Name System</code>，译为：域名系统<ul>
<li>利用<code>DNS</code>协议，可以将域名（比如<code>baidu.com</code>）解析成对应的<code>IP</code>地址（比如<code>220.181.38.148</code>）</li>
<li><code>DNS</code>可以基于<code>UDP</code>协议，也可以基于<code>TCP</code>协议，服务器占用<code>53</code>端口</li>
</ul>
</li>
</ul>
<h2 id="域名-Domain-Name"><a href="#域名-Domain-Name" class="headerlink" title="域名(Domain Name)"></a>域名(<code>Domain Name</code>)</h2><ul>
<li>由于<code>IP</code>地址不方便记忆，并且不能表达组织的名称和性质，人们设计出了域名（比如<code>baidu.com</code>）<ul>
<li>但实际上，为了能够访问到具体的主机，最终还是得知道目标主机的IP地址</li>
<li><a href="https://wanwang.aliyun.com/">域名申请注册</a></li>
</ul>
</li>
<li>那干脆全程直接用域名，不用<code>IP</code>地址？<ul>
<li><code>IP</code>地址固定<code>4</code>个字节，域名随随便便都至少<code>10</code>几个字节，这无疑会增加路由器的负担，浪费流量</li>
</ul>
</li>
<li>根据级别不同，域名可以分为<ul>
<li>顶级域名（<code>Top-level Domain</code>，简称<code>TLD</code>）</li>
<li>二级域名</li>
<li>三级域名</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><ul>
<li>通用顶级域名（<code>General Top-level Domain</code>，简称<code>gTLD</code>）<ul>
<li><code>.com</code>（公司），<code>.net</code>（网络机构），<code>.org</code>（组织机构），<code>.edu</code>（教育）</li>
<li><code>.gov</code>（政府部门），<code>.int</code>（国际组织）等</li>
</ul>
</li>
<li>国家及地区顶级域名（<code>Country Code Top-level Domain</code>，简称<code>ccTLD</code>）<ul>
<li><code>.cn</code>（中国）、<code>.jp</code>（日本）、<code>.uk</code>（英国）</li>
</ul>
</li>
<li>新通用顶级域名（<code>New Generic Top-level Domain</code>，简称：<code>New gTLD</code>）<ul>
<li><code>.vip</code>、<code>.xyz</code>、<code>.top</code>、<code>.club</code>、<code>.shop</code>等</li>
</ul>
</li>
</ul>
<h3 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h3><ul>
<li>二级域名是指顶级域名之下的域名<ul>
<li>在通用顶级域名下，它一般指域名注册人的名称，例如<code>google</code>、<code>baidu</code>、<code>microsoft</code>等</li>
<li>在国家及地区顶级域名下，它一般指注册类别的，例如<code>com</code>、<code>edu</code>、<code>gov</code>、<code>net</code>等</li>
</ul>
</li>
</ul>
<p><img src="1.jpg"></p>
<h2 id="域名解析的流程"><a href="#域名解析的流程" class="headerlink" title="域名解析的流程"></a>域名解析的流程</h2><p><img src="2.jpg"></p>
<ul>
<li>客户端首先会访问最近的一台<code>DNS</code>服务器（也就是客户端自己配置的<code>DNS</code>服务器）</li>
<li>所有的<code>DNS</code>服务器都记录了<code>DNS</code>根域名服务器的<code>IP</code>地址</li>
<li>上级<code>DNS</code>服务器记录了下一级<code>DNS</code>服务器的<code>IP</code>地址</li>
<li>全球一共<code>13</code>台<code>IPv4</code>的<code>DNS</code>根域名服务器、<code>25</code>台<code>IPv6</code>的<code>DNS</code>根域名服务器</li>
</ul>
<h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a><code>DHCP</code></h1><ul>
<li><code>DHCP</code>（<code>Dynamic Host Configuration Protocol</code>），译为：动态主机配置协议<ul>
<li><code>DHCP</code>协议基于<code>UDP</code>协议，客户端是<code>68</code>端口，服务器是<code>67</code>端口</li>
</ul>
</li>
<li><code>DHCP</code>服务器会从<code>IP</code>地址池中，挑选一个<code>IP</code>地址“出租“给客户端一段时间，时间到期就回收它们<ul>
<li>平时家里上网的路由器就可以充当<code>DHCP</code>服务器</li>
</ul>
</li>
</ul>
<h2 id="IP地址的分配"><a href="#IP地址的分配" class="headerlink" title="IP地址的分配"></a><code>IP</code>地址的分配</h2><ul>
<li><code>IP</code>地址按照分配方式，可以分为：静态<code>IP</code>地址、动态<code>IP</code>地址<ul>
<li>静态<code>IP</code>地址<ul>
<li>手动设置</li>
<li>适用场景：不怎么挪动的台式机（比如学校机房中的台式机）、服务器等</li>
</ul>
</li>
<li>动态<code>IP</code>地址<ul>
<li>从<code>DHCP</code>服务器自动获取<code>IP</code>地址</li>
<li>适用场景：移动设备、无线设备等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DHCP-分配IP地址的四个阶段"><a href="#DHCP-分配IP地址的四个阶段" class="headerlink" title="DHCP - 分配IP地址的四个阶段"></a><code>DHCP</code> - 分配<code>IP</code>地址的四个阶段</h2><ul>
<li><code>DISCOVER</code>：发现服务器<ul>
<li>发广播包（源<code>IP</code>是<code>0.0.0.0</code>，目标<code>IP</code>是<code>255.255.255.255</code>，目标<code>MAC</code>是<code>FF:FF:FF:FF:FF:FF</code>）</li>
</ul>
</li>
<li><code>OFFER</code>：提供租约<ul>
<li>服务器返回可以租用的<code>IP地址</code>，以及<code>租用期限</code>、<code>子网掩码</code>、<code>网关</code>、<code>DNS</code>等信息</li>
<li>注意：这里可能会有多个服务器提供租约</li>
</ul>
</li>
<li><code>REQUEST</code>：选择<code>IP地址</code><ul>
<li>客户端选择一个<code>OFFER</code>，发送广播包进行回应</li>
</ul>
</li>
<li><code>ACKNOWLEDGE</code>：确认<ul>
<li>被选中的服务器发送<code>ACK</code>数据包给客户端</li>
<li>至此，<code>IP地址</code>分配完毕</li>
</ul>
</li>
</ul>
<p><img src="3.jpg"></p>
<h2 id="wireshark抓包"><a href="#wireshark抓包" class="headerlink" title="wireshark抓包"></a><code>wireshark</code>抓包</h2><p><img src="4.jpg"></p>
<ol>
<li><p><code>Discover</code><br><img src="5.jpg"></p>
</li>
<li><p><code>offer</code><br><img src="6.jpg"></p>
</li>
<li><p><code>request</code><br><img src="7.jpg"></p>
</li>
<li><p><code>ACK</code><br><img src="8.jpg"></p>
</li>
</ol>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul>
<li><p><code>DHCP</code>服务器可以跨网段分配<code>IP</code>地址么？（<code>DHCP</code>服务器、客户端不在同一个网段）</p>
<ul>
<li>可以借助<code>DHCP</code>中继代理（<code>DHCP Relay Agent</code>）实现跨网段分配<code>IP地址</code></li>
</ul>
</li>
<li><p>自动续约</p>
<ul>
<li>客户端会在租期不足的时候，自动向<code>DHCP服务器</code>发送<code>REQUEST</code>信息申请续约</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2024/01/20/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层有2个协议</p>
<ul>
<li><code>TCP</code>（<code>Transmission Control Protocol</code>），传输控制协议</li>
<li><code>UDP</code>（<code>User Datagram Protocol</code>），用户数据报协议</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">连接性</td>
<td align="center">面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">可靠传输，不丢包</td>
<td align="center">不可靠传输，尽最大努力交付，可能丢包</td>
</tr>
<tr>
<td align="center">首部占用空间</td>
<td align="center">大</td>
<td align="center">小</td>
</tr>
<tr>
<td align="center">传输速率</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
<tr>
<td align="center">资料消耗</td>
<td align="center">大</td>
<td align="center">小</td>
</tr>
<tr>
<td align="center">应用场景</td>
<td align="center">浏览器，文件传输，邮件传输</td>
<td align="center">音视频通话、直播</td>
</tr>
<tr>
<td align="center">应用层协议</td>
<td align="center">HTTP、HTTPS、FTP、SMTP、DNS</td>
<td align="center">DNS</td>
</tr>
</tbody></table>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><code>UDP</code></h1><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ul>
<li><code>UDP</code>是无连接的，减少了建立和释放连接的开销</li>
<li><code>UDP</code>尽最大能力交付，不保证可靠交付<ul>
<li>因此不需要维护一些复杂的参数，首部只有<code>8</code>个字节（<code>TCP</code>的首部至少<code>20</code>个字节）</li>
</ul>
</li>
</ul>
<p><img src="1.jpg"></p>
<ul>
<li><code>UDP</code>长度（<code>Length</code>）<ul>
<li>占<code>16</code>位，首部的长度 + 数据的长度</li>
</ul>
</li>
</ul>
<h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><ul>
<li>检验和的计算内容：伪首部 + 首部 + 数据<ul>
<li>伪首部：仅在计算检验和时起作用，并不会传递给网络层</li>
</ul>
</li>
</ul>
<p><img src="2.jpg"></p>
<h3 id="端口-port"><a href="#端口-port" class="headerlink" title="端口(port)"></a>端口(<code>port</code>)</h3><ul>
<li><code>UDP</code>首部中端口是占用<code>2</code>字节<ul>
<li>可以推测出端口号的取值范围是：<code>0~65535</code></li>
</ul>
</li>
<li>客户端的源端口是临时开启的随机端口</li>
<li>防火墙可以设置开启\关闭某些端口来提高安全性</li>
<li>常用命令行<ul>
<li><code>netstat –an</code>：查看被占用的端口</li>
<li><code>netstat –anb</code>：查看被占用的端口、占用端口的应用程序</li>
<li><code>telnet 主机 端口</code>：查看是否可以访问主机的某个端</li>
</ul>
</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><code>TCP</code></h1><h2 id="数据格式-1"><a href="#数据格式-1" class="headerlink" title="数据格式"></a>数据格式</h2><p><img src="3.jpg"></p>
<ul>
<li>有些资料中，<code>TCP</code>首部的保留（<code>Reserved</code>）字段占<code>3</code>位，标志（<code>Flags</code>）字段占9位<br><img src="4.jpg"></li>
</ul>
<h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><ul>
<li>占<code>4</code>位，取值范围是<code>0x0101~0x1111</code></li>
<li>乘以<code>4</code>：首部长度（<code>Header Length</code>）</li>
<li>首部长度是<code>20</code> ~ <code>60</code>字节</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><p><code>UDP</code>的首部中有个<code>16</code>位的字段记录了整个<code>UDP</code>报文段的长度（首部+数据）</p>
</li>
<li><p>但是，<code>TCP</code>的首部中仅仅有个<code>4</code>位的字段记录了<code>TCP</code>报文段的首部长度，并没有字段记录TCP报文段的数据长度</p>
</li>
<li><p>分析</p>
<ul>
<li><code>UDP</code>首部中占<code>16</code>位的长度字段是冗余的，纯粹是为了保证首部是<code>32bit</code>对齐</li>
<li><code>TCP\UDP</code>的数据长度，完全可以由<code>IP</code>数据包的首部推测出来<ul>
<li>传输层的数据长度 = 网络层的总长度 – 网络层的首部长度 – 传输层的首部长度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="检验和-1"><a href="#检验和-1" class="headerlink" title="检验和"></a>检验和</h3><ul>
<li>跟<code>UDP</code>一样，<code>TCP</code>检验和的计算内容：伪首部 + 首部 + 数据<ul>
<li>伪首部：占用<code>12</code>字节，仅在计算检验和时起作用，并不会传递给网络层</li>
</ul>
</li>
</ul>
<p><img src="5.jpg"></p>
<h3 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h3><ul>
<li><code>URG（Urgent</code>）<ul>
<li>当<code>URG=1</code>时，紧急指针字段才有效。表明当前报文段中有紧急数据，应优先尽快传送</li>
</ul>
</li>
<li><code>ACK（Acknowledgment）</code><ul>
<li>当<code>ACK=1</code>时，确认号字段才有效</li>
</ul>
</li>
<li><code>PSH（Push）</code></li>
<li><code>RST（Reset）</code><ul>
<li>当<code>RST=1</code>时，表明连接中出现严重差错，必须释放连接，然后再重新建立连接</li>
</ul>
</li>
<li><code>SYN（Synchronization</code>,同步标识<ul>
<li>当<code>SYN=1</code>、<code>ACK=0</code>时，表明这是一个建立连接的请求</li>
<li>若对方同意建立连接，则回复<code>SYN=1</code>、<code>ACK=1</code></li>
</ul>
</li>
<li><code>FIN（Finish</code><ul>
<li>当<code>FIN=1</code>时，表明数据已经发送完毕，要求释放连接</li>
</ul>
</li>
</ul>
<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><ul>
<li>占<code>4</code>字节</li>
<li>首先，在传输过程的每一个字节都会有一个编号</li>
<li>在建立连接后，序号代表：这一次传给对方的<code>TCP</code>数据部分的第一个字节的编号</li>
</ul>
<h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><ul>
<li>占<code>4</code>字节</li>
<li>在建立连接后，确认号代表：期望对方下一次传过来的<code>TCP</code>数据部分的第一个字节的编号</li>
</ul>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><ul>
<li>占<code>2</code>字节</li>
<li>这个字段有流量控制功能，用以告知对方下一次允许发送的数据大小（字节为单位）</li>
</ul>
<h2 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h2><h3 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h3><ul>
<li><p><code>ARQ</code>（<code>Automatic Repeat–reQuest</code>），自动重传请求<br><img src="6.jpg"></p>
</li>
<li><p>出现重复包的情况，重复的确认，会丢弃<br><img src="7.jpg"></p>
</li>
</ul>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul>
<li>若有个包重传了<code>N</code>次还是失败，会一直持续重传到成功为止么？<ul>
<li>这个取决于<strong>系统的设置</strong>，比如有些系统，重传<code>5</code>次还未成功就会发送<code>reset</code>报文（<code>RST</code>）断开<code>TCP</code>连接<br><img src="8.jpg"></li>
</ul>
</li>
</ul>
<h3 id="停止等待ARQ协议-滑动窗口协议"><a href="#停止等待ARQ协议-滑动窗口协议" class="headerlink" title="停止等待ARQ协议 + 滑动窗口协议"></a>停止等待ARQ协议 + 滑动窗口协议</h3><p><img src="9.jpg"></p>
<ul>
<li>如果接收窗口最多能接收<code>4</code>个包<ul>
<li>但发送方只发了<code>2</code>个包</li>
</ul>
</li>
<li>接收方如何确定后面还有没有<code>2</code>个包？<ul>
<li>等待一定时间后没有第<code>3</code>个包</li>
<li>就会返回确认收到<code>2</code>个包给发送方</li>
</ul>
</li>
</ul>
<p><img src="10.jpg"></p>
<ul>
<li><p>现在假设每一组数据是<code>100</code>个字节，代表一个数据段的数据</p>
</li>
<li><p>每一组给一个编号</p>
</li>
<li><p>在<code>TCP</code>通信过程中，如果发送序列中间某个数据包丢失（比如<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code>中的<code>3</code>丢失了）</p>
</li>
<li><p><code>TCP</code>会通过重传最后确认的分组后续的分组（最后确认的是<code>2</code>，会重传<code>3</code>、<code>4</code>、<code>5</code>）</p>
</li>
<li><p>这样原先已经正确传输的分组也可能重复发送（比如<code>4</code>、<code>5</code>），降低了<code>TCP</code>性能</p>
</li>
<li><p>为改善上述情况，发展出了<code>SACK</code>（<code>Selective acknowledgment</code>，选择性确认）技术</p>
<ul>
<li>告诉发送方哪些数据丢失，哪些数据已经提前收到</li>
<li>使<code>TCP</code>只重新发送丢失的包（比如<code>3</code>），不用发送后续所有的分组（比如<code>4</code>、<code>5</code>）</li>
</ul>
</li>
</ul>
<h4 id="SACK选择确定"><a href="#SACK选择确定" class="headerlink" title="SACK选择确定"></a><code>SACK</code>选择确定</h4><ul>
<li><p><code>SACK信息</code><br><img src="11.jpg"></p>
</li>
<li><p><code>SACK</code>信息会放在<code>TCP</code>首部的选项部分</p>
<ul>
<li><code>Kind</code>：占<code>1</code>字节。值为<code>5</code>代表这是<code>SACK</code>选项</li>
<li><code>Length</code>：占<code>1</code>字节。表明<code>SACK</code>选项一共占用多少字节</li>
<li><code>Left Edge</code>：占<code>4</code>字节，左边界</li>
<li><code>Right Edge</code>：占<code>4</code>字节，右边界</li>
</ul>
</li>
</ul>
<p><img src="12.jpg"></p>
<ul>
<li>一对边界信息需要占用<code>8</code>字节，由于<code>TCP</code>首部的选项部分最多<code>40</code>字节，所以<ul>
<li><code>SACK</code>选项最多携带<code>4</code>组边界信息</li>
<li><code>SACK</code>选项的最大占用字节数 = <code>4</code> * <code>8</code> + <code>2</code> = <code>34</code></li>
</ul>
</li>
</ul>
<p><img src="13.png"></p>
<h3 id="传输层分包的原因"><a href="#传输层分包的原因" class="headerlink" title="传输层分包的原因"></a>传输层分包的原因</h3><ul>
<li>为什么选择在传输层就将数据“大卸八块”分成多个段，而不是等到网络层再分片传递给数据链路层？<ul>
<li>因为可以提高重传的性能</li>
<li>需要明确的是：可靠传输是在传输层进行控制的<ul>
<li>如果在传输层不分段，一旦出现数据丢失，整个传输层的数据都得重传</li>
<li>如果在传输层分了段，一旦出现数据丢失，只需要重传丢失的那些段即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul>
<li>如果接收方的缓存区满了，发送方还在疯狂着发送数据<ul>
<li>接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源</li>
<li>所以要进行流量控制</li>
</ul>
</li>
<li>什么是流量控制？<ul>
<li>让发送方的发送速率不要太快，让接收方来得及接收处理</li>
</ul>
</li>
<li>原理<ul>
<li>通过确认报文中窗口字段来控制发送方的发送速率</li>
<li>发送方的发送窗口大小不能超过接收方给出窗口大小</li>
<li>当发送方收到接收窗口的大小为<code>0</code>时，发送方就会停止发送数据</li>
</ul>
</li>
</ul>
<p><img src="12.png"></p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul>
<li><p>有一种特殊情况</p>
<ul>
<li>一开始，接收方给发送方发送了<code>0</code>窗口的报文段</li>
<li>后面，接收方又有了一些存储空间，给发送方发送的非<code>0</code>窗口的报文段丢失了</li>
<li>发送方的发送窗口一直为零，双方陷入<strong>僵局</strong></li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>当发送方收到<code>0</code>窗口通知时，这时发送方停止发送报文</li>
<li>并且同时开启一个定时器，隔一段时间就发个测试报文去询问接收方最新的窗口大小</li>
<li>如果接收的窗口大小还是为<code>0</code>，则发送方再次刷新启动定时器</li>
</ul>
</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><img src="13.jpg"></p>
<ul>
<li>拥塞控制<ul>
<li>防止过多的数据注入到网络中</li>
<li>避免网络中的路由器或链路过载</li>
</ul>
</li>
<li>拥塞控制是一个全局性的过程<ul>
<li>涉及到所有的主机、路由器</li>
<li>以及与降低网络传输性能有关的所有因素</li>
<li>是大家共同努力的结果</li>
</ul>
</li>
<li>相比而言，流量控制是点对点通信的控制</li>
</ul>
<h3 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h3><ol>
<li> 慢开始（<code>slow start</code>，慢启动）</li>
<li> 拥塞避免（<code>congestion avoidance</code>）</li>
<li> 快速重传（<code>fast retransmit</code>）</li>
<li> 快速恢复（<code>fast recovery</code>）</li>
</ol>
<ul>
<li>一些缩写<ul>
<li><code>MSS</code>（<code>Maximum Segment Size</code>）：每个段最大的数据部分大小</li>
<li>在建立连接时确定<ul>
<li><code>cwnd</code>（<code>congestion window</code>）：拥塞窗口</li>
<li><code>rwnd</code>（<code>receive window</code>）：接收窗口</li>
<li><code>swnd</code>（<code>send window</code>）：发送窗口<ul>
<li><code>swnd = min(cwnd, rwnd)</code></li>
<li> 当<code>rwnd</code> &lt; <code>cwnd</code>时，是接收方的接收能力限制发送窗口的最大值</li>
<li> 当<code>cwnd</code> &lt; <code>rwnd</code>时，则是网络的拥塞限制发送窗口的最大值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p><img src="14.jpg"></p>
<ul>
<li><code>cwnd</code>的初始值比较小，然后随着数据包被接收方确认（收到一个<code>ACK</code>）<ul>
<li><code>cwnd</code>就成倍增长（指数级）<br><img src="15.jpg"></li>
</ul>
</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p><img src="16.jpg"></p>
<ul>
<li><code>ssthresh</code>（<code>slow start threshold</code>）：<code>慢开始</code>阈值，<code>cwnd</code>达到阈值后，以线性方式增加</li>
<li>拥塞避免（加法增大）：<code>拥塞窗口</code>缓慢增大，以防止网络<code>过早</code>出现拥塞</li>
<li>乘法减小：只要网络出现拥塞，把<code>ssthresh</code>减为拥塞峰值的一半，同时执行<code>慢开始</code>算法（<code>cwnd</code>又恢复到初始值）</li>
<li>当网络出现频繁拥塞时，<code>ssthresh</code>值就下降的很快</li>
</ul>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p><img src="17.jpg"></p>
<ul>
<li><p>接收方</p>
<ul>
<li> 每收到一个失序的分组后就立即发出重复确认</li>
<li> 使发送方及时知道有分组没有到达</li>
<li> 而不要等待自己发送数据时才进行确认</li>
</ul>
</li>
<li><p>发送方</p>
<ul>
<li>只要连续收到三个重复确认（总共<code>4</code>个相同的确认），就应当立即<code>重传</code>对方尚未收到的报文段</li>
<li>而不必继续等待重传计时器到期后再重传</li>
</ul>
</li>
</ul>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><ul>
<li>当发送方连续收到三个重复确认，说明网络出现拥塞<ul>
<li>就执行“乘法减小”算法，把<code>ssthresh</code>减为拥塞峰值的一半</li>
</ul>
</li>
<li>与<code>慢开始</code>不同之处是现在不执行<code>慢开始</code>算法，即<code>cwnd</code>现在<code>不恢复</code>到<code>初始值</code><ul>
<li>而是把<code>cwnd</code>值设置为新的<code>ssthresh</code>值（减小后的值）</li>
<li>然后开始执行<code>拥塞避免</code>算法（“<code>加法增大</code>”），使<code>拥塞窗口</code>缓慢地<code>线性</code>增大</li>
</ul>
</li>
</ul>
<h4 id="快重传-快恢复"><a href="#快重传-快恢复" class="headerlink" title="快重传+快恢复"></a>快重传+快恢复</h4><p><img src="18.jpg"></p>
<h2 id="序号、确认号"><a href="#序号、确认号" class="headerlink" title="序号、确认号"></a>序号、确认号</h2><ul>
<li><p>服务端和客户段的<code>TCP</code>在建立连接的时候，会交互各自的初始序列号，在后续传输中</p>
<ul>
<li>服务端发送的<ul>
<li>序列号：服务端初始序列号 + 发送数据长度(从建立连接开始的数据)</li>
<li>确认号：服务端收到客户段的数据长度 + 客户端的初始序列号</li>
</ul>
</li>
<li>客户端发送的<ul>
<li>序列号：客户端初始序列号 + 发送数据长度(从建立连接开始的数据)</li>
<li>确认号：客户端收到服务端的数据长度 + 服务端的初始序列号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意</strong>，这里有个特殊的地方是，在建立/关闭连接（三次握手和四次挥手）的时候，<code>SYN</code>或<code>FIN</code>发送后，另一端回的确认号，尽管数据长度为<code>0</code>,但为了回应发送端，其确认号会加<code>1</code>.</p>
</li>
</ul>
<p><img src="20.png"></p>
<h3 id="模拟序号、确认号变化"><a href="#模拟序号、确认号变化" class="headerlink" title="模拟序号、确认号变化"></a>模拟序号、确认号变化</h3><p><img src="19.png"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">发送端</th>
<th align="center">seq</th>
<th align="center">ack</th>
<th align="center">SYN</th>
<th align="center">ACK</th>
<th align="center">携带数据长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">客户端</td>
<td align="center">s1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">服务器</td>
<td align="center">s2</td>
<td align="center">s1+1（回应客户端SYN，确定服务端发送数据的开始）</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">客户端</td>
<td align="center">s1+1</td>
<td align="center">s2+1（回应服务器的SYN，确定客户端发送数据的开始）</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">客户端</td>
<td align="center">s1+1</td>
<td align="center">s2+1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">k</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">服务器</td>
<td align="center">s2+1</td>
<td align="center">s1+k+1(接收了K数据，下次客户端发k+1开始的数据)</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">b1</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">服务器</td>
<td align="center">s2+b1+1</td>
<td align="center">s1+k+1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">b2</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">服务器</td>
<td align="center">s2+b1+b2+1</td>
<td align="center">s1+k+1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">b3</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">服务器</td>
<td align="center">s2+b1+b2+b3+1</td>
<td align="center">s1+k+1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">b4</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">客户端</td>
<td align="center">s1+k+1</td>
<td align="center">s2+b1+b2+b3+b4+1（响应已经收到的数据）</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h2 id="建立连接-3次握手"><a href="#建立连接-3次握手" class="headerlink" title="建立连接-3次握手"></a>建立连接-3次握手</h2><p><img src="21.png"></p>
<h3 id="状态解读"><a href="#状态解读" class="headerlink" title="状态解读"></a>状态解读</h3><ul>
<li><code>CLOSED</code>：<code>client</code>处于关闭状态</li>
<li><code>LISTEN</code>：<code>server</code>处于监听状态，等待<code>client</code>连接</li>
<li><code>SYN-RCVD</code>：表示<code>server</code>接受到了<code>SYN</code>报文，当收到<code>client</code>的<code>ACK</code>报文后，它会进入到<code>ESTABLISHED</code>状态</li>
<li><code>SYN-SENT</code>：表示<code>client</code>已发送<code>SYN</code>报文，等待<code>server</code>的第<code>2</code>次握手</li>
<li><code>ESTABLISHED</code>：表示连接已经建立</li>
</ul>
<h3 id="前两次握手的特点"><a href="#前两次握手的特点" class="headerlink" title="前两次握手的特点"></a>前两次握手的特点</h3><ul>
<li><code>SYN</code>都设置为<code>1</code></li>
<li>数据部分的长度都为<code>0</code><ul>
<li>在收到<code>SYN</code>后，相应的发送端的确认号会+1</li>
</ul>
</li>
<li><code>TCP</code>头部的长度一般是<code>44</code>字节<ul>
<li>固定头部：<code>20</code>字节</li>
<li>选项部分：<code>22</code>字节</li>
</ul>
</li>
<li>双方会交换确认一些信息<ul>
<li>比如<code>MSS</code>、是否支持<code>SACK</code>、<code>Window scale</code>（窗口缩放系数）、<code>Timestamps</code>(10字节)等</li>
<li>这些数据都放在了<code>TCP</code>头部的选项部分中（<code>22</code>字节）,有些没有<code>Timestamps</code>只有<code>12</code>字节</li>
</ul>
</li>
</ul>
<h3 id="连接疑问"><a href="#连接疑问" class="headerlink" title="连接疑问"></a>连接疑问</h3><ul>
<li>为什么建立连接的时候，要进行<code>3</code>次握手？<code>2</code>次不行么？<ul>
<li>主要目的：防止<code>server</code>端一直等待，浪费资源</li>
</ul>
</li>
<li>如果建立连接只需要<code>2</code>次握手，可能会出现的情况<ul>
<li>假设<code>client</code>发出的第一个连接请求报文段，因为网络延迟，在连接释放以后的某个时间才到达<code>server</code></li>
<li>本来这是一个早已失效的连接请求，但<code>server</code>收到此失效的请求后，误认为是<code>client</code>再次发出的一个新的连接请求</li>
<li>于是<code>server</code>就向<code>client</code>发出确认报文段，同意建立连接</li>
<li>如果不采用“<code>3</code>次握手”，那么只要<code>server</code>发出确认，新的连接就建立了</li>
<li>由于现在<code>client</code>并没有真正想连接服务器的意愿，因此不会理睬<code>server</code>的确认，也不会向<code>server</code>发送数据</li>
<li>但<code>server</code>却以为新的连接已经建立，并一直等待<code>client</code>发来数据，这样，<code>server</code>的很多资源就白白浪费掉了</li>
</ul>
</li>
<li>采用“三次握手”的办法可以防止上述现象发生<ul>
<li>例如上述情况，<code>client</code>没有向<code>server</code>的确认发出确认，<code>server</code>由于收不到确认，就知道<code>client</code>并没有要求建立连接</li>
</ul>
</li>
<li>第<code>3</code>次握手失败了，会怎么处理？<ul>
<li>此时<code>server</code>的状态为<code>SYN-RCVD</code>，若等不到<code>client</code>的<code>ACK</code>，<code>server</code>会重新发送<code>SYN+ACK</code>包，回到第<code>2</code>步</li>
<li>如果<code>server</code>多次重发<code>SYN+ACK</code>都等不到<code>client</code>的<code>ACK</code>，就会发送<code>RST</code>包，强制关闭连接</li>
</ul>
</li>
</ul>
<h2 id="释放连接-4次挥手"><a href="#释放连接-4次挥手" class="headerlink" title="释放连接-4次挥手"></a>释放连接-4次挥手</h2><p><img src="22.png"></p>
<h3 id="状态解读-1"><a href="#状态解读-1" class="headerlink" title="状态解读"></a>状态解读</h3><ul>
<li><p><code>FIN-WAIT-1</code>：表示想主动关闭连接</p>
<ul>
<li>向对方发送了<code>FIN</code>报文，此时进入到<code>FIN-WAIT-1</code>状态</li>
</ul>
</li>
<li><p><code>CLOSE-WAIT</code>：表示在等待关闭</p>
<ul>
<li>当对方发送<code>FIN</code>给自己，自己会回应一个<code>ACK</code>报文给对方，此时则进入到<code>CLOSE-WAIT</code>状态</li>
<li>在此状态下，需要考虑自己是否还有数据要发送给对方，如果没有，发送<code>FIN</code>报文给对方</li>
</ul>
</li>
<li><p><code>FIN-WAIT-2</code>：只要对方发送<code>ACK</code>确认后，主动方就会处于<code>FIN-WAIT-2</code>状态，然后等待对方发送<code>FIN</code>报文</p>
</li>
<li><p><code>CLOSING</code>：一种比较罕见的例外状态</p>
<ul>
<li>表示你发送<code>FIN</code>报文后，并没有收到对方的<code>ACK</code>报文，反而却也收到了对方的<code>FIN</code>报文</li>
<li>如果双方几乎在同时准备关闭连接的话，那么就出现了双方同时发送<code>FIN</code>报文的情况，也即会出现<code>CLOSING</code>状态</li>
<li>表示双方都正在关闭连接</li>
</ul>
</li>
<li><p><code>LAST-ACK</code>：被动关闭一方在发送<code>FIN</code>报文后，最后等待对方的<code>ACK</code>报文</p>
<ul>
<li>当收到<code>ACK</code>报文后，即可进入<code>CLOSED</code>状态了</li>
</ul>
</li>
<li><p><code>TIME-WAIT</code>：表示收到了对方的<code>FIN</code>报文，并发送出了<code>ACK</code>报文，就等<code>2MSL</code>后即可进入<code>CLOSED</code>状态了</p>
<ul>
<li>如果<code>FIN-WAIT-1</code>状态下，收到了对方同时带<code>FIN</code>标志和<code>ACK</code>标志的报文时<ul>
<li>可以直接进入到<code>TIME-WAIT</code>状态，而无须经过<code>FIN-WAIT-2</code>状态,(三次挥手)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>CLOSED</code>：关闭状态</p>
</li>
<li><p>由于有些状态的时间比较短暂，所以很难用<code>netstat</code>命令看到，比如<code>SYN-RCVD</code>、<code>FIN-WAIT-1</code>等</p>
</li>
</ul>
<h3 id="释放细节"><a href="#释放细节" class="headerlink" title="释放细节"></a>释放细节</h3><ul>
<li><p><code>TCP/IP</code>协议栈在设计上，允许任何一方先发起断开请求。这里演示的是<code>client</code>主动要求断开</p>
</li>
<li><p><code>client</code>发送<code>ACK</code>后，需要有个<code>TIME-WAIT</code>阶段，等待一段时间后，再真正关闭连接</p>
<ul>
<li>一般是等待<code>2</code>倍的<code>MSL</code>（<code>Maximum Segment Lifetime</code>，最大分段生存期）<ul>
<li><code>MSL</code>是<code>TCP</code>报文在<code>Internet</code>上的最长生存时间</li>
<li>每个具体的<code>TCP</code>实现都必须选择一个确定的<code>MSL</code>值，<code>RFC 1122</code>建议是<code>2</code>分钟</li>
<li>可以防止本次连接中产生的数据包误传到下一次连接中（因为本次连接中的数据包都会在<code>2MSL</code>时间内消失了）</li>
</ul>
</li>
</ul>
</li>
<li><p>如果<code>client</code>发送<code>ACK</code>后马上释放了，然后又因为网络原因，<code>server</code>没有收到<code>client</code>的<code>ACK</code>，<code>server</code>就会重发<code>FIN</code></p>
<ul>
<li>这时可能出现的情况是<ul>
<li><code>client</code>没有任何响应，服务器那边会干等，甚至多次重发<code>FIN</code>，浪费资源</li>
<li><code>client</code>有个新的应用程序刚好分配了同一个端口号，新的应用程序收到<code>FIN</code>后马上开始执行断开连接的操作，本来它可能是想跟<code>server</code>建立连接的</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么释放连接的时候，要进行<code>4</code>次挥手?</p>
<ul>
<li><code>TCP</code>是全双工模式</li>
<li>第<code>1</code>次挥手：当<code>主机1</code>发出<code>FIN</code>报文段时<ul>
<li>表示<code>主机1</code>告诉<code>主机2</code>，<code>主机1</code>已经没有数据要发送了，但是，此时<code>主机1</code>还是可以接受来自<code>主机2</code>的数据</li>
</ul>
</li>
<li>第<code>2</code>次挥手：当<code>主机2</code>返回<code>ACK</code>报文段时<ul>
<li>表示<code>主机2</code>已经知道<code>主机1</code>没有数据发送了，但是<code>主机2</code>还是可以发送数据到<code>主机1</code>的</li>
</ul>
</li>
<li>第<code>3</code>次挥手：当<code>主机2</code>也发送了<code>FIN</code>报文段时<ul>
<li>表示<code>主机2</code>告诉<code>主机1</code>，<code>主机2</code>已经没有数据要发送了</li>
</ul>
</li>
<li>第<code>4</code>次挥手：当<code>主机1</code>返回<code>ACK</code>报文段时<ul>
<li>表示<code>主机1</code>已经知道<code>主机2</code>没有数据发送了。随后正式断开整个<code>TCP</code>连接</li>
</ul>
</li>
</ul>
</li>
<li><p>有时候在使用抓包工具的时候，有可能只会看到“<code>3</code>次“挥手</p>
<ul>
<li>这其实是将第<code>2</code>、<code>3</code>次挥手合并了</li>
</ul>
</li>
<li><p>当<code>server</code>接收到<code>client</code>的<code>FIN</code>时，如果<code>server</code>后面也没有数据要发送给<code>client</code>了</p>
<ul>
<li>这时，<code>server</code>就可以将第<code>2</code>、<code>3</code>次挥手合并，同时告诉<code>client</code>两件事<ul>
<li>已经知道<code>client</code>没有数据要发</li>
<li><code>server</code>已经没有数据要发了</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2024/01/16/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><ul>
<li>网络层数据包（<code>IP</code>数据包，<code>Packet</code>）由首部、数据<code>2</code>部分组成<ul>
<li>数据：很多时候是由传输层传递下来的数据段（<code>Segment</code>）</li>
</ul>
</li>
</ul>
<p><img src="1.jpg"></p>
<h2 id="版本（Version）"><a href="#版本（Version）" class="headerlink" title="版本（Version）"></a>版本（<code>Version</code>）</h2><ul>
<li>占<code>4</code>位</li>
<li><code>0b0100</code>：<code>IPv4</code></li>
<li><code>0b0110</code>：<code>IPv6</code></li>
</ul>
<h2 id="首部长度（Header-Length）"><a href="#首部长度（Header-Length）" class="headerlink" title="首部长度（Header Length）"></a>首部长度（<code>Header Length</code>）</h2><ul>
<li>占<code>4</code>位，二进制乘以<code>4</code>才是最终长度</li>
<li><code>0b0101</code>：<code>20</code>（最小值）</li>
<li><code>0b1111</code>：<code>60</code>（最大值）</li>
</ul>
<h2 id="区分服务（Differentiated-Services-Field）"><a href="#区分服务（Differentiated-Services-Field）" class="headerlink" title="区分服务（Differentiated Services Field）"></a>区分服务（<code>Differentiated Services Field</code>）</h2><ul>
<li>占<code>8</code>位</li>
<li>可以用于提高网络的服务质量（<code>QoS</code>，<code>Quality of Service</code>）</li>
</ul>
<h2 id="总长度（Total-Length）"><a href="#总长度（Total-Length）" class="headerlink" title="总长度（Total Length）"></a>总长度（<code>Total Length</code>）</h2><ul>
<li><p>占<code>16</code>位</p>
</li>
<li><p>首部 + 数据的长度之和，最大值是<code>65535</code><br><img src="2.jpg"></p>
</li>
<li><p>由于帧的数据不能超过<code>1500</code>字节，所以过大的IP数据包，需要分成片（<code>fragments</code>）传输给数据链路层</p>
</li>
<li><p>每一片都有自己的网络层首部（<code>IP</code>首部）</p>
</li>
</ul>
<h2 id="标识（Identification）"><a href="#标识（Identification）" class="headerlink" title="标识（Identification）"></a>标识（<code>Identification</code>）</h2><ul>
<li>占<code>16</code>位</li>
<li>数据包的<code>ID</code>，当数据包过大进行分片时，同一个数据包的所有片的标识都是一样的</li>
<li>有一个计数器专门管理数据包的<code>ID</code>，每发出一个数据包，<code>ID</code>就加<code>1</code></li>
</ul>
<h2 id="标志（Flags）"><a href="#标志（Flags）" class="headerlink" title="标志（Flags）"></a>标志（<code>Flags</code>）</h2><ul>
<li>占<code>3</code>位</li>
<li>第<code>1</code>位（<code>Reserved Bit</code>）：保留</li>
<li>第<code>2</code>位（<code>Don&#39;t Fragment</code>）：<code>1</code>代表不允许分片，<code>0</code>代表允许分片</li>
<li>第<code>3</code>位（<code>More Fragments</code>）：<code>1</code>代表不是最后一片，<code>0</code>代表是最后一片</li>
</ul>
<h2 id="片偏移（Fragment-Offset）"><a href="#片偏移（Fragment-Offset）" class="headerlink" title="片偏移（Fragment Offset）"></a>片偏移（<code>Fragment Offset</code>）</h2><ul>
<li>占<code>13</code>位</li>
<li>片偏移乘以<code>8</code>：字节偏移</li>
<li>每一片的长度一定是<code>8</code>的整数倍</li>
</ul>
<p><img src="3.jpg"></p>
<h2 id="生存时间（Time-To-Live，TTL）"><a href="#生存时间（Time-To-Live，TTL）" class="headerlink" title="生存时间（Time To Live，TTL）"></a>生存时间（<code>Time To Live，TTL</code>）</h2><ul>
<li>占<code>8</code>位</li>
<li>每个路由器在转发之前会将<code>TTL</code>减<code>1</code>，一旦发现<code>TTL</code>减为<code>0</code>，路由器会返回错误报告</li>
<li>观察使用<code>ping</code>命令后的<code>TTL</code>，能够推测出对方的操作系统、中间经过了多少个路由器</li>
</ul>
<h2 id="协议（Protocol）"><a href="#协议（Protocol）" class="headerlink" title="协议（Protocol）"></a>协议（Protocol）</h2><ul>
<li>占<code>8</code>位</li>
<li>表明所封装的数据是使用了什么协议</li>
</ul>
<table>
<thead>
<tr>
<th align="center">协议</th>
<th align="center">ICMP</th>
<th align="center">IGMP</th>
<th align="center">IP</th>
<th align="center">TCP</th>
<th align="center">EGP</th>
<th align="center">IGP</th>
<th align="center">UDP</th>
<th align="center">IPv6</th>
<th align="center">ESP</th>
<th align="center">OSPF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">值（十进制）</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">17</td>
<td align="center">41</td>
<td align="center">50</td>
<td align="center">89</td>
</tr>
</tbody></table>
<h2 id="首部校验和（Header-Checksum）"><a href="#首部校验和（Header-Checksum）" class="headerlink" title="首部校验和（Header Checksum）"></a>首部校验和（<code>Header Checksum</code>）</h2><ul>
<li>用于检查首部是否有错误</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2024/01/14/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><ul>
<li><p>链路：从<code>1</code>个节点到相邻节点的一段物理线路（有线或无线），中间没有其他交换节点<br><img src="1.jpg"></p>
</li>
<li><p>数据链路：在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输</p>
<ul>
<li>不同类型的数据链路，所用的通信协议可能是不同的<ul>
<li>广播信道：<code>CSMA/CD</code>协议（比如同轴电缆、集线器等组成的网络）</li>
<li>点对点信道：<code>PPP</code>协议（比如<code>2</code>个路由器之间的信道）</li>
</ul>
</li>
</ul>
</li>
<li><p>数据链路层的<code>3</code>个基本问题</p>
<ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检验</li>
</ul>
</li>
</ul>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="2.jpg"></p>
<ul>
<li>帧（<code>Frame</code>）的数据部分<ul>
<li>就是网络层传递下来的数据包（<code>IP</code>数据包，<code>Packet</code>）</li>
</ul>
</li>
<li>最大传输单元<code>MTU</code>（<code>Maximum Transfer Unit</code>）<ul>
<li>每一种数据链路层协议都规定了所能够传送的帧的数据长度上限</li>
<li>以太网的<code>MTU</code>为<code>1500</code>个字节</li>
</ul>
</li>
</ul>
<h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p><img src="3.jpg"></p>
<ul>
<li>使用<code>SOH</code>（<code>Start Of Header</code>）作为帧开始符</li>
<li>使用<code>EOT</code>（<code>End Of Transmission</code>）作为帧结束</li>
<li>数据部分一旦出现了<code>SOH</code>、<code>EOT</code>，就需要进行转义</li>
</ul>
<p><img src="4.jpg"></p>
<h2 id="差错检验"><a href="#差错检验" class="headerlink" title="差错检验"></a>差错检验</h2><p><img src="5.jpg"></p>
<ul>
<li><code>FCS</code>是根据数据部分 + 首部计算得出的</li>
</ul>
<h1 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h1><ul>
<li><code>CSMA/CD</code>（<code>Carrier Sense Multiple Access with Collision Detectio</code>）<ul>
<li> 载波侦听多路访问/冲突检测</li>
</ul>
</li>
<li>使用了<code>CSMA/CD</code>的网络可以称为是以太网（<code>Ethernet</code>），它传输的是<code>以太网帧</code><ul>
<li>以太网帧的格式有：<code>Ethernet V2</code>标准、<code>IEEE</code>的<code>802.3</code>标准</li>
<li>使用最多的是：<code>Ethernet V2</code>标准</li>
</ul>
</li>
<li>为了能够检测正在发送的帧是否产生了冲突，以太网的帧至少要<code>64</code>字节.(小于<code>64</code>字节的,发出去了，因为冲突回来了，由于太小了，发送端已经发送完了，因此没法判断是否是因为冲突回来，还是反方向的)</li>
<li>用交换机组建的网络，已经支持全双工通信，不需要再使用<code>CSMA/CD</code>，但它传输的帧依然是以太网帧</li>
<li>所以，用交换机组建的网络，依然可以叫做<code>以太网</code></li>
</ul>
<h2 id="Ethernet-V2帧的格式"><a href="#Ethernet-V2帧的格式" class="headerlink" title="Ethernet V2帧的格式"></a><code>Ethernet V2</code>帧的格式</h2><p><img src="6.jpg"></p>
<ul>
<li>首部：目标<code>MAC</code> +源<code>MAC</code> + 网络类型</li>
<li>以太网帧：首部 + 数据 + <code>FCS</code></li>
<li>数据的长度至少是：64 – 6 – 6 – 2 – 4 = <code>46</code>字节</li>
</ul>
<h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><ul>
<li>当数据部分的长度小于<code>46</code>字节时<ul>
<li>数据链路层会在数据的后面加入一些字节填充</li>
<li>接收端会将添加的字节去掉</li>
</ul>
</li>
</ul>
<p><img src="7.jpg"></p>
<ul>
<li><p>长度总结</p>
<ul>
<li>以太网帧的数据长度：<code>46</code> ~ <code>1500</code>字节</li>
<li>以太网帧的长度：<code>64</code> ~ <code>1518</code>字节（目标<code>MAC</code> +源<code>MAC</code> + 网络类型 + 数据 + <code>FCS</code>）</li>
</ul>
</li>
<li><p><strong>注意</strong>，网卡接收到一个帧，首先会进行差错校验，如果校验通过则接收，否则丢弃</p>
<ul>
<li><code>Wireshark</code>抓到的帧没有<code>FCS</code> ，因为它抓到的是差错校验通过的帧（帧尾的<code>FCS</code>会被硬件去掉）</li>
<li><code>Wireshark</code>抓不到差错校验失败的帧</li>
</ul>
</li>
</ul>
<h1 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a><code>PPP</code>协议</h1><p><img src="8.jpg"></p>
<ul>
<li><code>Address</code>字段：图中的值是<code>0xFF</code>，形同虚设，点到点信道不需要源<code>MAC</code>、目标<code>MAC</code>地址<br>◼ <code>Control</code>字段：图中的值是<code>0x03</code>，目前没有什么作用<br>◼ <code>Protocol</code>字段：内部用到的协议类型<br>◼ 帧开始符、帧结束符：<code>0x7E</code></li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>MAC地址/IP地址</title>
    <url>/2024/01/12/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ul>
<li> 每一个网卡都有一个<code>6</code>字节（<code>49bit</code> ）的<code>MAC</code>地址</li>
<li>全球唯一，固化在了网卡的<code>ROM</code>中，由<code>IEEE802</code>标准规定<ul>
<li>前<code>3</code>字节：<code>OUI</code>，组织唯一标识符。<ul>
<li> 由IEE的注册管理机构分配给厂商</li>
</ul>
</li>
<li>后<code>3</code>字节：网络接口标识符<ul>
<li> 由厂商自行分配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MAC地址的获取"><a href="#MAC地址的获取" class="headerlink" title="MAC地址的获取"></a>MAC地址的获取</h3><ul>
<li>当不知道对方主机的<code>MAC</code>地址时，可以通过发<code>ARP</code>广播获取对方的<code>MAC</code>地址<ul>
<li>获取成功后，会缓存<code>IP</code>地址、<code>MAC</code>地址的映射信息，俗称：<code>ARP</code>缓存</li>
<li>通过<code>ARP</code>广播获取的<code>MAC</code>地址，属于动态（<code>dynamic</code>）缓存<ul>
<li>存储时间比较短（默认是<code>2</code>分钟），过期了就自动删除</li>
</ul>
</li>
</ul>
</li>
<li>相关命令<ul>
<li><code>arp -a [主机地址]</code>：查询<code>ARP</code>缓存</li>
<li><code>arp -d [主机地址]</code>：删除<code>ARP</code>缓存</li>
<li><code>arp -s 主机地址 MAC地址</code>：增加一条缓存信息（这是静态缓存，存储时间较久，不同系统的存储时间不同）</li>
</ul>
</li>
</ul>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ul>
<li><code>ARP</code>,译为：地址解析协议<ul>
<li> 通过<code>IP</code>地址获取<code>MAC</code>地址</li>
</ul>
</li>
<li><code>PARP</code>,译为：逆地址解析协议<ul>
<li>使用与<code>ARP</code>相同的报头结构</li>
<li>作用与<code>ARP</code>相反，用于将<code>MAC</code>地址转换为<code>IP</code>地址</li>
<li>后来被<code>BOOTP</code>、<code>DHCP</code>所取代</li>
</ul>
</li>
</ul>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ul>
<li><code>ICMP</code>,译为：互联网控制消息协议<ul>
<li><code>IPv4</code>中的<code>ICMP</code>被称作<code>ICMPv4</code>，<code>IPv6</code>中的<code>ICMP</code>则被称作<code>ICMPv6</code></li>
<li>通常用于返回错误信息<ul>
<li>比如 值过期、目的不可达</li>
</ul>
</li>
<li><code>ICMP</code>的错误消息总是包括了源数据并返回给发送者</li>
</ul>
</li>
</ul>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><ul>
<li><code>IP</code>地址（<code>Internet Protocol Address</code>）：互联网上的每一个主机都有一个IP地址<ul>
<li>最初是<code>IPv4</code>版本，<code>32bit</code>（<code>4</code>字节），<code>2019</code>年<code>11</code>月<code>25</code>日，全球的<code>IP</code>地址已经用完</li>
<li>后面推出了<code>IPv6</code>版本，<code>128bit</code>（<code>16</code>字节）</li>
</ul>
</li>
</ul>
<h3 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h3><ul>
<li><p><code>IP</code>地址由<code>2</code>部分组成：网络标识（网络<code>ID</code>）、主机标识（主机<code>ID</code>）</p>
<ul>
<li>通过子网掩码（<code>subnet mask</code>）可以得知网络<code>ID</code> 、主机<code>ID</code></li>
</ul>
</li>
<li><p>主机所在的网段 = 子网掩码 <code>&amp;</code> <code>IP</code>地址</p>
</li>
<li><p>计算机和其他计算机通信前，会先判断目标主机和自己是否在同一网段.(判断是以自己的淹码去判断是否是同一个)</p>
<ul>
<li>同一网段：不需要由路由器进行转发</li>
<li>不同网段：交由路由器进行转发</li>
</ul>
</li>
<li><p>下图是无法进行网络通信的</p>
<ul>
<li><code>PC0</code>(<code>192.168.0.10</code>)发送消息到<code>PC1</code>(<code>192.168.10.10</code>),会根据<code>PC0</code>的掩码<code>24</code>(即<code>255:255:255:0</code>)分别得出，<code>192.168.0.0</code>和<code>192.168.10.0</code>。<code>PC0</code>无法发送消息到<code>PC1</code></li>
<li>当<code>PC1</code>发送消息到<code>PC0</code>时，会根据<code>PC1</code>的掩码<code>16</code>,分别得出，<code>192.168.0.0</code>和<code>192.168.0.0</code>,<code>PC1</code>可以发送消息到<code>PC0</code>，但是<code>PC0</code>无法发送消息到<code>PC1</code>，因此网络通信无法建立</li>
</ul>
</li>
</ul>
<p><img src="1.png"></p>
<h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><ul>
<li><code>A</code>类地址：默认子网掩码是<code>255.0.0.0</code><ul>
<li>第一部分<code>0～127</code>开头的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>8bit</th>
<th>24bit</th>
</tr>
</thead>
<tbody><tr>
<td>网络ID:<code>0</code>开头</td>
<td>主机ID</td>
</tr>
</tbody></table>
<ul>
<li><code>B</code>类地址：默认子网掩码是<code>255.255.0.0</code><ul>
<li>第一部分<code>128～191</code>开头的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>16bit</th>
<th>16bit</th>
</tr>
</thead>
<tbody><tr>
<td>网络ID:<code>10</code>开头</td>
<td>主机ID</td>
</tr>
</tbody></table>
<ul>
<li><code>C</code>类地址：默认子网掩码是<code>255.255.255.0</code><ul>
<li>第一部分<code>192～223</code>开头的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>24bit</th>
<th>8bit</th>
</tr>
</thead>
<tbody><tr>
<td>网络ID:<code>110</code>开头</td>
<td>主机ID</td>
</tr>
</tbody></table>
<ul>
<li><p><code>D</code>类地址：以<code>1110</code>开头，多播地址</p>
</li>
<li><p><code>E</code>类地址：以<code>1111</code>开头，保留为今后使用</p>
</li>
<li><p>只有<code>A</code>`B<code>\</code>C`类地址才能分配给主机</p>
<ul>
<li>主机<code>ID</code>为全<code>0</code>，表示主机所在的网段</li>
<li>主机<code>ID</code>为全<code>1</code>，表示主机所在网段的全部主机（广播）</li>
<li>可以尝试用<code>ping</code>给某个网段的全部主机发数据</li>
</ul>
</li>
</ul>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><ul>
<li>子网划分：借用主机位作子网位，划分出多个子网</li>
<li>可用分为<ul>
<li>等长子网划分：将一个网段等分成多个子网，每个子网的可用IP地址数量是一样的</li>
<li>变长子网划分：每个子网的可用IP地址数量可以是不一样的</li>
</ul>
</li>
<li>子网划分的步骤<ul>
<li>确定子网的子网掩码长度</li>
<li>确定子网中第<code>1</code>个、最后<code>1</code>个主机可用的IP地址(主机位全<code>0</code>是掩码，全<code>1</code>是当前子网的广播地址，要排除)</li>
</ul>
</li>
</ul>
<h3 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h3><ul>
<li>超网：跟<code>子网</code>反过来，它是将多个连续的网段合并成一个更大的网段</li>
</ul>
<h4 id="合并规律"><a href="#合并规律" class="headerlink" title="合并规律"></a>合并规律</h4><ul>
<li>假设<code>n</code>是<code>2</code>的<code>k</code>次幂（<code>k</code>≥1）<ul>
<li>子网掩码左移<code>k</code>位能够将能够合并<code>n</code>个网段</li>
<li>如果第一个网段的网络号能被<code>n</code>整除，那么由它开始连续的<code>n</code>个网段，能通过左移<code>k</code>位子网掩码进行合并</li>
</ul>
</li>
<li>比如<ul>
<li>第一个网段的网络号以二进制<code>0</code>结尾，那么由它开始连续的<code>2</code>个网段，能通过左移<code>1</code>位子网掩码进行合并</li>
<li>第一个网段的网络号以二进制<code>00</code>结尾，那么由它开始连续的<code>4</code>个网段，能通过左移<code>2</code>位子网掩码进行合并</li>
<li>第一个网段的网络号以二进制<code>000</code>结尾，那么由它开始连续的<code>8</code>个网段，能通过左移<code>3</code>位子网掩码进行合并</li>
</ul>
</li>
</ul>
<h3 id="判断一个网段是子网还是超网"><a href="#判断一个网段是子网还是超网" class="headerlink" title="判断一个网段是子网还是超网"></a>判断一个网段是子网还是超网</h3><ul>
<li>首先<ul>
<li>看看该网段的类型，是<code>A</code>类网络、<code>B</code>类网络、<code>C</code>类网络？</li>
<li>默认情况下，<code>A</code>类子网掩码的位数是<code>8</code>，<code>B</code>类子网掩码的位数是<code>16</code>，C类子网掩码的位数是<code>24</code><br>◼ 然后<br>如果该网段的子网掩码位数比默认子网掩码多，就是子网<br>如果该网段的子网掩码位数比默认子网掩码少，则是超网<br>◼ 比如</li>
<li>25.100.0.0/16是一个<code>A</code>类子网</li>
<li>200.100.0.0/16是一个<code>C</code>类超网</li>
</ul>
</li>
</ul>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ul>
<li>在不同网段之间转发数据，需要有路由器的支持</li>
<li>默认情况下，路由器只知道跟它直连的网段，非直连的网段需要通过静态路由、动态路由告诉它（如果不知道，则无法转发数据）<ul>
<li>静态路由<ul>
<li>管理员手动添加路由信息</li>
<li>适用于小规模网络</li>
</ul>
</li>
<li>动态路由<ul>
<li> 路由器通过路由选择协议（比如RIP、OSPF）自动获取路由信息</li>
<li>适用于大规模网络</li>
</ul>
</li>
</ul>
</li>
<li>下图中，实现静态路由例子<ul>
<li>两个路由器的<code>serial</code>要在同一网段，以便路由器进行挑战</li>
<li>添加静态路由表，即它的网络/掩码以及下一跳的路由器<code>serial ip</code><ul>
<li>如果网络为<code>0.0.0.0</code>，掩码是<code>0.0.0.0</code>,表面默认跳转（其他没有精确查到的，最后，眺到默认的路由器处理）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="2.png"></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>按照网络的范围进行分类，可以分为：局域网、城域网、广域网等</li>
<li>局域网（<code>LAN</code>）<ul>
<li>一般是范围在几百米到十几公里内的计算机所构成的计算机网络</li>
<li>常用于公司、家庭、学校、医院、机关、一幢大楼等</li>
<li>局域网中使用最广泛的网络技术叫：以太网</li>
<li>在电脑、手机上经常见到的一个英文<code>WLAN</code>，意思是无线局域网</li>
</ul>
</li>
<li>城域网（<code>MAN</code>）<ul>
<li>一般范围是数十公里到数百公里，可以覆盖一个城市</li>
</ul>
</li>
<li>广域网（<code>WAN</code>）<ul>
<li>一般范围是几百公里到几千公里，可以覆盖一个国家。通常都需要租用 的线路。</li>
</ul>
</li>
</ul>
<h3 id="常见的几种接口"><a href="#常见的几种接口" class="headerlink" title="常见的几种接口"></a>常见的几种接口</h3><ul>
<li>FastEthernet<ul>
<li>快速以太网接口（100M）</li>
</ul>
</li>
<li>GigabitEthernet<ul>
<li>千兆以太网接口</li>
</ul>
</li>
<li>Serial<ul>
<li>串行接口</li>
</ul>
</li>
</ul>
<h3 id="公网IP、私网IP"><a href="#公网IP、私网IP" class="headerlink" title="公网IP、私网IP"></a>公网IP、私网IP</h3><ul>
<li><code>IP</code>地址也分为：公网<code>IP</code>、私网<code>IP</code></li>
<li>公网<code>IP</code>（<code>Public</code>）<ul>
<li><code>Internet</code>上的路由器中只有到达公网的路由表，没有到达私网的路由表</li>
<li>公网<code>IP</code>由因特网信息中心（<code>Inter NIC</code>）统一分配和管理</li>
<li><code>ISP</code>需要向<code>Inter NIC</code>申请公网<code>IP</code></li>
</ul>
</li>
<li>私网<code>IP</code>（<code>Private</code>）<ul>
<li>主要用于局域网。下面是保留的私网网段<ul>
<li>A类：10.0.0.0/8，1个A类网络</li>
<li>B类：172.16.0.0/16 ~ 172.31.0.0/16，16个B类网络</li>
<li>C类：192.168.0.0/24 ~ 192.168.255.0/24，256个C类网</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><ul>
<li>私网<code>IP</code>访问<code>Internet</code>需要进行<code>NAT</code>转换为公网<code>IP</code><ul>
<li><code>NAT</code>(<code>Network Address Translation</code>)</li>
<li>这一步可以由路由器来完成</li>
</ul>
</li>
<li><code>NAT</code>的特点<ul>
<li>可以节约公网 资源</li>
<li>会隐藏内部真实</li>
</ul>
</li>
<li><code>NAT</code>的分类<ul>
<li>静态转换<ul>
<li>手动配置 映射表</li>
<li>一对一转换</li>
</ul>
</li>
<li>动态转换<ul>
<li>定义外部地址池，动态随机转换</li>
<li>一对一转换</li>
</ul>
</li>
</ul>
</li>
<li><code>PAT</code>(<code>Port Address Translation</code>)<ul>
<li>多对一转换，最大程度节约公网 资源</li>
<li>采用端口多路复用方式，通过端口号标识不同的数据流</li>
<li>目前应用最广泛的 实现方式</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>本地音视频播放器</title>
    <url>/2024/01/09/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E6%9C%AC%E5%9C%B0%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ol>
<li><a href="#jump">初始化<code>SDL</code>子系统</a></li>
<li><a href="#jump1">开始播放</a>，开启子线程<code>A</code><a href="#jump2">读取文件信息</a><ol>
<li>传入文件地址<code>filename</code>,创建解封装上下文<code>_fmtCtx</code></li>
<li>从解封装上下文<code>_fmtCtx</code>中检索流信息</li>
<li><a href="#jump3">初始化音频信息</a><ol>
<li><a href="#jump4">初始化解码器</a><ol>
<li>根据解封装上下文找到音频流信息<code>_aStream</code></li>
<li>根据音频流信息中的<code>_aStream-&gt;codecpar-&gt;codec_id</code>,找到合适的解码器<code>AVCodec</code></li>
<li>根据解码器，初始化解码上下文</li>
<li>将音频流信息中的<code>codecpar</code>参数，复制到解码上下文</li>
<li>打开解码器</li>
</ol>
</li>
<li><a href="#jump5">初始化音频重采样上下文</a><ol>
<li>设定重采样输入/输出参数</li>
<li>根据输入/输出参数创建重采样上下文</li>
<li>初始化重采样上下文</li>
<li>创建重采样输入帧<code>_aSwrInFrame</code>和输出<code>_aSwrOutFrame</code></li>
<li>初始化输出帧的<code>_aSwrOutFrame</code>的数据空间（输入帧<code>_aSwrInFrame</code>会在解码的时候，自动获取合适的数据空间）</li>
</ol>
</li>
<li><a href="#jump6">初始化<code>SDL</code></a><ol>
<li>初始化<code>SDL</code>音频参数,即重采样输出的参数</li>
<li>打开音频设备</li>
</ol>
</li>
</ol>
</li>
<li><a href="#jump7">初始化视频信息</a><ol>
<li><a href="#jump4">初始化解码器</a><ol>
<li>根据解封装上下文找到视频流信息<code>_vStream</code></li>
<li>根据视频流信息中的<code>_vStream-&gt;codecpar-&gt;codec_id</code>,找到合适的解码器<code>AVCodec</code></li>
<li>根据解码器，初始化解码上下文</li>
<li>将视频流信息中的<code>codecpar</code>参数，复制到解码上下文</li>
<li>打开解码器</li>
</ol>
</li>
<li><a href="#jump8">初始化像素格式转换上下文</a><ol>
<li>设定格式转换输入/输出参数</li>
<li>根据输入/输出参数创建重采样上下文</li>
<li>创建格式转换输入帧<code>_vSwsInFrame</code>和输出帧<code>_vSwsOutFrame</code></li>
<li>初始化输出帧的<code>_vSwsOutFrame</code>的数据空间（输入帧<code>_vSwsInFrame</code>会在解码的时候赋值)</li>
</ol>
</li>
</ol>
</li>
<li>启动<a href="#jump9"><code>SDL</code>音频子线程</a>，开始播放声音</li>
<li>启动视频子线程，开始<a href="#jump10">解码视频</a></li>
<li>从解封装上下文中，<a href="#jump11">读取音视频数据</a></li>
<li>资源释放标记</li>
</ol>
</li>
<li><a href="#jump12">资源的释放</a></li>
<li><a href="#jump13">视频画面的显示</a></li>
</ol>
<h2 id="初始化SDL子系统"><a href="#初始化SDL子系统" class="headerlink" title="初始化SDL子系统"></a><span id="jump">初始化<code>SDL</code>子系统</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">CFFmpegPlayer::<span class="hljs-built_in">CFFmpegPlayer</span>() &#123;<br>    <br>    <span class="hljs-comment">// 初始化Audio子系统</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">SDL_Init</span>(SDL_INIT_AUDIO)) &#123;<br>        <span class="hljs-keyword">if</span> (_playFailFunc) &#123;<br>            _playFailFunc(<span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="开始播放"><a href="#开始播放" class="headerlink" title="开始播放"></a><span id="jump1">开始播放</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::play</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == Playing) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(_state == Stopped) &#123;<br>        <span class="hljs-built_in">thread</span>([<span class="hljs-keyword">this</span>]()&#123;<br>            cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;_filename &lt;&lt; endl;<br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">readFile</span>(<span class="hljs-keyword">this</span>-&gt;_filename);<br>        &#125;).<span class="hljs-built_in">detach</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">setState</span>(Playing);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="读取文件信息"><a href="#读取文件信息" class="headerlink" title="读取文件信息"></a><span id="jump2">读取文件信息</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CFFmpegPlayer::readFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span> </span>&#123;<br>    <span class="hljs-comment">// 返回结果</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**创建解封装上下文，打开文件</span><br><span class="hljs-comment">    int avformat_open_input(AVFormatContext **ps, const char *url,</span><br><span class="hljs-comment">                             const AVInputFormat *fmt, AVDictionary **options);</span><br><span class="hljs-comment">     - url 是打开的输入流，此前录制音频/视频的时候，是device序号，例如0，这里传入要解封的音视频文件</span><br><span class="hljs-comment">     - fmt 是输入格式，此前不为null，传入的是视频格式，例如avfoundation</span><br><span class="hljs-comment">     - options,传入一些额外的参数，例如视频录制时传入的  av_dict_set(&amp;options,&quot;pixel_format&quot;,&quot;yuyv422&quot;,0);</span><br><span class="hljs-comment">     */</span><br>    ret = <span class="hljs-built_in">avformat_open_input</span>(&amp;_fmtCtx, filename, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">ENDRET</span>(avformat_open_input)<br>    <br>    <span class="hljs-comment">// 从媒体文件中检索流信息</span><br>    ret = <span class="hljs-built_in">avformat_find_stream_info</span>(_fmtCtx,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">ENDRET</span>(avformat_open_input)<br>    <br>    <span class="hljs-comment">// 打印流信息到控制台</span><br>    <span class="hljs-built_in">av_dump_format</span>(_fmtCtx, <span class="hljs-number">0</span>, filename, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 初始化音频信息</span><br>    _hasAudio = <span class="hljs-built_in">initAudioInfo</span>() &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 初始化视频信息</span><br>    _hasVideo = <span class="hljs-built_in">initVideoInfo</span>() &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!_hasAudio &amp;&amp; !_hasVideo) &#123;<br>        <span class="hljs-comment">// 音视频信息均初始化失败了</span><br>        <span class="hljs-keyword">if</span> (_playFailFunc) &#123;<br>            _playFailFunc(<span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-built_in">setState</span>(Stopped);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 初始化完成</span><br>    <span class="hljs-keyword">if</span> (_initFinishFunc) &#123;<br>        _initFinishFunc(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-built_in">setState</span>(Playing);<br>    <span class="hljs-comment">//SDL音频子线程，开始播放声音</span><br>    <span class="hljs-built_in">SDL_PauseAudio</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//视频子线程，开始工作，开启新的线程解码，音频中SDL有自己线程，因此不用开线程</span><br>    <span class="hljs-built_in">thread</span>([<span class="hljs-keyword">this</span>]&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">decodeVideo</span>(); <span class="hljs-comment">//解码视频</span><br>    &#125;).<span class="hljs-built_in">detach</span>();<br>    <br>    <span class="hljs-built_in">readPacket</span>();<br>    <br>    <br>    <span class="hljs-comment">// 标记下可以释放了</span><br>    <span class="hljs-keyword">if</span> (_fmtctxCanFree) &#123;<br>        <span class="hljs-built_in">stop</span>(); <span class="hljs-comment">//正常播放完了</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        _fmtctxCanFree = <span class="hljs-literal">true</span>;<span class="hljs-comment">//手动停止的情况</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="初始化音频信息"><a href="#初始化音频信息" class="headerlink" title="初始化音频信息"></a><span id="jump3">初始化音频信息</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CFFmpegPlayer::initAudioInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化解码器</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">initDecoder</span>(&amp;_aDecodeCtx, &amp;_aStream, AVMEDIA_TYPE_AUDIO);<br>    <span class="hljs-built_in">RET</span>(initDecoder)<br>    <br>    <span class="hljs-comment">// 初始化音频重采样上下文</span><br>    ret = <span class="hljs-built_in">initSwr</span>();<br>    <span class="hljs-built_in">RET</span>(initSwr)<br>    <br>    <span class="hljs-comment">// 初始化SDL</span><br>    ret = <span class="hljs-built_in">initSDL</span>();<br>    <span class="hljs-built_in">RET</span>(initSDL)<br>    <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始化音频重采样上下文"><a href="#初始化音频重采样上下文" class="headerlink" title="初始化音频重采样上下文"></a><span id="jump5">初始化音频重采样上下文</span></h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CFFmpegPlayer::initSwr</span><span class="hljs-params">()</span> </span>&#123;<br>    _aSwrInSpec.sampleFmt = _aDecodeCtx-&gt;sample_fmt;<br>    _aSwrInSpec.channels = _aDecodeCtx-&gt;channels;<br>    _aSwrInSpec.sampleRate = _aDecodeCtx-&gt;sample_rate;<br>    <span class="hljs-comment">//SDL支持的输出音频参数</span><br>    _aSwrOutSpec.sampleFmt = AV_SAMPLE_FMT_S16;<br>    _aSwrOutSpec.sampleRate = <span class="hljs-number">44100</span>;<br>    _aSwrOutSpec.channels = <span class="hljs-number">1</span>;<br>    _aSwrOutSpec.bytesPerSampleFrame = _aSwrOutSpec.channels * <span class="hljs-built_in">av_get_bytes_per_sample</span>(_aSwrOutSpec.sampleFmt);<br>    <br>    <span class="hljs-comment">// 创建重采样上下文</span><br>    <br>    _aSwrCtx = <span class="hljs-built_in">swr_alloc_set_opts</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">av_get_default_channel_layout</span>(_aSwrOutSpec.channels), _aSwrOutSpec.sampleFmt, _aSwrOutSpec.sampleRate, <span class="hljs-built_in">av_get_default_channel_layout</span>(_aSwrInSpec.channels), _aSwrInSpec.sampleFmt, _aSwrInSpec.sampleRate, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!_aSwrCtx) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;swr_alloc_set_opts 初始化为NULL&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 初始化重采样上下文</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">swr_init</span>(_aSwrCtx);<br>    <span class="hljs-built_in">RET</span>(swr_init)<br>    <span class="hljs-comment">// 初始化输入</span><br>    _aSwrInFrame = <span class="hljs-built_in">av_frame_alloc</span>();<br>    <span class="hljs-keyword">if</span> (!_aSwrInFrame) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc error _aSwrInFrame&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 初始化输出frame</span><br>    _aSwrOutFrame = <span class="hljs-built_in">av_frame_alloc</span>();<br>    <span class="hljs-keyword">if</span> (!_aSwrOutFrame) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc error _aSwrOutFrame&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化重采样的输出frame的data[0]空间，不用初始化输入的，输入的通过avcodec_receive_frame可以赋值</span><br>    ret = <span class="hljs-built_in">av_samples_alloc</span>(_aSwrOutFrame-&gt;data, _aSwrOutFrame-&gt;linesize, _aSwrOutSpec.channels, <span class="hljs-number">4096</span>, _aSwrOutSpec.sampleFmt, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">RET</span>(av_samples_alloc)<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始化SDL"><a href="#初始化SDL" class="headerlink" title="初始化SDL"></a><span id="jump6">初始化<code>SDL</code></span></h4><ul>
<li>这里的<code>sdlAudioCallback</code>,即<code>SDL</code>子线程处理<a href="#jump9">音频数据的回调</a>。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CFFmpegPlayer::initSDL</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 音频参数</span><br>    SDL_AudioSpec spec;<br>    <span class="hljs-comment">// 采样率</span><br>    spec.freq = _aSwrOutSpec.sampleRate;<br>    <span class="hljs-comment">// 采样格式</span><br>    spec.format = AUDIO_S16LSB;<br>    <span class="hljs-comment">// 声道数</span><br>    spec.channels = _aSwrOutSpec.channels;<br>    <span class="hljs-comment">// 音频缓冲去的样本数量，必须是2的幂</span><br>    spec.samples = <span class="hljs-number">512</span>;<br>    <span class="hljs-comment">// 回调，音频子线程获取回调的参数</span><br>    spec.callback = sdlAudioCallback;<br>    <span class="hljs-comment">// 传递给回调的参数</span><br>    spec.userdata = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-comment">// 打开音频设备</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">SDL_OpenAudio</span>(&amp;spec, <span class="hljs-literal">nullptr</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="初始化视频信息"><a href="#初始化视频信息" class="headerlink" title="初始化视频信息"></a><span id="jump7">初始化视频信息</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CFFmpegPlayer::initVideoInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">initDecoder</span>(&amp;_vDecodeCtx, &amp;_vStream, AVMEDIA_TYPE_VIDEO);<br>    <span class="hljs-built_in">RET</span>(initDecoder)<br>    <span class="hljs-comment">// 初始化视频像素格式转换,不用像素格式转换，直接用YUP420</span><br>    ret = <span class="hljs-built_in">initSws</span>();<br>    <span class="hljs-built_in">RET</span>(initSws)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始化像素格式转换上下文"><a href="#初始化像素格式转换上下文" class="headerlink" title="初始化像素格式转换上下文"></a><span id="jump8">初始化像素格式转换上下文</span></h4><ul>
<li>在<code>IOS</code>系统中，不支持将将<code>YUV</code>格式转换成<code>RGB</code>格式，这里仍然初始化<code>_vSwsOutFrame</code>，目的是，保证解码后的数据，在填满<code>_vSwsOutFrame</code>后，可以直接写入数据，不用计算每个格式所占的比例（解码后的<code>YUV</code>数据格式，和实际标准的会多些，要重新分配）<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CFFmpegPlayer::initSws</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 取16位的整数，有助于转换效率</span><br>    _vSwsOutSpec.width = _vDecodeCtx-&gt;width;<br>    _vSwsOutSpec.height = _vDecodeCtx-&gt;height;<br>    _vSwsOutSpec.pixelFmt = _vDecodeCtx-&gt;pix_fmt;<br>    _vSwsOutSpec.size = <span class="hljs-built_in">av_image_get_buffer_size</span>(_vSwsOutSpec.pixelFmt, _vSwsOutSpec.width, _vSwsOutSpec.height, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 初始化像素格式转换上下文</span><br>    <span class="hljs-comment">// libswscale/yuv2rgb.c的669行只有ARCH_PPC、ARCH_X86、ARCH_LOONGARCH64支持YUV转RGB,iOS上暂时不支持</span><br><span class="hljs-comment">//    _vSwsctx = sws_getContext(_vDecodeCtx-&gt;width,</span><br><span class="hljs-comment">//                              _vDecodeCtx-&gt;height,</span><br><span class="hljs-comment">//                              _vDecodeCtx-&gt;pix_fmt,</span><br><span class="hljs-comment">//                              _vSwsOutSpec.width,</span><br><span class="hljs-comment">//                              _vSwsOutSpec.height,</span><br><span class="hljs-comment">//                              _vSwsOutSpec.pixelFmt,</span><br><span class="hljs-comment">//                              SWS_BILINEAR, nullptr, nullptr, nullptr);</span><br><span class="hljs-comment">//    if (!_vSwsctx) &#123;</span><br><span class="hljs-comment">//        cout &lt;&lt; &quot;sws_getContext _vSwsctx error&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//        return -1;</span><br><span class="hljs-comment">//    &#125;</span><br>    <br>    <span class="hljs-comment">// 初始化像素输入格式,解码数据</span><br>    _vSwsInFrame = <span class="hljs-built_in">av_frame_alloc</span>();<br>    <span class="hljs-keyword">if</span> (!_vSwsInFrame) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc _vSwsInFrame error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 接收存储数据</span><br>    _vSwsOutFrame = <span class="hljs-built_in">av_frame_alloc</span>();<br>    <span class="hljs-keyword">if</span> (!_vSwsOutFrame) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc _vSwsOutFrame error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">av_image_alloc</span>(_vSwsOutFrame-&gt;data,<br>                             _vSwsOutFrame-&gt;linesize,<br>                             _vSwsOutSpec.width,<br>                             _vSwsOutSpec.height,<br>                             _vSwsOutSpec.pixelFmt, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">RET</span>(av_image_alloc)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="初始化解码器"><a href="#初始化解码器" class="headerlink" title="初始化解码器"></a><span id="jump4">初始化解码器</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CFFmpegPlayer::initDecoder</span><span class="hljs-params">(AVCodecContext **decodeCtx, AVStream **stream, FF_AVMediaType type)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据type寻找最合适的流信息，返回是流索引</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * wanted_stream_nb: 用户请求的流，-1表示自动选择</span><br><span class="hljs-comment">         * related_stream： 尝试发现关联的流，-1表示没有关联的</span><br><span class="hljs-comment">         * decoder_ret: 为选择的流返回解码器，为null不返回</span><br><span class="hljs-comment">         * int av_find_best_stream(AVFormatContext *ic,</span><br><span class="hljs-comment">                            enum AVMediaType type,</span><br><span class="hljs-comment">                            int wanted_stream_nb,</span><br><span class="hljs-comment">                            int related_stream,</span><br><span class="hljs-comment">                            const AVCodec **decoder_ret,</span><br><span class="hljs-comment">                            int flags);</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">av_find_best_stream</span>(_fmtCtx, type, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">RET</span>(av_find_best_stream)<br>    *stream = _fmtCtx-&gt;streams[ret]; <span class="hljs-comment">// 检验流</span><br>    <span class="hljs-keyword">if</span> (!*stream) &#123;<br>        cout &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;相关流数据为空&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">// 为当前流找到合适的解码器</span><br>    <span class="hljs-comment">// 根据codecID获取解码器</span><br>    <span class="hljs-keyword">const</span> AVCodec *decoder = <span class="hljs-built_in">avcodec_find_decoder</span>((*stream)-&gt;codecpar-&gt;codec_id);<br>    <span class="hljs-keyword">if</span> (!decoder) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;decoder not found&quot;</span> &lt;&lt; (*stream) -&gt; codecpar-&gt;codec_id &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 初始化解码上下文</span><br>    *decodeCtx = <span class="hljs-built_in">avcodec_alloc_context3</span>(decoder);<br>    <span class="hljs-keyword">if</span> (!*decodeCtx) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;avcodec_alloc_context3 error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//从流中拷贝参数到解码上下文中</span><br>    ret = <span class="hljs-built_in">avcodec_parameters_to_context</span>(*decodeCtx, (*stream)-&gt;codecpar);<br>    <span class="hljs-built_in">RET</span>(avcodec_parameters_to_context)<br>    <span class="hljs-comment">//打开解码器</span><br>    ret = <span class="hljs-built_in">avcodec_open2</span>(*decodeCtx, decoder, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">RET</span>(avcodec_open2)<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="SDL音频子线程"><a href="#SDL音频子线程" class="headerlink" title="SDL音频子线程"></a><span id="jump9"><code>SDL</code>音频子线程</span></h3><ul>
<li><code>SDL</code>音频子线程的回调，需传入函数，这里用静态函数，将数据转到<code>CFFmpegPlayer</code>对象内处理<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sdl音频的回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::sdlAudioCallback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 * stream,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    CFFmpegPlayer *player = (CFFmpegPlayer *)userdata;<br>    player-&gt;<span class="hljs-built_in">sdlAudioCallback</span>(stream,len);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>对象内的函数，实现<code>SDL数据填充</code>。啥时候解码数据，由<code>SDL</code>子线程决定<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::sdlAudioCallback</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *stream, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// len SDL缓存区的大小，剩下未填的数据长度</span><br>    <span class="hljs-built_in">SDL_memset</span>(stream, <span class="hljs-number">0</span>, len);<br>    <span class="hljs-comment">// len: SDL音频缓冲区剩余的大小，还未填充的数据</span><br>    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(_state == Paused) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (_state == Stopped) &#123;<br>            _aCanFree = <span class="hljs-literal">true</span>;<span class="hljs-comment">//是否可以释放</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//说明当前PCM的数据已经全部拷贝到SDL的音频缓冲区了</span><br>        <span class="hljs-comment">// 需要解码下一个pkt，获取新的PCM数据</span><br>        <span class="hljs-keyword">if</span> (_aSwrOutIdex &gt;= _aSwrOutSize) &#123;<br>            <span class="hljs-comment">// 全新PCM的大小,解码音频数据</span><br>            _aSwrOutSize = <span class="hljs-built_in">decodeAudio</span>();<br>            <span class="hljs-comment">// 索引清零</span><br>            _aSwrOutIdex = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(_aSwrOutSize &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 解码异常，静音处理</span><br>            <span class="hljs-comment">//假定PCM的大小，不用SDL_memset(stream,0,len);因为只用短暂禁音</span><br>            _aSwrOutSize = <span class="hljs-number">1024</span>;<br>            <span class="hljs-comment">// 给PCM填充0（静音）</span><br>            <span class="hljs-built_in">memset</span>(_aSwrOutFrame-&gt;data[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>,_aSwrOutSize);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 本次可以填充的数据</span><br>        <span class="hljs-keyword">int</span> fillLen = _aSwrOutSize - _aSwrOutIdex;<br>        fillLen = <span class="hljs-built_in">min</span>(len,fillLen);<span class="hljs-comment">//实际填充的数据</span><br>        <span class="hljs-keyword">int</span> volumn = _mute ? <span class="hljs-number">0</span> : (_volumn * <span class="hljs-number">1.0</span> / Max) * SDL_MIX_MAXVOLUME;<br>        <span class="hljs-comment">// 填充到SDL的音频缓存区</span><br>        <span class="hljs-built_in">SDL_MixAudio</span>(stream, _aSwrOutFrame-&gt;data[<span class="hljs-number">0</span>] + _aSwrOutIdex, fillLen, volumn);<br>        <span class="hljs-comment">//数据输出偏移</span><br>        _aSwrOutIdex += fillLen;<br>        <span class="hljs-comment">// 缓存区数据偏移</span><br>        len -= fillLen;<br>        stream += fillLen;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="解码音频数据"><a href="#解码音频数据" class="headerlink" title="解码音频数据"></a>解码音频数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CFFmpegPlayer::decodeAudio</span><span class="hljs-params">()</span> </span>&#123;<br>    _aMutex.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-comment">//    while(_aPackets.empty()) &#123;</span><br>    <span class="hljs-comment">//        // wait会存在操作系统的假唤醒，因此加while</span><br>    <span class="hljs-comment">//        _aMutex.wait();</span><br>    <span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-keyword">if</span>(_aPackets.<span class="hljs-built_in">empty</span>() || _state == Stopped) &#123;<br>        _aMutex.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    AVPacket pkt = _aPackets.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//不能用引用</span><br>    <span class="hljs-comment">// 从头部中删除，如果引用的话，pop_front后就会删除指针，后续无法用pkt了</span><br>    _aPackets.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-comment">// 解锁</span><br>    _aMutex.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">if</span> (pkt.pts != AV_NOPTS_VALUE) &#123;<br>        _aTime = pkt.pts * <span class="hljs-built_in">av_q2d</span>(_aStream-&gt;time_base);<br>        cout &lt;&lt; <span class="hljs-string">&quot;输出当前音频包时间: &quot;</span> &lt;&lt; _aTime &lt;&lt; endl;<br>        <span class="hljs-comment">//通知外界，播放的时间</span><br>        <span class="hljs-keyword">if</span>(_timeChangeFunc) &#123;<br>            _timeChangeFunc(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span>(_seekTime &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// seek时，当前资源不要，不会影响后续解码</span><br>    &#125;<br>    <span class="hljs-comment">// 如果是视频，不能提前释放</span><br>    <span class="hljs-comment">// 发现音频的时间是早于seektime的，直接丢弃，因为视频是有i帧，p帧，因此seek到86时，可能要从81开始解码</span><br>    <span class="hljs-keyword">if</span> (_aseekTime &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(_aTime &lt; _aseekTime) &#123;<br>            <span class="hljs-comment">// 释放pkt</span><br>            <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _aseekTime = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 发送压缩数据到解码器</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avcodec_send_packet</span>(_aDecodeCtx, &amp;pkt);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        ERROR_BUF<br>        cout &lt;&lt; <span class="hljs-string">&quot;a:avcodec_send_packet: &quot;</span> &lt;&lt; errbuf &lt;&lt; endl;<br>        <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取解码后的数据</span><br>    ret = <span class="hljs-built_in">avcodec_receive_frame</span>(_aDecodeCtx,_aSwrInFrame);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        ERROR_BUF;<br>        cout &lt;&lt; <span class="hljs-string">&quot;avcodec_receive_frame error:&quot;</span> &lt;&lt; errbuf &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">int</span> outSamples = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">av_rescale_rnd</span>(_aSwrOutSpec.sampleRate, _aSwrInFrame-&gt;nb_samples, _aSwrInFrame-&gt;sample_rate, AV_ROUND_UP);<br>    ret = <span class="hljs-built_in">swr_convert</span>(_aSwrCtx,<br>                          (<span class="hljs-keyword">uint8_t</span> **)_aSwrOutFrame-&gt;data,<br>                          outSamples,<br>                          (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> **)_aSwrInFrame-&gt;data,<br>                          _aSwrInFrame-&gt;nb_samples); <span class="hljs-comment">//数据转换后的样本数量</span><br>    <span class="hljs-built_in">RET</span>(swr_convert)<br>    <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>    <span class="hljs-keyword">return</span> ret * _aSwrOutSpec.bytesPerSampleFrame;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="视频解码子线程"><a href="#视频解码子线程" class="headerlink" title="视频解码子线程"></a><span id="jump10">视频解码子线程</span></h3><ul>
<li>视频解码速度由音频播放的速度决定。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::decodeVideo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (_state == Paused &amp;&amp; _vseekTime == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// seek可以放到外面</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (_state == Stopped) &#123;<br>            _vCanFree = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        _vMutex.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (_vPackets.<span class="hljs-built_in">empty</span>()) &#123;<br>            _vMutex.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        AVPacket pkt = _vPackets.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 不能引用</span><br>        <span class="hljs-comment">// 从头部中删除，如果引用的话，pop_front后就会删除指针，后续无法用pkt了</span><br>        _vPackets.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-comment">// 解锁</span><br>        _vMutex.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">if</span> (pkt.pts != AV_NOPTS_VALUE) &#123;<br>            _vTime = pkt.pts * <span class="hljs-built_in">av_q2d</span>(_vStream-&gt;time_base);<br>            cout &lt;&lt; <span class="hljs-string">&quot;输出当前视频包时间: &quot;</span> &lt;&lt; _aTime &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-comment">// 要seek时间</span><br>        <span class="hljs-keyword">if</span> (_seekTime &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// seek时，当前资源不要，不会影响后续解码</span><br>        &#125;<br>        <span class="hljs-comment">// 发送压缩数据到解码器</span><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avcodec_send_packet</span>(_vDecodeCtx, &amp;pkt);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            ERROR_BUF<br>            cout &lt;&lt; <span class="hljs-string">&quot;v:avcodec_send_packet: &quot;</span> &lt;&lt; errbuf &lt;&lt; endl;<br>            <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>            <span class="hljs-keyword">continue</span>;;<br>        &#125;<br>        <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 获取解码后的数据</span><br>            ret = <span class="hljs-built_in">avcodec_receive_frame</span>(_vDecodeCtx,_vSwsInFrame);<br>            <span class="hljs-keyword">if</span> (ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>                <span class="hljs-keyword">break</span>;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>                ERROR_BUF;<br>                cout &lt;&lt; <span class="hljs-string">&quot;avcodec_receive_frame error:&quot;</span> &lt;&lt; errbuf &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 一定要解码成功后，再进行判断</span><br>            <span class="hljs-comment">// 发现视频的时间是早于seektime的，直接丢弃，因为视频是有i帧，p帧，因此seek到86时，可能要从81开始解码</span><br>            <span class="hljs-keyword">if</span> (_vseekTime &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//和音频不同，必须放在解码后，因为前面的帧可能有I帧，而要seek的帧需要依赖前面的帧，否则会出现花屏</span><br>                <span class="hljs-keyword">if</span> (_vTime &lt; _vseekTime) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    _vseekTime = <span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (_hasAudio) &#123; <span class="hljs-comment">//// 有音频数据</span><br>                <span class="hljs-comment">/// 如果视频包过早被解码出来需要等待</span><br>                <span class="hljs-keyword">while</span> (_vTime &gt; _aTime &amp;&amp; _state == Playing ) &#123; <span class="hljs-comment">// 注意停止后，_aTime不会在增加</span><br>                    <span class="hljs-comment">//SDL_Delay(5);</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">SDL_Delay</span>(<span class="hljs-number">25</span>);<span class="hljs-comment">// 没有音频，以25帧播放</span><br>            &#125;<br>            <span class="hljs-comment">// 把像素格式拷贝出来，因为画图的线程和解码的线程不一样，如果直接传指针的话，当sws_scale中对data改变时也会改变外部的data</span><br><br>            <span class="hljs-comment">//OPENGL渲染</span><br>            Uint8 *buf = (Uint8 *)<span class="hljs-built_in">malloc</span>(_vSwsOutSpec.size);<br>            <span class="hljs-comment">// 这种拷贝，可以保证_vSwsOutFrame-&gt;data[0]开始数据是连续的，_vSwsInFrame要根据，每linesize的数据</span><br>            <span class="hljs-built_in">av_image_copy</span>(_vSwsOutFrame-&gt;data,_vSwsOutFrame-&gt;linesize,(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> **)_vSwsInFrame-&gt;data,_vSwsInFrame-&gt;linesize,_vSwsOutSpec.pixelFmt,_vSwsOutSpec.width,_vSwsOutSpec.height);<br>            <br>            <span class="hljs-built_in">memcpy</span>(buf,_vSwsOutFrame-&gt;data[<span class="hljs-number">0</span>],_vSwsOutSpec.size);<br>            <span class="hljs-keyword">if</span> (_frameDevodedFunc) &#123;<br>                _frameDevodedFunc(<span class="hljs-keyword">this</span>,buf,_vSwsOutSpec.size,_vSwsOutSpec.width,_vSwsOutSpec.height);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="从解封装上下文读取音视频数据"><a href="#从解封装上下文读取音视频数据" class="headerlink" title="从解封装上下文读取音视频数据"></a><span id="jump11">从解封装上下文读取音视频数据</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::readPacket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 初始化pkt</span><br>    AVPacket pkt ; <span class="hljs-comment">// 每次赋值，都是拷贝赋值，因此放在下面while的外面也是可以的</span><br>    <span class="hljs-comment">// 从输入文件中读取数据，和此前解码不同，不用解析器，直接从解封装上下文中获取</span><br>    <span class="hljs-comment">// 返回解封装文件中，返回下一帧的流数据，类似之前视频/音频采集的方式</span><br>    <span class="hljs-keyword">while</span> (_state != Stopped) &#123;<br>        <span class="hljs-comment">// 处理seek操作</span><br>        <span class="hljs-keyword">if</span> (_seekTime &gt; <span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">//seek不记录之前的，就算之前读取过，也从seek位置重新读取</span><br>            <span class="hljs-keyword">int</span> streamIdx;<br>            <span class="hljs-keyword">if</span>(_hasAudio) &#123; <span class="hljs-comment">// 优先用音频流索引seek</span><br>                streamIdx = _aStream-&gt;index;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                streamIdx = _vStream-&gt;index;<br>            &#125;<br>            <span class="hljs-comment">// 现实时间 -&gt; 时间戳</span><br>            AVRational timeBase = _fmtCtx-&gt;streams[streamIdx]-&gt;time_base;<br>            <span class="hljs-keyword">int64_t</span> ts = _seekTime / <span class="hljs-built_in">av_q2d</span>(timeBase);<br>            ret = <span class="hljs-built_in">av_seek_frame</span>(_fmtCtx,streamIdx,ts,AVSEEK_FLAG_BACKWARD);<br>            <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//seeak失败</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;seeak 失败&quot;</span> &lt;&lt; endl;<br>                _seekTime = <span class="hljs-number">-1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;seeak 成功&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-comment">// 清空之前的时间</span><br>                <span class="hljs-built_in">clearAudioPkt</span>();<br>                <span class="hljs-built_in">clearVideoPkt</span>();<br>                <span class="hljs-comment">// 保证，在上一个资源改变之后，再进行操作</span><br>                _vTime = <span class="hljs-number">0</span>;<br>                _vseekTime = _seekTime;<br>                _aTime = <span class="hljs-number">0</span>;<br>                _aseekTime = _seekTime;<br>                _seekTime = <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vSize = _vPackets.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> aSize = _aPackets.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(vSize &gt;= VIDEO_MAX_PKT_SIZE || aSize &gt;= AUDIO_MAX_PKT_SIZE) &#123;<br>            <span class="hljs-comment">// SDL_Delay(2);// 防止av_read_frame读取pkt太多载入内存中</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        ret = <span class="hljs-built_in">av_read_frame</span>(_fmtCtx, &amp;pkt);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pkt.stream_index == _aStream-&gt;index) &#123;<br>                <span class="hljs-comment">// 读取到的是音频数据</span><br>                <span class="hljs-built_in">addAudioPkt</span>(pkt);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pkt.stream_index == _vStream-&gt;index) &#123;<br>                <span class="hljs-comment">// // 读取到的是视频数据</span><br>                <span class="hljs-built_in">addVideoPkt</span>(pkt);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 释放非音频视频流的pkt</span><br>                <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>            &#125;<br>        &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == AVERROR_EOF) &#123; <span class="hljs-comment">//读取到了文件尾部</span><br>            <span class="hljs-keyword">if</span> (vSize == <span class="hljs-number">0</span> &amp;&amp; aSize == <span class="hljs-number">0</span>) &#123;<br>                _fmtctxCanFree = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ERROR_BUF;<br>            cout &lt;&lt; <span class="hljs-string">&quot;av_read_frame:&quot;</span> &lt;&lt; errbuf &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="音频数据的添加"><a href="#音频数据的添加" class="headerlink" title="音频数据的添加"></a>音频数据的添加</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//MARK: 音频数据的添加处理</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::addAudioPkt</span><span class="hljs-params">(AVPacket &amp;pkt)</span> </span>&#123;<br>    _aMutex.<span class="hljs-built_in">lock</span>();<br>    _aPackets.<span class="hljs-built_in">push_back</span>(pkt);<br>    _aMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::clearAudioPkt</span><span class="hljs-params">()</span> </span>&#123;<br>    _aMutex.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">for</span> (AVPacket &amp;pkt : _aPackets) &#123;<br>        <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>    &#125;<br>    _aPackets.<span class="hljs-built_in">clear</span>();<br>    _aMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="视频数据的添加"><a href="#视频数据的添加" class="headerlink" title="视频数据的添加"></a>视频数据的添加</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::addVideoPkt</span><span class="hljs-params">(AVPacket &amp;pkt)</span> </span>&#123;<br>    _vMutex.<span class="hljs-built_in">lock</span>();<br>    _vPackets.<span class="hljs-built_in">push_back</span>(pkt);<br>    _vMutex.<span class="hljs-built_in">signal</span>();<br>    _vMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::clearVideoPkt</span><span class="hljs-params">()</span> </span>&#123;<br>    _vMutex.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">for</span> (AVPacket &amp;pkt:_vPackets) &#123;<br>        <span class="hljs-built_in">av_packet_unref</span>(&amp;pkt);<br>    &#125;<br>    _vPackets.<span class="hljs-built_in">clear</span>();<br>    _vMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="资源的释放"><a href="#资源的释放" class="headerlink" title="资源的释放"></a><span id="jump12">资源的释放</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::free</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (_hasAudio &amp;&amp; !_aCanFree);<br>    <span class="hljs-keyword">while</span> (_hasVideo &amp;&amp; !_vCanFree);<br>    <span class="hljs-keyword">while</span> (!_fmtctxCanFree); <span class="hljs-comment">//_fmtctx可能在用</span><br>    <span class="hljs-built_in">avformat_close_input</span>(&amp;_fmtCtx);<br>    _fmtctxCanFree = <span class="hljs-literal">false</span>;<br>    _seekTime = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">freeAudio</span>();<br>    <span class="hljs-built_in">freeVideo</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="音频资源释放"><a href="#音频资源释放" class="headerlink" title="音频资源释放"></a>音频资源释放</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::freeAudio</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">SDL_PauseAudio</span>(<span class="hljs-number">1</span>);<br>    _aSwrOutIdex = <span class="hljs-number">0</span>;<br>    _aSwrOutSize = <span class="hljs-number">0</span>;<br>    _aStream = <span class="hljs-literal">nullptr</span>;<br>    _aCanFree = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">clearAudioPkt</span>();<br>    <span class="hljs-built_in">avcodec_free_context</span>(&amp;_aDecodeCtx);<br>    <span class="hljs-built_in">av_frame_free</span>(&amp;_aSwrInFrame);<br>    <span class="hljs-built_in">swr_free</span>(&amp;_aSwrCtx);<br>    <span class="hljs-keyword">if</span>(_aSwrOutFrame) &#123; <span class="hljs-comment">// 防止data是野指针</span><br>        <span class="hljs-comment">// 这个自己创建了data</span><br>        <span class="hljs-built_in">av_freep</span>(&amp;_aSwrOutFrame-&gt;data[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">av_frame_free</span>(&amp;_aSwrOutFrame);<br>    &#125;<br>   <br>    <span class="hljs-built_in">SDL_CloseAudio</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="视频资源释放"><a href="#视频资源释放" class="headerlink" title="视频资源释放"></a>视频资源释放</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFFmpegPlayer::freeVideo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">clearVideoPkt</span>();<br>    <span class="hljs-built_in">avcodec_free_context</span>(&amp;_vDecodeCtx);<br>    <span class="hljs-built_in">av_frame_free</span>(&amp;_vSwsInFrame);<br>    <span class="hljs-keyword">if</span> (_vSwsOutFrame) &#123;<br>        <span class="hljs-built_in">av_freep</span>(&amp;_vSwsOutFrame-&gt;data[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">av_frame_free</span>(&amp;_vSwsOutFrame);<br>    &#125;<br><span class="hljs-comment">//    sws_freeContext(_vSwsctx);</span><br><span class="hljs-comment">//    _vSwsctx = nullptr;</span><br>    _vTime = <span class="hljs-number">0</span>;<br>    _vCanFree = <span class="hljs-literal">false</span>;<br>    _vStream = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="视频画面的显示"><a href="#视频画面的显示" class="headerlink" title="视频画面的显示"></a><span id="jump13">视频画面的显示</span></h3><ul>
<li>这里采用的<code>MetalKit</code>，去渲染<code>YUV</code>数据</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">OpenGLMetalKitView</span>()&lt;<span class="hljs-title">MTKViewDelegate</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">MTKView</span> *mtkView;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLDevice</span>&gt; device;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLCommandQueue</span>&gt; commandQueue;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLRenderPipelineState</span>&gt; pipelineState;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLTexture</span>&gt; yTexture;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLTexture</span>&gt; uTexture;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLTexture</span>&gt; vTexture;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) vector_uint2 viewportSize;<br><br><span class="hljs-comment">// reader</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) CVMetalTextureCacheRef textureCache;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLBuffer</span>&gt; vertices;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLBuffer</span>&gt; convertMatrix;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSUInteger</span> numVertices;<br><br><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">OpenGLMetalKitView</span></span><br>- (<span class="hljs-keyword">instancetype</span>)initWithFrame:(<span class="hljs-built_in">CGRect</span>)frame &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> initWithFrame:frame];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _device = <span class="hljs-built_in">MTLCreateSystemDefaultDevice</span>();<br>        _mtkView = [[<span class="hljs-built_in">MTKView</span> alloc] initWithFrame:<span class="hljs-keyword">self</span>.bounds device:<span class="hljs-keyword">self</span>.device];<br>        _mtkView.delegate = <span class="hljs-keyword">self</span>;<br>        _mtkView.clearColor = <span class="hljs-built_in">MTLClearColorMake</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1.0</span>f);<br>        _viewportSize = (vector_uint2)&#123;_mtkView.drawableSize.width, _mtkView.drawableSize.height&#125;;<br>        <br>        [<span class="hljs-keyword">self</span> addSubview:<span class="hljs-keyword">self</span>.mtkView];<br>        <br>        CVMetalTextureCacheCreate(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, _mtkView.device, <span class="hljs-literal">NULL</span>, &amp;_textureCache);<br>        <br>        [<span class="hljs-keyword">self</span> customInit];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)customInit &#123;<br>    [<span class="hljs-keyword">self</span> setupPipeline];<br>    [<span class="hljs-keyword">self</span> setupVertex];<br>    [<span class="hljs-keyword">self</span> setupMatrix];<br>&#125;<br><br><span class="hljs-comment">// 设置顶点</span><br>- (<span class="hljs-keyword">void</span>)setupVertex &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> LYVertex quadVertices[] =<br>    &#123;   <span class="hljs-comment">// 顶点坐标，分别是x、y、z、w；    纹理坐标，x、y；</span><br>        &#123; &#123;  <span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> &#125;,  &#123; <span class="hljs-number">1.</span>f, <span class="hljs-number">1.</span>f &#125; &#125;,<br>        &#123; &#123; <span class="hljs-number">-1.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> &#125;,  &#123; <span class="hljs-number">0.</span>f, <span class="hljs-number">1.</span>f &#125; &#125;,<br>        &#123; &#123; <span class="hljs-number">-1.0</span>,  <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> &#125;,  &#123; <span class="hljs-number">0.</span>f, <span class="hljs-number">0.</span>f &#125; &#125;,<br>        <br>        &#123; &#123;  <span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> &#125;,  &#123; <span class="hljs-number">1.</span>f, <span class="hljs-number">1.</span>f &#125; &#125;,<br>        &#123; &#123; <span class="hljs-number">-1.0</span>,  <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> &#125;,  &#123; <span class="hljs-number">0.</span>f, <span class="hljs-number">0.</span>f &#125; &#125;,<br>        &#123; &#123;  <span class="hljs-number">1.0</span>,  <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> &#125;,  &#123; <span class="hljs-number">1.</span>f, <span class="hljs-number">0.</span>f &#125; &#125;,<br>    &#125;;<br>    <span class="hljs-keyword">self</span>.vertices = [<span class="hljs-keyword">self</span>.mtkView.device newBufferWithBytes:quadVertices<br>                                                     length:<span class="hljs-keyword">sizeof</span>(quadVertices)<br>                                                    options:<span class="hljs-built_in">MTLResourceStorageModeShared</span>]; <span class="hljs-comment">// 创建顶点缓存</span><br>    <span class="hljs-keyword">self</span>.numVertices = <span class="hljs-keyword">sizeof</span>(quadVertices) / <span class="hljs-keyword">sizeof</span>(LYVertex); <span class="hljs-comment">// 顶点个数</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> // BT.601, which is the standard for SDTV.</span><br><span class="hljs-comment"> matrix_float3x3 kColorConversion601Default = (matrix_float3x3)&#123;</span><br><span class="hljs-comment"> (simd_float3)&#123;1.164,  1.164, 1.164&#125;,</span><br><span class="hljs-comment"> (simd_float3)&#123;0.0, -0.392, 2.017&#125;,</span><br><span class="hljs-comment"> (simd_float3)&#123;1.596, -0.813,   0.0&#125;,</span><br><span class="hljs-comment"> &#125;;</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> //// BT.601 full range (ref: http://www.equasys.de/colorconversion.html)</span><br><span class="hljs-comment"> matrix_float3x3 kColorConversion601FullRangeDefault = (matrix_float3x3)&#123;</span><br><span class="hljs-comment"> (simd_float3)&#123;1.0,    1.0,    1.0&#125;,</span><br><span class="hljs-comment"> (simd_float3)&#123;0.0,    -0.343, 1.765&#125;,</span><br><span class="hljs-comment"> (simd_float3)&#123;1.4,    -0.711, 0.0&#125;,</span><br><span class="hljs-comment"> &#125;;</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> //// BT.709, which is the standard for HDTV.</span><br><span class="hljs-comment"> matrix_float3x3 kColorConversion709Default[] = &#123;</span><br><span class="hljs-comment"> (simd_float3)&#123;1.164,  1.164, 1.164&#125;,</span><br><span class="hljs-comment"> (simd_float3)&#123;0.0, -0.213, 2.112&#125;,</span><br><span class="hljs-comment"> (simd_float3)&#123;1.793, -0.533,   0.0&#125;,</span><br><span class="hljs-comment"> &#125;;</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)setupMatrix &#123; <span class="hljs-comment">// 设置好转换的矩阵</span><br>    matrix_float3x3 kColorConversion601FullRangeMatrix = (matrix_float3x3)&#123;<br>        (simd_float3)&#123;<span class="hljs-number">1.0</span>,    <span class="hljs-number">1.0</span>,    <span class="hljs-number">1.0</span>&#125;,<br>        (simd_float3)&#123;<span class="hljs-number">0.0</span>,    <span class="hljs-number">-0.343</span>, <span class="hljs-number">1.765</span>&#125;,<br>        (simd_float3)&#123;<span class="hljs-number">1.4</span>,    <span class="hljs-number">-0.711</span>, <span class="hljs-number">0.0</span>&#125;,<br>    &#125;;<br>    <br>    vector_float3 kColorConversion601FullRangeOffset = (vector_float3)&#123; -(<span class="hljs-number">16.0</span>/<span class="hljs-number">255.0</span>), <span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>&#125;; <span class="hljs-comment">// 这个是偏移</span><br>    <br>    LYConvertMatrix matrix;<br>    <span class="hljs-comment">// 设置参数</span><br>    matrix.matrix = kColorConversion601FullRangeMatrix;<br>    matrix.offset = kColorConversion601FullRangeOffset;<br>    <br>    <span class="hljs-keyword">self</span>.convertMatrix = [<span class="hljs-keyword">self</span>.mtkView.device newBufferWithBytes:&amp;matrix<br>                                                          length:<span class="hljs-keyword">sizeof</span>(LYConvertMatrix)<br>                                                         options:<span class="hljs-built_in">MTLResourceStorageModeShared</span>];<br>&#125;<br><br><span class="hljs-comment">// 设置渲染管道</span><br>-(<span class="hljs-keyword">void</span>)setupPipeline &#123;<br>    <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLLibrary</span>&gt; defaultLibrary = [<span class="hljs-keyword">self</span>.mtkView.device newDefaultLibrary]; <span class="hljs-comment">// .metal</span><br>    <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLFunction</span>&gt; vertexFunction = [defaultLibrary newFunctionWithName:<span class="hljs-string">@&quot;vertexShader&quot;</span>]; <span class="hljs-comment">// 顶点shader，vertexShader是函数名</span><br>    <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLFunction</span>&gt; fragmentFunction = [defaultLibrary newFunctionWithName:<span class="hljs-string">@&quot;samplingShader&quot;</span>]; <span class="hljs-comment">// 片元shader，samplingShader是函数名</span><br>    <br>    <span class="hljs-built_in">MTLRenderPipelineDescriptor</span> *pipelineStateDescriptor = [[<span class="hljs-built_in">MTLRenderPipelineDescriptor</span> alloc] init];<br>    pipelineStateDescriptor.vertexFunction = vertexFunction;<br>    pipelineStateDescriptor.fragmentFunction = fragmentFunction;<br>    pipelineStateDescriptor.colorAttachments[<span class="hljs-number">0</span>].pixelFormat = <span class="hljs-keyword">self</span>.mtkView.colorPixelFormat; <span class="hljs-comment">// 设置颜色格式</span><br>    <br>    <span class="hljs-keyword">self</span>.pipelineState = [<span class="hljs-keyword">self</span>.mtkView.device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor<br>                                                                             error:<span class="hljs-literal">NULL</span>]; <span class="hljs-comment">// 创建图形渲染管道，耗性能操作不宜频繁调用</span><br>    <span class="hljs-keyword">self</span>.commandQueue = [<span class="hljs-keyword">self</span>.mtkView.device newCommandQueue]; <span class="hljs-comment">// CommandQueue是渲染指令队列，保证渲染指令有序地提交到GPU</span><br>&#125;<br><br><br>- (<span class="hljs-keyword">void</span>)updateYUVData:(<span class="hljs-built_in">NSData</span> *)yuvData width:(<span class="hljs-keyword">int</span>)width hegiht:(<span class="hljs-keyword">int</span>)height &#123;<br>    <br>    <span class="hljs-keyword">self</span>.viewportSize = (vector_uint2)&#123;width, height&#125;;<br>    <span class="hljs-built_in">MTLTextureDescriptor</span> *yDescriptor = [<span class="hljs-built_in">MTLTextureDescriptor</span> texture2DDescriptorWithPixelFormat:<span class="hljs-built_in">MTLPixelFormatR8Unorm</span> width:width height:height mipmapped:<span class="hljs-literal">NO</span>];<br>    <span class="hljs-built_in">MTLTextureDescriptor</span> *uyDescriptor = [<span class="hljs-built_in">MTLTextureDescriptor</span> texture2DDescriptorWithPixelFormat:<span class="hljs-built_in">MTLPixelFormatR8Unorm</span> width:width/<span class="hljs-number">2</span> height:height/<span class="hljs-number">2</span> mipmapped:<span class="hljs-literal">NO</span>];<br>    <span class="hljs-keyword">self</span>.yTexture = [<span class="hljs-keyword">self</span>.device newTextureWithDescriptor:yDescriptor];<br>    <span class="hljs-keyword">self</span>.uTexture = [<span class="hljs-keyword">self</span>.device newTextureWithDescriptor:uyDescriptor];<br>    <span class="hljs-keyword">self</span>.vTexture = [<span class="hljs-keyword">self</span>.device newTextureWithDescriptor:uyDescriptor];<br><br>    <span class="hljs-comment">// Upload YUV data to textures</span><br>    [<span class="hljs-keyword">self</span>.yTexture replaceRegion:<span class="hljs-built_in">MTLRegionMake2D</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height) mipmapLevel:<span class="hljs-number">0</span> withBytes:yuvData.bytes bytesPerRow:width];<br>    [<span class="hljs-keyword">self</span>.uTexture replaceRegion:<span class="hljs-built_in">MTLRegionMake2D</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width/<span class="hljs-number">2</span>, height/<span class="hljs-number">2</span>) mipmapLevel:<span class="hljs-number">0</span> withBytes:yuvData.bytes + width * height bytesPerRow:width/<span class="hljs-number">2</span>];<br>    [<span class="hljs-keyword">self</span>.vTexture replaceRegion:<span class="hljs-built_in">MTLRegionMake2D</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width/<span class="hljs-number">2</span>, height/<span class="hljs-number">2</span>) mipmapLevel:<span class="hljs-number">0</span> withBytes:yuvData.bytes + width * height * <span class="hljs-number">5</span> / <span class="hljs-number">4</span> bytesPerRow:width / <span class="hljs-number">2</span>];<br>&#125;<br><br><span class="hljs-comment">//MARK: MTKViewDelegate</span><br>- (<span class="hljs-keyword">void</span>)drawInMTKView:(<span class="hljs-built_in">MTKView</span> *)view &#123;<br>    <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLCommandBuffer</span>&gt; commandBuffer = [<span class="hljs-keyword">self</span>.commandQueue commandBuffer];<br>    <br>    view.currentRenderPassDescriptor.colorAttachments[<span class="hljs-number">0</span>].clearColor = <span class="hljs-built_in">MTLClearColorMake</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1.0</span>f); <span class="hljs-comment">// 设置默认颜色</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.yTexture &amp;&amp; <span class="hljs-keyword">self</span>.uTexture &amp;&amp; <span class="hljs-keyword">self</span>.vTexture) &#123;<br>        <span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">MTLRenderCommandEncoder</span>&gt; renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:view.currentRenderPassDescriptor];<br>        [renderEncoder setRenderPipelineState:<span class="hljs-keyword">self</span>.pipelineState];<br>        <span class="hljs-comment">// Set vertex and fragment shader resources</span><br>        [renderEncoder setViewport:<span class="hljs-keyword">self</span>.viewPortFrame];<br>        [renderEncoder setRenderPipelineState:<span class="hljs-keyword">self</span>.pipelineState]; <span class="hljs-comment">// 设置渲染管道，以保证顶点和片元两个shader会被调用</span><br>        <br>        [renderEncoder setVertexBuffer:<span class="hljs-keyword">self</span>.vertices<br>                                offset:<span class="hljs-number">0</span><br>                               atIndex:LYVertexInputIndexVertices]; <span class="hljs-comment">// 设置顶点缓存</span><br>        [renderEncoder setFragmentTexture:<span class="hljs-keyword">self</span>.yTexture atIndex:LYFragmentTextureIndexTextureY];<br>        [renderEncoder setFragmentTexture:<span class="hljs-keyword">self</span>.uTexture atIndex:LYFragmentTextureIndexTextureU];<br>        [renderEncoder setFragmentTexture:<span class="hljs-keyword">self</span>.vTexture atIndex:LYFragmentTextureIndexTextureV];<br>        <br>        [renderEncoder setFragmentBuffer:<span class="hljs-keyword">self</span>.convertMatrix<br>                                  offset:<span class="hljs-number">0</span><br>                                 atIndex:LYFragmentInputIndexMatrix];<br>         <span class="hljs-comment">//Draw call</span><br>        <br>        [renderEncoder drawPrimitives:<span class="hljs-built_in">MTLPrimitiveTypeTriangle</span> vertexStart:<span class="hljs-number">0</span> vertexCount:<span class="hljs-keyword">self</span>.numVertices];<br>        [renderEncoder endEncoding];<br>        <br>        [commandBuffer presentDrawable:view.currentDrawable];<br>    &#125;<br>    <br>    [commandBuffer commit];<br>&#125;<br><br><br>- (<span class="hljs-keyword">void</span>)mtkView:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">MTKView</span> *)view drawableSizeWillChange:(<span class="hljs-built_in">CGSize</span>)size &#123;<br>    <span class="hljs-keyword">self</span>.viewportSize = (vector_uint2)&#123;size.width, size.height&#125;;<br>&#125;<br><br>- (<span class="hljs-built_in">MTLViewport</span>)viewPortFrame &#123;<br>    <span class="hljs-keyword">int</span> dx = <span class="hljs-number">0</span>,dy = <span class="hljs-number">0</span>,<br>    w = <span class="hljs-keyword">self</span>.mtkView.drawableSize.width,h = <span class="hljs-keyword">self</span>.mtkView.drawableSize.height,<br>    dw = <span class="hljs-keyword">self</span>.viewportSize.x,dh = <span class="hljs-keyword">self</span>.viewportSize.y;<br>    <br>    <span class="hljs-comment">// 计算目标尺寸</span><br>    <span class="hljs-keyword">if</span> (dw * h &gt; w * dh) &#123;<br>        dh = w * dh / dw;<br>        dw = w;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dw = h * dw / dh;<br>        dh = h;<br>    &#125;<br>    dx = (w - dw) &gt;&gt; <span class="hljs-number">1</span>;<br>    dy = (h - dh) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">MTLViewport</span>)&#123;dx, dy, dw, dh, <span class="hljs-number">0</span>, <span class="hljs-number">10.0</span> &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="LYShaderTypes"><a href="#LYShaderTypes" class="headerlink" title="LYShaderTypes"></a>LYShaderTypes</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    vector_float4 position;<br>    vector_float2 textureCoordinate;<br>&#125; LYVertex;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    matrix_float3x3 matrix;<br>    vector_float3 offset;<br>&#125; LYConvertMatrix;<br><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LYVertexInputIndex</span></span><br><span class="hljs-class">&#123;</span><br>    LYVertexInputIndexVertices     = <span class="hljs-number">0</span>,<br>&#125; LYVertexInputIndex;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LYFragmentBufferIndex</span></span><br><span class="hljs-class">&#123;</span><br>    LYFragmentInputIndexMatrix     = <span class="hljs-number">0</span>,<br>&#125; LYFragmentBufferIndex;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LYFragmentTextureIndex</span></span><br><span class="hljs-class">&#123;</span><br>    LYFragmentTextureIndexTextureY     = <span class="hljs-number">0</span>,<br>    LYFragmentTextureIndexTextureU     = <span class="hljs-number">1</span>,<br>    LYFragmentTextureIndexTextureV     = <span class="hljs-number">2</span><br>&#125; LYFragmentTextureIndex;<br><br></code></pre></td></tr></table></figure>

<h4 id="shaders"><a href="#shaders" class="headerlink" title="shaders"></a>shaders</h4><ul>
<li>管线函数代码<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> metal;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    float4 clipSpacePosition [[position]]; <span class="hljs-comment">// position的修饰符表示这个是顶点</span><br>    <br>    float2 textureCoordinate; <span class="hljs-comment">// 纹理坐标，会做插值处理</span><br>    <br>&#125; RasterizerData;<br><br>vertex RasterizerData <span class="hljs-comment">// 返回给片元着色器的结构体</span><br><span class="hljs-built_in">vertexShader</span>(uint vertexID [[ vertex_id ]], <span class="hljs-comment">// vertex_id是顶点shader每次处理的index，用于定位当前的顶点</span><br>             constant LYVertex *vertexArray [[ <span class="hljs-built_in">buffer</span>(LYVertexInputIndexVertices) ]]) &#123; <span class="hljs-comment">// buffer表明是缓存数据，0是索引</span><br>    RasterizerData out;<br>    out.clipSpacePosition = vertexArray[vertexID].position;<br>    out.textureCoordinate = vertexArray[vertexID].textureCoordinate;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function">fragment float4</span><br><span class="hljs-function"><span class="hljs-title">samplingShader</span><span class="hljs-params">(RasterizerData input [[stage_in]], <span class="hljs-comment">// stage_in表示这个数据来自光栅化。（光栅化是顶点处理之后的步骤，业务层无法修改）</span></span></span><br><span class="hljs-params"><span class="hljs-function">               texture2d&lt;<span class="hljs-keyword">float</span>&gt; textureY [[ texture(LYFragmentTextureIndexTextureY) ]], <span class="hljs-comment">// texture表明是纹理数据，LYFragmentTextureIndexTextureY是索引</span></span></span><br><span class="hljs-params"><span class="hljs-function">               texture2d&lt;<span class="hljs-keyword">float</span>&gt; textureU [[ texture(LYFragmentTextureIndexTextureU) ]], <span class="hljs-comment">// texture表明是纹理数据，LYFragmentTextureIndexTextureU是索引</span></span></span><br><span class="hljs-params"><span class="hljs-function">               texture2d&lt;<span class="hljs-keyword">float</span>&gt; textureV [[ texture(LYFragmentTextureIndexTextureV) ]], <span class="hljs-comment">// texture表明是纹理数据，LYFragmentTextureIndexTextureV是索引</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">               constant LYConvertMatrix *convertMatrix [[ buffer(LYFragmentInputIndexMatrix) ]])</span> <span class="hljs-comment">//buffer表明是缓存数据，LYFragmentInputIndexMatrix是索引</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> sampler <span class="hljs-title">textureSampler</span> <span class="hljs-params">(mag_filter::linear,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      min_filter::linear)</span></span>; <span class="hljs-comment">// sampler是采样器</span><br>    <br>    float3 yuv = <span class="hljs-built_in">float3</span>(textureY.<span class="hljs-built_in">sample</span>(textureSampler, input.textureCoordinate).r,<br>                          textureU.<span class="hljs-built_in">sample</span>(textureSampler, input.textureCoordinate).r,<br>                        textureV.<span class="hljs-built_in">sample</span>(textureSampler, input.textureCoordinate).r);<br>    <br>    float3 rgb = convertMatrix-&gt;matrix * (yuv + convertMatrix-&gt;offset);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float4</span>(rgb, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>c++新特性</title>
    <url>/2024/01/07/C++%E5%AD%A6%E4%B9%A0/c-11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h1><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a><code>auto</code></h2><ul>
<li>可以从初始化表达式中推断出变量的类型，大大简化编程工作,类似<code>swift中的let，var</code></li>
<li>属于编译器特性，不影响最终的机器码质量，不影响运行效率<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">10</span>; <span class="hljs-comment">// int</span><br><span class="hljs-keyword">auto</span> str = <span class="hljs-string">&quot;c++&quot;</span>; <span class="hljs-comment">// const char *</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a><code>decltype</code></h2><ul>
<li>可以获取变量的类型。类似<code>typeof()</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">decltype</span>(a) b = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a><code>nullptr</code></h2><ul>
<li>可以解决<code>NULL</code>的二义性问题.本质上<code>NULL</code>就是<code>0</code>,(<code>c++11</code>之后<code>NULL</code>是<code>0</code>，下面会调用<code>func(int a)</code>)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func(int a)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *a)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func(void *a)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//(本质上`NULL`就是`0`)存在二义性问题，报错</span><br><span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//func(void *a) ,不会报错</span><br></code></pre></td></tr></table></figure>

<h2 id="数组便利"><a href="#数组便利" class="headerlink" title="数组便利"></a>数组便利</h2><ul>
<li>快速遍历<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> item : arr) &#123;<br>    cout &lt;&lt; item &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>更加简洁的初始化方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> array[]&#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><code>Lambda</code>表达式</h2><ul>
<li><code>Lambda</code>表达式<ul>
<li> 有点类似于<code>JavaScript</code>中的闭包、<code>iOS</code>中的<code>Block</code>，本质就是函数</li>
<li>完整结构： <code>[capture list]</code> <code>(params list)</code> <code>mutable</code> <code>exception</code> <code>-&gt;</code> <code>return type</code> <code>&#123; function body &#125;</code><ul>
<li><code>capture list</code>：捕获外部变量列表</li>
<li><code>params list</code>：形参列表，不能使用默认参数，不能省略参数名</li>
<li><code>mutable</code>：用来说用是否可以修改捕获的变量</li>
<li><code>exception</code>：异常设定</li>
<li><code>return type</code>：返回值类型</li>
<li><code>function body</code>：函数体</li>
</ul>
</li>
<li>有时可以省略部分结构<ul>
<li><code>[capture list] (params list) -&gt; return type &#123;function body&#125;</code></li>
<li><code>[capture list] (params list) &#123;function body&#125;</code></li>
<li><code>[capture list] &#123;function body&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li>可以视为匿名类型，带捕获的<code>Lambda</code>表达式是无法赋值给函数指针的，可以赋值给<code>std:function</code></li>
<li>可以用<code>auto</code>来替代具体的函数指针类型<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1,<span class="hljs-keyword">int</span> v2,<span class="hljs-keyword">int</span>(*p)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>))</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">p</span>(v1,v2);<br>&#125;<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*p)() = []&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Lambda&quot;</span> &lt;&lt; endl;<br>    &#125;;<br>    <br>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*p1)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>) = [](<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b) -&gt; <span class="hljs-keyword">int</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">auto</span> p3 = [](<span class="hljs-keyword">int</span> v1,<span class="hljs-keyword">int</span> v2) -&gt; <span class="hljs-keyword">int</span> &#123;<br>        <span class="hljs-keyword">return</span> v1 - v2;<br>    &#125;;<br>    <span class="hljs-built_in">p</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">p1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">p3</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;<br>    <span class="hljs-built_in">exec</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [](<span class="hljs-keyword">int</span> v1,<span class="hljs-keyword">int</span> v2) -&gt; <span class="hljs-keyword">int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> + <span class="hljs-number">4</span>;<br>    &#125;);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> func = [a,b] &#123; <span class="hljs-comment">//值捕获a和b</span><br>    cout &lt;&lt; a &lt;&lt; endl;<br>     cout &lt;&lt; b &lt;&lt; endl;<br>&#125;;<br><span class="hljs-keyword">auto</span> func1 = [=] &#123; <span class="hljs-comment">// =表示值捕获表达式中用到的参数，隐式捕获</span><br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>和<code>OC</code>中<code>block</code>一样，在声明时，捕获的值，就是表达式中的值<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">auto</span> func = [a,b] &#123; <span class="hljs-comment">// 捕获了a = 1，b = 2后续不会改变</span><br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br>&#125;;<br>a = <span class="hljs-number">20</span>;<br>b = <span class="hljs-number">40</span>;<br><span class="hljs-built_in">func</span>(); <span class="hljs-comment">// a = 1,b = 2</span><br></code></pre></td></tr></table></figure></li>
<li>如果要捕获实时的值，用引用捕获<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func = [&amp;a,&amp;b] &#123;<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> func = [&amp;] &#123; <span class="hljs-comment">//所有用到的，都是引用捕获</span><br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><code>=</code>值捕获，和<code>&amp;</code>引用捕获，可以混用<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func = [&amp;,b] &#123; <span class="hljs-comment">// b是值捕获，其他引用捕获</span><br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> func = [=,&amp;b] &#123; <span class="hljs-comment">// b是引用捕获，其他值捕获</span><br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a><code>mutable</code></h4><ul>
<li>表达式内值可变,可以通过引用捕获，但同时也会改变外部的值<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> func = [&amp;a] ()&#123;<br>    a ++;<span class="hljs-comment">// 引用捕获，肯定会改变外面的值</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;内部 &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;;<br>a = <span class="hljs-number">20</span>; <br><span class="hljs-built_in">func</span>();<span class="hljs-comment">// // 内部 21</span><br>cout &lt;&lt; <span class="hljs-string">&quot;外部 &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 外部 21</span><br></code></pre></td></tr></table></figure></li>
<li>用<code>mutable</code>不会改变外面的值，只会改变表达式中的值，相当于值捕获之后，在内部赋值了一个局部变量，进行改变<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> func = [a] () <span class="hljs-keyword">mutable</span>&#123;<br>    a ++; <span class="hljs-comment">//不会改变外部a的值</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;内部 &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;;<br>a = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 内部 2</span><br>cout &lt;&lt; <span class="hljs-string">&quot;外部 &quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">// 外部 20</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="c-14"><a href="#c-14" class="headerlink" title="c++14"></a>c++14</h1><ul>
<li><p>泛型<code>Lambda</code>表达式,用<code>auto</code>指定参数类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func = [](<span class="hljs-keyword">auto</span> v1,<span class="hljs-keyword">auto</span> v2) &#123; <span class="hljs-keyword">return</span> v1 + v2; &#125;;<br>cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li>
<li><p>对捕获的变量进行初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">auto</span> func1 = [a = <span class="hljs-number">10</span>]() &#123; <span class="hljs-comment">//只在表达式中赋值了</span><br>    cout &lt;&lt; a &lt;&lt; endl;<br>&#125;;<br><span class="hljs-built_in">func1</span>();<br><span class="hljs-comment">// 这里还是没有初始化</span><br>cout &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="c-14-1"><a href="#c-14-1" class="headerlink" title="c++14"></a>c++14</h1><ul>
<li>可以进行初始化的<code>if</code>、<code>switch</code>语句,新增的编译器特性<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 变量a,b的作用域是它所在的if语句，以及其后面的if-else语句</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; a &gt; <span class="hljs-number">10</span>) &#123;<br>    a = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; a &gt; <span class="hljs-number">5</span> &amp;&amp; b &gt; <span class="hljs-number">10</span>) &#123;<br>    b = <span class="hljs-number">2</span>;<br>    a = <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    b = <span class="hljs-number">4</span>;<br>    a = <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-comment">// 这里是无法访问a，b的</span><br><br><span class="hljs-comment">// 变量a的作用域是它所在的swift语句</span><br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; a) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li><p>异常是一种在程序运行过程中可能会发生的错误（比如内存不够）</p>
</li>
<li><p>异常没有被处理，会导致程序终止</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divide12</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1,<span class="hljs-keyword">int</span> v2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(v2 == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">DivideException</span>();<br>    <span class="hljs-keyword">return</span> v1/v2;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1,<span class="hljs-keyword">int</span> v2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(v2 == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span>  <span class="hljs-number">999</span>;<br>    <span class="hljs-keyword">return</span> v1/v2;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">divide12</span>(a,b);<br>        <span class="hljs-keyword">int</span> c = <span class="hljs-built_in">divide</span>(a, b);<br>    &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ecxeption) &#123;<br>        cout &lt;&lt; ecxeption &lt;&lt; endl;<br>    &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> &amp;errorCode) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;double &quot;</span> &lt;&lt; errorCode &lt;&lt; endl;<br>    &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;errorCode) &#123; <span class="hljs-comment">//类型要和抛出的类型一致</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;int &quot;</span> &lt;&lt; errorCode &lt;&lt; endl;<br>    &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> Exception &amp;exception) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Exception &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(...) &#123; <span class="hljs-comment">//拦截所有异常</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;出现的异常 &quot;</span> &lt;&lt; endl;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>catch</code>一般用<code>const</code>可以接收<code>const</code>和<code>非const</code>.用引用<code>&amp;</code>可以避免拷贝构造</p>
</li>
<li><p><code>throw</code>异常后，会在当前函数中查找匹配的<code>catch</code>，找不到就终止当前函数代码，去上一层函数中查找。如果最终都找不到匹配的<code>catch</code>，整个程序就会终止</p>
</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exception</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DivideException</span>:</span> <span class="hljs-keyword">public</span> Exception &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;不能除以0&quot;</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul>
<li>传统指针存在的问题<ul>
<li>需要手动管理内存</li>
<li>容易发生内存泄露（忘记释放、出现异常等）</li>
<li>释放之后产生野指针</li>
</ul>
</li>
<li>智能指针就是为了解决传统指针存在的问题<ul>
<li><code>auto_ptr</code>：属于<code>C++98</code>标准，在<code>C++11</code>中已经不推荐使用（有缺陷，比如不能用于数组）</li>
<li><code>shared_ptr</code>：属于<code>C++11</code>标准</li>
<li><code>unique_ptr</code>：属于<code>C++11</code>标准</li>
</ul>
</li>
</ul>
<h2 id="智能指针的简单自实现"><a href="#智能指针的简单自实现" class="headerlink" title="智能指针的简单自实现"></a>智能指针的简单自实现</h2><ul>
<li>其本质如下，在指针释放后，释放堆对象<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPointer</span> &#123;</span><br>    T *pointer;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmartPointer</span>(T *pointer):<span class="hljs-built_in">pointer</span>(pointer) &#123;&#125;<br>    ~<span class="hljs-built_in">SmartPointer</span>()&#123;<br>        <span class="hljs-keyword">if</span> (pointer == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">delete</span> pointer;<br>    &#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;()&#123;<br>        <span class="hljs-keyword">return</span> pointer;<br>    &#125;<br>    <br>&#125;;<br><br>&#123;<br>        <span class="hljs-function">SmartPointer&lt;Car&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Car(<span class="hljs-number">1</span>))</span></span>;<br>        p1-&gt;<span class="hljs-built_in">run</span>();<br>        p1.<span class="hljs-keyword">operator</span>-&gt;()-&gt;<span class="hljs-built_in">run</span>();<br>    &#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><code>shared_ptr</code></h2><ul>
<li><code>shared_ptr</code>的设计理念<ul>
<li>多个<code>shared_ptr</code>可以指向同一个对象，当最后一个<code>shared_ptr</code>在作用域范围内结束时，对象才会被自动释放</li>
</ul>
</li>
<li>可以通过一个已存在的智能指针初始化一个新的智能指针<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;Car&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Car)</span></span>;<br><span class="hljs-function">shared_ptr&lt;Car&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br></code></pre></td></tr></table></figure></li>
<li>针对数组的用法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;Car&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Car[<span class="hljs-number">5</span>]&#123;&#125;,[](Car *c)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">delete</span> [] c;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;)</span></span>;<br><span class="hljs-function">shared_ptr&lt;Car[]&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Car[<span class="hljs-number">5</span>]&#123;&#125;)</span></span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="shared-ptr的原理"><a href="#shared-ptr的原理" class="headerlink" title="shared_ptr的原理"></a><code>shared_ptr</code>的原理</h3><blockquote>
<p>原理和<code>OC</code>中的引用计数类似</p>
</blockquote>
<ul>
<li>一个<code>shared_ptr</code>会对一个对象产生强引用（<code>strong reference</code>）</li>
<li>每个对象都有个与之对应的强引用计数，记录着当前对象被多少个<code>shared_ptr</code>强引用着<ul>
<li>可以通过<code>shared_ptr</code>的<code>use_count</code>函数获得强引用计数</li>
</ul>
</li>
<li>当有一个新的<code>shared_ptr</code>指向对象时，对象的强引用计数就会<code>+1</code></li>
<li>当有一个<code>shared_ptr</code>销毁时（比如作用域结束），对象的强引用计数就会<code>-1</code></li>
<li>当一个对象的强引用计数为<code>0</code>时（没有任何<code>shared_ptr</code>指向对象时），对象就会自动销毁（析构）</li>
</ul>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><code>weak_ptr</code></h2><ul>
<li><code>weak_ptr</code>会对一个对象产生弱引用</li>
<li><code>weak_ptr</code>可以指向对象解决<code>shared_ptr</code>的循环引用问题</li>
</ul>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h2><ul>
<li><code>unique_ptr</code>也会对一个对象产生强引用，它可以确保同一时间只有<code>1</code>个指针指向对象</li>
<li>当<code>unique_ptr</code>销毁时（作用域结束时），其指向的对象也就自动销毁了</li>
<li>可以使用<code>std::move</code>函数转移<code>unique_ptr</code>的所有权</li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>c++类型转换</title>
    <url>/2024/01/06/C++%E5%AD%A6%E4%B9%A0/c-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><code>C</code>语言风格的类型转换符<ul>
<li><code>(type)expression</code></li>
<li><code>type(expression)</code></li>
</ul>
</li>
<li><code>C++</code>中有<code>4</code>个类型转换符<ul>
<li><code>static_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>const_cast</code></li>
<li>使用格式：<code>xx_cast&lt;type&gt;(expression)</code></li>
</ul>
</li>
</ul>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h3><ul>
<li>一般用于去除<code>const</code>属性，将<code>const</code>转换成<code>非const</code>。（实际上只是编译器上的欺骗）<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> Person *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>Person *p2 = <span class="hljs-keyword">const_cast</span>&lt;Person *&gt;(p1);<br>p2-&gt;age = <span class="hljs-number">3</span>;<br>cout &lt;&lt; p1-&gt;age &lt;&lt; endl; <span class="hljs-comment">// 3</span><br>Person *p3 = (Person *)p1; <span class="hljs-comment">//等价于</span><br>p3-&gt;age = <span class="hljs-number">6</span>;<br>cout &lt;&lt; p1-&gt;age &lt;&lt; endl; <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h3><ul>
<li>一般用于多态类型的转换，有运行时安全检测。要有虚函数（多态依赖虚函数实现），否则无法使用</li>
<li>如果存在<code>父类</code>赋值<code>子类</code>的不安全操作(以及其他类赋值操作)，会返回<code>0</code>即<code>NULL</code>.防止访问异常<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span> <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p1 = &quot;</span>;<br>    &#125;<br>&#125;;<br>    Person1 *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person1</span>();<br>    Person1 *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student1</span>();<br>    Car *ca1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>(<span class="hljs-number">1</span>);<br>    Student1 *stu1 = <span class="hljs-keyword">dynamic_cast</span>&lt;Student1 *&gt;(p1); <span class="hljs-comment">// 不安全 返回0</span><br>    Student1 *stu2 = <span class="hljs-keyword">dynamic_cast</span>&lt;Student1 *&gt;(p2); <span class="hljs-comment">// 安全</span><br>    Student1 *stu3 = <span class="hljs-keyword">dynamic_cast</span>&lt;Student1 *&gt;(ca1); <span class="hljs-comment">//不相关类赋值，不安全 返回0</span><br>    stu1-&gt;<span class="hljs-built_in">test</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1 = &quot;</span> &lt;&lt; p1  &lt;&lt; <span class="hljs-string">&quot; stu1 = &quot;</span> &lt;&lt; stu1 &lt;&lt; endl; <span class="hljs-comment">// p1 = p1 = 0x600003d60040 stu1 = 0x0</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;p2 = &quot;</span> &lt;&lt; p2  &lt;&lt; <span class="hljs-string">&quot; stu2 = &quot;</span> &lt;&lt; stu2 &lt;&lt; endl; <span class="hljs-comment">//p2 = 0x600003d60050 stu2 = 0x600003d60050</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;ca1 = &quot;</span> &lt;&lt; ca1  &lt;&lt; <span class="hljs-string">&quot; stu3 = &quot;</span> &lt;&lt; stu3 &lt;&lt; endl; <span class="hljs-comment">//ca1 = 0x600003d60060 stu3 = 0x0</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;NULL = &quot;</span> &lt;&lt; <span class="hljs-literal">NULL</span> &lt;&lt; endl; <span class="hljs-comment">//NULL = 0</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h3><ul>
<li>对比<code>dynamic_cast</code>，缺乏运行时安全检测<ul>
<li>不能交叉转换（不是同一继承体系的，无法转换）。无任何联系之类的类转换</li>
<li>常用于基本数据类型的转换、<code>非const</code>转成<code>const</code></li>
<li>适用范围较广（很弱，大部分可以隐式转换）</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(a);<br><span class="hljs-comment">// 等价   double d = a;</span><br>Person *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br><span class="hljs-keyword">const</span> Person *p2 = <span class="hljs-keyword">static_cast</span>&lt;Person *&gt;(p1);<br><span class="hljs-comment">// 等价  const Person *p2 = p1;</span><br></code></pre></td></tr></table></figure>

<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h3><ul>
<li>属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅是简单的二进制数据拷贝.(类似<code>swift</code>的<code>unsafeBitcast</code>)</li>
<li>可以交叉转换</li>
<li>可以将指针和整数互相转换<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">double</span>&amp;&gt;(a);<br><span class="hljs-keyword">int</span> * d1 = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">int</span> *&gt;(<span class="hljs-number">100</span>);<br>cout &lt;&lt; d &lt;&lt; endl &lt;&lt; d1 &lt;&lt; endl &lt;&lt; a; <span class="hljs-comment">// -0.998524  0x64. 10</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>c++模版</title>
    <url>/2024/01/05/C++%E5%AD%A6%E4%B9%A0/c-%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><blockquote>
<p>泛型，是一种将类型参数化以达到代码复用的技术，<code>C++</code>中使用模板来实现泛型</p>
<ul>
<li>模版的原理，是编译器在编译时，发现有模版类的使用，会根据传参生成对应的代码</li>
</ul>
</blockquote>
<ul>
<li>模板的使用格式如下<ul>
<li><code>template &lt;typename\class T&gt;</code></li>
<li><code>typename</code>和<code>class</code>是等价的<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a,T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>add&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>);<br>add&lt;Point&gt;(<span class="hljs-built_in">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<span class="hljs-built_in">Point</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>模板没有被<strong>使用</strong>时，是不会被实例化出来的</li>
<li>模板的声明和实现如果分离到<code>.h</code>和<code>.cpp</code>中，会导致链接错误。(因为<code>.cpp</code>是单独的编译单元,如果分开,编译器不会生成相关代码，只会生成模版代码（而模版代码在<code>cpp</code>中没有使用，是不会编译器生成出来的的）)</li>
<li>一般将模板的声明和实现统一放到一个<code>.hpp</code>文件中.</li>
</ul>
<h2 id="模版类实现"><a href="#模版类实现" class="headerlink" title="模版类实现"></a>模版类实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Item&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> &#123;</span><br>    <span class="hljs-comment">// 友元泛型，要这么写，不然会报错</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;,<span class="hljs-keyword">const</span> Array&lt;T&gt; &amp;);<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Array&lt;T&gt; &amp;arr)</span></span>;<br>    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">0</span>;<br>    Item *data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">int</span> capacity = <span class="hljs-number">0</span>);<br>    ~<span class="hljs-built_in">Array</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Item value)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Item&gt;<br>Array&lt;Item&gt;::<span class="hljs-built_in">Array</span>(<span class="hljs-keyword">int</span> capacity):<span class="hljs-built_in">capacity</span>(capacity) &#123;<br>    data = <span class="hljs-keyword">new</span> Item[<span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Item&gt;<br>Array&lt;Item&gt;::~<span class="hljs-built_in">Array</span>() &#123;<br>    <span class="hljs-keyword">delete</span>[] data;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Item&gt;<br><span class="hljs-keyword">void</span> Array&lt;Item&gt;::<span class="hljs-built_in">add</span>(Item value) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;size == <span class="hljs-keyword">this</span>-&gt;capacity) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;data[<span class="hljs-keyword">this</span>-&gt;size ++] = value;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Item&gt;<br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; cout,<span class="hljs-keyword">const</span> Array&lt;Item&gt; &amp;arr) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size; i++) &#123;<br>        cout &lt;&lt; arr.data[i];<br>        <span class="hljs-keyword">if</span> (i != arr.size - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/2024/01/03/C++%E5%AD%A6%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ul>
<li>运算符重载（操作符重载）：可以为运算符增加一些新的功能</li>
<li>全局函数、成员函数都支持运算符重载<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Point &amp;p1,<span class="hljs-keyword">const</span> Point &amp;p2);<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y)&#123;&#125;<br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> Point &amp;p) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x-p.x,y-p.y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disPlay</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;---&quot;</span> &lt;&lt; y &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>Point <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Point &amp;p1,<span class="hljs-keyword">const</span> Point &amp;p2)&#123; <span class="hljs-comment">//用const参数，引用（可以接收cost和非cost，同时引用不会有拷贝构造）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(p1.x+p2.x,p1.y+p2.y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>    Point p11 = p1 + p2 + p3;<br>    Point p22 = p1 + p2 - p3;<br>    p11.<span class="hljs-built_in">disPlay</span>(); <span class="hljs-comment">// 3---6</span><br>    p22.<span class="hljs-built_in">disPlay</span>(); <span class="hljs-comment">// 1---2</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul>
<li><code>c++</code>中支持表达式赋值。正常的<code>+</code>运算符是无法赋值的。然而上面自定义的是可以的，因为<code>p1 + p2</code>返回的是非常量的<code>point</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>(a = b) = <span class="hljs-number">3</span>; <span class="hljs-comment">// a: 3 ,b: 2</span><br><span class="hljs-comment">// (a + b) = 4;不允许，会出现4赋值给了常量5</span><br>(p1 + p2) = <span class="hljs-built_in">Person</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li>
<li>解决方式，返回值加上<code>const</code>。但是<code>p1 + p2 + p3</code>正常，<code>p1 + p2 - p3</code>报错，因为<code>p1 + p2</code>返回常数变量，而<code>const</code>变量是无法访问非<code>const</code>成员函数的<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> Point <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Point &amp;p1,<span class="hljs-keyword">const</span> Point &amp;p2)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(p1.x+p2.x,p1.y+p2.y);<br>&#125;<br><br>Point p11 = p1 + p2 + p3;<br>Point p22 = p1 + p2 - p3;<span class="hljs-comment">//报错，等价于operator+(p1,p2).operator-(p3)</span><br></code></pre></td></tr></table></figure></li>
<li>最终<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//全局函数</span><br><span class="hljs-keyword">const</span> Point <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Point &amp;p1,<span class="hljs-keyword">const</span> Point &amp;p2)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(p1.x+p2.x,p1.y+p2.y);<br>&#125;<br><span class="hljs-comment">// const成员函数</span><br><span class="hljs-keyword">const</span> Point Point::<span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> Point &amp;p) <span class="hljs-keyword">const</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x-p.x,y-p.y);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="特殊重载情况"><a href="#特殊重载情况" class="headerlink" title="特殊重载情况"></a>特殊重载情况</h3><ul>
<li><p>重载<code>+=</code>符号，类似实现<code>(a += 2) = 3</code>。函数返回引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br>(a += <span class="hljs-number">2</span>) = <span class="hljs-number">3</span>;<br><br>Point&amp; Point::<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> Point &amp;p) &#123; <span class="hljs-comment">//注意返回引用</span><br>    x = x + p.x;<br>    y += p.y;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//这里会出现拷贝构造，和之前的不一致了，要返回引用</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>前置<code>++</code>,和后置<code>++</code>(固定在里面加个<code>int</code>，语法糖)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Point&amp; Point::<span class="hljs-keyword">operator</span>++() &#123;<br>    x += <span class="hljs-number">1</span>;<br>    y += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 后置++固定，在里面加个int</span><br><span class="hljs-keyword">const</span> Point Point::<span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) &#123;<br>    Point old = *<span class="hljs-keyword">this</span>;<br>    x += <span class="hljs-number">1</span>;<br>    y += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> old;<br>&#125;<br><br><span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>Point p3 = p1++ + <span class="hljs-built_in">Point</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br>(++p1) = <span class="hljs-built_in">Person</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>重载输出打印<code>&lt;&lt;</code>,和输入<code>&gt;&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="hljs-keyword">const</span> Point &amp;point) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; point.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; point.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><br>istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;cin,Point &amp;point) &#123;<br>    cin &gt;&gt; point.x;<br>    cin &gt;&gt; point.y;<br>    <span class="hljs-keyword">return</span> cin;<br>&#125;<br><br>cin &gt;&gt; p1 &gt;&gt; p2;<br>cout &lt;&lt; p1 &lt;&lt; p2;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><blockquote>
<p>仿函数：将一个对象当作一个函数一样来使用,本质是利用重载运算符</p>
</blockquote>
<ul>
<li>对比普通函数，它作为对象可以保存状态<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;;<br><br>Sum sum;<br><span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="运算符重载注意点"><a href="#运算符重载注意点" class="headerlink" title="运算符重载注意点"></a>运算符重载注意点</h2><ul>
<li><p>有些运算符不可以被重载，比如</p>
<ul>
<li>对象成员访问运算符：<code>.</code></li>
<li>域运算符：<code>::</code></li>
<li>三目运算符：<code>?:</code></li>
<li><code>sizeof</code></li>
</ul>
</li>
<li><p>有些运算符只能重载为成员函数，比如</p>
<ul>
<li> 赋值运算符：<code>=</code></li>
<li> 下标运算符：<code>[ ]</code></li>
<li> 函数运算符：<code>( )</code></li>
<li> 指针访问成员：<code>-&gt;</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>c++面向对像(2)</title>
    <url>/2024/01/01/C++%E5%AD%A6%E4%B9%A0/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E5%83%8F(2)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="对象型参数和返回值"><a href="#对象型参数和返回值" class="headerlink" title="对象型参数和返回值"></a>对象型参数和返回值</h2><blockquote>
<p>使用对象类型作为函数的参数或者返回值，可能会产生一些不必要的中间对象</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Car()&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-built_in">Car</span>(<span class="hljs-keyword">const</span> Car &amp;car) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Car(const Car &amp;car)&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h3><ul>
<li>作为参数传入时，等价于(<code>car = car</code>),会调用拷贝构造。建议采用引用传参的方式，避免多余的中间参数<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(Car car)</span> </span>&#123;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Car &amp;car)</span> </span>&#123;<br>    <br>&#125;<br><br>Car car; <span class="hljs-comment">// Car()0x7ff7bfeff188</span><br><span class="hljs-built_in">test1</span>(car); <span class="hljs-comment">// Car(const Car &amp;car)0x7ff7bfeff180</span><br>cout &lt;&lt; <span class="hljs-string">&quot;-----&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">test</span>(car);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Car <span class="hljs-title">Car::test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//返回时，会出现拷贝构造</span><br>&#125;<br><br>Car car2; <span class="hljs-comment">// 构造函数</span><br>car2 =  <span class="hljs-built_in">test2</span>(); <span class="hljs-comment">//拷贝构造</span><br><br>Car car = <span class="hljs-built_in">test2</span>(); <span class="hljs-comment">// windows X86编译这里会优化只有一次构造(test2中)和一次拷贝构造，实测在XCode下只有一次构造(test2中)</span><br></code></pre></td></tr></table></figure>

<h2 id="匿名对象（临时对象）"><a href="#匿名对象（临时对象）" class="headerlink" title="匿名对象（临时对象）"></a>匿名对象（临时对象）</h2><blockquote>
<p>匿名对象：没有变量名、没有被指针指向的对象，用完后马上调用析构</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;----&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">Car</span>(); <span class="hljs-comment">// 就是匿名对象</span><br>cout &lt;&lt; <span class="hljs-string">&quot;----&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 输出</span><br>----<br><span class="hljs-built_in">Car</span>()<span class="hljs-number">0x7ff7bfeff188</span><br>~<span class="hljs-built_in">Car</span>()<span class="hljs-number">0x7ff7bfeff188</span><br>---<br></code></pre></td></tr></table></figure>

<ul>
<li>匿名对象作为对象参数，和返回值时，编译器有优化，不会有拷贝构造。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(Car car)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;test1(Car car)&quot;</span> &lt;&lt; &amp;car &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Car &amp;car)</span> </span>&#123; <span class="hljs-comment">//必须常引用，否则，无法传参临时变量</span><br>    <br>&#125;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;----&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">test1</span>(<span class="hljs-built_in">Car</span>());<br>cout &lt;&lt; <span class="hljs-string">&quot;----&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 输出</span><br>----<br><span class="hljs-built_in">Car</span>()<span class="hljs-number">0x7ff7bfeff188</span><br><span class="hljs-built_in">test1</span>(Car car)<span class="hljs-number">0x7ff7bfeff188</span><br>~<span class="hljs-built_in">Car</span>()<span class="hljs-number">0x7ff7bfeff188</span><br>----<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="隐式构造函数"><a href="#隐式构造函数" class="headerlink" title="隐式构造函数"></a>隐式构造函数</h2><ul>
<li><p><code>C++</code>中存在隐式构造的现象：某些情况下，会隐式调用单参数(包括有默认参数的)的构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>(<span class="hljs-keyword">int</span> age):<span class="hljs-built_in">age</span>(age) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Car()&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-built_in">Car</span>(<span class="hljs-keyword">const</span> Car &amp;car) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Car(const Car &amp;car)&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Car</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Car()&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>Car car = <span class="hljs-number">1</span>; <span class="hljs-comment">//实际上会调用构造函数，会查找参数为int的构造函数（没有Car(int age)编译器会报错）</span><br><span class="hljs-comment">// 等价于 Car car(1);</span><br><br><span class="hljs-function">Car <span class="hljs-title">car1</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>car1 = <span class="hljs-number">1</span>; <span class="hljs-comment">//隐式构造,等价于car1 = Person(1)</span><br><br><span class="hljs-function">Car <span class="hljs-title">test</span><span class="hljs-params">(Car car = <span class="hljs-number">8</span>)</span> </span>&#123;<span class="hljs-comment">// 隐式构造函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>; <span class="hljs-comment">// 隐式构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>可以通过关键字<code>explicit</code>禁止掉隐式构造。再调用会报错。提高代码可读性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Car</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span>:age(age) &#123;</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Car()&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="编译器自动生成的构造函数"><a href="#编译器自动生成的构造函数" class="headerlink" title="编译器自动生成的构造函数"></a>编译器自动生成的构造函数</h2><ul>
<li><p><code>C++</code>的编译器在某些特定的情况下，会给类自动生成无参的构造函数，比如</p>
<ul>
<li> 成员变量在声明的同时进行了初始化</li>
<li> 有定义虚函数</li>
<li> 虚继承了其他类</li>
<li> 包含了对象类型的成员，且这个成员有构造函数（编译器生成或自定义）</li>
<li> 父类有构造函数（编译器生成或自定义）</li>
</ul>
</li>
<li><p>总的来说，对象创建后，需要做一些额外操作时（比如内存操作、函数调用），编译器一般都会为其自动生成无参的构造函数</p>
</li>
<li><p>下面这种，尽管调用了<code>run</code>方法，实际上还是没有生成构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> price;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;;<br>TV tv; <span class="hljs-comment">// 没有生成构造函数</span><br>tv.<span class="hljs-built_in">run</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul>
<li>友元包括<code>友元函数</code>和<code>友元类</code></li>
<li>如果将<code>函数A</code>（非成员函数）声明为<code>类C</code>的友元函数，那么<code>函数A</code>就能直接访问<code>类C对象</code>的所有成员</li>
<li>如果将<code>类A</code>声明为<code>类C</code>的友元类，那么<code>类A</code>的所有成员函数都能直接访问<code>类C</code>对象的所有成员</li>
<li>友元破坏了面向对象的封装性，但在某些频繁访问成员变量的地方可以提高性能</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>;</span> <span class="hljs-comment">// 友元类</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> A <span class="hljs-title">add</span><span class="hljs-params">(A&amp;,A&amp;)</span></span>; <span class="hljs-comment">// 友元函数</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y)&#123;&#125;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">add</span><span class="hljs-params">(A &amp;a1,A &amp;a2)</span> </span>&#123; <span class="hljs-comment">// 友元函数，直接访问私有变量，和私有构造函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(a1.x + a2.x,a1.y + a2.y);<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 友元类，直接访问私有变量，和私有构造函数</span><br>        <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br>        a.x = <span class="hljs-number">1</span>;<br>        a.y = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>如果将<code>类A</code>定义在<code>类C</code>的内部，那么<code>类A</code>就是一个内部类（嵌套类）</li>
<li>内部类的特点<ul>
<li>支持<code>public</code>、<code>protected</code>、<code>private</code>权限</li>
<li>成员函数可以直接访问其外部类对象的所有成员（反过来则不行）</li>
<li>成员函数可以直接不带类名、对象名访问其外部类的<code>static</code>成员</li>
<li>不会影响外部类的内存布局</li>
<li>可以在外部类内部声明，在外部类外面进行定义</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &#123;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span><br>&#125;;<br><span class="hljs-keyword">int</span> C::num = <span class="hljs-number">2</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span>:A &#123;<span class="hljs-comment">//定义和实现分离</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">void</span> C::A::<span class="hljs-built_in">test</span>() &#123;<br>    num = <span class="hljs-number">3</span>;<br>    C c;<br>    c.x = <span class="hljs-number">1</span>;<br>    c.y = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">int</span> C::A::age = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">C::test</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    A::age = <span class="hljs-number">2</span>;<span class="hljs-comment">// 成员共有，否则外部类无法访问</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><ul>
<li>在一个函数内部定义的类，称为局部类</li>
<li>局部类的特点<ul>
<li>作用域仅限于所在的函数内部</li>
<li>其所有的成员必须定义在类内部（声明和实现，都必须在同一个地方），不允许定义<code>static</code>成员变量</li>
<li>成员函数不能直接访问函数的局部变量（<code>static</code>变量除外）</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">2</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// age = 3;无法访问函数汇总的变量</span><br>            num += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>拷贝构造函数</title>
    <url>/2024/01/01/C++%E5%AD%A6%E4%B9%A0/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><p> 拷贝构造函数是构造函数的一种</p>
</li>
<li><p> 当利用已存在的对象创建一个新对象时（类似于拷贝），就会调用新对象的拷贝构造函数进行初始化</p>
</li>
<li><p> 拷贝构造函数的格式是固定的，接收一个<code>const</code>引用作为参数</p>
</li>
<li><p>默认情况下，不自定义拷贝函数，也会默认实现拷贝构造。并且会拷贝父类的属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> name = <span class="hljs-number">2</span>;<br>&#125;;<br>Student stu;<br><span class="hljs-function">Student <span class="hljs-title">stu1</span><span class="hljs-params">(stu)</span></span>; <span class="hljs-comment">// 拷贝</span><br></code></pre></td></tr></table></figure></li>
<li><p>自定义拷贝函数,与默认实现的效果一致</p>
<ul>
<li>子类会默认调用父类无参构造函数<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span> <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> name = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-keyword">int</span> name = <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 默认调用父类无参构造函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-keyword">const</span> Student &amp;stu):<span class="hljs-built_in">Person</span>(stu),<span class="hljs-built_in">name</span>(stu.name) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>拷贝构造函数调用时机</p>
<ul>
<li><code>stu2</code>、<code>stu3</code>都是通过拷贝构造函数初始化的，<code>stu</code>、<code>stu4</code>是通过非拷贝构造函数初始化</li>
<li><code>stu4 = stu3</code>是一个赋值操作（默认是浅复制），并不会调用拷贝构造函数<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Student <span class="hljs-title">stu</span><span class="hljs-params">(<span class="hljs-number">200</span>)</span></span>; <span class="hljs-comment">// 构造函数</span><br>cout &lt;&lt; stu.age &lt;&lt; endl; <span class="hljs-comment">// 1，会默认调用父类无参构造函数</span><br>Student stu2 = stu; <span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-function">Student <span class="hljs-title">stu3</span><span class="hljs-params">(stu2)</span></span>; <span class="hljs-comment">// 拷贝构造</span><br>Student stu4; <span class="hljs-comment">// 构造函数</span><br>stu4 = stu3; <span class="hljs-comment">// 不会调用拷贝构造函数，但是会将stu3的值给stu4</span><br>cout &lt;&lt; stu.name &lt;&lt; endl; <span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><ul>
<li><p>编译器默认提供的拷贝是<code>浅拷贝</code>（<code>shallow copy</code>）</p>
<ul>
<li>将一个对象中所有成员变量的值拷贝到另一个对象</li>
<li>如果某个成员变量是个<code>指针</code>，只会拷贝<code>指针</code>中存储的地址值，并不会拷贝<code>指针</code>指向的内存空间</li>
<li>可能会导致堆空间多次<code>free</code>的<strong>问题</strong></li>
</ul>
</li>
<li><p>如果需要实现深拷贝（<code>deep copy</code>），就需要自定义拷贝构造函数</p>
<ul>
<li>将指针类型的成员变量所指向的内存空间，拷贝到新的内存空间</li>
</ul>
</li>
<li><p>下面是浅拷贝，将栈中的对象，指向堆，当栈释放之后(栈中生成的字符串释放)，<code>Person.name</code>指针指向未知（野指针）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> *name = <span class="hljs-literal">NULL</span>;<br>&#125;;<br>Person *g_person = <span class="hljs-keyword">new</span> Person;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    const char * name = &quot;abc&quot;; // 栈空间</span><br>    <span class="hljs-keyword">char</span> name[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;; <span class="hljs-comment">//字符串义\0结尾</span><br>    g_person -&gt; name = name;<br>    cout &lt;&lt; g_person -&gt;name &lt;&lt; endl; <span class="hljs-comment">//abc</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>    cout &lt;&lt; g_person -&gt;name &lt;&lt; endl; <span class="hljs-comment">// 未知参数，原来栈空间的字符串已经释放</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>此外拷贝构造函数<code>Person p = p1</code>的方式，就算<code>p1</code>中<code>name</code>有值，当时当前拷贝构造给<code>p</code>时，也是浅拷贝，<code>p</code>和<code>p1</code>的<code>name</code>公用一分内存。当<code>delete name</code>时，可能会<code>free</code>释放<code>name</code>多次，导致出现异常，甚至崩溃。因此需要深拷贝，进行改造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(name == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-number">1</span>] &#123;&#125;;<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;name, name);<span class="hljs-comment">// 将name cpy到新建的内存中</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">char</span> *name;<br>    <br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = <span class="hljs-literal">NULL</span>):<span class="hljs-built_in">age</span>(age) &#123;<br>        <span class="hljs-built_in">copyName</span>(name);<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">const</span> Person &amp;person):<span class="hljs-built_in">age</span>(person.age) &#123;<br>        <span class="hljs-built_in">copyName</span>(person.name);<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        <span class="hljs-keyword">if</span> (name != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] name;<br>        &#125;<br>    &#125;<br>    <br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Person *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;222&quot;</span>);<br>    Person *p1 = p; <span class="hljs-comment">//拷贝构造，也是深拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS中的JavaScriptCore</title>
    <url>/2023/12/26/js%E7%9A%84%E5%AD%A6%E4%B9%A0/JavaScriptCore%20/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><blockquote>
<p>苹果官方对<code>JavaScriptCore</code>框架的<a href="https://developer.apple.com/documentation/javascriptcore">说明</a>。从结构上看，<code>JavaScriptCore</code>框架主要由 <code>JSVirtualMachine</code> 、<code>JSContext</code>、<code>JSValue</code> 类组成</p>
</blockquote>
<ul>
<li><code>JSVirturalMachine</code>的作用，是为<code>JavaScript</code>代码的运行提供一个虚拟机环境。在同一时间内，<code>JSVirtualMachine</code>只能执行一个线程。如果想要多个线程执行任务，你可以创建多个 <code>JSVirtualMachine</code>。每个 <code>JSVirtualMachine</code> 都有自己的 <code>GC</code>（<code>Garbage Collector</code>，垃圾回收器），以便进行内存管理，所以多个 <code>JSVirtualMachine</code> 之间的对象无法传递。</li>
<li><code>JSContext</code> 是 <code>JavaScript</code> 运行环境的上下文，负责原生和 <code>JavaScript</code> 的数据传递。</li>
<li><code>JSValue</code> 是 <code>JavaScript</code> 的值对象，用来记录 <code>JavaScript</code> 的原始值，并提供进行原生值对象转换的接口方法。</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="原生中调用JS"><a href="#原生中调用JS" class="headerlink" title="原生中调用JS"></a>原生中调用JS</h3><ul>
<li><p>调用<code>js</code>变量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> jsvm <span class="hljs-operator">=</span> <span class="hljs-type">JSVirtualMachine</span>()<br><span class="hljs-comment">// 从webview中获取</span><br><span class="hljs-comment">//     JSContext *context = [self.webview valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><br><span class="hljs-keyword">let</span> ctx <span class="hljs-operator">=</span> <span class="hljs-type">JSContext</span>(virtualMachine: jsvm)<br>ctx<span class="hljs-operator">?</span>.evaluateScript(<span class="hljs-string">&quot;var i = 4 + 8&quot;</span>)<br><span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> ctx<span class="hljs-operator">?</span>.objectForKeyedSubscript(<span class="hljs-string">&quot;i&quot;</span>).toNumber()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var i is&quot;</span>,number<span class="hljs-operator">!</span>) <span class="hljs-comment">// var i is 12</span><br></code></pre></td></tr></table></figure></li>
<li><p>调用<code>js</code>函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">ctx<span class="hljs-operator">?</span>.evaluateScript(<span class="hljs-string">&quot;function addition(x,y) &#123; return x + y&#125;&quot;</span>)<br><span class="hljs-keyword">let</span> addition <span class="hljs-operator">=</span> ctx<span class="hljs-operator">?</span>.objectForKeyedSubscript(<span class="hljs-string">&quot;addition&quot;</span>)<br><span class="hljs-keyword">let</span> returnValue <span class="hljs-operator">=</span> addition<span class="hljs-operator">?</span>.call(withArguments: [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>])<br> <span class="hljs-comment">// resultValue is 7</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;resultValue is&quot;</span>,returnValue<span class="hljs-operator">?</span>.toNumber() <span class="hljs-keyword">as!</span> <span class="hljs-type">NSNumber</span>)<br><br><span class="hljs-comment">// 也可以用全局对象去获取</span><br><span class="hljs-keyword">let</span> returnValue2 <span class="hljs-operator">=</span> ctx<span class="hljs-operator">?</span>.globalObject.invokeMethod(<span class="hljs-string">&quot;addition&quot;</span>, withArguments: [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-comment">//  resultValue is 9</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;resultValue2 is&quot;</span>,returnValue2<span class="hljs-operator">?</span>.toNumber() <span class="hljs-keyword">as!</span> <span class="hljs-type">NSNumber</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="JS中调用原生"><a href="#JS中调用原生" class="headerlink" title="JS中调用原生"></a>JS中调用原生</h3><ul>
<li><p><code>JSExport</code>的方式，并且<code>js</code>中改变的值，也会影响原生</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@objc</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">MyJavaScriptInterface</span>: <span class="hljs-title">JSExport</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span>()</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObject</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">MyJavaScriptInterface</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;John Doe&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, <span class="hljs-subst">\(name)</span>!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ctx <span class="hljs-operator">=</span> <span class="hljs-type">JSContext</span>()<br><span class="hljs-keyword">let</span> myobject <span class="hljs-operator">=</span> <span class="hljs-type">MyObject</span>()<br>ctx<span class="hljs-operator">?</span>.setObject(myobject, forKeyedSubscript: <span class="hljs-string">&quot;myObject&quot;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">NSString</span>)<br><span class="hljs-comment">// Hello, 12Alice!</span><br>ctx<span class="hljs-operator">?</span>.evaluateScript(<span class="hljs-string">&quot;myObject.name = <span class="hljs-subst">\&quot;</span>Alice<span class="hljs-subst">\&quot;</span>; myObject.sayHello();&quot;</span>)<br><span class="hljs-comment">// JSExport 12Alice</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;JSExport&quot;</span>,myobject.name)<br></code></pre></td></tr></table></figure></li>
<li><p>非<code>JSExport</code>的方式。这里必须用<code>@convention(block)</code>,用<code>block</code>块的方式，而非<code>swift</code>的<code>闭包</code></p>
<ul>
<li><code>convention</code> 特性总是与下面的参数之一一起出现。<ul>
<li><code>swift</code>参数用于表示一个<code>Swift</code>函数引用。这是<code>Swift</code>中函数值的标准调用约定。</li>
<li><code>block</code>参数用于表示一个<code>Objective-C</code>兼容的块引用。函数值会作为一个块对象的引用，块是一种<code>id</code>兼容的<code>Objective-C</code>对象，其中嵌入了调用函数。调用函数使用<code>C</code>的调用约定。</li>
<li><code>c</code>参数用于表示一个<code>C</code>函数引用。函数值没有上下文，不具备捕获功能，并且使用<code>C</code>的调用约定。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> ctx <span class="hljs-operator">=</span> <span class="hljs-type">JSContext</span>()<br><span class="hljs-keyword">let</span> subtractionBlock: <span class="hljs-keyword">@convention(block)</span> (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> &#123; x, y <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原生调用&quot;</span>,x,y)<br>    <span class="hljs-keyword">return</span> x <span class="hljs-operator">-</span> y<br>&#125;<br>ctx<span class="hljs-operator">?</span>.setObject(subtractionBlock, forKeyedSubscript: <span class="hljs-string">&quot;subtraction&quot;</span> <span class="hljs-keyword">as</span> (<span class="hljs-type">NSCopying</span> &amp; <span class="hljs-type">NSObjectProtocol</span>))<br><span class="hljs-comment">// 在同一个jsContext里用javaScript代码来调用原生subtraction</span><br><span class="hljs-comment">// 原生调用 4 8</span><br><span class="hljs-keyword">let</span> subvalue <span class="hljs-operator">=</span> ctx<span class="hljs-operator">?</span>.evaluateScript(<span class="hljs-string">&quot;subtraction(4,8);&quot;</span>)<br><span class="hljs-comment">// subValue is -4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subValue is&quot;</span>,subvalue<span class="hljs-operator">?</span>.toNumber() <span class="hljs-keyword">as!</span> <span class="hljs-type">NSNumber</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>c++面向对像(1)</title>
    <url>/2023/12/24/C++%E5%AD%A6%E4%B9%A0/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E5%83%8F(1)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><blockquote>
<p><code>c++</code>可以适用<code>struct</code>、<code>class</code>来定义一个类。<code>c</code>语言是没有<code>class</code>的。<code>class</code>是<code>c++</code>中的概念</p>
<ul>
<li>以前<code>c</code>中结构体是无法定义函数的，只能通过函数指针的方式。现在<code>c++</code>中结构体视为类，且能定义方法了</li>
</ul>
</blockquote>
<ul>
<li><code>struct</code>和<code>class</code>.(除了权限外，在<code>c++</code>中基本没区别)<ul>
<li><code>struct</code>的默认成员权限<code>public</code></li>
<li><code>class</code>的默认成员权限<code>private</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><br>Person person; <span class="hljs-comment">//创建，对象在栈空间</span><br>person.age = <span class="hljs-number">20</span>;<br>person.<span class="hljs-built_in">run</span>();<br><br>Person *p = &amp;person;<br>p-&gt;age = <span class="hljs-number">20</span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>案例,在汇编中<code>0xcc</code>起到断点的作用，为了防止栈空间中指针指向其他地方，会给栈空间填满<code>0xCC</code>的数据，因此，这里<code>height</code>上的数据，也是<code>0xcccccccc</code>四个字节<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Person person;<br>person.id = <span class="hljs-number">10</span>;<br>person.age = <span class="hljs-number">20</span>;<br>person.hegiht = <span class="hljs-number">30</span>;<br><br>Person *p = (Person *) &amp;person.age;<br>p-&gt;id = <span class="hljs-number">40</span>;<br>p -&gt;age = <span class="hljs-number">50</span><br><span class="hljs-comment">// 打印当前的 id = 10,age = 40,height = 50;</span><br>person.<span class="hljs-built_in">description</span>(); <br><span class="hljs-comment">// 打印指针p的 id = 40,age = 50,height = 0xcccccccc</span><br>p-&gt;<span class="hljs-built_in">description</span>();<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="存储的位置"><a href="#存储的位置" class="headerlink" title="存储的位置"></a>存储的位置</h2><blockquote>
<p><code>c++</code>中的对象的内存可以存放在</p>
<ul>
<li>全局区（数据段）：全局变量</li>
<li>栈空间：函数里面的局部变量（类中的对象，均在栈）</li>
<li>堆空间：动态申请内存</li>
</ul>
</blockquote>
<h1 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><ul>
<li><p><code>free</code>释放的是对应<code>malloc</code>生成的指针，是不管是生成的<code>char *</code>数组，还是单个的<code>int *</code>。放入指针，均能释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *n = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br>*n = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// char 1个字节的</span><br><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  *p = 10;</span><br><span class="hljs-comment">  *(p + 1) = 11;</span><br><span class="hljs-comment">  *(p + 2) = 12;</span><br><span class="hljs-comment">  *(p + 3) = 13;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 两者等价</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>p[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<br>p[<span class="hljs-number">2</span>] = <span class="hljs-number">12</span>;<br>p[<span class="hljs-number">3</span>] = <span class="hljs-number">13</span>;<br><span class="hljs-built_in">free</span>(n);<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure></li>
<li><p><code>malloc</code>生成的对象最开始是不会进行初始化的。</p>
<ul>
<li>推荐初始化方法，赋值，但下面只能对<code>int</code>4字节清零，初始化  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br>*p = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li>
<li><code>memset(p,num,size)</code>(大部分用于将数据结构清零)，从<code>p</code>开始对<code>size</code>内的每一个字节都设置成<code>num</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> size = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">10</span><br><span class="hljs-keyword">int</span> *p = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(size);<br><span class="hljs-comment">// 从p开始，将每一个字节都设置为0</span><br><span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,size);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><ul>
<li><p>申请和释放必须是1对1的关系，不然可能会存在内存泄漏</p>
<ul>
<li>注意<code>new</code>一定要和<code>delete</code>用，不能用<code>free</code></li>
<li>注意，如果是<code>new []</code>,要和<code>delete[]</code>一起用<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br>*p = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-comment">// 申请4个字节，类比(char *) malloc(4)</span><br><span class="hljs-keyword">char</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">4</span>];<br><br><br><span class="hljs-keyword">delete</span>[] p1;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p0 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>; <span class="hljs-comment">//不会初始化（不同平台可能会有差异，可能会初始化）</span><br><span class="hljs-keyword">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(); <span class="hljs-comment">// 初始化为0</span><br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 初始化为5</span><br><br><span class="hljs-keyword">int</span> *p3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//数组元素未被初始化</span><br><span class="hljs-keyword">int</span> *p4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>](); <span class="hljs-comment">// 3个数组元素都被初始化为0</span><br><span class="hljs-keyword">int</span> *p5 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]&#123;&#125;;<span class="hljs-comment">// 3个数组元素都被初始化为0</span><br><span class="hljs-keyword">int</span> *p6 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]&#123; <span class="hljs-number">5</span> &#125;; <span class="hljs-comment">// 数组首元素 初始化为5，其他为0</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><blockquote>
<p>构造函数（也叫构造器），在对象创建的时候自动调用，一般用于完成对象的初始化工作</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>函数名与类同名，无返回值（<code>void</code>都不能写），可以有参数，可以重载，可以有多个构造函数</p>
</li>
<li><p>一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象</p>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>通过<code>malloc</code>分配的对象不会调用构造函数</li>
</ul>
</li>
<li><p><strong>注意</strong>,全局区的<code>Person p2();</code>实际是函数声明，不会调用构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Person p1; <span class="hljs-comment">// 调用Person()</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 实际是函数声明</span><br>Person p2&#123;&#125;; <span class="hljs-comment">//调用默认Person()</span><br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 调用Person(Int)</span><br>Person *p4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(); <span class="hljs-comment">// 调用Person()</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="默认情况下"><a href="#默认情况下" class="headerlink" title="默认情况下"></a>默认情况下</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-comment">// 全局区初始化变量为0，（全局区默认初始化为0）</span><br>Person g_person;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 栈空间：没有初始化成员变量</span><br>    Person person;<br>    <br>    <span class="hljs-comment">//堆空间 没有初始化成员变量</span><br>    Person *po = <span class="hljs-keyword">new</span> Person;<br>    <span class="hljs-comment">// 堆空间 初始化成员变量为0</span><br>    Person *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>    <span class="hljs-comment">// 3个person对象，不会初始化</span><br>    Person *p2 = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 3个person对象，初始化为0</span><br>    Person *p3 = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">3</span>]();<br>    <span class="hljs-comment">// 3个person对象，初始化为0</span><br>    Person *p4 = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">3</span>]&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="有构造函数"><a href="#有构造函数" class="headerlink" title="有构造函数"></a>有构造函数</h3><blockquote>
<p>如果自定义了构造函数，除了全局区，其他内存空间的成员变量默认都不会被初始化，需要开发人员手动初始化</p>
</blockquote>
<h4 id="空的实现"><a href="#空的实现" class="headerlink" title="空的实现"></a>空的实现</h4><ul>
<li>初始化一个空的构造函数，用<code>new Person()</code>,不会帮忙初始化为<code>0</code>，全局区仍然有数据<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-built_in">Person</span>() &#123;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 全局区初始化变量为0，（全局区默认初始化为0）</span><br>Person g_person;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 栈空间：没有初始化成员变量</span><br>    Person person;<br>    <br>    <span class="hljs-comment">//堆空间 没有初始化成员变量</span><br>    Person *po = <span class="hljs-keyword">new</span> Person;<br>    <span class="hljs-comment">// 堆空间 没有初始化成员变量</span><br>    Person *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>    <span class="hljs-comment">// 堆空间 没有初始化成员变量</span><br>    Person *p1 = <span class="hljs-keyword">new</span> Person&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="初始化方法建议"><a href="#初始化方法建议" class="headerlink" title="初始化方法建议"></a>初始化方法建议</h3><ul>
<li>初始化清理<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Person</span>() &#123;<br>    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Person));<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><ul>
<li><p>特点</p>
<ul>
<li>一种便捷的初始化成员变量的方式</li>
<li>只能用在构造函数中</li>
<li>初始化顺序只跟成员变量的声明顺序有关,(下面<code>age</code>先声明，先赋值<code>age</code>，就算方法列表是<code>height(height),age(age)</code>，仍然先初始化<code>age</code>)<ul>
<li>类比<code>height(myheight()),age(myage())</code>,里面有方法，也是<code>myage()</code>先调用</li>
</ul>
</li>
</ul>
</li>
<li><p>下面两种写法等价，汇编也是一致的,方法列表中，可以放<code>表达式</code>，<code>函数</code>..。（<code>this-&gt;age = x</code>,<code>x</code>可以是什么,<code>age(x)</code>中的<code>x</code>也可以是）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> height):<span class="hljs-built_in">age</span>(age),<span class="hljs-built_in">height</span>(height) &#123;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Person(int age,int height)&#123;</span><br><span class="hljs-comment">            this-&gt;age = age;</span><br><span class="hljs-comment">            this-&gt;height = height;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>默认参数，方法列表赋值的顺序,下面，最终<code>age</code>为<code>10</code>,方法列表中的赋值，是放在函数内执行代码之前的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> height = <span class="hljs-number">0</span>):<span class="hljs-built_in">age</span>(age),<span class="hljs-built_in">height</span>(height) &#123;<br>    age = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>,如果函数声明和实现是分离的</p>
<ul>
<li><strong>初始化列表</strong>只能写在函数的<code>实现</code>中（本质在实现中插入代码，因此必须在<strong>实现</strong>中）</li>
<li><strong>默认参数</strong>只能写在函数的<code>声明</code>中.(声明和实现可能会在不同的地方，编译器，需要根据声明去判断是否有默认参数)<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> height = <span class="hljs-number">0</span>);<br>&#125;;<br><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> height):<span class="hljs-built_in">age</span>(age),<span class="hljs-built_in">height</span>(height) &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="构造函数调用构造函数"><a href="#构造函数调用构造函数" class="headerlink" title="构造函数调用构造函数"></a>构造函数调用构造函数</h3><blockquote>
<p>构造函数调用构造函数<strong>必须</strong>是在<code>初始化列表</code>中调用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        Person() &#123; //无法赋值成功</span><br><span class="hljs-comment">             Person(10,20); //这种等于创建了一个临时变量，里面赋值的this和当前的不同</span><br><span class="hljs-comment">         &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) &#123;<span class="hljs-comment">//初始化列表，会把当前的this赋值给Person(10,20)中的this，因此能赋值成功</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> height) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>        <span class="hljs-keyword">this</span>-&gt;heigh = height;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="父类的构造函数"><a href="#父类的构造函数" class="headerlink" title="父类的构造函数"></a>父类的构造函数</h3><ul>
<li>子类的构造函数默认会调用父类的<code>无参构造函数</code></li>
<li>如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数</li>
<li>如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>   <span class="hljs-keyword">int</span> age;<br>   <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">Person</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>   <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age):<span class="hljs-built_in">age</span>(age)&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>:</span> Person &#123;<br>    <span class="hljs-keyword">int</span> no;<br>    <span class="hljs-built_in">Student</span>(): <span class="hljs-built_in">Student</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> no): <span class="hljs-built_in">Person</span>(age),<span class="hljs-built_in">no</span>(no)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><blockquote>
<p>析构函数（也叫析构器），在对象销毁的时候自动调用，一般用于完成对象的清理工作</p>
</blockquote>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li> 函数名以<code>~</code>开头，与类同名，无返回值（<code>void</code>都不能写），无参，不可以重载，有且只有一个析构函数</li>
<li><strong>注意</strong><ul>
<li> 通过<code>malloc</code>分配的对象<code>free</code>的时候不会<strong>调用析构函数</strong></li>
</ul>
</li>
<li>构造函数、析构函数要声明为<code>public</code>，才能被外界正常使用</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Car</span> &#123;</span><br>    <span class="hljs-keyword">int</span> price;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    Car *car;<br>    Car car1; <span class="hljs-comment">//对象car和age在同一空间，不用单独delete释放</span><br>    <span class="hljs-built_in">Person</span>() &#123;<br>        car = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>     <span class="hljs-keyword">delete</span> car;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="构造、析构顺序"><a href="#构造、析构顺序" class="headerlink" title="构造、析构顺序"></a>构造、析构顺序</h1><ul>
<li><strong>注意</strong>，构造是<code>先</code>父类，<code>再</code>子类，而析构是<code>先</code>子类，<code>再</code>父类。析构的顺序和<code>Swift</code>以及<code>OC</code>不同</li>
</ul>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><blockquote>
<p>命名空间可以用来避免命名冲突。命名空间不影响内存布局</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> N &#123;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    &#125;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    N::age = <span class="hljs-number">2</span>;<br>    N::Person *p = <span class="hljs-keyword">new</span> N::<span class="hljs-built_in">Person</span>();<br>    N::<span class="hljs-built_in">test</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>快捷使用<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> N;<br>age = <span class="hljs-number">2</span>;<br>Person *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br><span class="hljs-built_in">test</span>();<br></code></pre></td></tr></table></figure></li>
<li>使用单个<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> N:age;<br>age = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="命名空间的嵌套"><a href="#命名空间的嵌套" class="headerlink" title="命名空间的嵌套"></a>命名空间的嵌套</h2><blockquote>
<p>有个默认的全局命名空间，我们创建的命名空间默认都嵌套在它里面</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> N &#123;<br>    <span class="hljs-keyword">namespace</span> M &#123;<br>        <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> age;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ::N::M::age = <span class="hljs-number">10</span>;<br>    N::M::age = <span class="hljs-number">10</span>;<br>    ::age = <span class="hljs-number">20</span>;<span class="hljs-comment">// 用默认命令空间访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote>
<p>继承，可以让子类拥有父类的所有成员（变量\函数）</p>
<ul>
<li><code>c++</code>中，<code>struct</code>和<code>class</code>都是对象，因此都可以继承</li>
<li><code>C++</code>中没有像<code>Java</code>、<code>Objective-C</code>的基类<ul>
<li><code>Java</code>：<code>java.lang.Object</code></li>
<li><code>Objective-C</code>：<code>NSObject</code></li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>:</span> Person &#123;<br>    <span class="hljs-keyword">int</span> no;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="成员访问权限"><a href="#成员访问权限" class="headerlink" title="成员访问权限"></a>成员访问权限</h2><ul>
<li><p>成员访问权限、继承方式有3种</p>
<ul>
<li><code>public</code>：公共的，任何地方都可以访问（<code>struct</code>默认）</li>
<li><code>protected</code>：子类内部、当前类内部可以访问.(外部不行)</li>
<li><code>private</code>：私有的，只有当前类内部可以访问（<code>class</code>默认）</li>
</ul>
</li>
<li><p>子类内部访问父类成员的权限，是以下2项中权限最小的那个</p>
<ul>
<li> 成员本身的访问权限</li>
<li> 上一级父类的继承方式</li>
</ul>
</li>
</ul>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><blockquote>
<p>一般继承方式用<code>Public</code>，这样可以把父类对象中的权限完美继承下来</p>
<ul>
<li>开发中用的最多的继承方式是<code>public</code>，这样能保留父类原来的成员访问权限</li>
</ul>
</blockquote>
<ul>
<li><p><strong>注意</strong>，访问权限不影响对象的内存布局，<code>Student2</code>无法访问<code>no</code>但是还是会继承下来。</p>
<ul>
<li>这样设计的目的是，尽管无法通过成员变量直接访问，但是可以通过<code>set</code>方法设置，实现封装的目的<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setNo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        no = num;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> no;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>:</span> <span class="hljs-keyword">private</span> Person &#123; <br><span class="hljs-comment">//以私有的方式继承Person，person中的age，在student中是privare的。等价下面的</span><br><span class="hljs-comment">// private：</span><br><span class="hljs-comment">//    int age;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student2</span>:</span> Public Person &#123; <br>    <span class="hljs-comment">// 访问权限不影响对象的内存布局,Student2会继承 no,但是无法访问no</span><br>    <span class="hljs-comment">// 但是可以通过setNo设置，getNo访问</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>注意</strong>，<code>class</code>默认是<code>private</code>继承（写的时候，注意加上<code>public</code>），<code>struct</code>默认是<code>public</code>继承</p>
</li>
<li><p><code>c++</code>中<code>class</code>和<code>struct</code>只有访问权限的区别，其他基本一致，甚至可以互相继承</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span> <br>    <span class="hljs-keyword">int</span> age<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>:</span> Public Person &#123;  <span class="hljs-comment">//这样写是没有问题的 </span><br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>多态是面向对象非常重要的一个特性<ul>
<li>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果</li>
<li>在运行时，可以识别出真正的对象类型，调用对应子类中的函数</li>
</ul>
</li>
<li>多态的要素<ul>
<li>子类重写父类的成员函数（override）</li>
<li>父类指针指向子类对象</li>
<li>利用父类指针调用重写的成员函数</li>
</ul>
</li>
</ul>
<h2 id="父类指针、子类指针"><a href="#父类指针、子类指针" class="headerlink" title="父类指针、子类指针"></a>父类指针、子类指针</h2><ul>
<li>父类指针可以指向子类对象，是安全的，开发中经常用到（继承方式必须是<code>public</code>,如果是<code>private</code>则无法指向，编译器会报错）</li>
<li>子类指针指向父类对象(强转实现)是不安全的,访问未知内存</li>
</ul>
<h2 id="默认情况下-1"><a href="#默认情况下-1" class="headerlink" title="默认情况下"></a>默认情况下</h2><blockquote>
<p> 默认情况下，C++编译器只会根据指针类型调用对应的函数，不存在多态</p>
</blockquote>
<ul>
<li>下面，编译器，再编译的时候，根据指针，直接写死了调用的方法，并不会去查找<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Dog::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">liu</span><span class="hljs-params">(Animal *p)</span> </span>&#123;<br>    p-&gt;<span class="hljs-built_in">speak</span>();<br>    <br>&#125;<br><br><span class="hljs-built_in">liu</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>()); <span class="hljs-comment">// 实际输出&quot;Animal::speak&quot;，而非重写后的&quot;Dog::speak&quot;</span><br>Cat *p = (Cat *)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br>p-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// 实际输出&quot;Cat::speak&quot;,只看指针类型</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote>
<p><code>C++</code>中的多态通过虚函数（<code>virtual function</code>）来实现</p>
</blockquote>
<ul>
<li>虚函数：被<code>virtual</code>修饰的成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Dog::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">liu</span><span class="hljs-params">(Animal *p)</span> </span>&#123;<br>    p-&gt;<span class="hljs-built_in">speak</span>();<br>    <br>&#125;<br><br><span class="hljs-built_in">liu</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>()); <span class="hljs-comment">// 实际输出&quot;Dog::speak&quot;</span><br> <br>p-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// 实际输出&quot;Dog::speak&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数（也就是说子类中可以省略<code>virtual</code>关键字）</p>
<ul>
<li>下面<code>Animal</code>没有虚表，从<code>Cat1</code>开始存在虚表，</li>
<li>编译器还是看指针类型的，如果指针类型中没有虚表，则不会去查<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat1</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat1::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat2</span>:</span> Cat1 &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat2::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>Cat1 *p = (Cat1 *)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat2</span>();<br>Animal *p1 = (Animal *)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat2</span>();<br>p-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// &quot;Cat2::speak&quot;</span><br>p1-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">//&quot;Animal::speak&quot; ,这里不会调用虚表</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调用父类的成员函数的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat2</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        Cat1::<span class="hljs-built_in">speak</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat2::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><blockquote>
<p>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表</p>
</blockquote>
<ul>
<li>有虚函数的类，会多占<code>4</code>个字节(不同环境下有所不同)，其前<code>4</code>个字节存放虚表地址。虚表地址开始中，每<code>4</code>个字节存放相映虚函数的地址。（在<code>xcode</code>中时<code>8</code>个，windo的<code>x86</code>是<code>4</code>字节）</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><blockquote>
<p>编译器还是根据指针类型的，如果指针类型中没有虚表，则不会去查。那么如果存在父类指针指向子类对象的情况，应该将析构函数声明为虚函数（虚析构函数）。否则，销毁时，只会调用父类的析构函数，而导致实际子类析构函数不会调用，释放不完整</p>
</blockquote>
<ul>
<li><code>delete</code>父类指针时，才会调用子类的析构函数，保证析构的完整性<ul>
<li>下面，如果<code>Animal</code>的析构函数不是虚函数，那么只会调用<code>~Animal</code>,而<code>Cat2</code>中的析构函数不会释放，会出现内存问题。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">&#123;<br>    Animal *p = (Animal *)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat2</span>();<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><blockquote>
<p>纯虚函数：没有函数体且初始化为<code>0</code>的虚函数，用来定义接口规范</p>
</blockquote>
<ul>
<li>抽象类（<code>Abstract Class</code>）<ul>
<li>含有纯虚函数的类，不可以实例化（不可以创建对象）</li>
<li>抽象类也可以包含非纯虚函数、成员变量</li>
<li>如果父类是抽象类，子类没有<code>完全重写``纯虚函数</code>，那么这个子类依然是抽象类</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span> <br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runAndSpeak</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;;<br><span class="hljs-comment">//  Animal p;抽象类无法实例</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br><span class="hljs-comment">// Dog;speak没有重写，也是抽象类</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog2</span>:</span> Dog &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br><span class="hljs-comment">// Dog2;不是抽象类</span><br>Dog2 dog;<br></code></pre></td></tr></table></figure>

<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><blockquote>
<p><code>C++</code>允许一个类可以有多个父类（不建议使用，会增加程序设计复杂度）</p>
</blockquote>
<ul>
<li><p>多继承子类的内存的分布，看谁先继承，下面中先是<code>student</code>中的变量，再<code>worker</code>,最后是<code>Undergraduate</code>内的(这也是相应构造函数的调用顺序)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span><br>    <span class="hljs-keyword">int</span> score;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span><br>    <span class="hljs-keyword">int</span> salary;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 看先继承谁，谁的内存放在前面</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Undergraduate</span>:</span> <span class="hljs-keyword">public</span> student,<span class="hljs-keyword">private</span> worker &#123;<br>    <span class="hljs-keyword">int</span> grade;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br>Undergraduate ug;<br>ug.score = <span class="hljs-number">100</span>;<br>ug.salary = <span class="hljs-number">100</span>;<br>ug.grade = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>,如果子类继承的多个父类都有<code>虚函数</code>，那么子类对象就会产生对应的<code>多张虚表</code>(其内存会增加，n * 虚表大小的内存)，进行分别管理。</p>
</li>
</ul>
<h3 id="同名函数"><a href="#同名函数" class="headerlink" title="同名函数"></a>同名函数</h3><ul>
<li>多继承，子类中有父类相同的同名函数，选择调用父类中的同名函数<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Undergraduate ug;<br>ug.worker::<span class="hljs-built_in">work</span>(); <span class="hljs-comment">//调用父类worker中的work函数</span><br>ug.student::<span class="hljs-built_in">study</span>();<span class="hljs-comment">// 调用父类student中的study函数</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="同名成员变量"><a href="#同名成员变量" class="headerlink" title="同名成员变量"></a>同名成员变量</h3><ul>
<li><code>c++</code>支持，继承的时候，父类成员变量和子类成员变量同名，也会将父类同名的成员变量加到子类中(会包含父类同名的内存，和子类的同名的一同存在)。并且均可以存值。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span><br>    <span class="hljs-keyword">int</span> score;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span><br>    <span class="hljs-keyword">int</span> salary;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Undergraduate</span>:</span> <span class="hljs-keyword">public</span> student,<span class="hljs-keyword">private</span> worker &#123;<br>    <span class="hljs-keyword">int</span> score; <span class="hljs-comment">//运行同名，在子类和父类同时存在</span><br>    <span class="hljs-keyword">int</span> salary;<br>&#125;;<br><br>Undergraduate ug;<br>ug.worker::salary = <span class="hljs-number">100</span>; <span class="hljs-comment">//给父类的salary赋值</span><br>ug.salary = <span class="hljs-number">10000</span>; <span class="hljs-comment">// 给当前类的salary赋值</span><br><span class="hljs-comment">// 100  10000</span><br>std::cout &lt;&lt; ug.worker::salary &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; ug.salary;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><blockquote>
<p>多继承会出现菱形继承，导致出现二义性</p>
</blockquote>
<ul>
<li><p>这里<code>Undergraduate</code>(占<code>16</code>字节)里面变量为(同时出现了<code>2</code>个<code>age</code>):</p>
<ul>
<li><code>age</code>,<code>score</code>(来自<code>student</code>)</li>
<li><code>age</code>,<code>salary</code>(来自<code>worker</code>)<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>:</span> Person &#123;<br>    <span class="hljs-keyword">int</span> score;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span>:</span> Person&#123;<br>    <span class="hljs-keyword">int</span> salary;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Undergraduate</span>:</span> student,worker &#123;<br>&#125;;<br><span class="hljs-comment">// ug.age = 10;报错，出现二义性</span><br><span class="hljs-comment">// 可以成功赋值</span><br>ug.student::age = <span class="hljs-number">20</span>;<br>ug.worker::age = <span class="hljs-number">30</span>;<br><span class="hljs-comment">// 20  30</span><br>std::cout &lt;&lt; ug.student::age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ug.worker::age &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>菱形继承带来的问题</p>
<ul>
<li>最底下子类从基类继承的成员变量冗余、重复</li>
<li>最底下子类无法访问基类的成员，有二义性</li>
</ul>
</li>
</ul>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><ul>
<li>虚继承可以解决菱形继承带来的问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>:</span> <span class="hljs-keyword">virtual</span> Person &#123;<br>    <span class="hljs-keyword">int</span> score = <span class="hljs-number">2</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span>:</span> <span class="hljs-keyword">virtual</span> Person&#123;<br>    <span class="hljs-keyword">int</span> salary = <span class="hljs-number">3</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Undergraduate</span>:</span> student,worker &#123;<br>&#125;;<br><br>ug.age = <span class="hljs-number">10</span>;<span class="hljs-comment">//可以成功赋值，且采用同名成员变量赋值，是同一个</span><br>ug.student::age = <span class="hljs-number">20</span>;<br>ug.worker::age = <span class="hljs-number">30</span>; <br><span class="hljs-comment">// 30   30</span><br>std::cout &lt;&lt; ug.student::age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ug.worker::age &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>Person</code>类被称为虚基类</p>
</li>
<li><p>虚继承之后，会出现虚表指针(切虚基类中的成员变量会放到最后)，虚表指针中存放:</p>
<ul>
<li>虚表指针与本类起始的偏移量（一般是<code>0</code>）</li>
<li>虚基类第一个成员变量与本类起始的偏移量</li>
</ul>
</li>
<li><p>虚继承后的结构类型,这里是<code>Student</code>和<code>worker</code>内存情况。<code>虚基类</code>的成员变量放在最后面<br><img src="1.png"></p>
</li>
<li><p>这是<code>Undergraduate</code>的内存情况。注意虚表指针，指的是本类的起始的偏移量(这里在<code>Undergraduate</code>,也是相对于本类<code>student</code>和<code>worker</code>的位置也是0).<br><img src="2.png"></p>
</li>
</ul>
<h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><ul>
<li>静态成员：被<code>static</code>修饰的成员变量\函数<ul>
<li> 可以通过对象（对象.静态成员）、对象指针（对象指针-&gt;静态成员）、类访问（类名::静态成员）</li>
</ul>
</li>
<li>静态成员变量<ul>
<li>存储在数据段（全局区，类似于全局变量），整个程序运行过程中只有一份内存</li>
<li>对比全局变量，它可以设定访问权限（<code>public</code>、<code>protected</code>、<code>private</code>），达到局部共享的目的</li>
<li>必须初始化，必须在类外面初始化，初始化时不能带<code>static</code>，如果类的声明和实现分离（在实现<code>.cpp</code>中初始化）</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>内部不能使用<code>this</code>指针（<code>this</code>指针只能用在非静态成员函数内部）</li>
<li>不能是虚函数（虚函数只能是非静态成员函数）</li>
<li>内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数</li>
<li>非静态成员函数内部可以访问静态成员变量\函数</li>
<li>构造函数、析构函数不能是静态</li>
<li>当声明和实现分离时，实现部分不能带<code>static</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> price;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">int</span> Car::price = <span class="hljs-number">1</span>; <span class="hljs-comment">//必须在类外面初始化,实现部分，不带static</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Car::run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//当声明和实现分离时（不一定要在外面声明），实现部分不能带`static`，</span><br>    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoMiCar</span>:</span> <span class="hljs-keyword">public</span> Car &#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiCar</span>:</span> <span class="hljs-keyword">public</span> Car &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> price;<br>&#125;;<br><span class="hljs-keyword">int</span> HuaWeiCar::price = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 指针，类名，对象都可以访问，访问的同一个变量</span><br>    Car *car = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>();<br>    car-&gt;price = <span class="hljs-number">1</span>;<br>    car-&gt;<span class="hljs-built_in">run</span>();<br>    <br>    Car::price = <span class="hljs-number">2</span>;<br>    Car::<span class="hljs-built_in">run</span>();<br>    <br>    Car c;<br>    c.price = <span class="hljs-number">3</span>;<br>    c.<span class="hljs-built_in">run</span>();<br>    <br>    <span class="hljs-comment">// XiaoMiCar继承Car，但是和Car中静态变量是同一份内存</span><br>    XiaoMiCar::<span class="hljs-built_in">run</span>();<br>    XiaoMiCar::price = <span class="hljs-number">20</span>;<br>    HuaWeiCar::price = <span class="hljs-number">40</span>; <span class="hljs-comment">// 重新声明的，和Car中不同</span><br>    cout &lt;&lt; Car::price &lt;&lt; endl; <span class="hljs-comment">// 输出20</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>单例模式一般用指针，而不是对象。方便可以回收。</li>
<li>注意和<code>swift</code>静态变量是线程安全不同，<code>c++</code>中是线程不安全的<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rocket</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Rocket</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Rocket</span>() &#123;&#125;<br>    <span class="hljs-keyword">static</span> Rocket *_rocket;<br>    <span class="hljs-built_in">Rocket</span>(<span class="hljs-keyword">const</span> Rocket &amp;rocket) &#123;&#125; <span class="hljs-comment">//禁止拷贝构造</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Rocket&amp;rocket)&#123;&#125; <span class="hljs-comment">//禁止赋值</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Rocket *<span class="hljs-built_in">sharedInstance</span>() &#123;<br>        <span class="hljs-keyword">if</span> (_rocket == <span class="hljs-literal">NULL</span>) &#123;<br>            _rocket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rocket</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> _rocket;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteRocket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_rocket != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> _rocket;<br>            _rocket = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 静态变量必须在外面初始化</span><br>Rocket * Rocket::_rocket = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="cost成员"><a href="#cost成员" class="headerlink" title="cost成员"></a>cost成员</h1><blockquote>
<p><code>const</code>成员：被<code>const</code>修饰的成员变量、非静态成员函数</p>
</blockquote>
<ul>
<li><p><code>const</code>成员变量</p>
<ul>
<li>必须初始化（类内部初始化），可以在声明的时候直接初始化赋值</li>
<li>非<code>static</code>的<code>const</code>成员变量还可以在初始化列表中初始化</li>
</ul>
</li>
<li><p><code>const</code>成员函数（非静态）</p>
<ul>
<li><code>const</code>关键字写在参数列表后面，函数的<code>声明</code>和<code>实现</code>都必须带<code>const</code></li>
<li>内部不能修改非<code>static</code>成员变量</li>
<li>内部只能调用<code>const</code>成员函数、<code>static</code>成员函数</li>
<li><code>非const</code>成员函数可以调用<code>const</code>成员函数</li>
<li> <code>const</code>成员函数和<code>非const</code>成员函数构成重载</li>
<li> <code>非const</code>对象（指针）优先调用<code>非const</code>成员函数</li>
<li> <code>const</code>对象（指针）只能调用<code>const</code>成员函数、<code>static</code>成员函数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> price = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Phone</span>():<span class="hljs-built_in">price</span>(<span class="hljs-number">30</span>)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;const run()&quot;</span> &lt;&lt; price &lt;&lt; endl;<br>        Phone::num += <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//test();无法调用</span><br><span class="hljs-comment">//        age += 1; 无法修改非static成员变量</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;run()&quot;</span> &lt;&lt; price &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> Phone::num = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Phone iphonex;<br>    <span class="hljs-comment">// 可以调用const函数和非const函数，优先调用非const函数</span><br>    iphonex.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">//run() 30</span><br>    <span class="hljs-keyword">const</span> Phone iphone;<br>    <span class="hljs-comment">// const只能调用const函数</span><br>    iphone.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// const run() 30</span><br>    <span class="hljs-comment">// 这种只是，指针常量，可以访问const函数和非const函数，优先调用非const函数</span><br>    Phone * <span class="hljs-keyword">const</span> iphone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Phone</span>();<br>    iphone-&gt;<span class="hljs-built_in">run</span>();<br>    <span class="hljs-comment">// const对象，只能调用const函数</span><br>    <span class="hljs-keyword">const</span> Phone * iphone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Phone</span>();<br>    iphone-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="引用类型成员"><a href="#引用类型成员" class="headerlink" title="引用类型成员"></a>引用类型成员</h1><ul>
<li>引用类型成员变量必须初始化（不考虑<code>static</code>情况）<ul>
<li>在声明的时候直接初始化</li>
<li>通过初始化列表初始化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> &amp;price = age;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>(<span class="hljs-keyword">int</span> &amp;price):<span class="hljs-built_in">price</span>(price)&#123; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>视频解封装格式</title>
    <url>/2023/11/28/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E8%A7%86%E9%A2%91%E8%A7%A3%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="视频解封装"><a href="#视频解封装" class="headerlink" title="视频解封装"></a>视频解封装</h1><blockquote>
<p>将视频文件解封装成相应的<code>PCM</code>以及<code>YUV</code>数据文件</p>
</blockquote>
<h2 id="导入的三方库"><a href="#导入的三方库" class="headerlink" title="导入的三方库"></a>导入的三方库</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/imgutils.h&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="头文件数据"><a href="#头文件数据" class="headerlink" title="头文件数据"></a>头文件数据</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;<br>    <span class="hljs-keyword">int</span> sampleRate;<br>    AVSampleFormat sampleFmt;<br>    <span class="hljs-keyword">int</span> chLayout;<br>&#125; AudioDecodeSpec;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;<br>    <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">int</span> height;<br>    AVPixelFormat pixFmt;<br>    <span class="hljs-keyword">int</span> fps;<br>&#125; VideoDecodeSpec;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demuxer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Demuxer</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demux</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *inFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">               AudioDecodeSpec &amp;aOut,</span></span><br><span class="hljs-params"><span class="hljs-function">               VideoDecodeSpec &amp;vOut)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 解封装上下文</span><br>    AVFormatContext *_fmtCtx = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 解码上下文</span><br>    AVCodecContext *_aDecodeCtx = <span class="hljs-literal">nullptr</span>,* _vDecodeCtx = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 流索引</span><br>    <span class="hljs-keyword">int</span> _aStreamIdex = <span class="hljs-number">-1</span>,_vStreamIdex = <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 文件</span><br>    QFile _aOutFile, _vOutFile;<br>    <span class="hljs-comment">// 函数参数</span><br>    AudioDecodeSpec *_aOut = <span class="hljs-literal">nullptr</span>;<br>    VideoDecodeSpec *_vOut = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 存放解码后的数据</span><br>    AVFrame *_frame = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 存放一帧解码图片的缓冲区</span><br>    <span class="hljs-keyword">uint8_t</span> *_imgBuf[<span class="hljs-number">4</span>] = &#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    <span class="hljs-keyword">int</span> _imgLinesizes[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">int</span> _imgSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 每个音频样本帧（包含所有声道）的大小</span><br>    <span class="hljs-keyword">int</span> _sampleFrameSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 每一个音频样本的大小（单声道）</span><br>    <span class="hljs-keyword">int</span> _sampleSize = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initVideoInfo</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initAudioInfo</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initDecoder</span><span class="hljs-params">(AVCodecContext **decodeCtx,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">int</span> *streamIdx,</span></span><br><span class="hljs-params"><span class="hljs-function">                    AVMediaType type)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(AVCodecContext *decodeCtx,</span></span><br><span class="hljs-params"><span class="hljs-function">               AVPacket *pkt,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">void</span> (Demuxer::*func)())</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeVideoFrame</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeAudioFrame</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR_BUF \</span><br><span class="hljs-meta">char errbuf[1024]; \</span><br><span class="hljs-meta">    av_strerror(ret, errbuf, sizeof (errbuf));</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> END(func) \</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">if</span> (ret &lt; 0) &#123; \</span><br><span class="hljs-meta">        ERROR_BUF; \</span><br><span class="hljs-meta">        qDebug() &lt;&lt; #func &lt;&lt; <span class="hljs-meta-string">&quot;error&quot;</span> &lt;&lt; errbuf; \</span><br><span class="hljs-meta">        goto end; \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RET(func) \</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">if</span> (ret &lt; 0) &#123; \</span><br><span class="hljs-meta">        ERROR_BUF; \</span><br><span class="hljs-meta">        qDebug() &lt;&lt; #func &lt;&lt; <span class="hljs-meta-string">&quot;error&quot;</span> &lt;&lt; errbuf; \</span><br><span class="hljs-meta">        return ret; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ol>
<li>创建解封装上下文（打开输入文件，读取文件头）;<code>avformat_open_input</code></li>
<li>检索流信息;<code>avformat_find_stream_info</code></li>
<li>导出流信息到控制台（非必要）; <code>av_dump_format</code></li>
<li>初始化音频信息<ol>
<li>初始化解码器<ol>
<li>根据<code>AVMEDIA_TYPE_AUDIO</code>，在解封装上下文中找到音频流的索引;<code>av_find_best_stream</code></li>
<li>根据流中的解码参数，为音频流找到合适的解码器;<code>avcodec_find_decoder</code></li>
<li>创建解码上下文;<code>avcodec_alloc_context3</code></li>
<li> 从流中拷贝参数到解码上下文中;<code>avcodec_parameters_to_context</code></li>
<li>打开解码器;<code>avcodec_open2</code></li>
</ol>
</li>
<li>打开音频文件</li>
<li>保存音频信息<ul>
<li>采样率</li>
<li>采样格式</li>
<li>声道布局</li>
</ul>
</li>
</ol>
</li>
<li>初始化视频信息<ol>
<li>初始化解码器<ol>
<li>根据<code>AVMEDIA_TYPE_VIDEO</code>，在解封装上下文中找到视频流的索引;<code>av_find_best_stream</code></li>
<li>根据流中的解码参数，为视频频流找到合适的解码器;<code>avcodec_find_decoder</code></li>
<li>创建解码上下文;<code>avcodec_alloc_context3</code></li>
<li> 从流中拷贝参数到解码上下文中;<code>avcodec_parameters_to_context</code></li>
<li>打开解码器;<code>avcodec_open2</code></li>
</ol>
</li>
<li>打开视频文件</li>
<li>保存视频频信息<ul>
<li>宽度、高度</li>
<li>像素格式</li>
<li>帧率</li>
</ul>
</li>
</ol>
</li>
<li>初始化<code>frame</code>、<code>pkt</code></li>
<li>从输入文件中读取数据;<code>av_read_frame</code></li>
<li>解码,<code>avcodec_send_packet</code>、<code>avcodec_receive_frame</code></li>
<li>将解码后的数据写入文件中</li>
</ol>
<h3 id="创建解封装上下文"><a href="#创建解封装上下文" class="headerlink" title="创建解封装上下文"></a>创建解封装上下文</h3><ul>
<li>创建解封装上下文（打开输入文件，读取文件头）;<code>avformat_open_input</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Demuxer::demux</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *inFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                     AudioDecodeSpec &amp;aOut,</span></span><br><span class="hljs-params"><span class="hljs-function">                     VideoDecodeSpec &amp;vOut)</span> </span>&#123;<br>    <span class="hljs-comment">// 保留参数</span><br>    _aOut = &amp;aOut;<br>    _vOut = &amp;vOut;<br>    <span class="hljs-comment">// 存放解码前的数据</span><br>    AVPacket *pkt = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 返回结果</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 创建解封装上下文，打开文件</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *  int avformat_open_input(AVFormatContext **ps, const char *url,</span><br><span class="hljs-comment">                        const AVInputFormat *fmt, AVDictionary **options);</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// url是打开的输入流，此前录制音频/视频的时候，是device序号，例如0，这里传入要解封的音视频文件</span><br>    <span class="hljs-comment">// fmt是输入格式，此前不为null，传入的是视频格式，例如avfoundation</span><br>    <span class="hljs-comment">// options,传入一些额外的参数，例如视频录制时传入的 av_dict_set(&amp;options,&quot;pixel_format&quot;,&quot;yuyv422&quot;,0);</span><br>    ret = <span class="hljs-built_in">avformat_open_input</span>(&amp;_fmtCtx,inFilename,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">END</span>(avformat_open_input)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="检索流信息"><a href="#检索流信息" class="headerlink" title="检索流信息"></a>检索流信息</h3><ul>
<li>检索流信息;<code>avformat_find_stream_info</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 从媒体文件中检索流信息</span><br>ret = <span class="hljs-built_in">avformat_find_stream_info</span>(_fmtCtx,<span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">END</span>(avformat_open_input)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="导出流信息到控制台"><a href="#导出流信息到控制台" class="headerlink" title="导出流信息到控制台"></a>导出流信息到控制台</h3><ul>
<li>导出流信息到控制台（非必要）; <code>av_dump_format</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打印流信息到控制器</span><br>    <span class="hljs-built_in">av_dump_format</span>(_fmtCtx,<span class="hljs-number">0</span>,inFilename,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">fflush</span>(stderr);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="初始化音-视频信息"><a href="#初始化音-视频信息" class="headerlink" title="初始化音/视频信息"></a>初始化音/视频信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化音频信息</span><br>ret = <span class="hljs-built_in">initAudioInfo</span>();<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br><br><span class="hljs-comment">// 初始化视频信息,拿到解码上下文，和流索引</span><br>ret = <span class="hljs-built_in">initVideoInfo</span>();<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始化音频信息"><a href="#初始化音频信息" class="headerlink" title="初始化音频信息"></a>初始化音频信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Demuxer::initAudioInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化解码器</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">initDecoder</span>(&amp;_aDecodeCtx,&amp;_aStreamIdex,AVMEDIA_TYPE_AUDIO);<br>    <span class="hljs-built_in">RET</span>(initDecoder);<br>    <span class="hljs-comment">// 打开文件</span><br>    _aOutFile.<span class="hljs-built_in">setFileName</span>(_aOut-&gt;filename);<br>    <span class="hljs-keyword">if</span> (!_aOutFile.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; _aOut-&gt;filename;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 保存音频参数</span><br>    _aOut-&gt;sampleRate = _aDecodeCtx-&gt;sample_rate;<br>    _aOut-&gt;sampleFmt = _aDecodeCtx-&gt;sample_fmt;<br>    _aOut-&gt;chLayout = _aDecodeCtx-&gt;ch_layout.nb_channels;<br><br>    <span class="hljs-comment">// 音频样本帧的大小</span><br>    _sampleSize = <span class="hljs-built_in">av_get_bytes_per_sample</span>(_aOut-&gt;sampleFmt);<br>    _sampleFrameSize = _sampleSize * _aDecodeCtx-&gt;ch_layout.nb_channels;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始化视频信息"><a href="#初始化视频信息" class="headerlink" title="初始化视频信息"></a>初始化视频信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化视频信息</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Demuxer::initVideoInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化解码器</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">initDecoder</span>(&amp;_vDecodeCtx,&amp;_vStreamIdex,AVMEDIA_TYPE_VIDEO);<br>    <span class="hljs-built_in">RET</span>(initDecoder);<br><br>    <span class="hljs-comment">// 打开文件</span><br>    _vOutFile.<span class="hljs-built_in">setFileName</span>(_vOut-&gt;filename);<br>    <span class="hljs-keyword">if</span> (!_vOutFile.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; _vOut-&gt;filename;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 保存视频参数</span><br>    _vOut-&gt;width = _vDecodeCtx-&gt;width;<br>    _vOut-&gt;height = _vDecodeCtx-&gt;height;<br>    _vOut-&gt;pixFmt = _vDecodeCtx-&gt;pix_fmt;<br>    <span class="hljs-comment">// frametate time_base无法获取帧率,</span><br>    <span class="hljs-comment">// 帧率，根据解封装上下文和流推测出帧率</span><br>    AVRational framerate = <span class="hljs-built_in">av_guess_frame_rate</span>(<br>        _fmtCtx,<br>        _fmtCtx-&gt;streams[_vStreamIdex],<br>        <span class="hljs-literal">nullptr</span>);<br>    _vOut-&gt;fps = framerate.num / framerate.den;<br>    <span class="hljs-comment">// // 创建用于存放一帧解码图片的缓冲区</span><br>    ret = <span class="hljs-built_in">av_image_alloc</span>(_imgBuf,_imgLinesizes,<br>                         _vDecodeCtx-&gt;width,_vDecodeCtx-&gt;height,<br>                         _vDecodeCtx-&gt;pix_fmt,<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">RET</span>(av_image_alloc);<br>    _imgSize = ret;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始化解码器"><a href="#初始化解码器" class="headerlink" title="初始化解码器"></a>初始化解码器</h4><blockquote>
<p>音/视频获取解码器的方法相同，可以归纳成一个方法调用</p>
</blockquote>
<h5 id="寻找最合适的流信息"><a href="#寻找最合适的流信息" class="headerlink" title="寻找最合适的流信息"></a>寻找最合适的流信息</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Demuxer::initDecoder</span><span class="hljs-params">(AVCodecContext **decodeCtx,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">int</span> *streamIdx,</span></span><br><span class="hljs-params"><span class="hljs-function">                         AVMediaType type)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据type寻找最合适的流信息，</span><br>    <span class="hljs-comment">// 返回是流索引</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * wanted_stream_nb: 用户请求的流，-1表示自动选择</span><br><span class="hljs-comment">     * related_stream： 尝试发现关联的流，-1表示没有关联的</span><br><span class="hljs-comment">     * decoder_ret: 为选择的流返回解码器，为null不返回</span><br><span class="hljs-comment">     * int av_find_best_stream(AVFormatContext *ic,</span><br><span class="hljs-comment">                        enum AVMediaType type,</span><br><span class="hljs-comment">                        int wanted_stream_nb,</span><br><span class="hljs-comment">                        int related_stream,</span><br><span class="hljs-comment">                        const AVCodec **decoder_ret,</span><br><span class="hljs-comment">                        int flags);</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">av_find_best_stream</span>(_fmtCtx,type,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">RET</span>(av_find_best_stream);<br></code></pre></td></tr></table></figure>

<h5 id="检验流信息"><a href="#检验流信息" class="headerlink" title="检验流信息"></a>检验流信息</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 检验流</span><br>    *streamIdx = ret;<br>    AVStream *stream = _fmtCtx-&gt;streams[ret];<br>    <span class="hljs-keyword">if</span>(!stream) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;stream is empty&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="检验流信息-1"><a href="#检验流信息-1" class="headerlink" title="检验流信息"></a>检验流信息</h5><blockquote>
<p>根据流中的解码参数，为当前流找到合适的解码器</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 为当前流找到合适的解码器</span><br>    <span class="hljs-keyword">const</span> AVCodec *decoder = <span class="hljs-built_in">avcodec_find_decoder</span>(stream-&gt;codecpar-&gt;codec_id);<br>    <span class="hljs-keyword">if</span> (!decoder) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;decoder not found&quot;</span> &lt;&lt; stream-&gt;codecpar-&gt;codec_id;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="初始化解码上下文"><a href="#初始化解码上下文" class="headerlink" title="初始化解码上下文"></a>初始化解码上下文</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化解码上下文</span><br>    *decodeCtx = <span class="hljs-built_in">avcodec_alloc_context3</span>(decoder);<br>    <span class="hljs-keyword">if</span> (!decodeCtx) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_alloc_context3 error&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="设置解码参数"><a href="#设置解码参数" class="headerlink" title="设置解码参数"></a>设置解码参数</h5><blockquote>
<p>从流中拷贝参数到解码上下文</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//从流中拷贝参数到解码上下文中</span><br>    ret = <span class="hljs-built_in">avcodec_parameters_to_context</span>(*decodeCtx,stream-&gt;codecpar);<br>    <span class="hljs-built_in">RET</span>(avcodec_parameters_to_context);<br></code></pre></td></tr></table></figure>

<h5 id="打开解码器"><a href="#打开解码器" class="headerlink" title="打开解码器"></a>打开解码器</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开解码器</span><br>    ret = <span class="hljs-built_in">avcodec_open2</span>(*decodeCtx, decoder, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">RET</span>(avcodec_open2);<br></code></pre></td></tr></table></figure>

<h3 id="初始化frame、pkt"><a href="#初始化frame、pkt" class="headerlink" title="初始化frame、pkt"></a>初始化<code>frame</code>、<code>pkt</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化frame</span><br>_frame = <span class="hljs-built_in">av_frame_alloc</span>();<br><span class="hljs-keyword">if</span> (!_frame) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br><br><span class="hljs-comment">// 初始化pkt</span><br>pkt = <span class="hljs-built_in">av_packet_alloc</span>();<br>pkt-&gt;data = <span class="hljs-literal">nullptr</span>;<br>pkt-&gt;size = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><blockquote>
<p>音/视频解码方式基本一致，除了其数据写入的方式不同，这里用传入不同写入函数的地址的方式</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 从输入文件中读取数据，和此前解码不同，不用解析器，直接从解封装上下文中获取</span><br>    <span class="hljs-comment">// 返回解封装文件中，返回下一帧的流数据，类似之前视频/音频采集的方式</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">av_read_frame</span>(_fmtCtx,pkt) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (pkt-&gt;stream_index == _aStreamIdex) &#123;<br>            <span class="hljs-comment">// 读取到的是音频数据</span><br>            ret = <span class="hljs-built_in">decode</span>(_aDecodeCtx,pkt,&amp;Demuxer::writeAudioFrame);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pkt-&gt;stream_index == _vStreamIdex) &#123;<br>            <span class="hljs-comment">// // 读取到的是视频数据</span><br>             ret = <span class="hljs-built_in">decode</span>(_vDecodeCtx,pkt,&amp;Demuxer::writeVideoFrame);<br>        &#125;<br><br>        <span class="hljs-comment">// 释放pkt内部指针指向的一些额外内存</span><br>        <span class="hljs-built_in">av_packet_unref</span>(pkt);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 刷新缓存区</span><br>    <span class="hljs-built_in">decode</span>(_aDecodeCtx, <span class="hljs-literal">nullptr</span>, &amp;Demuxer::writeAudioFrame);<br>    <span class="hljs-built_in">decode</span>(_vDecodeCtx, <span class="hljs-literal">nullptr</span>, &amp;Demuxer::writeVideoFrame);<br></code></pre></td></tr></table></figure>

<h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 解码方法。音频和视频解码方法一致，但写入方法不同，用传函数地址的方式</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Demuxer::decode</span><span class="hljs-params">(AVCodecContext *decodeCtx,</span></span><br><span class="hljs-params"><span class="hljs-function">                    AVPacket *pkt,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">void</span> (Demuxer::*func)())</span> </span>&#123;<br>    <span class="hljs-comment">// 发送压缩的数据到解码器</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avcodec_send_packet</span>(decodeCtx,pkt);<br>    <span class="hljs-built_in">RET</span>(avcodec_send_packet);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 获取解码后的数据</span><br>        ret = <span class="hljs-built_in">avcodec_receive_frame</span>(decodeCtx,_frame);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">RET</span>(avcodec_receive_frame);<br><br>        <span class="hljs-comment">// 执行写入文件的代码</span><br>        (<span class="hljs-keyword">this</span>-&gt;*func)();<br>         <span class="hljs-comment">//        // 将frame的数据写入文件</span><br>         <span class="hljs-comment">//        if (decodeCtx-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO) &#123;</span><br>         <span class="hljs-comment">//            writeVideoFrame();</span><br>         <span class="hljs-comment">//        &#125; else &#123;</span><br>         <span class="hljs-comment">//            writeAudioFrame();</span><br>         <span class="hljs-comment">//        &#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="音频写入"><a href="#音频写入" class="headerlink" title="音频写入"></a>音频写入</h4><ul>
<li><strong>注意</strong>，<code>ffmpeg</code>自带的<code>aac</code>解码器，解码的音频文件是<code>fltp</code>格式，该格式具备<code>planer</code>,然后，带<code>planer</code>的音频文件是无法播放的，需要将其转换使得<code>LR</code>可以挨着，这样才能播放。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Demuxer::writeAudioFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// libfdk_aac解码器，解码出来的PCM格式：s16</span><br>    <span class="hljs-comment">// aac解码器，解码出来的PCM格式：ftlp,默认是aac解码器</span><br>    <span class="hljs-comment">// plannar 类似 LLLL RRRR DDDD FFFF数据分布</span><br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">av_sample_fmt_is_planar</span>(_aOut-&gt;sampleFmt)) &#123;<br>        <span class="hljs-comment">// 外层循环：每一个声道的样本数</span><br>        <span class="hljs-comment">// si = sample index</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> si = <span class="hljs-number">0</span>; si &lt; _frame-&gt;nb_samples;si++) &#123;<br>            <span class="hljs-comment">// 内层循环；有多少个声道</span><br>            <span class="hljs-comment">// ci = channel index</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>;ci &lt; _aDecodeCtx-&gt;ch_layout.nb_channels;ci++) &#123;<br>                <span class="hljs-comment">// 每个声道样本帧的大小</span><br>                <span class="hljs-keyword">char</span> *begin = (<span class="hljs-keyword">char</span> *) (_frame-&gt;data[ci] + si * _sampleSize);<br>                <span class="hljs-comment">// 写入一个样本帧的大小</span><br>                _aOutFile.<span class="hljs-built_in">write</span>(begin, _sampleSize);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 非planar</span><br>        <span class="hljs-comment">// 一般情况下 _frame-&gt;nb_samples * _sampleFrameSize == _frame-&gt;linesize[0]。</span><br>        <span class="hljs-comment">// 但是当在文件末尾时，则会出现_frame-&gt;linesize[0]大于实际采样大小的情况</span><br>        _aOutFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) _frame-&gt;data[<span class="hljs-number">0</span>],<br>                        _frame-&gt;nb_samples * _sampleFrameSize);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="视频写入"><a href="#视频写入" class="headerlink" title="视频写入"></a>视频写入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Demuxer::writeVideoFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 拷贝frame的数据到_imgBuff缓冲区</span><br>    <span class="hljs-built_in">av_image_copy</span>(_imgBuf,_imgLinesizes,(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> **)_frame-&gt;data,_frame-&gt;linesize,_vOut-&gt;pixFmt,_vOut-&gt;width,_vOut-&gt;height);<br>    <span class="hljs-comment">// 将缓冲区的数据写入文件</span><br>    _vOutFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) _imgBuf[<span class="hljs-number">0</span>], _imgSize);<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs c+">end:<br>    _aOutFile.close();<br>    _vOutFile.close();<br>    avcodec_free_context(&amp;_aDecodeCtx);<br>    avcodec_free_context(&amp;_vDecodeCtx);<br>    avformat_close_input(&amp;_fmtCtx);<br>    av_frame_free(&amp;_frame);<br>    av_packet_free(&amp;pkt);<br>    av_freep(&amp;_imgBuf[0]);<br></code></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ol>
<li>编码方式解码的两个文件大小和<code>ffmpeg</code>命令行解码去对比 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ffmpeg -i input.mp4 -f s32le input2.pcm input2.yuv<br></code></pre></td></tr></table></figure></li>
<li>播放看是否正常,<code>f16le</code>解码后实际为<code>f32le</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 视频播放</span><br>ffplay -video_size <span class="hljs-number">848</span>x478 -pixel_format yuv420p -framerate <span class="hljs-number">25</span> -i input.yuv<br><span class="hljs-comment">// 音频播放</span><br>ffplay -ar <span class="hljs-number">44100</span> -f f32le -ac <span class="hljs-number">1</span> input.pcm<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>h264解码实战</title>
    <url>/2023/11/26/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/h264%E8%A7%A3%E7%A0%81%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><blockquote>
<p><code>h264</code>的解码方式，实际上和<code>aac</code>的解码方式基本一致。</p>
</blockquote>
<h2 id="引入的库"><a href="#引入的库" class="headerlink" title="引入的库"></a>引入的库</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/imgutils.h&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 错误处理</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR_BUF(ret) \</span><br><span class="hljs-meta">char errbuf[1024]; \</span><br><span class="hljs-meta">    av_strerror(ret, errbuf, sizeof (errbuf));</span><br></code></pre></td></tr></table></figure>
<h2 id="输入的头文件"><a href="#输入的头文件" class="headerlink" title="输入的头文件"></a>输入的头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 解码后的YUV参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;<br>    <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">int</span> height;<br>    AVPixelFormat pixelFmt;<br>    <span class="hljs-keyword">int</span> fpx;<br>&#125; VideoDecodeSpec;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H264Decoder</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">H264Decoder</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">h264decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * inFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                          VideoDecodeSpec &amp;out)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">VideoDecodeSpec out;<br>out.filename = <span class="hljs-string">&quot;/Users/chenjingpo/Desktop/input888.yuv&quot;</span>;<br>H264Decoder::<span class="hljs-built_in">h264decode</span>(<span class="hljs-string">&quot;/Users/chenjingpo/Desktop/output1.h264&quot;</span>,out);<br><span class="hljs-built_in">qDebug</span>() &lt;&lt; out.fpx &lt;&lt; out.width &lt;&lt; out.height &lt;&lt; out.pixelFmt;<br></code></pre></td></tr></table></figure>
<h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">// 返回结果</span><br><span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 每次从输入文件中读取的长度</span><br><span class="hljs-keyword">int</span> inLen = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 用来存放读取的文件数据</span><br><span class="hljs-comment">// 加上AV_INPUT_BUFFER_PADDING_SIZE是为了防止某些优化过的reader一次性读取过多导致越界。</span><br><span class="hljs-comment">// 例如（读取到IN_DATA_SIZE - 1时，再次读取10个数据，则会越界）</span><br><span class="hljs-keyword">char</span> inDataArray[IN_DATA_SIZE + AV_INPUT_BUFFER_MIN_SIZE];<br><span class="hljs-comment">// 输入数据指针，现在指向的是数组第一位</span><br><span class="hljs-keyword">char</span> *inData = inDataArray;<br><br><span class="hljs-comment">// 文件</span><br><span class="hljs-function">QFile <span class="hljs-title">inFile</span><span class="hljs-params">(inFilename)</span></span>;<br><span class="hljs-function">QFile <span class="hljs-title">outFile</span><span class="hljs-params">(out.filename)</span></span>;<br><br><br><span class="hljs-comment">// 解码器</span><br><span class="hljs-keyword">const</span> AVCodec *codec = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 上下文</span><br>AVCodecContext *ctx = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 解析器上下文</span><br>AVCodecParserContext *parserCtx = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 存放解码前的数据</span><br>AVPacket *pkt = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 存放解码后的数据</span><br>AVFrame *frame = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 是否已经读取到了输入文件的尾部</span><br><span class="hljs-keyword">int</span> inEnd = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h2 id="初始化编码器"><a href="#初始化编码器" class="headerlink" title="初始化编码器"></a>初始化编码器</h2><blockquote>
<p>这里直接用<code>h264</code>编码即可，不用<code>libx264</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取h264解码器</span><br>codec = <span class="hljs-built_in">avcodec_find_decoder</span>(AV_CODEC_ID_H264);<br><span class="hljs-keyword">if</span>(!codec) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;decoder libfdk_aac not found&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建上下文"><a href="#创建上下文" class="headerlink" title="创建上下文"></a>创建上下文</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化解析器上下文</span><br>parserCtx = <span class="hljs-built_in">av_parser_init</span>(codec-&gt;id);<br><span class="hljs-keyword">if</span>(!parserCtx) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_parser_init error&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 创建上下文</span><br>ctx = <span class="hljs-built_in">avcodec_alloc_context3</span>(codec);<br><span class="hljs-keyword">if</span> (!ctx) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_alloc_context3 error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="打开编码器"><a href="#打开编码器" class="headerlink" title="打开编码器"></a>打开编码器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开解码器</span><br>ret = <span class="hljs-built_in">avcodec_open2</span>(ctx,codec,<span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_open2 error&quot;</span> &lt;&lt; errbuf;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建AVPacket"><a href="#创建AVPacket" class="headerlink" title="创建AVPacket"></a>创建<code>AVPacket</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建AVPacket</span><br>pkt = <span class="hljs-built_in">av_packet_alloc</span>();<br><span class="hljs-keyword">if</span>(!pkt) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_packet_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建avframe"><a href="#创建avframe" class="headerlink" title="创建avframe"></a>创建<code>avframe</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建AVFrame</span><br>frame = <span class="hljs-built_in">av_frame_alloc</span>();<br><br><span class="hljs-keyword">if</span> (!frame) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开文件</span><br><span class="hljs-keyword">if</span>(!inFile.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; in.filename;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!outFile.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; outFilename;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><h3 id="缺少一帧图片大小"><a href="#缺少一帧图片大小" class="headerlink" title="缺少一帧图片大小"></a>缺少一帧图片大小</h3><ul>
<li>下面相比<code>ffmpeg</code>转出来的视频，大小不一致，大概缺少一帧图片的大小，实际上是由于，在解析器中还有的数据，未刷新。（最后两次打印可以看到，最后有数据，但是<code>pkt-&gt;size</code>为<code>0</code>）。表明数据，在解析器中，要再刷新一次，从解析器中获取。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> ((inLen = inFile.<span class="hljs-built_in">read</span>(inDataArray,IN_DATA_SIZE))&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (inLen &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 经过解析器上下文处理</span><br>            ret = <span class="hljs-built_in">av_parser_parse2</span>(parserCtx,<br>                                   ctx,<br>                                   &amp;pkt-&gt;data,<br>                                   &amp;pkt-&gt;size,<br>                                   (<span class="hljs-keyword">uint8_t</span> *)inData,<br>                                   inLen,<br>                                   AV_NOPTS_VALUE,<br>                                   AV_NOPTS_VALUE,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>                <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_parser_parse2 error&quot;</span> &lt;&lt; errbuf;<br>                <span class="hljs-keyword">goto</span> end;<br>            &#125;<br>            <span class="hljs-comment">// ------- 0 0 36 36 </span><br>            <span class="hljs-comment">// ------- 0 0 573 573 // ret中有数据，但是pkt-&gt;size中为0</span><br>             <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;-------&quot;</span> &lt;&lt; pkt-&gt;size &lt;&lt; ret &lt;&lt; inLen;<br>            <span class="hljs-comment">// 跳过已经解析过的数据</span><br>             inData += ret;<br>            <span class="hljs-comment">// 减去已经解析过的数据</span><br>             inLen -= ret;<br><br>             <span class="hljs-comment">// 解码</span><br>             <span class="hljs-keyword">if</span> (pkt-&gt;size &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">decode</span>(ctx,pkt,frame,outFile) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> end;<br>             &#125;<br>        &#125;<br>        <span class="hljs-comment">// inData读取完之后，重新开始赋值</span><br>        inData = inDataArray;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="完整的"><a href="#完整的" class="headerlink" title="完整的"></a>完整的</h3><ul>
<li>这里加上<code>inEnd</code>来进行判断，在最后刷新下解析器中的数据,最后尽管<code>pkt-&gt;size</code>但是，解析器中还是有数据，再刷一次，就有数据了<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">// 读取文件数据</span><br><span class="hljs-keyword">do</span> &#123;<br>    inLen = inFile.<span class="hljs-built_in">read</span>(inDataArray, IN_DATA_SIZE);<br>    <span class="hljs-comment">// 设置是否到了文件尾部</span><br>    inEnd = !inLen;<br><br>    <span class="hljs-comment">// 让inData指向数组的首元素</span><br>    inData = inDataArray;<br><br>    <span class="hljs-comment">// 只要输入缓冲区中还有等待进行解码的数据</span><br>    <span class="hljs-keyword">while</span> (inLen &gt; <span class="hljs-number">0</span> || inEnd) &#123;<br>        <span class="hljs-comment">// 到了文件尾部（虽然没有读取任何数据，但也要调用av_parser_parse2，修复bug）</span><br>        <span class="hljs-comment">// 经过解析器解析</span><br>        ret = <span class="hljs-built_in">av_parser_parse2</span>(parserCtx, ctx,<br>                               &amp;pkt-&gt;data, &amp;pkt-&gt;size,<br>                               (<span class="hljs-keyword">uint8_t</span> *) inData, inLen,<br>                               AV_NOPTS_VALUE, AV_NOPTS_VALUE, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_parser_parse2 error&quot;</span> &lt;&lt; errbuf;<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125;<br>        <span class="hljs-comment">// 最后有ret返回数据，但是 pkt-&gt;size为0，再末尾时，在刷一次</span><br>        <span class="hljs-comment">// ------- 0 0 36 36 </span><br>        <span class="hljs-comment">// ------- 0 0 573 573 // 按之前的，到这里就结束了 inLen - ret == 0了</span><br>        <span class="hljs-comment">// ------- 1 609 0 0 // 再刷一次</span><br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;-------&quot;</span> &lt;&lt;inEnd &lt;&lt; pkt-&gt;size &lt;&lt; ret &lt;&lt; inLen;<br>        <span class="hljs-comment">// 跳过已经解析过的数据</span><br>        inData += ret;<br>        <span class="hljs-comment">// 减去已经解析过的数据大小</span><br>        inLen -= ret;<br><br>        <span class="hljs-comment">// 解码</span><br>        <span class="hljs-keyword">if</span> (pkt-&gt;size &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">decode</span>(ctx, pkt, frame, outFile) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果到了文件尾部</span><br>        <span class="hljs-keyword">if</span> (inEnd) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> (!inEnd);<br><span class="hljs-built_in">decode</span>(ctx,<span class="hljs-literal">nullptr</span>,frame,outFile);<br>out.width = ctx-&gt;width;<br>out.height = ctx-&gt;height;<br>out.pixelFmt = ctx-&gt;pix_fmt;<br>out.fpx = ctx-&gt;framerate.num; <span class="hljs-comment">//和解码不同，编码是time_base</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h3><h4 id="解码问题"><a href="#解码问题" class="headerlink" title="解码问题"></a>解码问题</h4><ul>
<li><p><strong>注意</strong>解码上下文中的对于<code>888x680</code>的视频，由于宽度不是<code>16</code>的备注，解码上下文会将<code>888</code>向上让其满足<code>16</code>的倍数。</p>
<ul>
<li>这里<code>ctx-&gt;coded_width</code>和<code>frame-&gt;linesize[0]</code>均为<code>896</code>的大小，而<code>ctx.width</code>仍是<code>888</code>。解码后的<code>yuv</code>需要通过<code>896x680</code>才能正常播放    </li>
</ul>
</li>
<li><p><code>680x480</code>解码出来的视频，解码长度和实际长度一致，播放正常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(AVCodecContext *ctx,</span></span><br><span class="hljs-params"><span class="hljs-function">                  AVPacket *pkt,</span></span><br><span class="hljs-params"><span class="hljs-function">                  AVFrame *frame,</span></span><br><span class="hljs-params"><span class="hljs-function">                  QFile &amp;outFile)</span> </span>&#123;<br>    <span class="hljs-comment">// 发送压缩数据到解码器</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avcodec_send_packet</span>(ctx,pkt);<br>    <span class="hljs-comment">// ctx-&gt;coded_width 是 896</span><br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_send_packet error&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-built_in">av_frame_unref</span>(frame);<br><br>        <span class="hljs-comment">// 获取解码后的数据</span><br><br>        ret = <span class="hljs-built_in">avcodec_receive_frame</span>(ctx,frame);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>             <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_receive_frame error&quot;</span> &lt;&lt; errbuf;<br>             <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-comment">//  0x7fe3d1946000 0x7fe3d19e1000 0x7fe3d1a08000</span><br>         <span class="hljs-comment">//  888 x 680</span><br>        <span class="hljs-comment">// 634880 159744</span><br>        <span class="hljs-comment">// 603840  150960</span><br>        <span class="hljs-comment">//   896 x 680</span><br><br><br>        <span class="hljs-comment">//  0x7fceadd95000 0x7fceadde1000 0x7fceaddf4000</span><br>        <span class="hljs-comment">//  640 x 480</span><br>        <span class="hljs-comment">// 311296 77824</span><br>        <span class="hljs-comment">// 307200  76800</span><br>        <span class="hljs-comment">// 33550</span><br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; frame-&gt;data[<span class="hljs-number">0</span>] &lt;&lt; frame-&gt;data[<span class="hljs-number">1</span>] &lt;&lt; frame-&gt;data[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;旧的的&quot;</span> &lt;&lt; frame-&gt;linesize[<span class="hljs-number">0</span>] &lt;&lt; frame-&gt;linesize[<span class="hljs-number">1</span>] &lt;&lt; frame-&gt;linesize[<span class="hljs-number">2</span>] &lt;&lt; frame-&gt;width &lt;&lt; frame-&gt;height &lt;&lt;  ctx-&gt;width &lt;&lt; ctx-&gt;height;<br>        <span class="hljs-comment">// 每个平面数据不同，不能这么写</span><br>        <span class="hljs-comment">// 将解码后的数据写入文件</span><br>        <span class="hljs-keyword">int</span> height = ctx-&gt;height;<br><br>        <span class="hljs-comment">// 写入Y平面</span><br>        outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) frame-&gt;data[<span class="hljs-number">0</span>],<br>                      frame-&gt;linesize[<span class="hljs-number">0</span>] * height);<br>        <span class="hljs-comment">// 写入U平面</span><br>        outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) frame-&gt;data[<span class="hljs-number">1</span>],<br>                      frame-&gt;linesize[<span class="hljs-number">1</span>] * height &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 写入V平面</span><br>        outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) frame-&gt;data[<span class="hljs-number">2</span>],<br>                      frame-&gt;linesize[<span class="hljs-number">2</span>] * height &gt;&gt; <span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>数据写入是<code>frame-&gt;data[0]</code>中数据的长度，和实际<code>Y</code>数据长度不同。此外考虑可能出现的解码宽度和实际宽度不同的情况，例如<code>888x680</code>。这里用</p>
<ul>
<li><code>frame-&gt;linesize[0] * height</code>为<code>Y</code>数据大小</li>
<li><code>frame-&gt;linesize[1] * heigh &gt;&gt; 1</code>为<code>U</code>数据大小，垂直方向<code>YUV420p</code>是<code>Y</code>的<code>1:2</code></li>
<li><code>frame-&gt;linesize[2] * heigh &gt;&gt; 1</code>为<code>v</code>数据大小</li>
</ul>
</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul>
<li>实际发现，上述方法在<code>896x680</code>分辨率下可以播放，但是视频画面有问题。借助<code>ffmpeg</code>的<code>api</code>重新写入数据的方法（这种方式并且不用关心视频的格式）。<ul>
<li><code>frame</code>中的<code>data</code>会多于标准的，借助<code>av_image_alloc</code>生成标准的<code>imgBuff</code>和<code>linesizes</code>,通过<code>av_image_copy</code>方法，将<code>frame</code>的数据拷贝到标准缓存区即可</li>
<li><code>frame</code>中的数据，是一帧<code>yuv</code>图片的数据，即<code>imageSize</code>，并且标准<code>imgBuff</code>中数据是连续存放的，直接通过<code>outFile.write((char *) _imgBuff[0],imageSize)</code>，即可写入成功<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">uint8_t</span> *imgBuff[<span class="hljs-number">4</span>] = &#123; <span class="hljs-literal">nullptr</span> &#125;;<br><span class="hljs-keyword">int</span> linesizes[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">int</span> imageSize = <span class="hljs-built_in">av_image_alloc</span>(imgBuff,linesizes,ctx-&gt;width,ctx-&gt;height,ctx-&gt;pix_fmt,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">av_image_copy</span>(imgBuff,linesizes,<br>                  (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> **)(frame-&gt;data),<br>                  frame-&gt;linesize,<br>                  ctx-&gt;pix_fmt,<br>                  ctx-&gt;width,<br>                  ctx-&gt;height);<br><span class="hljs-comment">// 写一帧图片大小</span><br>outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) _imgBuff[<span class="hljs-number">0</span>],imageSize);<br><br><span class="hljs-comment">// 注意，imgBuff生成了堆地址，使用完要释放</span><br><span class="hljs-keyword">if</span>(imgBuff) &#123;<br>    <span class="hljs-built_in">free</span>(imgBuff[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul>
<li>查看<code>av_image_copy</code>源码，实际上通过下列方法，同样可以实现和上述方法的效果。即写入一帧图片的数据<ol>
<li>用一个指针<code>inData</code>指向<code>frame-&gt;data[0]</code>上<code>Y</code>数据的起始位置</li>
<li>根据<code>高度</code>循环遍历写入数据。并且每次<code>inData + frame-&gt;linesize[0]</code>,即<code>frame-&gt;data[0]</code>中一行数据的大小<ul>
<li><code>frame-&gt;linesize[0] &gt;= ctx-&gt;width</code>,因此要用<code>frame</code>对应的<code>linesize</code>，也就是<code>896</code>,实际写入的数据长度是<code>888</code></li>
<li>后续<code>U</code>、<code>V</code>,考虑是<code>Y</code>的水平/垂直的<code>1/2</code>,同样的方式便利<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> height = ctx-&gt;height;<br><span class="hljs-keyword">uint8_t</span> *inData = frame-&gt;data[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;z &lt; height;z++) &#123;<br>     outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) (inData),<br>                         ctx-&gt;width);<br>     inData = inData + frame-&gt;linesize[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">uint8_t</span> *inData1 = frame-&gt;data[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;z &lt; height / <span class="hljs-number">2</span>;z++) &#123;<br>     outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) inData1,<br>                   ctx-&gt;width &gt; <span class="hljs-number">1</span>);<br>     inData1 = inData1 + frame-&gt;linesize[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">uint8_t</span> *inData2 = frame-&gt;data[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;z &lt; height / <span class="hljs-number">2</span>;z++) &#123;<br>     outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *) inData2,<br>                   ctx-&gt;width &gt; <span class="hljs-number">1</span>);<br>     inData2 = inData2 + frame-&gt;linesize[<span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">end:<br>    inFile.<span class="hljs-built_in">close</span>();<br>    outFile.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-built_in">av_frame_free</span>(&amp;frame);<br>    <span class="hljs-built_in">av_packet_free</span>(&amp;pkt);<br>    <span class="hljs-built_in">av_parser_close</span>(parserCtx);<br>    <span class="hljs-built_in">avcodec_free_context</span>(&amp;ctx);<br></code></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul>
<li>指令播放<code>input888.yuv</code>,看能否正常播放  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ffplay -video_size <span class="hljs-number">888</span>x680 -pixel_format yuv420p -framerate <span class="hljs-number">25</span> input888.yuv<br></code></pre></td></tr></table></figure></li>
<li>指令解码相同的<code>libx264</code>编码文件，查看指令的文件和编码文件大小是否一致</li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>h264编码实战</title>
    <url>/2023/11/24/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/h264%E7%BC%96%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><blockquote>
<p><code>h264</code>的编码方式，实际上和<code>aac</code>的编码方式基本一致。</p>
</blockquote>
<h2 id="引入的库"><a href="#引入的库" class="headerlink" title="引入的库"></a>引入的库</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/imgutils.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 错误处理</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR_BUF(ret) \</span><br><span class="hljs-meta">char errbuf[1024]; \</span><br><span class="hljs-meta">    av_strerror(ret, errbuf, sizeof (errbuf));</span><br></code></pre></td></tr></table></figure>
<h2 id="输入的头文件"><a href="#输入的头文件" class="headerlink" title="输入的头文件"></a>输入的头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;<br>    <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">int</span> height;<br>    AVPixelFormat pixelFmt;<br>    <span class="hljs-keyword">int</span> fpx;<br>&#125; VideEncodeSpec;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H264EnCoder</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">H264EnCoder</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">h264Encode</span><span class="hljs-params">(VideEncodeSpec &amp;in,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *outFilename)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">VideEncodeSpec in = &#123;<br>    <span class="hljs-string">&quot;/Users/chenjingpo/Desktop/input.yuv&quot;</span>,<br>    <span class="hljs-number">888</span>,<br>    <span class="hljs-number">680</span>,<br>    AV_PIX_FMT_YUV420P,<br>    <span class="hljs-number">25</span><br>&#125;;<br><br>H264EnCoder::<span class="hljs-built_in">h264Encode</span>(in,<span class="hljs-string">&quot;/Users/chenjingpo/Desktop/output1.h264&quot;</span>);<br></code></pre></td></tr></table></figure>
<h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//编码器</span><br><span class="hljs-keyword">const</span> AVCodec *codec = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">//上下文</span><br>AVCodecContext *ctx = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 用来存放编码前的数据</span><br>AVFrame *frame = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 用来存放编码后的数据</span><br>AVPacket *pkt = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 返回结果</span><br><span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> imageSize = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 输入文件</span><br><span class="hljs-function">QFile <span class="hljs-title">inFile</span><span class="hljs-params">(in.filename)</span></span>;<br><span class="hljs-comment">// 输出文件</span><br><span class="hljs-function">QFile <span class="hljs-title">outFile</span><span class="hljs-params">(outFilename)</span></span>;<br></code></pre></td></tr></table></figure>

<h2 id="初始化编码器"><a href="#初始化编码器" class="headerlink" title="初始化编码器"></a>初始化编码器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">codec = <span class="hljs-built_in">avcodec_find_encoder_by_name</span>(<span class="hljs-string">&quot;libx264&quot;</span>);<br><span class="hljs-keyword">if</span>(!codec) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;encoder libx264 not found&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="检查采样格式"><a href="#检查采样格式" class="headerlink" title="检查采样格式"></a>检查采样格式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 检查采样格式</span><br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check_pixel_fmt</span>(codec,in.pixelFmt)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Encoder does not support pixelFmt&quot;</span> &lt;&lt; <span class="hljs-built_in">av_get_pix_fmt_name</span>(in.pixelFmt);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="检查采样格式函数"><a href="#检查采样格式函数" class="headerlink" title="检查采样格式函数"></a>检查采样格式函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 检查编码器codec是否支持采样格式AVPixelFormat</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">check_pixel_fmt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> AVCodec *codec,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">enum</span> AVPixelFormat pixel_fmt)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVPixelFormat</span> *<span class="hljs-title">p</span> =</span> codec-&gt;pix_fmts;<br>    <span class="hljs-keyword">while</span> (*p != AV_PIX_FMT_NONE) &#123;<br>        <span class="hljs-keyword">if</span> (*p == pixel_fmt) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        p++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建上下文"><a href="#创建上下文" class="headerlink" title="创建上下文"></a>创建上下文</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建上下文</span><br>ctx = <span class="hljs-built_in">avcodec_alloc_context3</span>(codec);<br><span class="hljs-keyword">if</span>(!ctx) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_alloc_context3 error&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 设置参数</span><br><span class="hljs-comment">// 视频格式</span><br>ctx-&gt;pix_fmt = in.pixelFmt;<br><span class="hljs-comment">// 宽</span><br>ctx-&gt;width = in.width;<br><span class="hljs-comment">// 高</span><br>ctx-&gt;height = in.height;<br><br>ctx-&gt;time_base = &#123;<span class="hljs-number">1</span>,in.fpx&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="打开编码器"><a href="#打开编码器" class="headerlink" title="打开编码器"></a>打开编码器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开编码器</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *     类似之前设置libfdk_aac的特有参数，比如vbr，也可以通过options参数传递</span><br><span class="hljs-comment"> *      AVDictionary *options = nullptr;</span><br><span class="hljs-comment"> *      av_dict_set(&amp;options,&quot;vbr&quot;,&quot;1&quot;,0);</span><br><span class="hljs-comment"> *      ret = avcodec_open2(ctx,codec,options);</span><br><span class="hljs-comment">*/</span><br>ret = <span class="hljs-built_in">avcodec_open2</span>(ctx,codec,<span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_open2 error&quot;</span> &lt;&lt; errbuf;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建avframe"><a href="#创建avframe" class="headerlink" title="创建avframe"></a>创建<code>avframe</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建avframe</span><br>frame = <span class="hljs-built_in">av_frame_alloc</span>();<br><span class="hljs-keyword">if</span>(!frame) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br><br>frame-&gt;width = ctx-&gt;width;<br>frame-&gt;format = ctx-&gt;pix_fmt;<br>frame-&gt;height = ctx-&gt;height;<br>frame-&gt;pts = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h3 id="创建avframe内部的缓存区"><a href="#创建avframe内部的缓存区" class="headerlink" title="创建avframe内部的缓存区"></a>创建<code>avframe</code>内部的缓存区</h3><ul>
<li>已经<code>frame</code>中<code>data</code>数组，会连续存放<code>YUV</code>的数据，由于是<code>YUV420p</code>,其数据比是<code>1:0.25:0.25</code>。根据计算可以<code>Y</code>的存储大小为:<code>888 x 460 = 426240</code>。<code>U</code>/<code>V</code>的存储大小为:<code>888 x 460 / 4 = 106560</code><ul>
<li>此前<code>aac</code>编码通过<code>av_frame_get_buffer</code>可以生成正确的数据，但是在<code>h264</code>中查看数据，可看到，数据并非是连续存放<code>YUV</code>数据的大小，比正常的要大小</li>
<li>而用<code>av_image_alloc</code>生成<code>frame</code>中<code>data</code>大小,得到的数据是连续精确的。此外这里用了<code>av_image_alloc</code>代表，需要主动去释放生成的<code>data</code>,要有<code>av_freep(&amp;frame-&gt;data[0]);</code>方法</li>
</ul>
</li>
<li><code>linesize</code>指的是<code>yuv</code>水平上数据的大小,例如，<code>yuv420p</code>是，<code>y</code>和<code>u</code>/<code>v</code>水平方向是<code>1:2</code>,垂直方向也是<code>1:2</code>.<ul>
<li>这里<code>linesize[0..2]</code>即为<code>888 444 444</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建avframe内部的缓存区</span><br>ret = <span class="hljs-built_in">av_image_alloc</span>(&amp;frame-&gt;data[<span class="hljs-number">0</span>],&amp;frame-&gt;linesize[<span class="hljs-number">0</span>],ctx-&gt;width,ctx-&gt;height,ctx-&gt;pix_fmt,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//  426240  106560 连续地址，刚好连续存放YUV数据---&gt;(888 x 460  888 x 460 / 4)</span><br><span class="hljs-comment">// 0x7f9238b86000 0x7f9238bee100 0x7f9238c08140</span><br><span class="hljs-built_in">qDebug</span>() &lt;&lt; frame-&gt;data[<span class="hljs-number">0</span>] &lt;&lt; frame-&gt;data[<span class="hljs-number">1</span>] &lt;&lt; frame-&gt;data[<span class="hljs-number">2</span>];<br><span class="hljs-comment">//  430112  107552 地址并非连续存放YUV</span><br><span class="hljs-comment">//0x7fd7e2399000 0x7fd7e2402020 0x7fd7e241c440</span><br><span class="hljs-comment">// ret = av_frame_get_buffer(frame,0);</span><br><br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_frame_get_buffer error&quot;</span> &lt;&lt; errbuf;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="创建avpacket"><a href="#创建avpacket" class="headerlink" title="创建avpacket"></a>创建<code>avpacket</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建avpacket</span><br>pkt = <span class="hljs-built_in">av_packet_alloc</span>();<br><span class="hljs-keyword">if</span> (!pkt) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_packet_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开文件</span><br><span class="hljs-keyword">if</span>(!inFile.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; in.filename;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!outFile.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; outFilename;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><ul>
<li><code>aac</code>编码时，读取数据大小时<code>frame-&gt;linesize[0]</code>，因为这里存放了单个声道<code>pcm</code>的数据。</li>
<li>这里<code>yuv</code>,<code>linesize</code>只存放了，每一排的数据大小。通过计算出一帧<code>yuv</code>数据打大小，每次读一帧数据，进行编码<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">imageSize = <span class="hljs-built_in">av_image_get_buffer_size</span>(ctx-&gt;pix_fmt,ctx-&gt;width,ctx-&gt;height,<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 开始编码</span><br><span class="hljs-comment">// frame-&gt;linesize[0]是缓冲区的大小</span><br><span class="hljs-comment">// 读取文件数据，将数据填充到frame中</span><br><span class="hljs-keyword">while</span>((ret = inFile.<span class="hljs-built_in">read</span>((<span class="hljs-keyword">char</span> *)frame-&gt;data[<span class="hljs-number">0</span>],imageSize)) == imageSize) &#123;<br>    <span class="hljs-comment">// 编码</span><br>    frame-&gt;pts += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">encode</span>(ctx,frame,pkt,outFile)) &#123;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;编码第&quot;</span> &lt;&lt; frame-&gt;pts &lt;&lt; <span class="hljs-string">&quot;帧&quot;</span>;<br>&#125;<br><span class="hljs-comment">// flush编码器</span><br><span class="hljs-built_in">encode</span>(ctx,<span class="hljs-literal">nullptr</span>,pkt,outFile);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="编码方法"><a href="#编码方法" class="headerlink" title="编码方法"></a>编码方法</h3><blockquote>
<p>和<code>aac</code>编码一致，没有更改</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">encode</span><span class="hljs-params">(AVCodecContext *ctx,</span></span><br><span class="hljs-params"><span class="hljs-function">                  AVFrame *frame,</span></span><br><span class="hljs-params"><span class="hljs-function">                  AVPacket *pkt,</span></span><br><span class="hljs-params"><span class="hljs-function">                  QFile &amp;outFile)</span></span>&#123;<br>    <span class="hljs-comment">// 发送数据到编码器，将frame中的yuv数据，发送给h264上下文</span><br>    <span class="hljs-comment">// frame 为null，则flushed缓冲区</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avcodec_send_frame</span>(ctx,frame);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_send_frame error&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 从编码器中获取编码后的数据,从ctx中获取从frame转换后的数据，传给pkt</span><br>        ret = <span class="hljs-built_in">avcodec_receive_packet</span>(ctx,pkt);<br>        <span class="hljs-comment">// packet中已经没有数据，需要重新发送数据到编码器（send frame)</span><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 出现了其他错误</span><br>            <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_receive_packet error&quot;</span> &lt;&lt; errbuf;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-comment">// 将编码后的数据写入文件</span><br>        outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *)pkt-&gt;data,pkt-&gt;size);<br><br>        <span class="hljs-comment">// 释放资源</span><br>        <span class="hljs-built_in">av_packet_unref</span>(pkt);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">end:<br>    <span class="hljs-comment">// 关闭文件</span><br>    inFile.<span class="hljs-built_in">close</span>();<br>    outFile.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">if</span> (frame) &#123;<br>        <span class="hljs-built_in">av_freep</span>(&amp;frame-&gt;data[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">av_frame_free</span>(&amp;frame);<br>    &#125;<br>    <span class="hljs-built_in">av_packet_free</span>(&amp;pkt);<br>    <span class="hljs-built_in">avcodec_free_context</span>(&amp;ctx);<br></code></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul>
<li>指令播放<code>output1.h264</code>,看能否正常播放  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ffplay output1.h264<br></code></pre></td></tr></table></figure></li>
<li>指令编码出相同的<code>libx264</code>编码，查看指令的文件和编码文件大小是否一致  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ffmpeg -s 888x680 -pix_fmt yuv420p -i input.yuv -c:v libx264 output.h264<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>播放yuv视频</title>
    <url>/2023/11/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E6%92%AD%E6%94%BEyuv%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li><code>yuv</code>视频的播放，和图片显示原理基本一致，只要设置一个定时任务，每秒<code>30</code>帧，去读取<code>YUV</code>视频数据，去显示即可。</li>
<li>但是用<code>SD</code>L框架在<code>QT</code>中渲染<code>yuv</code>图片，存在跨平台的异常问题，考虑此，我门采用<code>qt</code>中图片渲染框架(<code>QImage</code>，然后<code>QImage</code>只支持<code>RGB</code>格式)</li>
</ul>
</blockquote>
<h2 id="yuv视频数据格式转换"><a href="#yuv视频数据格式转换" class="headerlink" title="yuv视频数据格式转换"></a>yuv视频数据格式转换</h2><blockquote>
<p>对每一帧写入的图片数据进行转换</p>
</blockquote>
<h3 id="头文件定义"><a href="#头文件定义" class="headerlink" title="头文件定义"></a>头文件定义</h3><h4 id="数据结构结构"><a href="#数据结构结构" class="headerlink" title="数据结构结构"></a>数据结构结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">char</span> *pixels;<br>    <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">int</span> height;<br>    AVPixelFormat format;<br>&#125; RawVideoFrame;<br></code></pre></td></tr></table></figure>

<h4 id="定义的函数"><a href="#定义的函数" class="headerlink" title="定义的函数"></a>定义的函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">converRawVideo</span><span class="hljs-params">(RawVideoFrame &amp;in,</span></span><br><span class="hljs-params"><span class="hljs-function">                               RawVideoFrame &amp;out)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="导入的函数库"><a href="#导入的函数库" class="headerlink" title="导入的函数库"></a>导入的函数库</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/imgutils.h&gt;</span></span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERR_BUF(ret) \</span><br><span class="hljs-meta">char errbuf[1024]; \</span><br><span class="hljs-meta">av_strerror(ret,errbuf,sizeof(errbuf));</span><br></code></pre></td></tr></table></figure>
<h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SwsContext *ctx = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">//返回结果</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 每一帧图片的大小</span><br>    <span class="hljs-keyword">int</span> inFrameSize, outFrameSize;<br>    <span class="hljs-keyword">uint8_t</span> *inData[<span class="hljs-number">4</span>],*outData[<span class="hljs-number">4</span>];<br>    <span class="hljs-comment">/*每个屏幕的宽度比，列如640 x 480 的 yuv420p</span><br><span class="hljs-comment">     * inLineStride[0] 640 一行640个y</span><br><span class="hljs-comment">     * inLineStride[1] 320 一行320个u,水平方向1比2，垂直方向1比2</span><br><span class="hljs-comment">     * inLineStride[2] 320 一行320个v,水平方向1比2，垂直方向1比2</span><br><span class="hljs-comment">     * 转成RGB,RGB是3个字节，只有一行640 * 3</span><br><span class="hljs-comment">     * outLineStride[4];</span><br><span class="hljs-comment">     * outLineStride[0]; 640 * 3</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">int</span> inLineStride[<span class="hljs-number">4</span>],outLineStride[<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure>

<h3 id="创建上下文"><a href="#创建上下文" class="headerlink" title="创建上下文"></a>创建上下文</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建上下文</span><br>    ctx = <span class="hljs-built_in">sws_getContext</span>(in.width,<br>                         in.height,<br>                         in.format,<br>                         out.width,out.height,out.format,<br>                         SWS_BILINEAR,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!ctx) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;sws_getContext error&quot;</span>;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建缓存区"><a href="#创建缓存区" class="headerlink" title="创建缓存区"></a>创建缓存区</h3><blockquote>
<p>系统提供的api，在缓存区中，可为<code>inLineStride</code>赋值，以及初始化<code>inData</code>(分配给数组中每个指针多少堆大小)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输入缓存区</span><br>    res = <span class="hljs-built_in">av_image_alloc</span>(inData,inLineStride,in.width,in.height,in.format,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (!res) &#123;<br>        <span class="hljs-built_in">ERR_BUF</span>(res)<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;in av_image_alloc error&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出缓存区</span><br>    res = <span class="hljs-built_in">av_image_alloc</span>(outData,outLineStride,out.width,out.height,out.format,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (!res) &#123;<br>        <span class="hljs-built_in">ERR_BUF</span>(res)<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;out av_image_alloc error&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 计算每一帧图片的大小</span><br>    inFrameSize = <span class="hljs-built_in">av_image_get_buffer_size</span>(in.format,in.width,in.height,<span class="hljs-number">1</span>);<br>    outFrameSize = <span class="hljs-built_in">av_image_get_buffer_size</span>(out.format,out.width,out.height,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//拷贝输入数据到缓存区，数据放到从inData数据首地址开始存放。每个地址事先设置了堆大小，inData[0]存放完了，则会到inData[1]</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 数组中 int a[4].  a是数组地址, a[0] 等价于 *a,都是数组的首元素值</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">memcpy</span>(inData[<span class="hljs-number">0</span>],in.pixels,inFrameSize);<br><br>    <span class="hljs-comment">// 进行每一帧图片转换</span><br>        <span class="hljs-comment">//转换</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *  int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[],</span><br><span class="hljs-comment">              const int srcStride[], int srcSliceY, int srcSliceH,</span><br><span class="hljs-comment">              uint8_t *const dst[], const int dstStride[]);</span><br><span class="hljs-comment">    */</span><br>      <span class="hljs-built_in">sws_scale</span>(ctx,inData,inLineStride,<span class="hljs-number">0</span>,in.height,outData,outLineStride);<br><br>    <span class="hljs-comment">// 创建堆，写到输入输出帧的堆中.生成的视频堆资源，由外部释放</span><br>      out.pixels = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>(outFrameSize);<br>       <span class="hljs-built_in">memcpy</span>(out.pixels,outData[<span class="hljs-number">0</span>],outFrameSize);<br></code></pre></td></tr></table></figure>

<h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">end:<br>    <span class="hljs-built_in">sws_freeContext</span>(ctx);<br>    <span class="hljs-built_in">av_freep</span>(&amp;inData[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">av_freep</span>(&amp;outData[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure>


<h2 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h2><h3 id="视频播放器实现的头参数"><a href="#视频播放器实现的头参数" class="headerlink" title="视频播放器实现的头参数"></a>视频播放器实现的头参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;<br>    <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-keyword">int</span> fps;<br>    AVPixelFormat pixelFormat;<br>&#125; YUV;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YUVPlayer</span> :</span> <span class="hljs-keyword">public</span> QWidget<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span><br>        Playing,<br>        Paused,<br>        Stopped,<br>        Finished<br>    &#125;State;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">YUVPlayer</span><span class="hljs-params">(QWidget *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pluse</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setYUV</span><span class="hljs-params">(YUV &amp;yuv)</span></span>;<br>    <span class="hljs-function">State <span class="hljs-title">getState</span><span class="hljs-params">()</span></span>;<br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stateChange</span><span class="hljs-params">(State state)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    State _state = Stopped;<br>    QImage *_currentImage;<br>    YUV _yuv;<br>    QRect _dstRect;<br>    <span class="hljs-keyword">int</span> _timeId = <span class="hljs-number">0</span>;<br>    QFile *_file = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 监听定时事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">timerEvent</span><span class="hljs-params">(QTimerEvent *event)</span></span>;<br>    <span class="hljs-comment">// 绘画事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span></span>;<br>    <span class="hljs-comment">// 释放图片</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeCurrentImage</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 停止定时器</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stopTimer</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span></span>;<br>    ~<span class="hljs-built_in">YUVPlayer</span>();<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="视频播放器实现的文件"><a href="#视频播放器实现的文件" class="headerlink" title="视频播放器实现的文件"></a>视频播放器实现的文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;yuvplayer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ffmpegs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPainter&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QFile&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/imgutils.h&gt;</span></span><br>&#125;<br>YUVPlayer::<span class="hljs-built_in">YUVPlayer</span>(QWidget *parent)<br>    : QWidget&#123;parent&#125;<br>&#123;<br>    <span class="hljs-built_in">setAttribute</span>(Qt::WA_StyledBackground);<br>    <span class="hljs-built_in">setStyleSheet</span>(<span class="hljs-string">&quot;background: black&quot;</span>);<br>&#125;<br><br>YUVPlayer::~<span class="hljs-built_in">YUVPlayer</span>() &#123;<br>    _file-&gt;<span class="hljs-built_in">close</span>();<br>    <span class="hljs-built_in">stopTimer</span>();<br>    <span class="hljs-built_in">freeCurrentImage</span>();<br>&#125;<br><br><span class="hljs-function">YUVPlayer::State <span class="hljs-title">YUVPlayer::getState</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _state;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::play</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == YUVPlayer::Playing) <span class="hljs-keyword">return</span>;<br>   _timeId =  <span class="hljs-built_in">startTimer</span>(<span class="hljs-number">1000</span> / _yuv.fps);<br>   <span class="hljs-built_in">setState</span>(YUVPlayer::Playing);<br><br>   <span class="hljs-keyword">if</span>(!_file-&gt;<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; _yuv.filename;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::pluse</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">if</span> (_state != YUVPlayer::Playing) <span class="hljs-keyword">return</span>;<br>   <span class="hljs-built_in">stopTimer</span>();<br>   <span class="hljs-built_in">setState</span>(YUVPlayer::Paused);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::stop</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">if</span> (_state == YUVPlayer::Stopped) <span class="hljs-keyword">return</span>;<br>   <span class="hljs-built_in">stopTimer</span>();<br>   <span class="hljs-built_in">freeCurrentImage</span>();<br>   <span class="hljs-built_in">update</span>();<br>   <span class="hljs-built_in">setState</span>(YUVPlayer::Stopped);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::setYUV</span><span class="hljs-params">(YUV &amp;yuv)</span> </span>&#123;<br>    _yuv = yuv;<br>   _file = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QFile</span>();<br>   _file-&gt;<span class="hljs-built_in">setFileName</span>(yuv.filename);<br>   <span class="hljs-keyword">int</span> w = <span class="hljs-built_in">width</span>();<br>   <span class="hljs-keyword">int</span> h = <span class="hljs-built_in">height</span>();<br><br>   <span class="hljs-comment">// 计算rect</span><br>   <span class="hljs-keyword">int</span> dx = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">int</span> dy = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">int</span> dw = _yuv.width;<br>   <span class="hljs-keyword">int</span> dh = _yuv.height;<br>   <span class="hljs-comment">// 计算目标尺寸</span><br>   <span class="hljs-keyword">if</span> (dw &gt; w || dh &gt; h) &#123; <span class="hljs-comment">//缩放</span><br>       <span class="hljs-keyword">if</span> (dw * h &gt; w * dh) &#123; <span class="hljs-comment">// 视频宽高比 &gt; 播放器宽高比</span><br>           dh = w * dh / dw;<br>           dw = w;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           dw = h * dw / dh;<br>           dh = h;<br>       &#125;<br>   &#125;<br>    <span class="hljs-comment">// 剧中</span><br>   dx = (w - dw) &gt;&gt; <span class="hljs-number">1</span>;<br>   dy = (h - dh) &gt;&gt; <span class="hljs-number">1</span>;<br>   _dstRect = &#123;dx,dy,dw,dh&#125;;<br>&#125;<br><br><span class="hljs-comment">// 当组件想重绘时，就会调用，勒是layoutsubview</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!_currentImage) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">drawImage</span>(_dstRect,* _currentImage);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::timerEvent</span><span class="hljs-params">(QTimerEvent *event)</span> </span>&#123;<br>    <span class="hljs-comment">// 图片大小</span><br>    <span class="hljs-keyword">int</span> imgSize = <span class="hljs-built_in">av_image_get_buffer_size</span>(_yuv.pixelFormat,_yuv.width,_yuv.height,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">char</span> data[imgSize];<br>    <span class="hljs-keyword">if</span> (_file-&gt;<span class="hljs-built_in">read</span>(data,imgSize) &gt; <span class="hljs-number">0</span>) &#123;<br>       RawVideoFrame in = &#123;<br>           data,<br>           <span class="hljs-comment">//输入格式不能改，因为输入数据是不能修改的</span><br>           _yuv.width,<br>           _yuv.height,<br>           _yuv.pixelFormat<br>       &#125;;<br>       RawVideoFrame out = &#123;<br>           <span class="hljs-literal">nullptr</span>,<br>           <span class="hljs-comment">// 输出格式建议16的倍数,数据对齐，可以加快转换速度</span><br>           _yuv.width &gt;&gt; <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">4</span>,<br>           _yuv.height &gt;&gt; <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">4</span>,<br>           AV_PIX_FMT_RGB24<br>       &#125;;<br>       FFMPEGS::<span class="hljs-built_in">converRawVideo</span>(in,out);<br>       <span class="hljs-built_in">freeCurrentImage</span>();<br>       _currentImage =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">QImage</span>((uchar *)out.pixels,out.width,out.height,QImage::Format_RGB888);<br>       <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;更新&quot;</span>;<br>       <span class="hljs-built_in">update</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 文件数据已经读取完毕</span><br>       <span class="hljs-built_in">stopTimer</span>();<br>       <span class="hljs-built_in">setState</span>(YUVPlayer::Finished);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::freeCurrentImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_currentImage) &#123;<br>       <span class="hljs-keyword">delete</span> _currentImage;<br>       <span class="hljs-built_in">free</span>(_currentImage-&gt;<span class="hljs-built_in">bits</span>());<br>       _currentImage = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::stopTimer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(_timeId == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">killTimer</span>(_timeId);<br>    _timeId = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YUVPlayer::setState</span><span class="hljs-params">(State state)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == state) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (_state == YUVPlayer::Stopped || _state == YUVPlayer::Finished)  &#123;<br>       <span class="hljs-comment">// 文件读取指针到文件首部</span><br>       _file-&gt;<span class="hljs-built_in">seek</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    _state = state;<br>    <span class="hljs-function">emit <span class="hljs-title">stateChange</span><span class="hljs-params">(state)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>显示YUV图片</title>
    <url>/2023/11/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E6%98%BE%E7%A4%BAYUV%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL2/SDL.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> END(judge,func) \</span><br><span class="hljs-meta">            <span class="hljs-meta-keyword">if</span> (judge) &#123; \</span><br><span class="hljs-meta">              qDebug() &lt;&lt; #func &lt;&lt; <span class="hljs-meta-string">&quot;Error&quot;</span> &lt;&lt; SDL_GetError(); \</span><br><span class="hljs-meta">               goto end; \</span><br><span class="hljs-meta">            &#125;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILENAME <span class="hljs-meta-string">&quot;/Users/chenjingpo/Desktop/out.yuv&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIXEL_FORMAT SDL_PIXELFORMAT_IYUV <span class="hljs-comment">// 即yuv420p</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMG_W 640</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMG_H 480</span><br></code></pre></td></tr></table></figure>

<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 窗口</span><br>SDL_Window *window = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 渲染上下文</span><br>SDL_Renderer *renderer = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 纹理（直接跟特定驱动程序相关的像素数据</span><br>SDL_Texture *texture = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 文件</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(FILENAME)</span></span>;<br></code></pre></td></tr></table></figure>

<h2 id="初始化子系统"><a href="#初始化子系统" class="headerlink" title="初始化子系统"></a>初始化子系统</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化vide子系统</span><br>    <span class="hljs-built_in">END</span>(<span class="hljs-built_in">SDL_Init</span>(SDL_INIT_VIDEO),SDL_Init);<br></code></pre></td></tr></table></figure>

<h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 下面是创建一个以window为中心的窗口</span><br>window = <span class="hljs-built_in">SDL_CreateWindowFrom</span>(windowId);<br><span class="hljs-comment">// 创建一个弹窗的窗口</span><br><span class="hljs-comment">//    window = SDL_CreateWindow(</span><br><span class="hljs-comment">//        // 窗口标题</span><br><span class="hljs-comment">//        &quot;显示YUV图片&quot;,</span><br><span class="hljs-comment">//        // 窗口X（未定义）</span><br><span class="hljs-comment">//        SDL_WINDOWPOS_UNDEFINED,</span><br><span class="hljs-comment">//        // 窗口Y（未定义）</span><br><span class="hljs-comment">//        SDL_WINDOWPOS_UNDEFINED,</span><br><span class="hljs-comment">//        // 窗口宽度（跟图片宽度一样）</span><br><span class="hljs-comment">//        IMG_W,</span><br><span class="hljs-comment">//        // 窗口高度（跟图片高度一样）</span><br><span class="hljs-comment">//        IMG_H,</span><br><span class="hljs-comment">//        // 显示窗口</span><br><span class="hljs-comment">//        SDL_WINDOW_SHOWN);</span><br><span class="hljs-built_in">END</span>(!window,SDL_CreateWindow);<br></code></pre></td></tr></table></figure>

<h2 id="创建渲染上下文"><a href="#创建渲染上下文" class="headerlink" title="创建渲染上下文"></a>创建渲染上下文</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建渲染上下文</span><br>    renderer = <span class="hljs-built_in">SDL_CreateRenderer</span>(window,<br>                                  <span class="hljs-number">-1</span>,<br>                                  <span class="hljs-comment">// 支持渲染硬件加速</span><br>                                  SDL_RENDERER_ACCELERATED |<br>                                      SDL_RENDERER_PRESENTVSYNC);<br><br>    <span class="hljs-keyword">if</span> (!renderer) &#123; <span class="hljs-comment">// 说明开启硬件加速失败</span><br>        renderer = <span class="hljs-built_in">SDL_CreateRenderer</span>(window, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">END</span>(!renderer,SDL_CreateRenderer);<br></code></pre></td></tr></table></figure>

<h2 id="创建纹理"><a href="#创建纹理" class="headerlink" title="创建纹理"></a>创建纹理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建纹理</span><br>    texture = <span class="hljs-built_in">SDL_CreateTexture</span>(renderer,<br>                                PIXEL_FORMAT,<br>                                SDL_TEXTUREACCESS_STREAMING,<br>                                IMG_W,<br>                                IMG_H);<br>    <span class="hljs-built_in">END</span>(!texture,SDL_CreateTexture);<br></code></pre></td></tr></table></figure>

<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开文件</span><br>    <span class="hljs-keyword">if</span>(!file.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; FILENAME;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 渲染，和BMP显示不同的地方</span><br>    <span class="hljs-comment">// 将YUV的像素数据填充到texture</span><br>    <span class="hljs-built_in">END</span>(<span class="hljs-built_in">SDL_UpdateTexture</span>(texture,<br>                          <span class="hljs-literal">nullptr</span>,<br>                          file.<span class="hljs-built_in">readAll</span>().<span class="hljs-built_in">data</span>(),IMG_W),SDL_UpdateTexture)<br><span class="hljs-comment">// 设置绘制颜色  END(SDL_SetRenderDrawColor(renderer,0,0,0,SDL_ALPHA_OPAQUE),SDL_SetRenderDrawColor);</span><br><br><span class="hljs-comment">// 用绘制颜色（画笔颜色）清除渲染目标,也就是画面的底色</span><br><span class="hljs-built_in">END</span>(<span class="hljs-built_in">SDL_RenderClear</span>(renderer),<br>        SDL_RenderClear);<br><br><span class="hljs-comment">// 拷贝纹理数据到渲染目标（默认是window）</span><br><span class="hljs-built_in">END</span>(<span class="hljs-built_in">SDL_RenderCopy</span>(renderer,texture,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>),SDL_RenderCopy);<br><br><span class="hljs-comment">// 更新所有的渲染操作到屏幕上</span><br><span class="hljs-built_in">SDL_RenderPresent</span>(renderer);<br></code></pre></td></tr></table></figure>

<h2 id="监听手势退出"><a href="#监听手势退出" class="headerlink" title="监听手势退出"></a>监听手势退出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">//  监听窗口退出，之后，才退出程序去释放资源</span><br>        SDL_Event event;<br>        <span class="hljs-built_in">SDL_WaitEvent</span>(&amp;event);<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (event.type) &#123;<br>        <span class="hljs-keyword">case</span> SDL_QUIT:<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">end:<br>    <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-built_in">SDL_DestroyRenderer</span>(renderer);<br>    <span class="hljs-built_in">SDL_DestroyTexture</span>(texture);<br>    <span class="hljs-built_in">SDL_DestroyWindow</span>(window);<br>    <span class="hljs-built_in">SDL_Quit</span>();<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>视频录制</title>
    <url>/2023/10/29/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="avfoundation支持的设备"><a href="#avfoundation支持的设备" class="headerlink" title="avfoundation支持的设备"></a><code>avfoundation</code>支持的设备</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ffmpeg -f avfoundation -list_devices true -i &#x27;&#x27;<br></code></pre></td></tr></table></figure>
<ul>
<li>结果如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[AVFoundation indev @ 0x7fb010b04140] AVFoundation video devices:<br>[AVFoundation indev @ 0x7fb010b04140] [0] FaceTime高清摄像头（内建）<br>[AVFoundation indev @ 0x7fb010b04140] [1] “Iphone”的相机<br>[AVFoundation indev @ 0x7fb010b04140] [2] Capture screen 0<br>[AVFoundation indev @ 0x7fb010b04140] [3] Capture screen 1<br>[AVFoundation indev @ 0x7fb010b04140] AVFoundation audio devices:<br>[AVFoundation indev @ 0x7fb010b04140] [0] MacBook Pro麦克风<br>[AVFoundation indev @ 0x7fb010b04140] [1] “Iphone”的麦克风<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="avfoundation支持的参数"><a href="#avfoundation支持的参数" class="headerlink" title="avfoundation支持的参数"></a><code>avfoundation</code>支持的参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ffmpeg -h demuxer=avfoundation<br></code></pre></td></tr></table></figure>
<ul>
<li>结果如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">AVFoundation indev AVOptions:<br>  -list_devices      &lt;boolean&gt;    .D......... list available devices (default false)<br>  -video_device_index &lt;int&gt;        .D......... select video device by index for devices with same name (starts at 0) (from -1 to INT_MAX) (default -1)<br>  -audio_device_index &lt;int&gt;        .D......... select audio device by index for devices with same name (starts at 0) (from -1 to INT_MAX) (default -1)<br>  -pixel_format      &lt;pix_fmt&gt;    .D......... set pixel format (default yuv420p)<br>  -framerate         &lt;video_rate&gt; .D......... set frame rate (default &quot;ntsc&quot;)<br>  -video_size        &lt;image_size&gt; .D......... set video size<br>  -capture_cursor    &lt;boolean&gt;    .D......... capture the screen cursor (default false)<br>  -capture_mouse_clicks &lt;boolean&gt;    .D......... capture the screen mouse clicks (default false)<br>  -capture_raw_data  &lt;boolean&gt;    .D......... capture the raw data from device connection (default false)<br>  -drop_late_frames  &lt;boolean&gt;    .D......... drop frames that are available later than expected (default true)<br></code></pre></td></tr></table></figure></li>
<li><code>video_size</code>：分辨率</li>
<li><code>pixel_format</code>：像素格式<ul>
<li>默认是<code>yuv420p</code></li>
</ul>
</li>
<li><code>framerate</code>：帧率（每秒采集多少帧画面）<ul>
<li>默认是<a href="https://ffmpeg.org/ffmpeg-all.html#Video-rate"><code>ntsc</code></a>，也就是<code>30000/1001</code>，约等于<code>29.970030</code></li>
</ul>
</li>
<li><code>list_devices：true</code>表示列出<code>avfoundation</code>支持的所有设备</li>
</ul>
<h3 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 使用0号视频设备<br>ffmpeg -f avfoundation -framerate 30 -i 0 out.yuv<br></code></pre></td></tr></table></figure>
<ul>
<li>注意<code>avfoundation</code>中的默认参数不一定符合当前视频设备支持的<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">2023-10-29 19:18:53.529 ffmpeg[26404:314273] WARNING: AVCaptureDeviceTypeExternal is deprecated for Continuity Cameras. Please use AVCaptureDeviceTypeContinuityCamera and add NSCameraUseContinuityCameraDeviceType to your Info.plist.<br>[avfoundation @ 0x7f9bd7a04400] Selected pixel format (yuv420p) is not supported by the input device.<br>[avfoundation @ 0x7f9bd7a04400] Supported pixel formats:<br>[avfoundation @ 0x7f9bd7a04400]   uyvy422<br>[avfoundation @ 0x7f9bd7a04400]   yuyv422<br>[avfoundation @ 0x7f9bd7a04400]   nv12<br>[avfoundation @ 0x7f9bd7a04400]   0rgb<br>[avfoundation @ 0x7f9bd7a04400]   bgr0<br>[avfoundation @ 0x7f9bd7a04400] Overriding selected pixel format to use uyvy422 instead.<br>Input #0, avfoundation, from &#x27;0&#x27;:<br>  Duration: N/A, start: 25111.941200, bitrate: N/A<br>  Stream #0:0: Video: rawvideo (UYVY / 0x59565955), uyvy422, 1280x720, 31 tbr, 1000k tbn<br>File &#x27;out.yuv&#x27; already exists. Overwrite? [y/N] y<br>Stream mapping:<br>  Stream #0:0 -&gt; #0:0 (rawvideo (native) -&gt; rawvideo (native))<br>Press [q] to stop, [?] for help<br>Output #0, rawvideo, to &#x27;out.yuv&#x27;:<br>  Metadata:<br>    encoder         : Lavf60.3.100<br>  Stream #0:0: Video: rawvideo (UYVY / 0x59565955), uyvy422(progressive), 1280x720, q=2-31, 457113 kb/s, 31 fps, 31 tbn<br>    Metadata:<br>      encoder         : Lavc60.3.100 rawvideo<br>frame=  356 fps=127 q=-0.0 Lsize=  640800kB time=00:00:11.45 bitrate=458401.2kbits/s dup=284 drop=0 speed=4.08x<br>video:640800kB audio:0kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 0.000000%<br></code></pre></td></tr></table></figure></li>
<li>这里当前设备所支持的参数是<ul>
<li><code>-pixel_format</code>:<code>uyvy422</code></li>
<li><code>-video_size</code>:<code>1280x720</code></li>
<li><code>-framerate</code>:<code>30</code></li>
</ul>
</li>
</ul>
<h3 id="播放录制好的yuv"><a href="#播放录制好的yuv" class="headerlink" title="播放录制好的yuv"></a>播放录制好的<code>yuv</code></h3><blockquote>
<p>注意录制好的视频，只有视频数据，不包含音频数据，是没有声音的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ffplay -video_size 1280x720 -pixel_format uyvy422 -framerate 30 out.yuv<br></code></pre></td></tr></table></figure>

<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="权限申请"><a href="#权限申请" class="headerlink" title="权限申请"></a>权限申请</h2><blockquote>
<p>在<code>Mac</code>平台，需要像音频录制一样，增加<code>Info.plist</code>权限文件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">plist</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSCameraUsageDescription<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>使用摄像头采集您的靓照<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="框架引入"><a href="#框架引入" class="headerlink" title="框架引入"></a>框架引入</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavdevice/avdevice.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/imgutils.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br>    <span class="hljs-comment">// 格式名称</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FMT_NAME <span class="hljs-meta-string">&quot;dshow&quot;</span></span><br>    <span class="hljs-comment">// 设备名称</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEVICE_NAME <span class="hljs-meta-string">&quot;video=Integrated Camera&quot;</span></span><br>    <span class="hljs-comment">// YUV文件名</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILENAME <span class="hljs-meta-string">&quot;F:/out.yuv&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FMT_NAME <span class="hljs-meta-string">&quot;avfoundation&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEVICE_NAME <span class="hljs-meta-string">&quot;0&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILENAME <span class="hljs-meta-string">&quot;/Users/chenjingpo/Desktop/out.yuv&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR_BUF(ret) \</span><br><span class="hljs-meta">    char errbuf[1024]; \</span><br><span class="hljs-meta">    av_strerror(ret, errbuf, sizeof (errbuf));</span><br></code></pre></td></tr></table></figure>

<h2 id="注册设备"><a href="#注册设备" class="headerlink" title="注册设备"></a>注册设备</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1. 初始化libavdevice并注册所有输入和输出设备</span><br>    <span class="hljs-built_in">avdevice_register_all</span>(); <span class="hljs-comment">// 只要执行1次注册设备的代码</span><br></code></pre></td></tr></table></figure>

<h2 id="获取输入格式对象"><a href="#获取输入格式对象" class="headerlink" title="获取输入格式对象"></a>获取输入格式对象</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 2. 获取输入格式对象</span><br>    <span class="hljs-keyword">const</span> AVInputFormat *fmt = <span class="hljs-built_in">av_find_input_format</span>(FMT_NAME);<br>    <span class="hljs-keyword">if</span>(!fmt) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_find_input_format error&quot;</span> &lt;&lt; FMT_NAME;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="打开输入设备"><a href="#打开输入设备" class="headerlink" title="打开输入设备"></a>打开输入设备</h2><ul>
<li>这里输入设备参数固定传入了，这是因为<code>ffmpeg</code>是音视频编解码的框架， 无法获取音视频设备的具体参数</li>
<li><strong>注意</strong>如果输入的视频参数不对(非当前设备所支持)，则无法打开设备<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 3. 打开输入设备</span><br>    <span class="hljs-comment">// 格式化上下文将来利用上下文操纵设备）</span><br>    AVFormatContext *ctx = <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-comment">// 传递给输入设备的参数</span><br>    AVDictionary *options = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">av_dict_set</span>(&amp;options,<span class="hljs-string">&quot;pixel_format&quot;</span>,<span class="hljs-string">&quot;yuyv422&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">av_dict_set</span>(&amp;options,<span class="hljs-string">&quot;video_size&quot;</span>,<span class="hljs-string">&quot;640x480&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">av_dict_set</span>(&amp;options, <span class="hljs-string">&quot;framerate&quot;</span>, <span class="hljs-string">&quot;30&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 打开输入设备</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avformat_open_input</span>(&amp;ctx,DEVICE_NAME,fmt,&amp;options);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avformat_open_input error&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="具体输入设备参数"><a href="#具体输入设备参数" class="headerlink" title="具体输入设备参数"></a>具体输入设备参数</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取输入流</span><br>   AVStream *stream = ctx-&gt;streams[<span class="hljs-number">0</span>];<br>   <span class="hljs-comment">// 获取视频参数，和录制音频一样</span><br>   AVCodecParameters *params = stream-&gt;codecpar;<br>   <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;视频格式&quot;</span> &lt;&lt; <span class="hljs-built_in">av_get_pix_fmt_name</span>((AVPixelFormat)params-&gt;format);<br>   <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;宽度&quot;</span> &lt;&lt; params-&gt;width;<br>   <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;高度&quot;</span> &lt;&lt; params-&gt;height;<br>   <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;framerate&quot;</span> &lt;&lt; params-&gt;height;<br></code></pre></td></tr></table></figure>

<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 4. 打开文件</span><br>   <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(FILENAME)</span></span>;<br>   <span class="hljs-keyword">if</span>(!file.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>       <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; FILENAME;<br><br>       <span class="hljs-comment">// 关闭输入设备</span><br>       <span class="hljs-built_in">avformat_close_input</span>(&amp;ctx);<br>       <span class="hljs-keyword">return</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="采集视频数据"><a href="#采集视频数据" class="headerlink" title="采集视频数据"></a>采集视频数据</h2><ul>
<li>每次采集实际上是一张图片大小，即<code>imageSize</code>。这里实测，<code>pkt-&gt;size</code>可能比<code>imageSize</code>大。因此采用<code>imageSize</code>作为写入的长度<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 5.采集视频数据</span><br>AVStream *stream = ctx-&gt;streams[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 获取视频参数，和录制音频一样</span><br>AVCodecParameters *params = stream-&gt;codecpar;<br><span class="hljs-comment">// 获取每一帧的大小</span><br>    <span class="hljs-keyword">int</span> imageSize = <span class="hljs-built_in">av_image_get_buffer_size</span>((AVPixelFormat)params-&gt;format,params-&gt;width,params-&gt;height,<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 数据包</span><br>    AVPacket *pkt = <span class="hljs-built_in">av_packet_alloc</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isInterruptionRequested</span>()) &#123;<br>        <span class="hljs-comment">// 不断采集数据</span><br>        ret = <span class="hljs-built_in">av_read_frame</span>(ctx,pkt);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 读取成功</span><br>            <span class="hljs-comment">// 将数据写入文件,视频每次写一张图片</span><br>            file.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *) pkt-&gt;data, imageSize);<br>            <span class="hljs-comment">// 实际数据 614400 615680</span><br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;实际数据&quot;</span>&lt;&lt; imageSize &lt;&lt; pkt-&gt;size;<br>            <br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             这里要使用imageSize，而不是pkt-&gt;size。</span><br><span class="hljs-comment">             pkt-&gt;size有可能比imageSize大（比如在Mac平台），</span><br><span class="hljs-comment">             使用pkt-&gt;size会导致写入一些多余数据到YUV文件中，</span><br><span class="hljs-comment">             进而导致YUV内容无法正常播放</span><br><span class="hljs-comment">            */</span><br><br>            <span class="hljs-comment">// 释放资源</span><br>            <span class="hljs-built_in">av_packet_unref</span>(pkt);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN)) &#123; <span class="hljs-comment">// 资源临时不可用</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他错误</span><br>            <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_read_frame error&quot;</span> &lt;&lt; errbuf;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 释放资源</span><br><span class="hljs-built_in">av_packet_free</span>(&amp;pkt);<br><br><span class="hljs-comment">// 关闭文件</span><br>file.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-comment">// 关闭设备</span><br><span class="hljs-built_in">avformat_close_input</span>(&amp;ctx);<br></code></pre></td></tr></table></figure>

<h2 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h2><ul>
<li>通过命令行播放视频，验证结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ffplay -video_size 640x480 -pixel_format yuyv422 -framerate 30 out.yuv<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>yuv格式图片</title>
    <url>/2023/10/29/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/yuv%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="图片初识"><a href="#图片初识" class="headerlink" title="图片初识"></a><a href="https://www.cnblogs.com/mjios/p/14661561.html">图片初识</a></h1><h2 id="RGB颜色模型"><a href="#RGB颜色模型" class="headerlink" title="RGB颜色模型"></a>RGB颜色模型</h2><blockquote>
<p><code>RGB</code>颜色模型（<code>RGB color model</code>），又称为三原色光模式</p>
</blockquote>
<ul>
<li>每个像素的颜色，可以通过红色、绿色、蓝色以不同的含量混合而成。比如：<ul>
<li>红色（<code>Red</code>）、绿色（<code>Green</code>）可以合成：黄色（<code>Yellow</code>）</li>
<li>红色（<code>Red</code>）、蓝色（<code>Blue</code>）可以合成：洋红色（<code>Magenta</code>）</li>
<li>绿色（<code>Green</code>）、蓝色（<code>Blue</code>）可以合成：青色（<code>Cyan</code>）</li>
<li>红色（<code>Red</code>）、绿色（<code>Green</code>）、蓝色（<code>Blue</code>）可以合成：白色（<code>White</code>）</li>
</ul>
</li>
</ul>
<h2 id="位深度"><a href="#位深度" class="headerlink" title="位深度"></a>位深度</h2><ul>
<li><p>每一个像素的颜色信息是如何存储的呢？</p>
<ul>
<li>取决于图片的位深度（<code>Bit Depth</code>），也称为：色彩深度（<code>Color Depth</code>，简称：色深）</li>
<li>如果一张图片的位深度为<code>n</code>，那么它的每一个像素都会使用<code>n</code>个二进制位来存储颜色信息</li>
</ul>
</li>
<li><p>如果位深度为<code>n</code>，那么每一个像素能显示<code>2n</code>种颜色。</p>
<ul>
<li>所以，位深度为<code>24</code>时，每一个像素能显示<code>224</code>种颜色，也就是<code>16777216</code>种颜色（约<code>1678</code>万）</li>
<li><code>24bit</code>颜色，也被称为是：真彩色（<code>True Color</code>），也就是常说的<code>24</code>位真彩</li>
</ul>
</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="图片压缩类型"><a href="#图片压缩类型" class="headerlink" title="图片压缩类型"></a>图片压缩类型</h3><ul>
<li>图片的压缩类型可以分为<code>2</code>种：<ul>
<li>无损压缩</li>
<li>不损失图片质量</li>
<li>压缩比小，体积大</li>
<li>解压（显示）后能够还原出完整的原始图片数据，不会损失任何图片信息</li>
</ul>
</li>
<li>有损压缩<ul>
<li>会损失图片质量</li>
<li>压缩比大，体积小</li>
<li>解压（显示）后无法还原出完整的原始图片数据，会损失掉一些图片信息</li>
</ul>
</li>
<li>压缩比 = 未压缩大小 / 压缩后大小</li>
</ul>
<table>
<thead>
<tr>
<th>格式</th>
<th>压缩类型</th>
<th>位深度</th>
</tr>
</thead>
<tbody><tr>
<td>JPG（JPEG）</td>
<td>有损压缩</td>
<td>24bit</td>
</tr>
<tr>
<td>PNG</td>
<td>无损压缩</td>
<td>8bit、24bit、32bit</td>
</tr>
<tr>
<td>GIF</td>
<td>无损压缩</td>
<td>8bit</td>
</tr>
</tbody></table>
<h1 id="YUV详解"><a href="#YUV详解" class="headerlink" title="YUV详解"></a><a href="https://www.cnblogs.com/mjios/p/14686970.html">YUV详解</a></h1><blockquote>
<p><code>YUV</code>，是一种颜色编码方法，跟<code>RGB</code>是同一个级别的概念，广泛应用于多媒体领域中。也就是说，图像中每<code>1</code>个像素的颜色信息，除了可以用RGB的方式表示，也可以用<code>YUV</code>的方式表示。</p>
</blockquote>
<h2 id="vs-RGB"><a href="#vs-RGB" class="headerlink" title="vs RGB"></a><code>vs RGB</code></h2><blockquote>
<p>对比<code>RGB</code>，<code>YUV</code>有哪些不同和优势呢？</p>
</blockquote>
<h3 id="体积更小"><a href="#体积更小" class="headerlink" title="体积更小"></a>体积更小</h3><ul>
<li>如果使用<code>RGB</code><ul>
<li>比如<code>RGB888</code>（<code>R</code>、<code>G</code>、<code>B</code>每个分量都是<code>8bit</code>）</li>
<li><code>1</code>个像素占用<code>24bit</code>（<code>3</code>字节）</li>
</ul>
</li>
<li>如果使用<code>YUV</code><ul>
<li><code>1</code>个像素可以减小至平均只占用<code>12bit</code>（<code>1.5</code>字节）</li>
<li>体积为<code>RGB888</code>的一半</li>
</ul>
</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote>
<ul>
<li><code>RGB</code>数据由<code>R</code>、<code>G</code>、<code>B</code>三个分量组成。</li>
<li><code>YUV</code>数据由<code>Y</code>、<code>U</code>、<code>V</code>三个分量组成，现在通常说的<code>YUV</code>指的是<code>YCbCr</code>。</li>
</ul>
</blockquote>
<ul>
<li><code>Y</code>：表示亮度（<code>Luminance、Luma</code>），占<code>8bit</code>（<code>1</code>字节）</li>
<li><code>Cb</code>、<code>Cr</code>：表示色度（<code>Chrominance、Chroma</code>）<ul>
<li><code>Cb</code>（<code>U</code>）：蓝色色度分量，占<code>8bit</code>（<code>1</code>字节）</li>
<li><code>Cr</code>（<code>V</code>）：红色色度分量，占<code>8bit</code>（<code>1</code>字节）</li>
</ul>
</li>
</ul>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul>
<li><code>Y</code>分量对呈现出清晰的图像有着很大的贡献</li>
<li><code>Cb</code>、<code>Cr</code>分量的内容不太容易识别清楚</li>
<li><code>YUV</code>的发明处在彩色电视与黑白电视的过渡时期。<ul>
<li><code>YUV</code>将亮度信息（<code>Y</code>）与色度信息（<code>UV</code>）分离，没有<code>UV</code>信息一样可以显示完整的图像，只不过是黑白的</li>
<li>这样的设计很好地解决了彩色电视与黑白电视的兼容性问题，使黑白电视也能够接收彩色电视信号，只不过它只显示了<code>Y</code>分量</li>
<li>彩色电视有<code>Y</code>、<code>U</code>、<code>V</code>分量，如果去掉<code>UV</code>分量，剩下的<code>Y</code>分量和黑白电视相同</li>
</ul>
</li>
</ul>
<h2 id="RBG和YUV转换"><a href="#RBG和YUV转换" class="headerlink" title="RBG和YUV转换"></a>RBG和YUV转换</h2><h3 id="公式1"><a href="#公式1" class="headerlink" title="公式1"></a>公式1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y = 0.257R + 0.504G + 0.098B + 16<br>U = -0.148R - 0.291G + 0.439B + 128<br>V = 0.439R - 0.368G - 0.071B + 128<br> <br>R = 1.164(Y - 16) + 2.018(U - 128)<br>G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128)<br>B = 1.164(Y - 16) + 1.596(V - 128)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>RGB</code>的取值范围是<code>[0,255]</code></li>
<li><code>Y</code>的取值范围是<code>[16,235]</code></li>
<li><code>UV</code>的取值范围是<code>[16,239]</code></li>
</ul>
<h3 id="公式2"><a href="#公式2" class="headerlink" title="公式2"></a>公式2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y = 0.299R + 0.587G + 0.114B<br>U = 0.564(B - Y) = -0.169R - 0.331G + 0.500B<br>V = 0.713(R - Y) = 0.500R - 0.419G - 0.081B<br> <br>R = Y + 1.403V<br>G = Y - 0.344U - 0.714V<br>B = Y + 1.770U<br></code></pre></td></tr></table></figure>
<ul>
<li><code>RGB</code>的取值范围是<code>[0, 1]</code></li>
<li><code>Y</code>的取值范围是<code>[0, 1]</code></li>
<li><code>UV</code>的取值范围是<code>[-0.5, 0.5]</code></li>
</ul>
<h3 id="公式3"><a href="#公式3" class="headerlink" title="公式3"></a>公式3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y = 0.299R + 0.587G + 0.114B<br>U = -0.169R - 0.331G + 0.500B + 128<br>V = 0.500R - 0.419G - 0.081B + 128<br> <br>R = Y + 1.403(V - 128)<br>G = Y - 0.343(U - 128) - 0.714(V - 128)<br>B = Y + 1.770(U - 128)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>RGB</code>的取值范围是<code>[0, 255]</code></li>
<li><code>YUV</code>的取值范围是<code>[0, 255]</code></li>
</ul>
<h2 id="色度二次采样"><a href="#色度二次采样" class="headerlink" title="色度二次采样"></a>色度二次采样</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>人眼的视网膜上，分布着两种感光细胞：<code>视杆细胞</code>和<code>视锥细胞</code>。</p>
</blockquote>
<ul>
<li><code>视杆细胞</code><ul>
<li>感知<code>光线的强弱</code></li>
<li>没有色彩识别功能</li>
<li>负责夜间非彩色视觉</li>
</ul>
</li>
<li><code>视锥细胞</code><ul>
<li>感知<code>颜色</code></li>
<li>负责白天彩色视觉</li>
<li>如果你的视锥细胞发育不正常，数量太少，那感知颜色就会受阻，可能会导致你色弱</li>
</ul>
</li>
</ul>
<p>人眼中有上亿个感光细胞，其中视杆细胞占了<code>95%</code>，而视锥细胞仅占<code>5%</code>。<br>因此，人眼对亮度的敏感程度要高于对色度的敏感程度，人眼对于亮度的分辨要比对颜色的分辨精细一些。<br>如果把图像的色度分量(<code>U</code>,<code>V</code>)减少一些，人眼也丝毫感觉不到变化和差异。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>如果在色度分量上进行（相对亮度分量）较低分辨率的采样，也就是存储较多的亮度细节、较少的色度细节，这样就可以在不明显降低画面质量的同时减小图像的体积。上述过程称为：色度二次采样（<code>Chroma Subsampling</code>）</p>
</blockquote>
<h3 id="采样格式"><a href="#采样格式" class="headerlink" title="采样格式"></a>采样格式</h3><p>采样格式通常用<code>A:B:C</code>的形式来表示，比如<code>4:4:4</code>、<code>4:2:2</code>、<code>4:2:0</code>等，其中我们最需要关注的是<code>4:2:0</code>。</p>
<p><img src="1.png"></p>
<p><img src="2.png"></p>
<ul>
<li>上图中，不管是哪种采样格式，<code>Y</code>分量都是全水平、全垂直分辨率采样的，每一个像素都有自己独立的<code>Y</code>分量。</li>
</ul>
<h4 id="4-4-4"><a href="#4-4-4" class="headerlink" title="4:4:4"></a><code>4:4:4</code></h4><ul>
<li>第<code>1</code>行采集<code>4</code>组<code>CbCr</code>分量，第<code>2</code>行采集<code>4</code>组<code>CbCr</code>分量</li>
<li>每<code>1</code>个像素都有自己独立的<code>1</code>组<code>CbCr</code>分量<ul>
<li><code>Y</code>分量与<code>CbCr</code>分量的水平方向比例是<code>1:1</code>（每<code>1</code>列都有<code>1</code>组<code>CbCr</code>分量）</li>
<li><code>Y</code>分量与<code>CbCr</code>分量的垂直方向比例是<code>1:1</code>（每<code>1</code>行都有<code>1</code>组<code>CbCr</code>分量）</li>
<li><code>Y</code>分量与<code>CbCr</code>分量的总比例是<code>1:1</code></li>
</ul>
</li>
<li><code>1</code>个像素占用<code>24bit</code>（<code>3</code>字节），跟<code>RGB888</code>的体积一样<ul>
<li><code>24bpp（bits per pixel</code>）</li>
</ul>
</li>
<li>这种格式是没有进行色度二次采样的<ul>
<li>叉叉代表：亮度。</li>
<li>圆圈代表：色度。<br>  <img src="3.gif"></li>
</ul>
</li>
</ul>
<h4 id="4-2-2"><a href="#4-2-2" class="headerlink" title="4:2:2"></a><code>4:2:2</code></h4><ul>
<li>第<code>1</code>行采集<code>2</code>组<code>CbCr</code>分量，第<code>2</code>行采集<code>2</code>组<code>CbCr</code>分量</li>
<li>水平方向相邻的<code>2</code>个像素（<code>1</code>行<code>2</code>列）共用<code>1</code>组<code>CbCr</code>分量<ul>
<li><code>Y</code>分量与<code>CbCr</code>分量的水平方向比例是<code>2:1</code>（每<code>2</code>列就有<code>1</code>组<code>CbCr</code>分量）</li>
<li><code>Y</code>分量与<code>CbCr</code>分量的垂直方向比例是<code>1:1</code>（每<code>1</code>行都有<code>1</code>组<code>CbCr</code>分量）</li>
<li><code>Y</code>分量与<code>CbCr</code>分量的总比例是<code>2:1</code></li>
</ul>
</li>
<li><code>1</code>个像素平均占用<code>16bit</code>（<code>2</code>字节）<ul>
<li><code>16bpp</code></li>
<li>因为<code>2</code>个像素共占用<code>32bit</code>（<code>4字节</code> = <code>2</code>个<code>Y</code>分量 + <code>1</code>个<code>Cb</code>分量 + <code>1</code>个<code>Cr</code>分量）</li>
</ul>
</li>
<li>这种格式是没有进行色度二次采样的<ul>
<li>叉叉代表：亮度。</li>
<li>圆圈代表：色度。<br>  <img src="4.gif"></li>
</ul>
</li>
</ul>
<h4 id="4-2-0"><a href="#4-2-0" class="headerlink" title="4:2:0"></a><code>4:2:0</code></h4><ul>
<li><p>第<code>1</code>行采集<code>2</code>组<code>CbCr</code>分量，第<code>2</code>行共享第<code>1</code>行的<code>CbCr</code>分量</p>
</li>
<li><p>相邻的<code>4</code>个像素（<code>2</code>行<code>2</code>列）共用<code>1</code>组<code>CbCr</code>分量</p>
<ul>
<li><code>Y</code>分量与<code>CbCr</code>分量的水平方向比例是<code>2:1</code>（每<code>2</code>列就有<code>1</code>组<code>CbCr</code>分量）</li>
<li><code>Y</code>分量与<code>CbCr</code>分量的垂直方向比例是<code>2:1</code>（每<code>2</code>行就有<code>1</code>组<code>CbCr</code>分量）</li>
<li><code>Y</code>分量与<code>CbCr</code>分量的总比例是<code>4:1</code></li>
</ul>
</li>
<li><p><code>1</code>个像素平均占用<code>12bit</code>（<code>1.5</code>字节）</p>
<ul>
<li><code>12bpp</code></li>
<li>因为<code>4</code>个像素共占用<code>48bit</code>（<code>6</code>字节 = <code>4</code>个<code>Y</code>分量 + <code>1</code>个<code>Cb</code>分量 + <code>1</code>个Cr分量）</li>
</ul>
</li>
<li><p>这种格式是没有进行色度二次采样的</p>
<ul>
<li>叉叉代表：亮度。</li>
<li>圆圈代表：色度。<br>  <img src="5.gif"></li>
</ul>
</li>
</ul>
<h2 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h2><blockquote>
<p>存储格式，决定了<code>YUV</code>数据是如何排列和存储的。本文只介绍一些常见的存储格式。</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><code>YUV</code>的存储格式可以分为<code>3</code>大类：<ul>
<li><code>Planar</code>（平面）<ul>
<li><code>Y</code>、<code>U</code>、<code>V</code>分量分开单独存储</li>
<li>名称通常以字母<code>p</code>结尾</li>
</ul>
</li>
<li><code>Semi-Planar</code>（半平面）<ul>
<li><code>Y</code>分量单独存储，<code>U</code>、<code>V</code>分量交错存储</li>
<li>名称通常以字母<code>sp</code>结尾</li>
</ul>
</li>
<li><code>Packed</code>（紧凑）<ul>
<li>或者叫<code>Interleaved</code> （交错）</li>
<li><code>Y</code>、<code>U</code>、<code>V</code>分量交错存储</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-4-4-1"><a href="#4-4-4-1" class="headerlink" title="4:4:4"></a><code>4:4:4</code></h4><p><img src="6.png"></p>
<h5 id="Planar"><a href="#Planar" class="headerlink" title="Planar"></a><code>Planar</code></h5><ul>
<li><p><code>I444</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>U U U U<br>U U U U<br>V V V V<br>V V V V<br></code></pre></td></tr></table></figure></li>
<li><p><code>YV24</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>V V V V<br>V V V V<br>U U U U<br>U U U U<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="Semi-Planar"><a href="#Semi-Planar" class="headerlink" title="Semi-Planar"></a><code>Semi-Planar</code></h5><ul>
<li><p><code>NV24</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>U V U V U V U V<br>U V U V U V U V<br></code></pre></td></tr></table></figure></li>
<li><p><code>NV42</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>V U V U V U V U<br>V U V U V U V U<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-2-2-1"><a href="#4-2-2-1" class="headerlink" title="4:2:2"></a><code>4:2:2</code></h4><p><img src="7.png"></p>
<h5 id="Planar-1"><a href="#Planar-1" class="headerlink" title="Planar"></a><code>Planar</code></h5><ul>
<li><p><code>I422</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>U U<br>U U<br>V V<br>V V<br></code></pre></td></tr></table></figure></li>
<li><p><code>YV16</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>V V<br>V V<br>U U<br>U U<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="Semi-Planar-1"><a href="#Semi-Planar-1" class="headerlink" title="Semi-Planar"></a><code>Semi-Planar</code></h5><ul>
<li><p><code>NV16</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>U V U V<br>U V U V<br></code></pre></td></tr></table></figure></li>
<li><p><code>NV61</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>V U V U<br>V U V U<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="Packed"><a href="#Packed" class="headerlink" title="Packed"></a><code>Packed</code></h4><ul>
<li><p><code>UYVY</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">U Y V Y U Y V Y<br>U Y V Y U Y V Y<br></code></pre></td></tr></table></figure></li>
<li><p><code>YUYV</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y U Y V Y U Y V <br>Y U Y V Y U Y V <br></code></pre></td></tr></table></figure></li>
<li><p><code>YVYU</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y V Y U Y V Y U<br>Y V Y U Y V Y U<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-2-0-1"><a href="#4-2-0-1" class="headerlink" title="4:2:0"></a><code>4:2:0</code></h4><p><img src="8.png"></p>
<h5 id="Planar-2"><a href="#Planar-2" class="headerlink" title="Planar"></a><code>Planar</code></h5><ul>
<li><p><code>I420</code></p>
<ul>
<li>大多数视频解码器以<code>I420</code>格式输出原始图片<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>U U<br>V V<br></code></pre></td></tr></table></figure>
<img src="9.png"></li>
</ul>
</li>
<li><p><code>YV12</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>V V<br>U U<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="Semi-Planar-2"><a href="#Semi-Planar-2" class="headerlink" title="Semi-Planar"></a><code>Semi-Planar</code></h5><ul>
<li><p><code>NV12</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>U V U V<br></code></pre></td></tr></table></figure></li>
<li><p><code>NV21</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y Y Y Y<br>Y Y Y Y<br>V U V U<br></code></pre></td></tr></table></figure></li>
</ul>
<p><img src="10.png"></p>
<h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><h3 id="其他图片格式转YUV"><a href="#其他图片格式转YUV" class="headerlink" title="其他图片格式转YUV"></a>其他图片格式转<code>YUV</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ffmpeg -i in.png -s 512x512 -pix_fmt yuv420p out.yuv<br></code></pre></td></tr></table></figure>
<ul>
<li>上述命令生成的<code>yuv</code>文件大小是：<code>393216</code>字节 = <code>512</code> * <code>512</code> * <code>1.5</code>字节。<ul>
<li><code>s</code><ul>
<li>设置图片的尺寸</li>
<li>可以用一些<a href="https://ffmpeg.org/ffmpeg-all.html#Video-size">固定字符串</a>表示尺寸，比如<code>hd720</code>表示<code>1280x720</code>、<code>2k</code>表示<code>2048x1080</code></li>
</ul>
</li>
<li><code>-pix_fmt</code><ul>
<li>设置像素格式</li>
<li>可以通过<code>ffmpeg -pix_fmts</code>查看<code>FFmpeg</code>支持的像素格式</li>
<li>如果不设置此选项，默认会跟随输入图片的像素格式<ul>
<li>比如可能是<code>rgb24</code>、<code>rgba8</code>、<code>pal8</code>等</li>
<li>可以通过<code>ffprobe</code>查看某图片的像素格式，比如<code>ffprobe in.png</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="YUV转其他图片格式"><a href="#YUV转其他图片格式" class="headerlink" title="YUV转其他图片格式"></a><code>YUV</code>转其他图片格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ffmpeg -s 512x512 -pix_fmt yuv420p -i in.yuv out.jpg<br></code></pre></td></tr></table></figure>
<ul>
<li>这里必须得设置<code>YUV</code>的尺寸（<code>-s</code>）、像素格式（<code>-pix_fmt</code>）</li>
<li>这就类似于：对<code>pcm</code>进行编码时，必须得设置采样率（<code>-ar</code>）、声道数（<code>-ac</code>）、采样格式（<code>-f</code>）</li>
</ul>
<h2 id="显示YUV"><a href="#显示YUV" class="headerlink" title="显示YUV"></a>显示YUV</h2><h3 id="完整的YUV"><a href="#完整的YUV" class="headerlink" title="完整的YUV"></a>完整的YUV</h3><ul>
<li>可以通过<code>ffplay</code>显示<code>YUV</code>数据。<ul>
<li><code>YUV</code>中直接存储的是所有像素的颜色信息（可以理解为是图像的一种原始数据）</li>
<li>必须得设置<code>YUV</code>的尺寸、像素格式才能正常显示<ul>
<li>注意<code>ffplay</code>的尺寸是<code>-video_size</code>，而非<code>-s</code></li>
<li>像素格式是<code>-pixel_format</code>,而非<code>-pix_fmt</code></li>
</ul>
</li>
<li>这就类似于：播放pcm时，必须得设置采样率（<code>-ar</code>）、声道数（<code>-ac</code>）、采样格式（<code>-f</code>）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ffplay -video_size 512x512 -pixel_format yuv420p in.yuv<br></code></pre></td></tr></table></figure>

<h3 id="单个分量"><a href="#单个分量" class="headerlink" title="单个分量"></a>单个分量</h3><ul>
<li>可以使用过滤器（filter）显示其中的单个分量（<code>r</code>、<code>g</code>、<code>b</code>、<code>y</code>、<code>u</code>、<code>v</code>）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 只显示r分量<br>ffplay -vf extractplanes=r in.png<br> <br># 只显示g分量<br>ffplay -vf extractplanes=g in.png<br> <br># 只显示b分量<br>ffplay -vf extractplanes=b in.png<br> <br># 只显示y分量<br>ffplay -video_size 512x512 -pixel_format yuv420p -vf extractplanes=y in.yuv<br># 只显示y分量<br>ffplay -video_size 512x512 -pixel_format yuv420p -vf extractplanes=u in.yuv<br># 只显示y分量<br>ffplay -video_size 512x512 -pixel_format yuv420p -vf extractplanes=v in.yuv<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>-vf</code></p>
<ul>
<li>设置视频过滤器</li>
<li>等价写法：<code>-filter:v</code></li>
</ul>
</li>
<li><p><a href="https://ffmpeg.org/ffmpeg-filters.html#extractplanes"><code>extractplanes</code></a></p>
<ul>
<li>抽取单个分量的内容到灰度视频流中</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>基本语法学习</title>
    <url>/2023/10/12/C++%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote>
<p>c语言是没有函数重载的</p>
</blockquote>
<ul>
<li>规则<ul>
<li>函数名相同</li>
<li>参数个数不同、参数类型不同、参数顺序不同<ul>
<li><code>c++</code>和<code>OC</code>中只有返回值不同，无法重载，但是<code>swift</code>可以，但是会有二义性，需要在使用时，指定返回值类型</li>
</ul>
</li>
</ul>
</li>
<li>注意<ul>
<li>返回值类型与函数重载无关</li>
<li>调用函数时，实参的隐式类型转换可能会产生二义性</li>
</ul>
</li>
<li>本质<ul>
<li>采用了<code>name mangling</code>或者叫<code>name decoration</code>技术（函数方法名尽管相同，但是在编译时，会根据参数不同生成不同的函数名）</li>
</ul>
</li>
</ul>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><ul>
<li><code>C++</code>允许函数设置默认参数，在调用时可以根据情况省略实参。规则如下：<ul>
<li>默认参数只能按照右到左的顺序</li>
<li>如果函数同时有<code>声明</code>、<code>实现</code>，默认参数<strong>只能放在函数声明</strong>中</li>
<li>默认参数的值可以是常量、全局符号（全局变量、函数名)</li>
</ul>
</li>
<li><strong>注意</strong>,函数重载、默认参数可能会产生冲突、二义性（建议优先选择使用默认参数）,<code>swift</code>也是如此</li>
</ul>
<h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a><code>extern</code></h1><blockquote>
<p>由于<code>c++</code>编译后的函数（采用<code>name mangling</code>）和<code>c</code>编译的函数不同，因此如果在<code>C++</code>中直接调用<code>c</code>的函数，会找不到<code>c</code>函数，因此需要用<code>extern &quot;C&quot;</code>，将<code>c</code>函数以<code>c++</code>的方式编译</p>
</blockquote>
<ul>
<li>被<code>extern</code> <code>&quot;C&quot;</code>修饰的代码会按照<code>C</code>语言的方式去编译</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果函数同时有声明和实现，要让函数声明被<code>extern &quot;C&quot;</code>修饰，函数实现可以不修饰<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="防止头文件的内容被重复包含"><a href="#防止头文件的内容被重复包含" class="headerlink" title="防止头文件的内容被重复包含"></a>防止头文件的内容被重复包含</h1><ul>
<li><p>经常使用<code>#ifndef</code>、<code>#define</code>、<code>#endif</code>来防止头文件的内容被重复包含</p>
<ul>
<li><code>objc.h</code>文件就算导入多次，由于<code>#ifndef</code>的判断<code>void func();</code>也只会包含一次</li>
<li><code>_OBJC_H·</code>一般采用当前的文件名，作为判断<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// objc.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span>  _OBJC_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  _OBJC_H</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>#pragma once</code>可以防止整个文件的内容被重复包含</p>
</li>
</ul>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><ul>
<li><code>#ifndef</code>、<code>#define</code>、<code>#endif</code>受<code>C\C++</code>标准的支持，不受编译器的任何限制</li>
<li>有些编译器不支持<code>#pragma once</code>（较老编译器不支持，如<code>GCC 3.4</code>版本之前），兼容性不够好</li>
<li><code>#ifndef</code>、<code>#define</code>、<code>#endif</code>可以针对一个文件中的部分代码，而<code>#pragma once</code>只能针对整个文件</li>
</ul>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><blockquote>
<p> <code>C++</code>的有些表达式是可以被赋值的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 赋值给了a</span><br>(a = b) = <span class="hljs-number">3</span>; <span class="hljs-comment">// a 3， b 2</span><br><span class="hljs-comment">// 赋值给了b</span><br>(a &lt; b ? a:b) = <span class="hljs-number">4</span>; a <span class="hljs-number">3</span>, b <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li>在<code>C</code>语言中，使用指针（<code>Pointer</code>）可以间接获取、修改某个变量的值</li>
<li>在<code>C++</code>中，使用引用（<code>Reference</code>）可以起到跟指针类似的功能<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// rage即为引用</span><br><span class="hljs-keyword">int</span> &amp;rage = age;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>引用相当于是变量的别名（基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用）<ul>
<li>和指针不同，因为是别名，表示在任何地方都代表最开始的值<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> height = <span class="hljs-number">40</span>;<br><span class="hljs-comment">// rage即为引用</span><br><span class="hljs-keyword">int</span> &amp;rage = age;<br>rage = height; <span class="hljs-comment">// age 40 , height 40</span><br>rage = <span class="hljs-number">10</span>; <span class="hljs-comment">// age 10,height 40</span><br><br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变，“从一而终”。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">&amp;rage = height;<span class="hljs-comment">// 错误，因为rage就是age，&amp;rage是age的地址，是不等于height的</span><br></code></pre></td></tr></table></figure></li>
<li>对引用做计算，就是对引用所指向的变量做计算，可以利用这个，实现函数传值 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,in b)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> temp = a<br>     a = b<br>     b = temp<br>&#125;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>,b = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">swap</span>(a,b);<span class="hljs-comment">// 函数调用后，a,b是没有交换的，仍然是 a = 20,b = 30</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a,in &amp;b)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> temp = a<br>     a = b<br>     b = temp<br>&#125;<br> <span class="hljs-built_in">swap1</span>(a,b); <span class="hljs-comment">// 函数调用后，a,b会交换的,因为函数内的a,b是引用，函数里面的引用可以指代外面的值</span><br> <br></code></pre></td></tr></table></figure>
</li>
<li>可以利用引用初始化另一个引用，相当于某个变量的多个别名</li>
<li>不存在【引用的引用、指向引用的指针、引用数组】</li>
</ul>
<h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><ul>
<li>引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针</li>
<li>一个引用占用一个指针的大小</li>
</ul>
<h2 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h2><ul>
<li>这里<code>ref</code>是指针<code>p</code>的引用。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span><br><span class="hljs-keyword">int</span> *p = &amp;age<br><span class="hljs-keyword">int</span> * &amp;ref = p;<span class="hljs-comment">// 这里引用类型是int *的指针</span><br>*ref = <span class="hljs-number">30</span>; <span class="hljs-comment">// age = 30</span><br><br><span class="hljs-keyword">int</span> height = <span class="hljs-number">30</span>；<br>ref = &amp;height;<span class="hljs-comment">// 修改指针的指向</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (&amp;ref)[<span class="hljs-number">3</span>] = arr;<br>ref[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">//修改过arr的第一项</span><br><span class="hljs-comment">// 也可以</span><br><span class="hljs-comment">// int * &amp;ref1 = arr;报错，因为arr时常量，必须用常量指针引用</span><br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> &amp;ref1 = arr; <br></code></pre></td></tr></table></figure>

<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><ul>
<li><p>引用可以被<code>const</code>修饰，这样就无法通过引用修改数据了，可以称为常引用</p>
<ul>
<li><code>const</code>必须写在<code>&amp;</code>符合的左边，才能算常引用。（右边，代表无法改变指向，而引用本身就无法改变）  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> hegiht = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> &amp;ref = age;<br><span class="hljs-comment">// ref = 20; 无法赋值，引用其实就是指针，可看作 int const * ref = age;因此*ref = 20;会失败</span><br><span class="hljs-keyword">int</span> &amp; <span class="hljs-keyword">const</span> ref = age; <span class="hljs-comment">// ref无法修改执行，对于引用本身是无法修改指向的。这里加不加const一样</span><br>ref = <span class="hljs-number">30</span>; <span class="hljs-comment">// 可以赋值，这里常量修饰的是指针，但是可以修改所指向的变量</span><br><span class="hljs-comment">// p1不能修改指向，可以利用p1简介修改所指向的变量</span><br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p1 = &amp;age;<br>*p1 = <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// p2可以修改过指向，不可以利用p2间接修改所指向的变量</span><br><span class="hljs-keyword">int</span> cont *p2 = &amp;age;<br>p2 = &amp;height;<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>cost</code>引用的特点，(规则同样适用<code>const</code><strong>指针</strong>(如果不是指针，则不行))</p>
<ul>
<li>可以指向临时数据（常量，表达式，函数返回值等，这些返回的都是临时值）。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// int &amp;ref = 30;//30是临时值，没地址报错，加上const，就不会了</span><br> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ref = <span class="hljs-number">30</span>；<br> <br></code></pre></td></tr></table></figure></li>
<li>可以指向不同类型的数据<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;<br> <span class="hljs-comment">// double &amp;ref = age;报错</span><br> <span class="hljs-keyword">const</span>  <span class="hljs-keyword">double</span> &amp;ref = age;<span class="hljs-comment">// 正常</span><br></code></pre></td></tr></table></figure></li>
<li>作为函数参数时<ul>
<li>可以接受<code>const</code>和<code>非const</code>实参（<code>非const</code>引用，只能接受<code>非const</code>实参）<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">`非<span class="hljs-keyword">const</span>`引用，只能接受`非<span class="hljs-keyword">const</span>`实参<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;v1,<span class="hljs-keyword">int</span> &amp;v2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> v1 + v2<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// sum(a,b);报错，不接收常量</span><br><span class="hljs-comment">// sum(10,20);报错，引用不接收临时值</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> v1 + v2<br>&#125;<br> <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">// 正常</span><br></code></pre></td></tr></table></figure></li>
<li>可以跟<code>非const</code>引用构成重载,(<code>非const</code>的调用会优先<code>非const</code>)</li>
</ul>
</li>
<li>当常引用指向了不同类型的数据时，会产生<code>临时变量</code>，即引用指向的并不是<code>初始化</code>时的那个<code>变量</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ref = age;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> &amp;ref1 = age;<br><br>age = <span class="hljs-number">30</span>; <br><span class="hljs-comment">// age = 30，ref = 30。本质还是指针，相同类型不会生成一个临时变量的</span><br><span class="hljs-comment">// ref1 = 10。// ref1还是没有变化，不同类型会生成一个临时变量进行指向</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>aac解码实战</title>
    <url>/2023/10/11/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/aac%E8%A7%A3%E7%A0%81%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><a href="http://ffmpeg.org/ffmpeg-all.html#libfdk_005faac">基本使用</a></h2><ul>
<li>将<code>aac</code>文件解码成<code>pcm</code>文件<ul>
<li><code>-c:a libfdk_aac</code><ul>
<li>使用<code>fdk-aac</code>解码器</li>
<li>需要注意的是：这个参数要写在<code>aac</code>文件那边，也就是属于输入参数</li>
</ul>
</li>
<li><code>-f s16le</code><ul>
<li>设置<code>pcm</code>文件最终的采样格式<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> -c:a libfdk_aac -i in.aac -f s16le out.pcm<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><blockquote>
<p>需要用到两个库</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br>&#125;<br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR_BUF(ret) \</span><br><span class="hljs-meta">    char errbuf[1024]; \</span><br><span class="hljs-meta">    av_strerror(ret, errbuf, sizeof (errbuf));</span><br></code></pre></td></tr></table></figure>

<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><blockquote>
<p>将<code>AAC</code>的解码操作封装到一个函数内</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br>&#125;<br><br>/ 解码后的PCM参数<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;<br>    <span class="hljs-keyword">int</span> sampleRate;<br>    AVSampleFormat sampleFmt;<br>    AVChannelLayout chLayout;<br>&#125; AudioDecodeSpec;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">aac_decode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">aac_decode</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aacDecode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * inFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                          AudioDecodeSpec &amp;out)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回结果</span><br><span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 每次从输入文件中读取的长度</span><br><span class="hljs-keyword">int</span> inLen = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 是否已经读取到了输入文件的尾部</span><br><span class="hljs-keyword">int</span> inEnd = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 用来存放读取的文件数据</span><br><span class="hljs-comment">// 加上AV_INPUT_BUFFER_PADDING_SIZE是为了防止某些优化过的reader一次性读取过多导致越界。</span><br><span class="hljs-comment">// 例如（读取到IN_DATA_SIZE - 1时，再次读取10个数据，则会越界）</span><br><span class="hljs-keyword">char</span> inDataArray[IN_DATA_SIZE + AV_INPUT_BUFFER_MIN_SIZE];<br><span class="hljs-comment">// 输入数据指针，现在指向的是数组第一位</span><br><span class="hljs-keyword">char</span> *inData = inDataArray;<br><br><span class="hljs-comment">// 文件</span><br><span class="hljs-function">QFile <span class="hljs-title">inFile</span><span class="hljs-params">(inFilename)</span></span>;<br><span class="hljs-function">QFile <span class="hljs-title">outFile</span><span class="hljs-params">(out.filename)</span></span>;<br><br><span class="hljs-comment">// 解码器</span><br><span class="hljs-keyword">const</span> AVCodec *codec = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 上下文</span><br>AVCodecContext *ctx = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 解析器上下文</span><br>AVCodecParserContext *parserCtx = <span class="hljs-literal">nullptr</span>;<br><br><br><span class="hljs-comment">// 存放解码前的数据</span><br>AVPacket *pkt = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 存放解码后的数据</span><br>AVFrame *frame = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>

<h3 id="获取解码器"><a href="#获取解码器" class="headerlink" title="获取解码器"></a>获取解码器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取fdk-aac解码器</span><br>codec = <span class="hljs-built_in">avcodec_find_decoder_by_name</span>(<span class="hljs-string">&quot;libfdk_aac&quot;</span>);<br><span class="hljs-keyword">if</span>(!codec) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;decoder libfdk_aac not found&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="初始化解析器上下文"><a href="#初始化解析器上下文" class="headerlink" title="初始化解析器上下文"></a>初始化解析器上下文</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化解析器上下文</span><br>parserCtx = <span class="hljs-built_in">av_parser_init</span>(codec-&gt;id);<br><span class="hljs-keyword">if</span>(!parserCtx) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_parser_init error&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建上下文"><a href="#创建上下文" class="headerlink" title="创建上下文"></a>创建上下文</h3><blockquote>
<p>和编码不同，无需对解码上下文，进行采样率、采样格式、声道等的设置。因为<code>aac</code>文件中会具有这些信息</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建上下文</span><br>ctx = <span class="hljs-built_in">avcodec_alloc_context3</span>(codec);<br><span class="hljs-keyword">if</span> (!ctx) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_alloc_context3 error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建AVPacket"><a href="#创建AVPacket" class="headerlink" title="创建AVPacket"></a>创建<code>AVPacket</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建AVPacket</span><br>pkt = <span class="hljs-built_in">av_packet_alloc</span>();<br><span class="hljs-keyword">if</span>(!pkt) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_packet_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建AVFrame"><a href="#创建AVFrame" class="headerlink" title="创建AVFrame"></a>创建<code>AVFrame</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建AVFrame</span><br>frame = <span class="hljs-built_in">av_frame_alloc</span>();<br><span class="hljs-keyword">if</span> (!frame) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="打开解码器"><a href="#打开解码器" class="headerlink" title="打开解码器"></a>打开解码器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开解码器</span><br>ret = <span class="hljs-built_in">avcodec_open2</span>(ctx,codec,<span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_open2 error&quot;</span> &lt;&lt; errbuf;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开文件</span><br><span class="hljs-keyword">if</span>(!inFile.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error:&quot;</span> &lt;&lt; inFilename;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!outFile.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error:&quot;</span> &lt;&lt; out.filename;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 解码</span><br><span class="hljs-comment">// 读取数据</span><br>inLen = inFile.<span class="hljs-built_in">read</span>(inData,IN_DATA_SIZE);<br><span class="hljs-keyword">while</span> (inLen &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 经过解析器上下文处理</span><br>    ret = <span class="hljs-built_in">av_parser_parse2</span>(parserCtx,<br>                           ctx,<br>                           &amp;pkt-&gt;data,<br>                           &amp;pkt-&gt;size,<br>                           (<span class="hljs-keyword">uint8_t</span> *)inData,<br>                           inLen,<br>                           AV_NOPTS_VALUE,<br>                           AV_NOPTS_VALUE,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_parser_parse2 error&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br><br>    <span class="hljs-comment">// 跳过已经解析过的数据</span><br>    inData += ret;<br>    <span class="hljs-comment">// 减去已经解析过的数据</span><br>    inLen -= ret;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">if</span> (pkt-&gt;size &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">decode</span>(ctx,pkt,frame,outFile) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果数据不够了，再次读取文件</span><br>    <span class="hljs-keyword">if</span>(inLen &lt; REFILL_THRESH &amp;&amp; !inEnd) &#123;<br>        <span class="hljs-comment">// 剩余数据移动到缓冲区前,将inData开始长inLen的数据，移动到inDataArray的位置</span><br>        <span class="hljs-built_in">memmove</span>(inDataArray,inData,inLen);<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; (<span class="hljs-keyword">uint8_t</span> *)inData &lt;&lt; (<span class="hljs-keyword">uint8_t</span> *)inDataArray;<br>        <span class="hljs-comment">// 重新开始从缓冲区开始读取，此时缓冲区有效数据长度为inLen</span><br>        inData = inDataArray;<br><br>        <span class="hljs-comment">// 跨过已有数据inlen，读取填满缓冲区的文件数据,其长度，即为IN_DATA_SIZE - inLen</span><br>        <span class="hljs-keyword">int</span> len = inFile.<span class="hljs-built_in">read</span>(inData + inLen,IN_DATA_SIZE - inLen);<br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>            inLen += len;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//aac文件数据读取完了</span><br>            inEnd = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// flush解码器</span><br><span class="hljs-comment">// pkt-&gt; data = NULL;</span><br><span class="hljs-comment">// pkt-&gt; size = 0;</span><br><span class="hljs-built_in">decode</span>(ctx,<span class="hljs-literal">nullptr</span>,frame,outFile);<br></code></pre></td></tr></table></figure>

<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><blockquote>
<p>也可以通过两个<code>while</code>循环不断读取数据，来将<code>aac</code>数据，通过解析器传到<code>pkt</code>中，如果不足一采样格式的数据，则会保存在解析器中，等下次来采集</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> ((inLen = inFile.<span class="hljs-built_in">read</span>(inData,IN_DATA_SIZE)) &gt; <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;---&quot;</span> &lt;&lt; (<span class="hljs-keyword">uint8_t</span> *)inData &lt;&lt; (<span class="hljs-keyword">uint8_t</span> *)inDataArray;<br>       <span class="hljs-keyword">while</span> (inLen &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// 经过解析器上下文处理</span><br>           ret = <span class="hljs-built_in">av_parser_parse2</span>(parserCtx,<br>                                  ctx,<br>                                  &amp;pkt-&gt;data,<br>                                  &amp;pkt-&gt;size,<br>                                  (<span class="hljs-keyword">uint8_t</span> *)inData,<br>                                  inLen,<br>                                  AV_NOPTS_VALUE,<br>                                  AV_NOPTS_VALUE,<span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>               <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_parser_parse2 error&quot;</span> &lt;&lt; errbuf;<br>               <span class="hljs-keyword">goto</span> end;<br>           &#125;<br><br>           <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;------&quot;</span> &lt;&lt; pkt-&gt;size &lt;&lt; ret &lt;&lt; inLen;<br>           <span class="hljs-comment">// 跳过已经解析过的数据</span><br>           inData += ret;<br>           <span class="hljs-comment">// 减去已经解析过的数据</span><br>           inLen -= ret;<br><br>           <span class="hljs-comment">// 解码</span><br>           <span class="hljs-keyword">if</span> (pkt-&gt;size &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">decode</span>(ctx,pkt,frame,outFile) &lt; <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-keyword">goto</span> end;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// inData读取完之后，重新开始赋值</span><br>       inData = inDataArray;<br>   &#125;<br>   <br>    <span class="hljs-built_in">decode</span>(ctx,<span class="hljs-literal">nullptr</span>,frame,outFile);<br></code></pre></td></tr></table></figure>

<h4 id="具体解码函数"><a href="#具体解码函数" class="headerlink" title="具体解码函数"></a>具体解码函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(AVCodecContext *ctx,</span></span><br><span class="hljs-params"><span class="hljs-function">                  AVPacket *pkt,</span></span><br><span class="hljs-params"><span class="hljs-function">                  AVFrame *frame,</span></span><br><span class="hljs-params"><span class="hljs-function">                  QFile &amp;outFile)</span> </span>&#123;<br>    <span class="hljs-comment">// 发送压缩数据到解码器</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avcodec_send_packet</span>(ctx,pkt);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_send_packet error&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 获取解码后的数据</span><br>        ret = <span class="hljs-built_in">avcodec_receive_frame</span>(ctx,frame);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_receive_frame error&quot;</span> &lt;&lt; errbuf;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br><br>        <span class="hljs-comment">// 将解码后的数据写入文件</span><br>        outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *)frame-&gt;data[<span class="hljs-number">0</span>],frame-&gt;linesize[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="设置输出参数"><a href="#设置输出参数" class="headerlink" title="设置输出参数"></a>设置输出参数</h3><blockquote>
<p>从上下文中获取<code>aac</code>解码后的<code>pcm</code>文件的音频参数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 设置输出参数</span><br>out.sampleRate = ctx-&gt;sample_rate;<br>out.sampleFmt = ctx-&gt;sample_fmt;<br>out.chLayout = ctx-&gt;ch_layout;<br></code></pre></td></tr></table></figure>

<h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">end:<br>    inFile.<span class="hljs-built_in">close</span>();<br>    outFile.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-built_in">av_frame_free</span>(&amp;frame);<br>    <span class="hljs-built_in">av_packet_free</span>(&amp;pkt);<br>    <span class="hljs-built_in">av_parser_close</span>(parserCtx);<br>    <span class="hljs-built_in">avcodec_free_context</span>(&amp;ctx);<br></code></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">AudioDecodeSpec out;<br>out.filename = <span class="hljs-string">&quot;/Users/chenjingpo/Desktop/44100_s16le_decode.pcm&quot;</span>;<br>aac_decode::<span class="hljs-built_in">aacDecode</span>(<span class="hljs-string">&quot;/Users/chenjingpo/Desktop/44100_s16le_2_43.aac&quot;</span>,out);<br></code></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul>
<li>通过<code>ffplay -ar 44100 -ac 2 -f s16le -i 44100_s16le_decode.pcm</code>，播放解码的数据</li>
<li>通过官方命令行解码验证大小<code>ffmpeg -c:a libfdk_aac -i in.aac -f s16le out.pcm</code></li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>aac编码实战</title>
    <url>/2023/09/17/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/aac%E7%BC%96%E7%A0%81%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><ul>
<li><code>fdk-aac</code>对输入的<code>PCM</code>数据是有参数要求的，如果参数不对，就会出现以下错误：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">[libfdk_aac @ <span class="hljs-number">0x7fa3db033000</span>] Unable to initialize the encoder: SBR library initialization error<br>Error initializing output stream <span class="hljs-number">0</span>:<span class="hljs-number">0</span> -- Error <span class="hljs-keyword">while</span> opening encoder <span class="hljs-keyword">for</span> output stream #<span class="hljs-number">0</span>:<span class="hljs-number">0</span> - maybe incorrect parameters such as bit_rate, rate, width <span class="hljs-keyword">or</span> height<br>Conversion failed!<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="采样格式"><a href="#采样格式" class="headerlink" title="采样格式"></a>采样格式</h2><blockquote>
<p>必须<code>16</code>位整数<code>PCM</code></p>
</blockquote>
<h2 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h2><ul>
<li>支持的采样率（<code>hz</code>）<ul>
<li><code>8000</code>、<code>11025</code>、<code>12000</code>、<code>16000</code>、<code>22050</code>、<code>24000</code>、<code>32000</code></li>
<li><code>44100</code>、<code>48000</code>、<code>64000</code>、<code>88200</code>、<code>96000</code></li>
</ul>
</li>
</ul>
<h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><a href="http://ffmpeg.org/ffmpeg-all.html#libfdk_005faac">基本使用</a></h2><ul>
<li><code>wav</code>-&gt;<code>aac</code>,<code>ffmpeg -i in.wav -c:a libfdk_aac out.aac</code></li>
<li><code>PCM</code>-&gt;<code>aac</code>,<code>wav</code>带有音频三要素，因此不用加，而<code>PCM</code>没有,指令<code>ffmpeg -ar 44100 -ac 2 -f s16le -i in.pcm -c:a libfdk_aac out.aac</code><ul>
<li><code>-ar 44100 -ac 2 -f s16le</code><ul>
<li><code>PCM</code>输入数据的参数</li>
</ul>
</li>
<li><code>-c:a</code>,属于输出参数<ul>
<li>设置音频编码器</li>
<li><code>c</code>表示<code>codec</code>（编解码器），<code>a</code>表示<code>audio</code>（音频）</li>
</ul>
</li>
<li>等价写法<ul>
<li><code>-codec:a</code></li>
<li><code>-acodec</code></li>
</ul>
</li>
</ul>
</li>
<li>默认生成的<code>aac</code>文件事<code>LC</code>规格的<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffprobe</span> out.aac<br> <br><span class="hljs-comment"># 输出结果如下所示</span><br>Audio: aac (LC), 44100 Hz, stereo, fltp, 120 kb/s<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li><p><code>b:a</code></p>
<ul>
<li>设置输出比特率</li>
<li>比如<code>-b:a 96k</code><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> -i in.wav -c:a libfdk_aac -b:a 96k out.aac<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>-profile:a</code></p>
<ul>
<li>设置输出规格</li>
<li>取值有(这些值都是固定的)：<ul>
<li><code>aac_low</code>：<code>Low Complexity AAC (LC)</code>，默认值</li>
<li><code>aac_he</code>：<code>High Efficiency AAC (HE-AAC)</code></li>
<li><code>aac_he_v2</code>：<code>High Efficiency AAC version 2 (HE-AACv2)</code></li>
<li><code>aac_ld</code>：<code>Low Delay AAC (LD)</code></li>
<li><code>aac_eld</code>：<code>Enhanced Low Delay AAC (ELD)</code><br>一旦设置了输出规格，会自动设置一个合适的输出比特率</li>
<li>也可以通过<code>-b:a</code>自行设置输出比特率<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> -i in.wav -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k out.aac<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><code>-vbr</code></p>
<ul>
<li>开启<a href="https://wiki.hydrogenaud.io/index.php?title=Fraunhofer_FDK_AAC#Bitrate_Modes"><code>VBR</code></a>模式（Variable Bit Rate，可变比特率）</li>
<li>如果开启了<code>VBR</code>模式，<code>-b:a</code>选项将会被忽略，但<code>-profile:a</code>选项仍然有效</li>
<li>取值范围是<code>0</code> ~ <code>5</code><ul>
<li><code>0</code>：默认值，关闭<code>VBR</code>模式，开启<code>CBR</code>模式（<code>Constant Bit Rate</code>，固定比特率）</li>
<li><code>1</code>：质量最低（但是音质仍旧很棒）</li>
<li><code>5</code>：质量最高</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>VBR</th>
<th align="left">kbps/channel</th>
<th align="left">AOTs</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">20-32</td>
<td align="left">LC、HE、HEv2</td>
</tr>
<tr>
<td>2</td>
<td align="left">32-40</td>
<td align="left">LC、HE、HEv2</td>
</tr>
<tr>
<td>3</td>
<td align="left">48-56</td>
<td align="left">LC、HE、HEv2</td>
</tr>
<tr>
<td>4</td>
<td align="left">64-72</td>
<td align="left">LC</td>
</tr>
<tr>
<td>5</td>
<td align="left">96-112</td>
<td align="left">LC</td>
</tr>
</tbody></table>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><blockquote>
<p><code>AAC</code>编码的文件扩展名主要有<code>3</code>种：<code>aac</code>、<code>m4a</code>、<code>mp4</code>,(其中<code>m4a</code>和<code>mp4</code>的文件内容格式一致，因此两者大小一致。而<code>aac</code>内容格式不一样)。</p>
</blockquote>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><ul>
<li>需要用到两个库<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br>&#125;<br> <br><span class="hljs-comment">// 错误处理</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR_BUF(ret) \</span><br><span class="hljs-meta">    char errbuf[1024]; \</span><br><span class="hljs-meta">    av_strerror(ret, errbuf, sizeof (errbuf));</span><br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;<br>    <span class="hljs-keyword">int</span> sampleRate;<br>    AVSampleFormat sampleFmt;<br>    AVChannelLayout chLayout;<br>&#125; AudioEncodeSpec;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AACEncode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AACEncode</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aacEncode</span><span class="hljs-params">(AudioEncodeSpec &amp;in,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *outFilename)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//编码器</span><br>    <span class="hljs-keyword">const</span> AVCodec *codec = <span class="hljs-literal">nullptr</span>;<br>   <span class="hljs-comment">//上下文</span><br>    AVCodecContext *ctx = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 用来存放编码前的数据</span><br>    AVFrame *frame = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 用来存放编码后的数据</span><br>    AVPacket *pkt = <span class="hljs-literal">nullptr</span>;<br><br>   <span class="hljs-comment">// 返回结果</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 输入文件</span><br>    <span class="hljs-function">QFile <span class="hljs-title">inFile</span><span class="hljs-params">(in.filename)</span></span>;<br>    <span class="hljs-comment">// 输出文件</span><br>    <span class="hljs-function">QFile <span class="hljs-title">outFile</span><span class="hljs-params">(outFilename)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="资源回收"><a href="#资源回收" class="headerlink" title="资源回收"></a>资源回收</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">end:<br>    <span class="hljs-comment">// 关闭文件</span><br>    inFile.<span class="hljs-built_in">close</span>();<br>    outFile.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-built_in">av_frame_free</span>(&amp;frame);<br>    <span class="hljs-built_in">av_packet_free</span>(&amp;pkt);<br>    <span class="hljs-built_in">avcodec_free_context</span>(&amp;ctx);<br></code></pre></td></tr></table></figure>

<h3 id="获取编码器"><a href="#获取编码器" class="headerlink" title="获取编码器"></a>获取编码器</h3><ul>
<li><p>下面的代码可以获取<code>FFmpeg</code>默认的<code>AAC</code>编码器（并不是<code>libfdk_aac</code>）</p>
<ul>
<li><code>avcodec_find_encoder</code>和<code>avcodec_find_encoder_by_name</code>获取的编码器是一样的<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> AVCodec *codec1 = <span class="hljs-built_in">avcodec_find_encoder</span>(AV_CODEC_ID_AAC);<br><br><span class="hljs-keyword">const</span> AVCodec *codec2 = <span class="hljs-built_in">avcodec_find_encoder_by_name</span>(<span class="hljs-string">&quot;aac&quot;</span>);<br><br><span class="hljs-comment">// true 0x109fc9310 0x109fc9310</span><br><span class="hljs-built_in">qDebug</span>() &lt;&lt; (codec1 == codec2) &lt;&lt; codec1 &lt;&lt; codec2;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>获取<code>libfdk_aac</code>的编码器，(注意<code>ffmpeg</code>本身不含有，要自己加入)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取fdk-aac编码器</span><br>codec = <span class="hljs-built_in">avcodec_find_encoder_by_name</span>(<span class="hljs-string">&quot;libfdk_aac&quot;</span>);<br><span class="hljs-keyword">if</span>(!codec) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;encoder libfdk_aac not found&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="检查采样格式"><a href="#检查采样格式" class="headerlink" title="检查采样格式"></a>检查采样格式</h3><ul>
<li><p>编码器有自己的采样格式要求，输入的<code>pcm</code>文件必须满足，不满足可通过重采样的方式满足</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 检查采样格式</span><br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check_sample_fmt</span>(codec,in.sampleFmt)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Encoder does not support sample format&quot;</span> &lt;&lt; <span class="hljs-built_in">av_get_sample_fmt_name</span>(in.sampleFmt);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>检查采样格式的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 检查编码器codec是否支持采样格式sample_fmt</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">check_sample_fmt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> AVCodec *codec,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">enum</span> AVSampleFormat sample_fmt)</span> </span>&#123;<br><span class="hljs-comment">// 得到编码器支持的采样格式，然后进行遍历</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> *<span class="hljs-title">p</span> =</span> codec-&gt;sample_fmts;<br><span class="hljs-keyword">while</span> (*p != AV_SAMPLE_FMT_NONE) &#123;<br>    <span class="hljs-keyword">if</span> (*p == sample_fmt) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    p++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建上下文"><a href="#创建上下文" class="headerlink" title="创建上下文"></a>创建上下文</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建上下文</span><br>ctx = <span class="hljs-built_in">avcodec_alloc_context3</span>(codec);<br><span class="hljs-keyword">if</span>(!ctx) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_alloc_context3 error&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 设置参数</span><br><span class="hljs-comment">// 采样格式</span><br>ctx-&gt;sample_fmt = in.sampleFmt;<br><span class="hljs-comment">// 采样率</span><br>ctx-&gt;sample_rate = in.sampleRate;<span class="hljs-comment">// 声道</span><br>ctx-&gt;ch_layout = in.chLayout;<br><span class="hljs-comment">// aac相关的</span><br><span class="hljs-comment">// 比特率。要压缩的</span><br>ctx-&gt;bit_rate = <span class="hljs-number">43000</span>;<br><span class="hljs-comment">// 压缩的规格</span><br>ctx-&gt;profile = FF_PROFILE_AAC_HE_V2;<br></code></pre></td></tr></table></figure>

<h3 id="打开编码器"><a href="#打开编码器" class="headerlink" title="打开编码器"></a>打开编码器</h3><ul>
<li><p><code>avcodec_open2</code>的三个参数是，上下文、编码器以及可选项字典。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ret = <span class="hljs-built_in">avcodec_open2</span>(ctx,codec,<span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_open2 error&quot;</span> &lt;&lt; errbuf;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>这里可选项字典，可以像命令行一样设置参数。可以设置一些<code>libfdk_aa</code>特有的参数,例如<code>vbr</code>，可以通过<code>options</code>参数传递</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 设置libfdk_aac的特有参数，比如vbr，可以通过options参数传递</span><br>AVDictionary *options = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-built_in">av_dict_set</span>(&amp;options,<span class="hljs-string">&quot;vbr&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-number">0</span>);<br>ret = <span class="hljs-built_in">avcodec_receive_frame</span>(ctx,codec,options);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建AVFrame"><a href="#创建AVFrame" class="headerlink" title="创建AVFrame"></a>创建AVFrame</h3><blockquote>
<p><code>AVFrame</code>用来存放编码前的数据。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建avframe</span><br>frame = <span class="hljs-built_in">av_frame_alloc</span>();<br><span class="hljs-keyword">if</span>(!frame) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_frame_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br><br><br><span class="hljs-comment">// 样本帧的数量（由frame_size）决定</span><br>frame-&gt;nb_samples = ctx-&gt;frame_size;<br><span class="hljs-comment">// 采样格式</span><br>frame-&gt;format = ctx-&gt;sample_fmt;<br><span class="hljs-comment">// 声道布局</span><br>frame-&gt;ch_layout = ctx-&gt;ch_layout;<br><span class="hljs-comment">// 创建avframe内部的缓存区</span><br>ret = <span class="hljs-built_in">av_frame_get_buffer</span>(frame,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_frame_get_buffer error&quot;</span> &lt;&lt; errbuf;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建AVPacket"><a href="#创建AVPacket" class="headerlink" title="创建AVPacket"></a>创建AVPacket</h3><blockquote>
<p><code>AVPacket</code>用来接收编码后的数据。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建avpacket</span><br>pkt = <span class="hljs-built_in">av_packet_alloc</span>();<br><span class="hljs-keyword">if</span> (!pkt) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_packet_alloc error&quot;</span>;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打开文件</span><br><span class="hljs-keyword">if</span>(!inFile.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; in.filename;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!outFile.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;file open error&quot;</span> &lt;&lt; outFilename;<br>    <span class="hljs-keyword">goto</span> end;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">// 开始编码</span><br> <span class="hljs-comment">// frame-&gt;linesize[0]是缓冲区的大小</span><br><span class="hljs-comment">// 读取文件数据，将数据填充到frame中</span><br> <span class="hljs-keyword">while</span>((ret = inFile.<span class="hljs-built_in">read</span>((<span class="hljs-keyword">char</span> *)frame-&gt;data[<span class="hljs-number">0</span>],frame-&gt;linesize[<span class="hljs-number">0</span>])) &gt; <span class="hljs-number">0</span>) &#123;<br>     <span class="hljs-comment">// 最后一次读取文件数据时，有可能并没有填满frame的缓冲区</span><br>     <span class="hljs-keyword">if</span> (ret &lt; frame-&gt;linesize[<span class="hljs-number">0</span>]) &#123;<br>         <span class="hljs-comment">// 声道数</span><br>         <span class="hljs-keyword">int</span> chs = frame-&gt;ch_layout.nb_channels;<br>         <span class="hljs-comment">// 每个样本的大小</span><br>         <span class="hljs-keyword">int</span> bytes = <span class="hljs-built_in">av_get_bytes_per_sample</span>((AVSampleFormat)frame-&gt;format);<br>         <span class="hljs-comment">// 改为真正有效的样本帧数量</span><br>         frame-&gt;nb_samples = ret / (chs * bytes);<br>     &#125;<br><br>     <span class="hljs-comment">// 编码</span><br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">encode</span>(ctx,frame,pkt,outFile)) &#123;<br>         <span class="hljs-keyword">goto</span> end;<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// flush编码器</span><br> <span class="hljs-built_in">encode</span>(ctx,<span class="hljs-literal">nullptr</span>,pkt,outFile);<br></code></pre></td></tr></table></figure>

<h4 id="编码函数"><a href="#编码函数" class="headerlink" title="编码函数"></a>编码函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 音频编码</span><br><span class="hljs-comment">// 返回负数：中途出现了错误</span><br><span class="hljs-comment">// 返回0：编码操作正常完成</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">encode</span><span class="hljs-params">(AVCodecContext *ctx,</span></span><br><span class="hljs-params"><span class="hljs-function">                  AVFrame *frame,</span></span><br><span class="hljs-params"><span class="hljs-function">                  AVPacket *pkt,</span></span><br><span class="hljs-params"><span class="hljs-function">                  QFile &amp;outFile)</span></span>&#123;<br>    <span class="hljs-comment">// 发送数据到编码器，将frame中的pcm数据，发送给aac上下文</span><br>    <span class="hljs-comment">// frame 为null，则flushed缓冲区</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avcodec_send_frame</span>(ctx,frame);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_send_frame error&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 从编码器中获取编码后的数据,从ctx中获取从frame转换后的数据，传给pkt</span><br>        ret = <span class="hljs-built_in">avcodec_receive_packet</span>(ctx,pkt);<br>        <span class="hljs-comment">// packet中已经没有数据，需要重新发送数据到编码器（send frame)</span><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 出现了其他错误</span><br>            <span class="hljs-built_in">ERROR_BUF</span>(ret);<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;avcodec_receive_packet error&quot;</span> &lt;&lt; errbuf;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br><br>        <span class="hljs-comment">// 将编码后的数据写入文件</span><br>        outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *)pkt-&gt;data,pkt-&gt;size);<br><br>        <span class="hljs-comment">// 释放资源</span><br>        <span class="hljs-built_in">av_packet_unref</span>(pkt);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><ul>
<li>这里将<code>44100HZ</code>、<code>双声道</code>、<code>s16le</code>格式的<code>pcm</code>文件，进行转换<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">AudioEncodeSpec in;<br>in.filename = <span class="hljs-string">&quot;/Users/chenjingpo/Desktop/44100_s16le_2.pcm&quot;</span>;<br>in.sampleRate = <span class="hljs-number">44100</span>;<br>in.sampleFmt = AV_SAMPLE_FMT_S16;<br>in.chLayout = AV_CHANNEL_LAYOUT_STEREO;<br>AACEncode::<span class="hljs-built_in">aacEncode</span>(in,<span class="hljs-string">&quot;/Users/chenjingpo/Desktop/44100_s16le_2.aac&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul>
<li>这里用官方命令行生成的<code>aac</code>文件，和编码生成的<code>aac</code>进行对比验证</li>
<li>命令行，<code>ffmpeg -ar 44100 -ac 2 -f s16le -i 44100_s16le_2.pcm -c:a libfdk_aac -b:a 32k -profile:a aac_he_v2 out.aac</code></li>
<li>查看文件大小一致，并通过<code>ffprobe</code>查看格式，<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffprobe</span> 44100_s16le_2.aac<br>[aac @ 0x7fe8cd9050c0] Estimating duration from bitrate, this may be inaccurate<br>Input <span class="hljs-comment">#0, aac, from &#x27;44100_s16le_2.aac&#x27;:</span><br>  Duration: 00:00:06.21, bitrate: 32 kb/s<br>  Stream <span class="hljs-comment">#0:0: Audio: aac (HE-AACv2), 44100 Hz, stereo, fltp, 32 kb/s</span><br><span class="hljs-variable">$ffprobe</span> out.aac<br>[aac @ 0x7f9ffc004380] Estimating duration from bitrate, this may be inaccurate<br>Input <span class="hljs-comment">#0, aac, from &#x27;out.aac&#x27;:</span><br>  Duration: 00:00:06.21, bitrate: 32 kb/s<br>  Stream <span class="hljs-comment">#0:0: Audio: aac (HE-AACv2), 44100 Hz, stereo, fltp, 32 kb/s</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>aac编码</title>
    <url>/2023/09/17/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/aac%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对比MP3"><a href="#对比MP3" class="headerlink" title="对比MP3"></a>对比<code>MP3</code></h1><blockquote>
<p><code>AAC</code>被设计为<code>MP3</code>格式的后继产品，通常在相同的比特率下可以获得比<code>MP3</code>更高的声音质量，是<code>iPhone</code>、<code>iPod</code>、<code>iPad</code>、<code>iTunes</code>的标准音频格式。</p>
</blockquote>
<ul>
<li><code>AAC</code>相较于<code>MP3</code>的改进包含：<ul>
<li>更多的采样率选择：<code>8kHz ~ 96kHz</code>，<code>MP3</code>为<code>16kHz ~ 48kHz</code></li>
<li>更高的声道数上限：<code>48</code>个，<code>MP3</code>在<code>MPEG-1</code>模式下为最多<code>双声道</code>，<code>MPEG-2</code>模式下<code>5.1</code>声道</li>
<li>改进的压缩功能：以较小的文件大小提供更高的质量</li>
<li>改进的解码效率：需要较少的处理能力进行解码</li>
<li>……</li>
</ul>
</li>
</ul>
<h1 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h1><ul>
<li><code>AAC</code>是一个庞大家族，为了适应不同场合的需要，它有很多种规格可供选择。下面列举其中的9种规格（<code>Profile</code>）：<ul>
<li><code>MPEG-2 AAC LC</code>：低复杂度规格（<code>Low Complexity</code>）</li>
<li><code>MPEG-2 AAC Main</code>：主规格</li>
<li><code>MPEG-2 AAC SSR</code>：可变采样率规格（<code>Scaleable Sample Rate</code>）</li>
<li><code>MPEG-4 AAC LC</code>：低复杂度规格（<code>Low Complexity</code>）<ul>
<li>现在的手机比较常见的MP4文件中的音频部分使用了该规格</li>
</ul>
</li>
<li><code>MPEG-4 AAC Main</code>：主规格</li>
<li><code>MPEG-4 AAC SSR</code>：可变采样率规格（<code>Scaleable Sample Rate</code>）</li>
<li><code>MPEG-4 AAC LTP</code>：长时期预测规格（<code>Long Term Predicition</code>）</li>
<li><code>MPEG-4 AAC LD</code>：低延迟规格（<code>Low Delay</code>）</li>
<li><code>MPEG-4 AAC HE</code>：高效率规格（<code>High Efficiency</code>）</li>
</ul>
</li>
<li>最早是基于<code>MPEG-2</code>标准，称为：<code>MPEG-2 AAC</code>。后来<code>MPEG-4</code>标准在原来基础上增加了一些新技术，称为：<code>MPEG-4 AAC</code>。</li>
</ul>
<h1 id="LC和HE"><a href="#LC和HE" class="headerlink" title="LC和HE"></a><code>LC</code>和<code>HE</code></h1><blockquote>
<p>虽然上面列举了<code>9</code>种规格，但我们目前只需要把注意力放在常用的<code>LC</code>和<code>HE</code>上。下图很好的展示了从<code>LC</code>到<code>HE</code>的发展历程。</p>
</blockquote>
<p><img src="1.png" alt="从LC到HE"></p>
<p><img src="2.png" alt="从LC到HE"></p>
<h2 id="LC"><a href="#LC" class="headerlink" title="LC"></a><code>LC</code></h2><ul>
<li><code>LC</code>适合中等比特率，比如<code>96kbps ~ 192kbps</code>之间。</li>
<li><code>MPEG-4 AAC LC</code>等价于：<ul>
<li><code>MPEG-2 AAC LC</code> + <code>PNS</code></li>
</ul>
</li>
<li><code>PNS</code>（<a href="https://wiki.hydrogenaud.io/index.php?title=Perceptual_Noise_Substitution">Perceptual Noise Substitution</a>）译为：感知噪声替代。<ul>
<li><code>PNS</code>可以提高<code>AAC</code>的编码效率</li>
</ul>
</li>
</ul>
<h2 id="HE"><a href="#HE" class="headerlink" title="HE"></a><code>HE</code></h2><blockquote>
<p><code>HE</code>有<code>v1</code>和<code>v2</code>两个版本，适合低比特率：</p>
</blockquote>
<ul>
<li><code>v1</code>：适合<code>48kbps ~ 64kbps</code></li>
<li><code>v2</code>：适合低于<code>32kbps</code>，可在低至<code>32kbps</code>的比特率下提供接近<code>CD</code>品质的声音</li>
</ul>
<h3 id="v1"><a href="#v1" class="headerlink" title="v1"></a><code>v1</code></h3><ul>
<li><p><code>MPEG-4 AAC HE v1</code>的别名：</p>
<ul>
<li><code>aacPlus v1</code></li>
<li><code>eAAC</code></li>
<li><code>AAC+</code></li>
<li><code>CT-aacPlus（Coding Technologies）</code><ul>
<li><code>Coding Technologies</code>是瑞典是一家技术公司，率先在<code>AAC</code>中使用了<code>SBR</code>技术</li>
<li>在<code>2007</code>年，被杜比实验室（<code>Dolby Laboratories</code>）以<code>2.5</code>亿美元收购</li>
</ul>
</li>
</ul>
</li>
<li><p><code>MPEG-4 AAC HE v1</code>等价于：</p>
<ul>
<li><p><code>MPEG-4 AAC LC + SBR</code></p>
<p>  <img src="3.jpg" alt="SBR"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>SBR</code>（<a href="https://en.wikipedia.org/wiki/Parametric_Stereo"><code>Spectral Band Replication</code></a>）译为：频段复制。<ul>
<li>是一种增强的压缩技术</li>
<li>可以将高频信号存储在少量的<code>SBR data</code>中</li>
<li>解码器可以根据<code>SBR data</code>恢复出高频信号</li>
</ul>
</li>
</ul>
<h3 id="v2"><a href="#v2" class="headerlink" title="v2"></a><code>v2</code></h3><ul>
<li><p><code>MPEG-4 AAC HE v2</code>的别名：</p>
<ul>
<li><code>aacPlus v2</code></li>
<li><code>AAC++</code></li>
<li><code>eAAC+、Enhanced AAC+</code></li>
</ul>
</li>
<li><p><code>MPEG-4 AAC HE v2</code>等价于：</p>
<ul>
<li><code>MPEG-4 AAC HE v1</code> + <code>PS</code></li>
</ul>
<p>  <img src="4.jpg" alt="PS"></p>
</li>
<li><p><code>PS</code>（<a href="https://en.wikipedia.org/wiki/Parametric_Stereo">Parametric Stereo</a>）译为：参数立体声。</p>
<ul>
<li>是一种有损的音频压缩算法，可以进一步提高压缩率</li>
<li>可以将左右声道信号组合成单声道信号，声道之间的差异信息存储到少量的<code>PS data</code>中（大概占<code>2</code> ~ <code>3kbps</code>）</li>
<li>解码器可以根据<code>PS data</code>中恢复出立体声信号</li>
</ul>
</li>
</ul>
<h1 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h1><blockquote>
<p>如果想对<code>PCM</code>数据进行<code>AAC</code>编码压缩，那么就要用到<code>AAC</code>编码器（<code>encoder</code>）。<br>如果想将<code>AAC</code>编码后的数据解压出<code>PCM</code>数据，那么就要用到<code>AAC</code>解码器（<code>decoder</code>）。</p>
</blockquote>
<ul>
<li>这里只列举几款常用的<code>AAC</code>编解码器：<ul>
<li>支持<code>LC</code>/<code>HE</code>规格</li>
<li>目前已经停止开发维护</li>
</ul>
</li>
<li><code>FFmpeg AAC</code><ul>
<li>支持<code>LC</code>规格</li>
<li><code>FFmpeg</code>官方内置的<code>AAC</code>编解码器，在<code>libavcodec</code>库中<ul>
<li>编解码器名字叫做<code>aac</code></li>
<li>在开发过程中通过这个名字找到编解码器</li>
</ul>
</li>
</ul>
</li>
<li><code>FAAC</code>（<a href="https://en.wikipedia.org/wiki/FAAC">Freeware Advanced Audio Coder</a>）<ul>
<li>支持<code>LC</code>规格</li>
<li>可以集成到<code>FFmpeg</code>的<code>libavcodec</code>中<ul>
<li>编解码器名字叫做<code>libfaac</code></li>
<li>在开发过程中通过这个名字找到编解码器，最后调用<code>FAAC</code>库的功能</li>
</ul>
</li>
<li>从<code>2016</code>年开始，<code>FFmpeg</code>已经<a href="https://ffmpeg.org/pipermail/ffmpeg-devel/2016-August/197790.html">移除</a>了对FAAC的支持</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Fraunhofer_FDK_AAC">Fraunhofer FDK AAC</a><ul>
<li>支持<code>LC</code>/<code>HE</code>规格</li>
<li>目前质量最高的<code>AAC</code>编解码器</li>
<li>可以集成到<code>FFmpeg</code>的<code>libavcodec</code>中<ul>
<li>编解码器名字叫做<code>libfdk_aac</code></li>
<li>在开发过程中通过这个名字找到编解码器，最后调用<code>FDK AAC</code>库的功能</li>
</ul>
</li>
</ul>
</li>
<li>编码质量排名：<code>Fraunhofer FDK AAC</code> &gt; <code>FFmpeg AAC</code> &gt; <code>FAAC</code>。</li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>编译ffmpeg</title>
    <url>/2023/09/17/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E7%BC%96%E8%AF%91ffmpeg/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>此前用<code>brew</code>安装的<code>ffmpeg</code>、<code>ffprobe</code>、<code>ffplay</code>,这里希望通过编译源码得到，主要为了实现下面的效果<ol>
<li>编译出<code>ffmpeg</code>、<code>ffprobe</code>、<code>ffplay</code>三个命令行工具</li>
<li>只产生动态库，不产生静态库</li>
<li>将<code>fdk-aac</code>、<code>x264</code>、<code>x265</code>集成到<code>FFmpeg</code>中<ul>
<li><code>x264</code>、<code>x265</code>会在以后讲解的视频模块中用到</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="源码的下载"><a href="#源码的下载" class="headerlink" title="源码的下载"></a>源码的下载</h1><blockquote>
<p><a href="http://ffmpeg.org/releases/?C=M;O=D">官网</a>下载<code>release</code>包的源码（注意一定要<code>release</code>版本的，<code>git</code>上的版本，不一定能编译）。这里现在的事<code>ffmpeg-6.0.tar.xz</code>版本</p>
</blockquote>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><ul>
<li><p><code>brew install yasm</code></p>
<ul>
<li><code>ffmpeg</code>的编译过程依赖<code>yasm</code></li>
<li>若未安装<code>yasm</code>会出现错误：<code>nasm/yasm not found or too old. Use --disable-x86asm for a crippled build</code>.</li>
</ul>
</li>
<li><p><code>brew install sdl2</code></p>
<ul>
<li><code>ffplay</code>依赖于<code>sdl2</code></li>
<li>如果缺少<code>sdl2</code>，就无法编译出<code>ffplay</code></li>
</ul>
</li>
<li><p><code>brew install fdk-aac</code></p>
<ul>
<li>不然会出现错误：<code>ERROR: libfdk_aac not found</code></li>
</ul>
</li>
<li><p><code>brew install x264</code></p>
<ul>
<li>不然会出现错误：<code>ERROR: libx264 not found</code></li>
</ul>
</li>
<li><p><code>brew install x265</code></p>
<ul>
<li>不然会出现错误：<code>ERROR: libx265 not found</code></li>
</ul>
</li>
<li><p>注意，可以通过<code>brew list</code>的结果查看是否安装过,如果已经安装过，可以不用再执行<code>brew install</code></p>
<ul>
<li><code>brew list | grep fdk</code></li>
<li><code>brew list | grep x26</code></li>
<li><code>brew list | grep -E &#39;fdk|x26&#39;</code></li>
</ul>
</li>
</ul>
<h2 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h2><blockquote>
<p>进入源码目录，目录下有个<code>configure</code>可执行文件，通过该可执行文件生成<code>makefile</code>文件</p>
</blockquote>
<ul>
<li>执行命令  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">./configure --prefix=/usr/<span class="hljs-built_in">local</span>/ffmpeg --enable-shared --disable-static --enable-gpl  --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libx265<br></code></pre></td></tr></table></figure>
<ul>
<li><code>--prefix</code><ul>
<li>用以指定编译好的<code>FFmpeg</code>安装到哪个目录</li>
<li>一般放到<code>/usr/local/ffmpeg</code>中即可</li>
</ul>
</li>
<li><code>--enable-shared</code><ul>
<li>生成动态库</li>
</ul>
</li>
<li><code>--disable-static</code><ul>
<li>不生成静态库</li>
</ul>
</li>
<li><code>--enable-libfdk-aac</code><ul>
<li>将<code>fdk-aac</code>内置到<code>FFmpeg</code>中</li>
</ul>
</li>
<li><code>--enable-libx264</code><ul>
<li>将<code>x264</code>内置到<code>FFmpeg</code>中</li>
</ul>
</li>
<li><code>--enable-libx265</code><ul>
<li>将<code>x265</code>内置到<code>FFmpeg</code>中</li>
</ul>
</li>
<li><code>--enable-gpl</code><ul>
<li><code>x264</code>、<code>x265</code>要求开启<a href="https://www.gnu.org/licenses/gpl-3.0.html"><code>GPL License</code></a></li>
</ul>
</li>
<li><code>--enable-nonfree</code><ul>
<li><a href="https://github.com/FFmpeg/FFmpeg/blob/master/LICENSE.md">fdk-aac与GPL不兼容</a>，需要通过开启<code>nonfree</code>进行配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h2><ul>
<li>通过执行<code>make -j8</code>，开始编译代码，<ul>
<li><code>-j8</code>表示允许同时执行<code>8</code>个编译任务。</li>
</ul>
</li>
<li><code>make install</code>安装到之前指定的位置<code>/usr/local/ffmpeg</code></li>
<li>为了让<code>bin</code>目录中的<code>ffmpeg</code>、<code>ffprobe</code>、<code>ffplay</code>在任意位置都能够使用，需要先将<code>bin</code>目录配置到环境变量<code>PATH</code>中。  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ~/.zprofile<br>// .zprofile文件中写入以下内容<br><span class="hljs-built_in">export</span> PATH=/usr/<span class="hljs-built_in">local</span>/ffmpeg/bin:<span class="hljs-variable">$PATH</span><br>// 让.zprofile生效<br><span class="hljs-built_in">source</span> ~/.zprofile<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ol>
<li><p><code>ffmpeg -version</code>验证版本</p>
</li>
<li><p><code>ffmpeg -codecs | grep aac</code>，查询安装了的<code>aac</code></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">DEAIL. aac                  AAC (Advanced Audio Coding) (decoders: aac aac_fixed aac_at libfdk_aac ) (encoders: aac aac_at libfdk_aac )<br>D.AIL. aac_latm             AAC LATM (Advanced Audio Coding LATM syntax)<br></code></pre></td></tr></table></figure></li>
<li><p><code>ffmpeg -codecs | grep x25</code>，查询安装了的<code>x264</code>和<code>x265</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">DEV.LS h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (encoders: libx264 libx264rgb h264_videotoolbox )<br> DEV.L. hevc                 H.265 / HEVC (High Efficiency Video Coding) (encoders: libx265 hevc_videotoolbox )<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><ol>
<li><a href="https://www.cnblogs.com/mjios/p/14633516.html">【秒懂音视频开发】14_编译FFmpeg </a></li>
</ol>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>播放wav</title>
    <url>/2023/09/15/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E6%92%AD%E6%94%BEwav/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>此前有介绍<code>pcm</code>的播放，实际上<code>wav</code>的播放和<code>pcm</code>类似，只是<code>wav</code>文件头会包含了音频的位深，声道以及采样率等</p>
</blockquote>
<h1 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h1><h2 id="初始化Audio子系统"><a href="#初始化Audio子系统" class="headerlink" title="初始化Audio子系统"></a>初始化<code>Audio</code>子系统</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">SDL_Init</span>(SDL_INIT_AUDIO)) &#123;<br>        <span class="hljs-comment">//返回值不是0，就代表失败</span><br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;SDL_Init Error&quot;</span> &lt;&lt; <span class="hljs-built_in">SDL_GetError</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="加载WAV文件"><a href="#加载WAV文件" class="headerlink" title="加载WAV文件"></a>加载WAV文件</h2><blockquote>
<p>通过加载<code>WAV</code>文件，可以获取音频参数，以及<code>PCM</code>原始数据</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">// 音频参数</span><br> SDL_AudioSpec spec;<br><br> Uint8 *data = <span class="hljs-literal">nullptr</span>;<br> Uint32 len = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//打开wav文件,获取pcmData、数据长度，以及音频参数</span><br> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SDL_LoadWAV</span>(FILENAME,&amp;spec,&amp;data,&amp;len)) &#123;<br>     <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;SDL_OpenAudio Error&quot;</span> &lt;&lt; <span class="hljs-built_in">SDL_GetError</span>();<br><br>     <span class="hljs-comment">// 清除所有初始化的子系统</span><br>     <span class="hljs-built_in">SDL_Quit</span>();<br>     <span class="hljs-keyword">return</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<h2 id="打开音频设备"><a href="#打开音频设备" class="headerlink" title="打开音频设备"></a>打开音频设备</h2><blockquote>
<p>设置回调函数，打开音频设备，回调函数，要在打开音频设备之前设置，否则不会加载的音频设备中。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 回调,这里音频设备主要需要音频数据，这里回调放在加载wav后，打开音频设备之前</span><br>    spec.callback = pull_audio_data;<br>    <span class="hljs-comment">//传递给回调的参数</span><br>    AudioBuffer buffer;<br>    <span class="hljs-comment">//一开始就获取了全部的data和len</span><br>    buffer.len = len;<br>    buffer.data = data;<br>    spec.userdata = &amp;buffer;<br><br>    <span class="hljs-comment">//打开音频设备</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SDL_OpenAudio</span>(&amp;spec,<span class="hljs-literal">nullptr</span>)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;SDL_OpenAudio Error&quot;</span> &lt;&lt; <span class="hljs-built_in">SDL_GetError</span>();<br>        <span class="hljs-comment">// 清除所有初始化的子系统</span><br>        <span class="hljs-built_in">SDL_Quit</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h2><blockquote>
<p><code>wav</code>的<code>PCM</code>数据一开始就读取完毕，这里不用再从文件中读取了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//开始播放（0是取消暂停）</span><br>    <span class="hljs-built_in">SDL_PauseAudio</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;开始&quot;</span> &lt;&lt; <span class="hljs-built_in">SDL_AUDIO_BITSIZE</span>(spec.format) &lt;&lt; spec.channels &lt;&lt; spec.samples;<br>    <span class="hljs-comment">//存放从文件中读取的数据</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isInterruptionRequested</span>()) &#123;<br>        <span class="hljs-comment">// 只要从文件中读取的音频数据，还没有填充完毕，就跳过</span><br>        <span class="hljs-keyword">if</span>(buffer.len &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> ( buffer.len &lt;= <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-comment">//剩余的样本数量</span><br>            <span class="hljs-keyword">int</span> samples = buffer.pulllen / (<span class="hljs-built_in">SDL_AUDIO_BITSIZE</span>(spec.format) * spec.channels &gt;&gt; <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">int</span> ms = samples * <span class="hljs-number">1000.0</span> / spec.samples;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;剩余时间&quot;</span> &lt;&lt; ms;<br>            <span class="hljs-comment">//这里延迟毫秒</span><br>            <span class="hljs-built_in">SDL_Delay</span>(ms);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// userdata：SDL_AudioSpec.userdata</span><br><span class="hljs-comment">// stream：音频缓冲区（需要将音频数据填充到这个缓冲区）</span><br><span class="hljs-comment">// len：音频缓冲区的大小（SDL_AudioSpec.samples * 每个样本的大小,即声道乘以位深，这里是16*2,即4字节）</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pull_audio_data</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 清空stream</span><br>    <span class="hljs-built_in">SDL_memset</span>(stream,<span class="hljs-number">0</span>,len);<br>    AudioBuffer *buffer = (AudioBuffer *)userdata;<br>    <span class="hljs-comment">//文件数据还没有准备好</span><br>    <span class="hljs-keyword">if</span> (buffer-&gt;len &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 取len、bufferlen的最小值(为了保证数据安全，防止指针越界)</span><br>    buffer-&gt;pulllen = (len &gt; buffer-&gt;len) ? buffer-&gt;len:len;<br>    <span class="hljs-comment">// 填充数据</span><br>    <span class="hljs-built_in">SDL_MixAudio</span>(stream,buffer-&gt;data, buffer-&gt;pulllen,SDL_MIX_MAXVOLUME);<br>     buffer-&gt;data += buffer-&gt;pulllen;<br>    buffer-&gt;len -= buffer-&gt;pulllen;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//释放文件资源</span><br><span class="hljs-built_in">SDL_FreeWAV</span>(data);<br><span class="hljs-comment">//关闭音频设备</span><br><span class="hljs-built_in">SDL_CloseAudio</span>();<br><span class="hljs-comment">// 清除所有初始化的子系统</span><br><span class="hljs-built_in">SDL_Quit</span>();<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>音频重采样</title>
    <url>/2023/09/11/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E9%A2%91%E9%87%8D%E9%87%87%E6%A0%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="音频重采样"><a href="#音频重采样" class="headerlink" title="音频重采样"></a>音频重采样</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>音频重采样（<code>Audio Resample</code>）：将音频<code>A</code>转换成音频<code>B</code>，并且音频<code>A</code>、<code>B</code>的参数（采样率、采样格式、声道数）并不完全相同。</p>
</blockquote>
<ul>
<li>例如：<ul>
<li>音频<code>A</code>的参数<ul>
<li>采样率：<code>48000</code></li>
<li>采样格式：<code>f32le</code></li>
<li>声道数：<code>1</code></li>
</ul>
</li>
<li>音频<code>B</code>的参数<ul>
<li>采样率：<code>44100</code></li>
<li>采样格式：<code>s16le</code></li>
<li>声道数：<code>2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="音频重采样的用途"><a href="#音频重采样的用途" class="headerlink" title="音频重采样的用途"></a>音频重采样的用途</h2><ul>
<li>有些音频编码器对输入的原始<code>PCM</code>数据是有特定参数要求的，比如要求必须是<code>44100_s16le_2</code>。但是你提供的<code>PCM</code>参数可能是<code>48000_f32le_1</code>。这个时候就需要先将<code>48000_f32le_1</code>转换成<code>44100_s16le_2</code>，然后再使用音频编码器对转换后的<code>PCM</code>进行编码。</li>
</ul>
<h1 id="音频重采样的方式"><a href="#音频重采样的方式" class="headerlink" title="音频重采样的方式"></a>音频重采样的方式</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><ul>
<li>通过下面的命令行可以将<code>44100_s16le_2</code>转换成<code>48000_f32le_1</code><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> -ar 44100 -ac 2 -f s16le -i 44100_s16le_2.pcm -ar 48000 -ac 1 -f f32le 48000_f32le_1.pcm<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><blockquote>
<ul>
<li>音频重采样需要用到<code>2</code>个库：<ul>
<li><code>swresample</code></li>
<li><code>avutil</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 音频参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;<br>    <span class="hljs-keyword">int</span> sampleRate;<br>    AVSampleFormat sampleFmt;<br>    AVChannelLayout chLayout;<br>&#125; ResampleAudioSpec;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FFmpegs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resampleAudio</span><span class="hljs-params">(ResampleAudioSpec &amp;in,</span></span><br><span class="hljs-params"><span class="hljs-function">                              ResampleAudioSpec &amp;out)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resampleAudio</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *inFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">int</span> inSampleRate,</span></span><br><span class="hljs-params"><span class="hljs-function">                              AVSampleFormat inSampleFmt,</span></span><br><span class="hljs-params"><span class="hljs-function">                              AVChannelLayout inChLayout,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *outFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">int</span> outSampleRate,</span></span><br><span class="hljs-params"><span class="hljs-function">                              AVSampleFormat outSampleFmt,</span></span><br><span class="hljs-params"><span class="hljs-function">                              AVChannelLayout outChLayout)</span></span>;<br>&#125;;<br><br><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswresample/swresample.h&gt;</span></span><br>&#125;<br><span class="hljs-comment">//处理错误异常</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR_BUF(ret) \</span><br><span class="hljs-meta">char errbuf[1024]; \</span><br><span class="hljs-meta">    av_strerror(ret,errbuf,sizeof(errbuf));</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFmpegs::resampleAudio</span><span class="hljs-params">(ResampleAudioSpec &amp;in,</span></span><br><span class="hljs-params"><span class="hljs-function">                            ResampleAudioSpec &amp;out)</span> </span>&#123;<br>    <span class="hljs-built_in">resampleAudio</span>(in.filename,<br>                  in.sampleRate,<br>                  in.sampleFmt,<br>                  in.chLayout,<br>                  out.filename,<br>                  out.sampleRate,<br>                  out.sampleFmt,<br>                  out.chLayout);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ResampleAudioSpec in;<br>in.filename = <span class="hljs-string">&quot;/Users/chenjingpo/Desktop/44100_s16le_2.pcm&quot;</span>;<br>in.sampleFmt = AV_SAMPLE_FMT_S16;<br>in.sampleRate = <span class="hljs-number">44100</span>;<br>in.chLayout = AV_CHANNEL_LAYOUT_STEREO;<br>ResampleAudioSpec out;<br>out.filename = <span class="hljs-string">&quot;/Users/chenjingpo/Desktop/48000_f32le_1.pcm&quot;</span>;<br>out.sampleFmt = AV_SAMPLE_FMT_FLT;<br>out.sampleRate = <span class="hljs-number">48000</span>;<br>out.chLayout = AV_CHANNEL_LAYOUT_MONO;<br>FFmpegs::<span class="hljs-built_in">resampleAudio</span>(in,out);<br></code></pre></td></tr></table></figure>

<h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><ul>
<li>采用<code>goto</code>语句跳转到，统一处理异常，需要把用到的变量先进行定义<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//文件名定义</span><br>    <span class="hljs-function">QFile <span class="hljs-title">inFile</span><span class="hljs-params">(inFilename)</span></span>;<br>    <span class="hljs-function">QFile <span class="hljs-title">outFile</span><span class="hljs-params">(outFilename)</span></span>;<br><br>    <span class="hljs-comment">//指向输入缓冲区的指针</span><br>    <span class="hljs-keyword">uint8_t</span> **inData = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 缓冲区的大小</span><br>    <span class="hljs-keyword">int</span> inlinesize = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 声道数</span><br>    <span class="hljs-keyword">int</span> inCh = inChLayout.nb_channels;<br>    <span class="hljs-comment">// 一个样本的大小</span><br>    <span class="hljs-keyword">int</span> inBytesPerSample = inCh * <span class="hljs-built_in">av_get_bytes_per_sample</span>(inSampleFmt);<br>    <span class="hljs-comment">// 缓冲区的样本数量</span><br>    <span class="hljs-keyword">int</span> inSample = <span class="hljs-number">1024</span>;<br>    <span class="hljs-comment">// 读取文件数据的大小</span><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//指向输出缓冲区的指针</span><br>    <span class="hljs-keyword">uint8_t</span> **outData = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 缓冲区的大小</span><br>    <span class="hljs-keyword">int</span> outlinesize = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 声道数</span><br>    <span class="hljs-keyword">int</span> outCh = outChLayout.nb_channels;<br>    <span class="hljs-comment">// 一个样本的大小</span><br>    <span class="hljs-keyword">int</span> outBytesPerSample = outCh * <span class="hljs-built_in">av_get_bytes_per_sample</span>(outSampleFmt);<br>    <span class="hljs-comment">// 缓冲区的样本数量</span><br>    <span class="hljs-comment">/* 输出的样本数和输入的样本数，不同，因为采样率高的代表1s内采样的次数多</span><br><span class="hljs-comment">     * inSampleRate   inSample</span><br><span class="hljs-comment">     * ------------ = ---------</span><br><span class="hljs-comment">     * outSampleRate  outSample</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">int</span> outSample = <span class="hljs-built_in">av_rescale_rnd</span>(outSampleRate,inSample,inSampleRate,AV_ROUND_UP);<br>    <span class="hljs-comment">// 返回结果</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//采样上下文</span><br>    SwrContext *ctx;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建采样上下文"><a href="#创建采样上下文" class="headerlink" title="创建采样上下文"></a>创建采样上下文</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建采样上下文</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">int swr_alloc_set_opts2(struct SwrContext **ps,</span><br><span class="hljs-comment">                        const AVChannelLayout *out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,</span><br><span class="hljs-comment">                        const AVChannelLayout *in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,</span><br><span class="hljs-comment">                        int log_offset, void *log_ctx);*/</span><br>  <br>    ret = <span class="hljs-built_in">swr_alloc_set_opts2</span>(&amp;ctx,<br>                              &amp;outChLayout,outSampleFmt,outSampleRate,<br>                              &amp;inChLayout,inSampleFmt,inSampleRate,<br>                              <span class="hljs-number">0</span>,<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-keyword">if</span> (!ctx &amp;&amp; ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret)<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;创建上下文失败&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="初始化重采样上下文"><a href="#初始化重采样上下文" class="headerlink" title="初始化重采样上下文"></a>初始化重采样上下文</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化重采样上下文</span><br>   ret = <span class="hljs-built_in">swr_init</span>(ctx);<br>   <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">ERROR_BUF</span>(ret)<br>       <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;初始化重采样上下文失败&quot;</span> &lt;&lt; errbuf;<br>       <span class="hljs-keyword">goto</span> end;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建缓冲区"><a href="#创建缓冲区" class="headerlink" title="创建缓冲区"></a>创建缓冲区</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">/ 创建输入缓冲区<br>    <span class="hljs-comment">/*这里1是不对齐，实际上在其源码中设置为0，底层也会将其设为1</span><br><span class="hljs-comment">     * buffer size alignment (0 = default, 1 = no alignment)</span><br><span class="hljs-comment">int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels,</span><br><span class="hljs-comment">                                       int nb_samples, enum AVSampleFormat sample_fmt, int align);</span><br><span class="hljs-comment">    */</span><br>    ret = <span class="hljs-built_in">av_samples_alloc_array_and_samples</span>(&amp;inData,<br>                                             &amp;inlinesize,<br>                                             inCh,<br>                                             inSample,<br>                                             inSampleFmt,<br>                                             <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret)<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;创建输入缓冲区失败&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建输出缓冲区</span><br>    ret = <span class="hljs-built_in">av_samples_alloc_array_and_samples</span>(&amp;outData,<br>                                             &amp;outlinesize,<br>                                             outCh,<br>                                             outSample,<br>                                             outSampleFmt,<br>                                             <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ERROR_BUF</span>(ret)<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;创建输出缓冲区失败&quot;</span> &lt;&lt; errbuf;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ol>
<li><p>注意，这里的<code>outData</code>和<code>inData</code>，是<code>uint8_t **</code>，是一个<code>uint8_t *</code>的数组。实际上只用到了数组的第一项的<code>uint8_t *</code>。这样设计的目的，是为了兼容<code>nb_planes</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_samples_alloc_array_and_samples</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> ***audio_data, <span class="hljs-keyword">int</span> *linesize, <span class="hljs-keyword">int</span> nb_channels,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">int</span> nb_samples, <span class="hljs-keyword">enum</span> AVSampleFormat sample_fmt, <span class="hljs-keyword">int</span> align)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//如果是nb_planes，则数组长度是声道数，否则是1</span><br>    <span class="hljs-keyword">int</span> ret, nb_planes = <span class="hljs-built_in">av_sample_fmt_is_planar</span>(sample_fmt) ? nb_channels : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这里实际上类比创建uint8_t *audio_data[nb_planes]</span><br>    *audio_data = <span class="hljs-built_in">av_calloc</span>(nb_planes, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(**audio_data));<br>    <span class="hljs-keyword">if</span> (!*audio_data)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">AVERROR</span>(ENOMEM);<br>    <span class="hljs-comment">// 创建数组中的数据</span><br>    ret = <span class="hljs-built_in">av_samples_alloc</span>(*audio_data, linesize, nb_channels,<br>                           nb_samples, sample_fmt, align);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">av_freep</span>(audio_data);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>av_samples_alloc</code>初始化数组中的数据的堆大小</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_samples_alloc</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> **audio_data, <span class="hljs-keyword">int</span> *linesize, <span class="hljs-keyword">int</span> nb_channels,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">int</span> nb_samples, <span class="hljs-keyword">enum</span> AVSampleFormat sample_fmt, <span class="hljs-keyword">int</span> align)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint8_t</span> *buf;<br>    <span class="hljs-comment">// 获取数据的大小</span><br>    <span class="hljs-keyword">int</span> size = <span class="hljs-built_in">av_samples_get_buffer_size</span>(<span class="hljs-literal">NULL</span>, nb_channels, nb_samples,<br>                                          sample_fmt, align);<br>    <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> size;<br>        <br>    <span class="hljs-comment">// 初始化对</span><br>    buf = <span class="hljs-built_in">av_malloc</span>(size);<br>    <span class="hljs-keyword">if</span> (!buf)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">AVERROR</span>(ENOMEM);<br>    <span class="hljs-comment">// 填充audio_data中的数据</span><br>    size = <span class="hljs-built_in">av_samples_fill_arrays</span>(audio_data, linesize, buf, nb_channels,<br>                                  nb_samples, sample_fmt, align);<br>    <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">av_free</span>(buf);<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-built_in">av_samples_set_silence</span>(audio_data, <span class="hljs-number">0</span>, nb_samples, nb_channels, sample_fmt);<br><br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>获取采样数据的大小，实际返回的是采样数乘以每个样本的大小（采样数x位深x声道）。注意这里可以看到<code>align</code>设置为<code>0</code>，其值也会设置为<code>1</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_samples_get_buffer_size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *linesize, <span class="hljs-keyword">int</span> nb_channels, <span class="hljs-keyword">int</span> nb_samples,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">enum</span> AVSampleFormat sample_fmt, <span class="hljs-keyword">int</span> align)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> line_size;<br>    <span class="hljs-comment">// 获取每个样本有多少字节数</span><br>    <span class="hljs-keyword">int</span> sample_size = <span class="hljs-built_in">av_get_bytes_per_sample</span>(sample_fmt);<br>    <span class="hljs-keyword">int</span> planar      = <span class="hljs-built_in">av_sample_fmt_is_planar</span>(sample_fmt);<br><br>    <span class="hljs-comment">/* validate parameter ranges */</span><br>    <span class="hljs-keyword">if</span> (!sample_size || nb_samples &lt;= <span class="hljs-number">0</span> || nb_channels &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">AVERROR</span>(EINVAL);<br><br>    <span class="hljs-comment">/* auto-select alignment if not specified */</span><br>    <span class="hljs-comment">//为0，则会设为1</span><br>    <span class="hljs-keyword">if</span> (!align) &#123;<br>        <span class="hljs-keyword">if</span> (nb_samples &gt; INT_MAX - <span class="hljs-number">31</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">AVERROR</span>(EINVAL);<br>        align = <span class="hljs-number">1</span>;<br>        nb_samples = <span class="hljs-built_in">FFALIGN</span>(nb_samples, <span class="hljs-number">32</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* check for integer overflow */</span><br>    <span class="hljs-keyword">if</span> (nb_channels &gt; INT_MAX / align ||<br>        (<span class="hljs-keyword">int64_t</span>)nb_channels * nb_samples &gt; (INT_MAX - (align * nb_channels)) / sample_size)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">AVERROR</span>(EINVAL);<br><br>    line_size = planar ? <span class="hljs-built_in">FFALIGN</span>(nb_samples * sample_size,               align) :<br>                         <span class="hljs-built_in">FFALIGN</span>(nb_samples * sample_size * nb_channels, align);<br>    <span class="hljs-keyword">if</span> (linesize)<br>        *linesize = line_size;<br><br>    <span class="hljs-keyword">return</span> planar ? line_size * nb_channels : line_size;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>数据的填充，如果不是<a href="#jump"><code>nb_planar</code></a>则会填充第一个。通过<code>av_sample_fmt_is_planar(sample_fmt)</code>判断是否是<code>planar</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_samples_fill_arrays</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> **audio_data, <span class="hljs-keyword">int</span> *linesize,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *buf, <span class="hljs-keyword">int</span> nb_channels, <span class="hljs-keyword">int</span> nb_samples,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">enum</span> AVSampleFormat sample_fmt, <span class="hljs-keyword">int</span> align)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ch, planar, buf_size, line_size;<br><br>    planar   = <span class="hljs-built_in">av_sample_fmt_is_planar</span>(sample_fmt);<br>    buf_size = <span class="hljs-built_in">av_samples_get_buffer_size</span>(&amp;line_size, nb_channels, nb_samples,<br>                                          sample_fmt, align);<br>    <span class="hljs-keyword">if</span> (buf_size &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> buf_size;<br><br>    <span class="hljs-keyword">if</span> (linesize)<br>        *linesize = line_size;<br><br>    <span class="hljs-built_in">memset</span>(audio_data, <span class="hljs-number">0</span>, planar<br>                          ? <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*audio_data) * nb_channels<br>                          : <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*audio_data));<br><br>    <span class="hljs-keyword">if</span> (!buf)<br>        <span class="hljs-keyword">return</span> buf_size;<br><br>    audio_data[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span> *)buf;<br>    <span class="hljs-keyword">for</span> (ch = <span class="hljs-number">1</span>; planar &amp;&amp; ch &lt; nb_channels; ch++)<br>        audio_data[ch] = audio_data[ch<span class="hljs-number">-1</span>] + line_size;<br><br>    <span class="hljs-keyword">return</span> buf_size;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="nb-planar"><a href="#nb-planar" class="headerlink" title="nb_planar"></a><span id="jump"><code>nb_planar</code></span></h4><blockquote>
<p><code>nb_planar</code>实际上是数据采样声道数据的分布方式</p>
</blockquote>
<ol>
<li><p>正常情况下。每个样本下的，左声道和右声道数据是哎在一起的，便于播放时进行采集。因为声道数据在一块，因此用<code>Unint8 *</code>的一维数组即可<br><img src="1.png"></p>
</li>
<li><p>但是具有<code>planar</code>的数据，其声道数据是分开的，例如。先全部是左声道，然后在右声道。左右声道没在一块，因此在取数据的时候，要分开取。因此这里缓存区的样本数，会分成两个数组，并且</p>
<ol>
<li><code>planar</code>时的<code>linsize</code>是单个声道的长度。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">line_size = planar ? <span class="hljs-built_in">FFALIGN</span>(nb_samples * sample_size,               align) :<br>                     <span class="hljs-built_in">FFALIGN</span>(nb_samples * sample_size * nb_channels, align);<br><br></code></pre></td></tr></table></figure></li>
<li>同时在对二维数组初始化时,第二个数组的开始位置，实际上等于第一个声道数据开始加上该声道数据的长度。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">audio_data[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span> *)buf;<br><span class="hljs-keyword">for</span> (ch = <span class="hljs-number">1</span>; planar &amp;&amp; ch &lt; nb_channels; ch++)<br>    audio_data[ch] = audio_data[ch<span class="hljs-number">-1</span>] + line_size;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><code>planar</code>的作用主要是便于需要处于左声道或者右声道数据的情况</p>
</li>
</ol>
<h3 id="读取文件数据"><a href="#读取文件数据" class="headerlink" title="读取文件数据"></a>读取文件数据</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!inFile.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;输入文件打开失败&quot;</span> &lt;&lt; inFilename;<br>        <span class="hljs-keyword">goto</span> end;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!outFile.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;输出文件打开失败&quot;</span> &lt;&lt; outFilename;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取文件数据</span><br><br>    <span class="hljs-keyword">while</span> ((len = inFile.<span class="hljs-built_in">read</span>((<span class="hljs-keyword">char</span> *) inData[<span class="hljs-number">0</span>],inlinesize))) &#123;<br>        <span class="hljs-comment">//读取的样本数量</span><br>        inSample = len / inBytesPerSample;<br>        <span class="hljs-comment">//重采样</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         *int swr_convert(struct SwrContext *s, uint8_t **out, int out_count,</span><br><span class="hljs-comment">                                const uint8_t **in , int in_count);</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//number of samples output per channel</span><br>        ret = <span class="hljs-built_in">swr_convert</span>(ctx,outData,outSample,(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> **)inData,inSample);<br>        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">ERROR_BUF</span>(ret)<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;数据交换失败&quot;</span> &lt;&lt; errbuf;<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125;<br><br>        <span class="hljs-comment">// 这里的size等价于ret * outBytesPerSample，转换返回的样本数，乘以每个样本的大小</span><br>        <span class="hljs-keyword">int</span> size = <span class="hljs-built_in">av_samples_get_buffer_size</span>(<span class="hljs-literal">nullptr</span>,outCh,ret,outSampleFmt,<span class="hljs-number">1</span>);<br><br>        outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *)outData[<span class="hljs-number">0</span>],size);<br>        <span class="hljs-comment">// 将转换后的数据写入到输出文件中</span><br>        <span class="hljs-comment">//  outFile.write((char *)outData[0],ret * outBytesPerSample);</span><br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><ul>
<li>刷新缓冲区，可能有残留的样本，要刷新一次，防止漏掉<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>((ret = <span class="hljs-built_in">swr_convert</span>(ctx,outData,outSample,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> size = <span class="hljs-built_in">av_samples_get_buffer_size</span>(<span class="hljs-literal">nullptr</span>,outCh,ret,outSampleFmt,<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;残留样本&quot;</span> &lt;&lt; ret &lt;&lt; size;<br>                                          outFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">char</span> *)outData[<span class="hljs-number">0</span>],size);<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="资源回收"><a href="#资源回收" class="headerlink" title="资源回收"></a>资源回收</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">end:<br>    <span class="hljs-keyword">if</span>(inData) &#123;<br>        <span class="hljs-built_in">av_freep</span>(&amp;inData[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-built_in">av_freep</span>(inData);<br>    <span class="hljs-keyword">if</span>(outData) &#123;<br>        <span class="hljs-built_in">av_freep</span>(&amp;outData[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-built_in">av_freep</span>(outData);<br>    inFile.<span class="hljs-built_in">close</span>();<br>    outFile.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-comment">// 释放重采样上下文</span><br>    <span class="hljs-built_in">swr_free</span>(&amp;ctx);<br></code></pre></td></tr></table></figure>


<h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><p><a href="https://www.cnblogs.com/mjios/p/14540642.html#toc_title_1">【秒懂音视频开发】08_音频录制02_编程</a></p>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>pcm转wav</title>
    <url>/2023/09/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/pcm%E8%BD%ACwav/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<blockquote>
<p>播放器是无法直接播放<code>PCM</code>的，因为播放器并不知道<code>PCM</code>的采样率、声道数、位深度等参数。当<code>PCM</code>转成某种特定的音频文件格式后（比如转成<code>WAV</code>），就能够被播放器识别播放了。</p>
</blockquote>
<h1 id="WAV"><a href="#WAV" class="headerlink" title="WAV"></a>WAV</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p><code>WAV（Waveform Audio File Format）</code>，是由<code>IBM</code>和<code>Microsoft</code>开发的音频文件格式，扩展名是<code>.wav</code>，通常采用<code>PCM</code>编码，常用于<code>Windows</code>系统中。</p>
</blockquote>
<ul>
<li><a href="https://wavefilegem.com/how_wave_files_work.html">WAV的文件格式</a>,如下图所示(<a href="http://soundfile.sapp.org/doc/WaveFormat/">原图</a>)，前面有<code>44</code>个字节的文件头，紧跟在后面的就是音频数据（比如PCM数据）。<br><img src="1.gif"><br><img src="2.gif"></li>
<li><code>NumChannels</code>：声道数</li>
<li><code>SampleRate</code>：采样率（<code>Hz</code>）</li>
<li><code>ByteRate</code>：每秒多少个字节（<code>Byte/s</code>）</li>
<li><code>BlockAlign</code>: 一个样本的字节数（<code>NumChannels</code> * <code>BitsPerSample</code>/<code>8</code>）</li>
<li><code>BitsPerSample</code>：位深度</li>
</ul>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><blockquote>
<ul>
<li><code>WAV</code>、<code>AVI</code>文件都是基于<code>RIFF</code>标准的文件格式</li>
<li><code>RIFF</code>（<code>Resource Interchange File Format</code>，资源交换文件格式）由<code>Microsoft</code>和<code>IBM</code>提出</li>
<li>所以<code>WAV</code>、<code>AVI</code>文件的最前面<code>4</code>个字节都是<code>RIFF</code>四个字符</li>
</ul>
</blockquote>
<p><img src="3.png"></p>
<ul>
<li><p>每一个<code>chunk</code>（数据块）都由<code>3</code>部分组成：</p>
<ul>
<li><code>id</code>：<code>chunk</code>的标识</li>
<li><code>data size</code>：<code>chunk</code>的数据部分大小，字节为单位</li>
<li><code>data</code>，<code>chunk</code>的数据部分</li>
</ul>
</li>
<li><p>整个<code>WAV</code>文件是一个<code>RIFF chunk</code>，它的<code>data</code>由<code>3</code>部分组成：</p>
<ul>
<li><code>format</code>：文件类型</li>
<li><code>fmt chunk</code><ul>
<li>音频参数相关的<code>chunk</code></li>
<li>它的<code>data</code>里面有采样率、声道数、位深度等参数信息</li>
</ul>
</li>
</ul>
</li>
<li><p><code>data chunk</code></p>
<ul>
<li>音频数据相关的<code>chunk</code></li>
<li>它的<code>data</code>就是真正的音频数据（比如PCM数据）</li>
</ul>
</li>
<li><p><code>RIFF chunk</code>除去<code>data chunk</code>的<code>data</code>（音频数据）后，剩下的内容可以称为：WAV文件头，一般是<code>44</code>字节。</p>
</li>
<li><p>一般二进制文件格式,可以通过<code>ffmpeg -ar 44100 -ac 2 -f s16le -i out.pcm -bitexact out2.wav</code>转换获取。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">           RIFF      文件大小减<span class="hljs-number">4</span> WAVE      fmt       <span class="hljs-number">16</span>字节长度  PCM 声道<span class="hljs-number">2</span><br><span class="hljs-number">00000000</span>:  <span class="hljs-number">5249</span> <span class="hljs-number">4646</span> <span class="hljs-number">2458</span> <span class="hljs-number">0200</span> <span class="hljs-number">5741</span> <span class="hljs-number">5645</span> <span class="hljs-number">666</span>d <span class="hljs-number">7420</span> <span class="hljs-number">1000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0100</span> <span class="hljs-number">0200</span>  :RIFF$X..WAVEfmt ........<br>        采样率<span class="hljs-number">0xac44</span>  字节数          位深  data      PCM数据大小<br><span class="hljs-number">00000018</span>:  <span class="hljs-number">44</span>ac <span class="hljs-number">0000</span> <span class="hljs-number">10b</span>1 <span class="hljs-number">0200</span> <span class="hljs-number">0400</span> <span class="hljs-number">1000</span> <span class="hljs-number">6461</span> <span class="hljs-number">7461</span> <span class="hljs-number">0058</span> <span class="hljs-number">0200</span> <span class="hljs-number">092</span>d <span class="hljs-number">36b</span>a  :D...........data.X...<span class="hljs-number">-6.</span><br><span class="hljs-number">00000030</span>:  <span class="hljs-number">61f</span>f b4ba cfb6 a5ba <span class="hljs-number">63</span>c2 ffba ae3c <span class="hljs-number">0f</span>bb fd82 <span class="hljs-number">4</span>cbb <span class="hljs-number">7</span>d94 <span class="hljs-number">5f</span>bb  :a.......c....&lt;....L.&#125;._.<br>......<br></code></pre></td></tr></table></figure>
<ul>
<li>有一些<code>WAVE</code>会多增加了一个<code>34</code>字节大小的<code>LIST chunk</code>(包含库版本等信息，非必要<code>chunk</code>)。通过<code>ffmpeg -ar 44100 -ac 2 -f s16le -i out.pcm out.wav</code>,可看到.<ul>
<li><a href="https://stackoverflow.com/questions/63929283/what-is-a-list-chunk-in-a-riff-wav-header">What is a “LIST” chunk in a RIFF/Wav header?</a></li>
<li><a href="https://www.recordingblogs.com/wiki/list-chunk-of-a-wave-file">List chunk (of a RIFF file)</a><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00000000</span>:  <span class="hljs-number">5249</span> <span class="hljs-number">4646</span> <span class="hljs-number">460</span>c <span class="hljs-number">0f</span>00 <span class="hljs-number">5741</span> <span class="hljs-number">5645</span> <span class="hljs-number">666</span>d <span class="hljs-number">7420</span> <span class="hljs-number">1000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span>  :RIFFF...WAVEfmt ........<br><span class="hljs-number">00000018</span>:  <span class="hljs-number">80b</span>b <span class="hljs-number">0000</span> <span class="hljs-number">0077</span> <span class="hljs-number">0100</span> <span class="hljs-number">0200</span> <span class="hljs-number">1000</span> <span class="hljs-number">4</span>c49 <span class="hljs-number">5354</span> <span class="hljs-number">1</span>a00 <span class="hljs-number">0000</span> <span class="hljs-number">494</span>e <span class="hljs-number">464f</span>  :.....w......LIST....INFO<br><span class="hljs-number">00000030</span>:  <span class="hljs-number">4953</span> <span class="hljs-number">4654</span> <span class="hljs-number">0</span>d00 <span class="hljs-number">0000</span> <span class="hljs-number">4</span>c61 <span class="hljs-number">7666</span> <span class="hljs-number">3630</span> <span class="hljs-number">2e33</span> <span class="hljs-number">2e31</span> <span class="hljs-number">3030</span> <span class="hljs-number">0000</span> <span class="hljs-number">6461</span>  :ISFT....Lavf60<span class="hljs-number">.3</span><span class="hljs-number">.100</span>..da<br><span class="hljs-number">00000048</span>:  <span class="hljs-number">7461</span> <span class="hljs-number">000</span>c <span class="hljs-number">0f</span>00 d0ff e7ff fcff <span class="hljs-number">0</span>a00 <span class="hljs-number">2400</span> <span class="hljs-number">4</span>d00 <span class="hljs-number">6300</span> <span class="hljs-number">5b</span>00 <span class="hljs-number">4700</span>  :ta............$.M.c.[.G.<br><span class="hljs-number">00000060</span>:  <span class="hljs-number">3200</span> <span class="hljs-number">2400</span> <span class="hljs-number">2600</span> <span class="hljs-number">2e00</span> <span class="hljs-number">2600</span> <span class="hljs-number">1500</span> <span class="hljs-number">0600</span> <span class="hljs-number">0200</span> <span class="hljs-number">1300</span> <span class="hljs-number">2</span>d00 <span class="hljs-number">2</span>d00 <span class="hljs-number">1700</span>  :<span class="hljs-number">2.</span>$.&amp;...&amp;.........-.-...<br><span class="hljs-number">00000078</span>:  <span class="hljs-number">1200</span> <span class="hljs-number">2200</span> <span class="hljs-number">2700</span> <span class="hljs-number">1400</span> feff fdff <span class="hljs-number">1100</span> <span class="hljs-number">1e00</span> <span class="hljs-number">1700</span> <span class="hljs-number">1300</span> <span class="hljs-number">1b</span>00 <span class="hljs-number">1f</span>00  :..<span class="hljs-string">&quot;.&#x27;...................</span><br><span class="hljs-string">......</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="WAV的文件头结构"><a href="#WAV的文件头结构" class="headerlink" title="WAV的文件头结构"></a><code>WAV</code>的文件头结构</h3><ul>
<li>根据上述介绍,<code>WAV</code>的文件头结构大概如下所示：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_FORMAT_PCM 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_FORMAT_FLOAT 3</span><br> <br><span class="hljs-comment">// WAV文件头（44字节）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// RIFF chunk的id,不能用&quot;RIFF&quot;赋值，因为c++中&quot;RIFF&quot;实际为&#123;&#x27;R&#x27;, &#x27;I&#x27;, &#x27;F&#x27;, &#x27;F&#x27;,&#x27;\0&#x27;&#125;</span><br>    <span class="hljs-keyword">uint8_t</span> riffChunkId[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>&#125;;<br>    <span class="hljs-comment">// RIFF chunk的data大小，即文件总长度减去8字节</span><br>    <span class="hljs-keyword">uint32_t</span> riffChunkDataSize;<br> <br>    <span class="hljs-comment">// &quot;WAVE&quot;</span><br>    <span class="hljs-keyword">uint8_t</span> format[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>&#125;;<br> <br>    <span class="hljs-comment">/* fmt chunk */</span><br>    <span class="hljs-comment">// fmt chunk的id</span><br>    <span class="hljs-keyword">uint8_t</span> fmtChunkId[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>&#125;;<br>    <span class="hljs-comment">// fmt chunk的data大小：存储PCM数据时，是16</span><br>    <span class="hljs-keyword">uint32_t</span> fmtChunkDataSize = <span class="hljs-number">16</span>;<br>    <span class="hljs-comment">// 音频编码，1表示PCM，3表示Floating Point</span><br>    <span class="hljs-keyword">uint16_t</span> audioFormat = AUDIO_FORMAT_PCM;<br>    <span class="hljs-comment">// 声道数</span><br>    <span class="hljs-keyword">uint16_t</span> numChannels;<br>    <span class="hljs-comment">// 采样率</span><br>    <span class="hljs-keyword">uint32_t</span> sampleRate;<br>    <span class="hljs-comment">// 字节率 = sampleRate * blockAlign</span><br>    <span class="hljs-keyword">uint32_t</span> byteRate;<br>    <span class="hljs-comment">// 一个样本的字节数 = bitsPerSample * numChannels &gt;&gt; 3</span><br>    <span class="hljs-keyword">uint16_t</span> blockAlign;<br>    <span class="hljs-comment">// 位深度</span><br>    <span class="hljs-keyword">uint16_t</span> bitsPerSample;<br> <br>    <span class="hljs-comment">/* data chunk */</span><br>    <span class="hljs-comment">// data chunk的id</span><br>    <span class="hljs-keyword">uint8_t</span> dataChunkId[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;;<br>    <span class="hljs-comment">// data chunk的data大小：音频数据的总长度，即文件总长度减去文件头的长度(一般是44)</span><br>    <span class="hljs-keyword">uint32_t</span> dataChunkDataSize;<br>&#125; WAVHeader;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="PCM转WAV代码"><a href="#PCM转WAV代码" class="headerlink" title="PCM转WAV代码"></a>PCM转WAV代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QFile&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FFmpegs</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FFmpegs</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pcm2wav</span><span class="hljs-params">(WAVHeader &amp;header,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pcmFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *wavFilename)</span></span>;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFmpegs::pcm2wav</span><span class="hljs-params">(WAVHeader &amp;header,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pcmFilename,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *wavFilename)</span> </span>&#123;<br>    header.blockAlign = header.bitsPerSample * header.numChannels &gt;&gt; <span class="hljs-number">3</span>;<br>    header.byteRate = header.sampleRate * header.blockAlign;<br> <br>    <span class="hljs-comment">// 打开pcm文件</span><br>    <span class="hljs-function">QFile <span class="hljs-title">pcmFile</span><span class="hljs-params">(pcmFilename)</span></span>;<br>    <span class="hljs-keyword">if</span> (!pcmFile.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; pcmFilename;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    header.dataChunkDataSize = pcmFile.<span class="hljs-built_in">size</span>();<br>    header.riffChunkDataSize = header.dataChunkDataSize<br>                               + <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (WAVHeader) - <span class="hljs-number">8</span>;<br> <br>    <span class="hljs-comment">// 打开wav文件</span><br>    <span class="hljs-function">QFile <span class="hljs-title">wavFile</span><span class="hljs-params">(wavFilename)</span></span>;<br>    <span class="hljs-keyword">if</span> (!wavFile.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; wavFilename;<br> <br>        pcmFile.<span class="hljs-built_in">close</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 写入头部</span><br>    wavFile.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *) &amp;header, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (WAVHeader));<br> <br>    <span class="hljs-comment">// 写入pcm数据</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">while</span> ((size = pcmFile.<span class="hljs-built_in">read</span>(buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (buf))) &gt; <span class="hljs-number">0</span>) &#123;<br>        wavFile.<span class="hljs-built_in">write</span>(buf, size);<br>    &#125;<br> <br>    <span class="hljs-comment">// 关闭文件</span><br>    pcmFile.<span class="hljs-built_in">close</span>();<br>    wavFile.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 封装WAV的头部</span><br>WAVHeader header;<br>header.numChannels = <span class="hljs-number">2</span>;<br>header.sampleRate = <span class="hljs-number">44100</span>;<br>header.bitsPerSample = <span class="hljs-number">16</span>;<br> <br><span class="hljs-comment">// 调用函数</span><br>FFmpegs::<span class="hljs-built_in">pcm2wav</span>(header, <span class="hljs-string">&quot;/usr/in.pcm&quot;</span>, <span class="hljs-string">&quot;/usr/out.wav&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>一般情况下是<code>s16le</code>，如果是<code>f32le</code>,这里<code>f</code>指浮点，这里<code>audioFormat</code>要设置成<code>3</code></li>
<li>具体见<a href="https://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">WAV的文件格式</a></li>
<li>如果是录制的转换，可以从格式化上下文<code>AVFormatContext</code>的<code>ctx</code>中解析参数赋值<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">AVCodecParameters *params = ctx-&gt;streams[<span class="hljs-number">0</span>]-&gt;codecpar;<br>WAVHeader wavHeader;<br>wavHeader.numChannel = params-&gt;ch_layout.nb_channels;<br>wavHeader.sampleRate = params-&gt;sample_rate;<br>wavHeader.bitsPerSample = <span class="hljs-built_in">av_get_bits_per_sample</span>(params-&gt;codec_id);<br>wavHeader.audioFormat = (params-&gt;codec_id &gt;= AV_CODEC_ID_PCM_F32BE) ? <span class="hljs-number">3</span>:<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>pcm音频播放</title>
    <url>/2023/08/31/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/pcm%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a><code>SDL</code></h1><blockquote>
<ul>
<li>正常播放音频可以通过<code>ffplay</code>来播放，通过命令指令:<code>fplay -ar 44100 -ac 2 -f s16le out.pcm</code><ul>
<li><code>ar</code>: 采样率</li>
<li><code>ac</code>: 声道数</li>
<li><code>f</code>: 采样格式，通过<code>ffmpeg -formats | grep PCM</code></li>
</ul>
</li>
<li><code>ffplay</code>是基于<code>FFmpeg</code>、<code>SDL</code>两个库实现的。通过编程的方式播放音视频，也是需要用到这<code>2</code>个库。</li>
</ul>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><code>SDL（Simple DirectMedia Layer</code>，是一个跨平台的C语言多媒体开发库。<ul>
<li>支持<code>Windows</code>、<code>Mac OS X</code>、<code>Linux</code>、<code>iOS</code>、<code>Android</code></li>
<li>提供对音频、键盘、鼠标、游戏操纵杆、图形硬件的底层访问</li>
<li>很多的视频播放软件、模拟器、受欢迎的游戏都在使用它</li>
<li><a href="https://wiki.libsdl.org/SDL2/FrontPage"><code>API</code>文档</a></li>
<li><code>mac</code>上在安装<code>ffmpeg</code>时已经顺带安装了<code>SDL</code></li>
</ul>
</li>
</ul>
<h1 id="播放PCM"><a href="#播放PCM" class="headerlink" title="播放PCM"></a>播放<code>PCM</code></h1><blockquote>
<p>在<code>QT</code>中进行开发</p>
</blockquote>
<h2 id="准备PCM文件"><a href="#准备PCM文件" class="headerlink" title="准备PCM文件"></a><sapn id="jump">准备PCM文件</sapn></h2><ol>
<li><code>ffprobe 01.mp3</code>,查看转换的<code>mp3</code>的格式，可以看出是 <code>mp3</code> 文件采样率是 <code>44100</code> Hz，单声道(<code>mono</code>)<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Duration: <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">14.89</span>, start: <span class="hljs-number">0.000000</span>, bitrate: <span class="hljs-number">64</span> kb/s<br> Stream #<span class="hljs-number">0</span>:<span class="hljs-number">0</span>: Audio: mp3, <span class="hljs-number">44100</span> Hz, mono, fltp, <span class="hljs-number">64</span> kb/s<br> Stream #<span class="hljs-number">0</span>:<span class="hljs-number">1</span>: Video: png, <span class="hljs-built_in">rgba</span>(pc), <span class="hljs-number">400</span>x400, <span class="hljs-number">90</span>k tbr, <span class="hljs-number">90</span><span class="hljs-function">k <span class="hljs-title">tbn</span> <span class="hljs-params">(attached pic)</span></span><br><span class="hljs-function">   Metadata:</span><br><span class="hljs-function">     comment         : Cover (front)</span><br></code></pre></td></tr></table></figure></li>
<li><code> ffmpeg -i 01.mp3 -f s16le -ac 1 -ar 44100 11.pcm</code></li>
<li>验证<code>ffplay -ar 44100 -ac 1 -f s16le -i 11.pcm</code></li>
</ol>
<h2 id="pro文件配置"><a href="#pro文件配置" class="headerlink" title=".pro文件配置"></a><code>.pro</code>文件配置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">mac: &#123;<br>    FFMPEG_HOME = /usr/local/Cellar/ffmpeg/<span class="hljs-number">6.0</span>_1<br>    SDL_HOME = /usr/local/Cellar/sdl2/<span class="hljs-number">2.28</span><span class="hljs-number">.2</span><br>&#125;<br><br>    INCLUDEPATH += $$&#123;FFMPEG_HOME&#125;/include<br>    LIBS += -L$$&#123;FFMPEG_HOME&#125;/lib \<br>            -lavdevice \<br>            -lavcodec \<br>             -lavformat \<br>             -lavutil<br><br>    INCLUDEPATH += $$&#123;SDL_HOME&#125;/include<br>    LIBS += -L$$&#123;SDL_HOME&#125;/lib \<br>        -lSDL2<br></code></pre></td></tr></table></figure>

<h2 id="初始化子系统"><a href="#初始化子系统" class="headerlink" title="初始化子系统"></a>初始化子系统</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_TIMER          0x00000001u</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_AUDIO          0x00000010u</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_VIDEO          0x00000020u  <span class="hljs-comment">/**&lt; SDL_INIT_VIDEO implies SDL_INIT_EVENTS */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_JOYSTICK       0x00000200u  <span class="hljs-comment">/**&lt; SDL_INIT_JOYSTICK implies SDL_INIT_EVENTS */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_HAPTIC         0x00001000u</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_GAMECONTROLLER 0x00002000u  <span class="hljs-comment">/**&lt; SDL_INIT_GAMECONTROLLER implies SDL_INIT_JOYSTICK */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_EVENTS         0x00004000u</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_SENSOR         0x00008000u</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_NOPARACHUTE    0x00100000u  <span class="hljs-comment">/**&lt; compatibility; this flag is ignored. */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_INIT_EVERYTHING ( \</span><br><span class="hljs-meta">                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \</span><br><span class="hljs-meta">                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER | SDL_INIT_SENSOR \</span><br><span class="hljs-meta">            )</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>SDL</code>分成好多个子系统（<code>subsystem</code>）：</p>
<ul>
<li><code>Video</code>：显示和窗口管理</li>
<li><code>Audio</code>：音频设备管理</li>
<li><code>Joystick</code>：游戏摇杆控制</li>
<li><code>Timers</code>：定时器</li>
<li>……</li>
</ul>
</li>
<li><p>目前只用到了音频功能，所以只需要通过<code>SDL_init</code>函数初始化<code>Audio</code>子系统即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化Audio子系统</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SDL_Init</span>(SDL_INIT_AUDIO)) &#123;<br>        <span class="hljs-comment">//返回值不是0，就代表失败</span><br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;SDL_Init Error&quot;</span> &lt;&lt; <span class="hljs-built_in">SDL_GetError</span>();<br>        <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="打开音频设备"><a href="#打开音频设备" class="headerlink" title="打开音频设备"></a>打开音频设备</h2><blockquote>
<p>打开音频设备，设置一些音频参数，这里参数和一开始提供的<a href="#jump">PCM文件</a>参数保持一致，否则会出现噪音</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 采样率</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_RATE 44100</span><br><span class="hljs-comment">// 采样格式</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_FORMAT AUDIO_S16LSB</span><br><span class="hljs-comment">// 采样大小</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_SIZE SDL_AUDIO_BITSIZE(SAMPLE_FORMAT)</span><br><span class="hljs-comment">// 声道数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHANNELS 1</span><br><span class="hljs-comment">// 音频缓冲区的样本数量</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLES 1024</span><br><span class="hljs-comment">//每个样本占用多少个字节</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BYTES_PER_SAMPPLE (SAMPLE_SIZE * CHANNELS &gt;&gt; 3)</span><br><span class="hljs-comment">// 文件缓冲区的大小</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE (SAMPLES * BYTES_PER_SAMPPLE)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILENAME <span class="hljs-meta-string">&quot;/Users/chenjingpo/Desktop/11.pcm&quot;</span></span><br><br><span class="hljs-comment">// 用于存储读取的音频数据和长度</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AudioBuffer</span> &#123;</span><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>; <span class="hljs-comment">//数据大小</span><br>    <span class="hljs-keyword">int</span> pulllen = <span class="hljs-number">0</span>;<span class="hljs-comment">// 实际播放拉取的数据</span><br>    Uint8 *data = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br><br><span class="hljs-comment">// 音频参数</span><br>SDL_AudioSpec spec;<br>spec.freq = SAMPLE_RATE;<br><span class="hljs-comment">// 采样格式（s16le）</span><br>spec.format = SAMPLE_FORMAT;<br>spec.channels = CHANNELS;<br><span class="hljs-comment">// 音频缓冲区的样本数量（这个值必须是2的幂）</span><br>spec.samples = SAMPLES;<br><span class="hljs-comment">// 回调,这里音频设备主要需要音频数据</span><br>spec.callback = pull_audio_data;<br><span class="hljs-comment">//传递给回调的参数</span><br>AudioBuffer buffer;<br>spec.userdata = &amp;buffer;<br><br><span class="hljs-comment">//打开音频设备</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">SDL_OpenAudio</span>(&amp;spec,<span class="hljs-literal">nullptr</span>)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;SDL_OpenAudio Error&quot;</span> &lt;&lt; <span class="hljs-built_in">SDL_GetError</span>();<br>    <span class="hljs-comment">// 清除所有初始化的子系统</span><br>    <span class="hljs-built_in">SDL_Quit</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>SAMPLES</code>,样本数据必须是<code>2</code>的幂，并且，这个数是有上限的，根据平台不同会不同。此外如果这个数过大的话，表明缓冲区也很大（需要播放的时间较长），那么回调中获取数据的间隔也会变长</li>
</ul>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//打开文件</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(FILENAME)</span></span>;<br><span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;打开文件失败&quot;</span> &lt;&lt; FILENAME;<br>    <span class="hljs-comment">//关闭音频设备</span><br>    <span class="hljs-built_in">SDL_CloseAudio</span>();<br>    <span class="hljs-comment">// 清除所有初始化的子系统</span><br>    <span class="hljs-built_in">SDL_Quit</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="开始播放"><a href="#开始播放" class="headerlink" title="开始播放"></a>开始播放</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">//开始播放（0是取消暂停）</span><br><span class="hljs-built_in">SDL_PauseAudio</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 存放文件数据</span><br>Uint8 data[BUFFER_LEN];<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isInterruptionRequested</span>()) &#123;<br>    <span class="hljs-comment">// 只要从文件中读取的音频数据，还没有填充完毕，就跳过</span><br>    <span class="hljs-keyword">if</span>(buffer.len &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    buffer.len = file.<span class="hljs-built_in">read</span>(data,BUFFER_SIZE);<br>    <span class="hljs-comment">//数据已经读取完毕</span><br>    <span class="hljs-keyword">if</span> ( buffer.len &lt;= <span class="hljs-number">0</span> ) &#123;<br>        <span class="hljs-comment">//剩余的样本数量</span><br>        <span class="hljs-keyword">int</span> samples = buffer.pulllen / BYTES_PER_SAMPPLE;<br>        <span class="hljs-keyword">int</span> ms = samples * <span class="hljs-number">1000</span> / SAMPLE_RATE;<br>        <span class="hljs-comment">//这里延迟毫秒,防止最后一段文件，没在回调播放完，就循环退出，导致无法播放</span><br>        <span class="hljs-built_in">SDL_Delay</span>(ms);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取到的数据</span><br>    buffer.data = (Uint8 *) data;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><blockquote>
<p>这里需要将音频文件中的数据，填充到缓冲区</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// userdata：SDL_AudioSpec.userdata</span><br><span class="hljs-comment">// stream：音频缓冲区（需要将音频数据填充到这个缓冲区）</span><br><span class="hljs-comment">// len：音频缓冲区的大小（SDL_AudioSpec.samples * 每个样本的大小,即声道乘以位深，这里是16*2,即4字节）</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pull_audio_data</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 清空stream</span><br>    <span class="hljs-built_in">SDL_memset</span>(stream,<span class="hljs-number">0</span>,len);<br>    <br>    <span class="hljs-comment">//取出缓冲的信息</span><br>    AudioBuffer *buffer = (AudioBuffer *)userdata;<br>    <span class="hljs-comment">//文件数据还没有准备好</span><br>    <span class="hljs-keyword">if</span> (buffer-&gt;len &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 取len、bufferlen的最小值(为了保证数据安全，防止指针越界)</span><br>    buffer-&gt;pulllen = (len &gt; buffer-&gt;len) ? buffer-&gt;len:len;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; len &lt;&lt; buffer-&gt;pulllen;<br>    <span class="hljs-comment">// 填充数据</span><br>    <span class="hljs-built_in">SDL_MixAudio</span>(stream,buffer-&gt;data, buffer-&gt;pulllen,SDL_MIX_MAXVOLUME);<br>     buffer-&gt;data += buffer-&gt;pulllen;<br>    buffer-&gt;len -= buffer-&gt;pulllen;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 关闭文件</span><br>file.<span class="hljs-built_in">close</span>();<br><span class="hljs-comment">// 关闭音频设备</span><br><span class="hljs-built_in">SDL_CloseAudio</span>();<br><span class="hljs-comment">// 清理所有初始化的子系统</span><br><span class="hljs-built_in">SDL_Quit</span>();<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>命令行和编程实现音视频录制</title>
    <url>/2023/08/23/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8C%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h1><blockquote>
<ol>
<li>通过<code>brew install ffmpeg</code>指令安装<code>FFmpeg</code>,后，会存放在<code>/usr/local/Cellar/ffmpeg</code>文件夹中</li>
<li>其<code>bin</code>目录中提供了<code>3</code>个命令（<code>ffmpeg</code>、<code>ffplay</code>、<code>ffprobe</code>），可以直接在命令行上使用</li>
</ol>
</blockquote>
<h2 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a><code>ffmpeg</code></h2><blockquote>
<p><code>ffmpeg</code>的主要作用：对音视频进行编解码。</p>
</blockquote>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><ul>
<li><p><code>ffmpeg</code>命令的使用格式是</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...<br></code></pre></td></tr></table></figure></li>
<li><p>简化一下，常用格式是：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> arg1 arg2 -i arg3 arg4 arg5<br></code></pre></td></tr></table></figure>
<ul>
<li><code>arg1</code>：全局参数</li>
<li><code>arg2</code>：输入文件参数</li>
<li><code>arg3</code>：输入文件</li>
<li><code>arg4</code>：输出文件参数</li>
<li><code>arg5</code>：输出文件</li>
</ul>
</li>
<li><p>更多详细用法，可以参考官方文档：<a href="https://ffmpeg.org/ffmpeg-all.html">ffmpeg-all.html</a>，或者使用以下命令查看：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 简易版</span><br><span class="hljs-variable">$ffmpeg</span> -h<br><span class="hljs-comment"># 详细版</span><br><span class="hljs-variable">$ffmpeg</span> -h long<br><span class="hljs-comment"># 完整版</span><br><span class="hljs-variable">$ffmpeg</span> -h full<br> <br><span class="hljs-comment"># 或者使用</span><br><span class="hljs-comment"># ffmpeg -help</span><br><span class="hljs-comment"># ffmpeg -help long</span><br><span class="hljs-comment"># ffmpeg -help full</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>将<code>MP3</code>文件转成<code>WAV</code>文件<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> -i xx.mp3 yy.wav<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="ffprobe"><a href="#ffprobe" class="headerlink" title="ffprobe"></a><code>ffprobe</code></h2><blockquote>
<p><code>ffprobe</code>的主要作用：查看音视频的参数信息。</p>
</blockquote>
<h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><ul>
<li><code>ffmpeg</code>命令的使用格式是  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffprobe</span> [OPTIONS] [INPUT_FILE]<br><span class="hljs-comment"># OPTIONS：参数</span><br><span class="hljs-comment"># INPUT_FILE：输入文件</span><br></code></pre></td></tr></table></figure></li>
<li>更多详细用法，可以参考官方文档：<a href="https://ffmpeg.org/ffprobe-all.html">ffprobe-all.html</a>，或者使用以下命令查看：  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 简易版</span><br><span class="hljs-variable">$ffprobe</span> -h<br><span class="hljs-comment"># 详细版</span><br><span class="hljs-variable">$ffprobe</span> -h long<br><span class="hljs-comment"># 完整版</span><br><span class="hljs-variable">$ffprobe</span> -h full<br> <br><span class="hljs-comment"># 或者使用</span><br><span class="hljs-comment"># ffprobe -help</span><br><span class="hljs-comment"># ffprobe -help long</span><br><span class="hljs-comment"># ffprobe -help full</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><ul>
<li>查看<code>MP3</code>文件的<code>采样率</code>、<code>比特率</code>、<code>时长</code>等信息  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffprobe</span> xx.mp3<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a><code>ffplay</code></h2><blockquote>
<p><code>ffplay</code>的主要作用：播放音视频。</p>
</blockquote>
<h3 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h3><ul>
<li><code>ffplay</code>命令的使用格式是  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffplay</span> [options] input_file<br><span class="hljs-comment"># options：参数</span><br><span class="hljs-comment"># input_file：输入文件</span><br></code></pre></td></tr></table></figure></li>
<li>更多详细用法，可以参考官方文档：<a href="https://ffmpeg.org/ffplay-all.html">ffplay-all.html</a>，或者使用以下命令查看：  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 简易版</span><br><span class="hljs-variable">$ffplay</span> -h<br><span class="hljs-comment"># 详细版</span><br><span class="hljs-variable">$ffplay</span> -h long<br><span class="hljs-comment"># 完整版</span><br><span class="hljs-variable">$ffplay</span> -h full<br> <br><span class="hljs-comment"># 或者使用</span><br><span class="hljs-comment"># ffplay -help</span><br><span class="hljs-comment"># ffplay -help long</span><br><span class="hljs-comment"># ffplay -help full</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><ul>
<li>播放<code>MP3</code>文件  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffplay</span> xx.mp3<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="hide-banner"><a href="#hide-banner" class="headerlink" title="hide_banner"></a><code>hide_banner</code></h2><blockquote>
<p>增加<code>-hide_bannder</code>参数可以隐藏一些冗余的描述信息</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffprobe</span> -hide_banner xx.mp3<br> <br><span class="hljs-comment"># ffmpeg、ffprobe、ffplay都适用</span><br></code></pre></td></tr></table></figure>

<h1 id="通过命令行录音"><a href="#通过命令行录音" class="headerlink" title="通过命令行录音"></a>通过命令行录音</h1><h2 id="查看可用设备"><a href="#查看可用设备" class="headerlink" title="查看可用设备"></a>查看可用设备</h2><ol>
<li>使用命令行查看当前平台的可用设备： <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> -devices<br></code></pre></td></tr></table></figure>
<ul>
<li><code>Mac</code>的输出结果如下所示：<ul>
<li>列表中有个<code>avfoundation</code>，是<code>Mac</code>平台的多媒体系统库</li>
<li>我们可以使用<code>avfoundation</code>去操作多媒体输入设备（比如录音设备）<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Devices:<br>D. = Demuxing supported<br>.E = Muxing supported<br>--<br> E audiotoolbox    AudioToolbox output device<br>D  avfoundation    AVFoundation input device<br>D  lavfi           Libavfilter virtual input device<br> E sdl,sdl2        SDL2 output device<br>D  x11grab         X11 screen capture, using XCB<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>Windows</code>的输出结果如下所示：<ul>
<li>列表中有个<code>dshow</code>，全名叫<code>DirectShow</code>，是<code>Windows</code>平台的多媒体系统库</li>
<li>我们可以使用<code>dshow</code>去操作多媒体输入设备（比如录音设备）<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Devices:<br>D. = Demuxing supported<br>.E = Muxing supported<br>--<br> E caca            caca (color ASCII art) output device<br>D  dshow           DirectShow capture<br>D  gdigrab         GDI API Windows frame grabber<br>D  lavfi           Libavfilter virtual input device<br>D  libcdio<br> E sdl,sdl2        SDL2 output device<br>D  vfwcap          VfW video capture<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="查看avfoundation支持的设备"><a href="#查看avfoundation支持的设备" class="headerlink" title="查看avfoundation支持的设备"></a>查看<code>avfoundation</code>支持的设备</h2><ul>
<li>在<code>Mac</code>平台，使用的是<code>avfoundation</code>,查看所支持的设备  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> -f avfoundation -list_devices <span class="hljs-literal">true</span> -i <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>f</code>表示输入设备的格式</li>
<li><code>ffmpeg</code>规定格式<code>i</code>(input)后面是输入文件路径，这里没有，用<code>&#39;&#39;</code>来表示</li>
<li>输出结果如下所示：  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[AVFoundation indev @ 0x7ff282f04ec0] AVFoundation video devices:<br>[AVFoundation indev @ 0x7ff282f04ec0] [0] FaceTime高清摄像头（内建）<br>[AVFoundation indev @ 0x7ff282f04ec0] [1] “HUAWEI 12plus”的相机<br>[AVFoundation indev @ 0x7ff282f04ec0] [2] Capture screen 0<br>[AVFoundation indev @ 0x7ff282f04ec0] AVFoundation audio devices:<br>[AVFoundation indev @ 0x7ff282f04ec0] [0] “HUAWEI 12plus”的麦克风<br>[AVFoundation indev @ 0x7ff282f04ec0] [1] MacBook Pro麦克风<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="指定设备进行录音"><a href="#指定设备进行录音" class="headerlink" title="指定设备进行录音"></a>指定设备进行录音</h2><ul>
<li>在<code>Mac</code>上通过编号指定设备，即<code>avfoundation</code>支持设备的编号  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffmpeg</span> -f avfoundation -i :0 out.wav<br><span class="hljs-comment"># :0表示使用0号音频设备</span><br><span class="hljs-comment"># 0:1表示使用0号视频设备和1号音频设备</span><br></code></pre></td></tr></table></figure></li>
<li>可以使用快捷键<code>control + C</code>终止录音</li>
<li>音频默认参数是<ul>
<li><code>Mac</code>：<code>48000</code>Hz采样率、<code>16</code>位深度、<code>2</code>声道、<code>789</code>Kbps比特率</li>
</ul>
</li>
</ul>
<h2 id="设置avfoundation参数"><a href="#设置avfoundation参数" class="headerlink" title="设置avfoundation参数"></a>设置<code>avfoundation</code>参数</h2><ul>
<li>先通过命令查看一下<code>avfoundation</code>可以使用的参数，详情可以查看官方文档：<a href="https://ffmpeg.org/ffmpeg-devices.html#avfoundation">avfoundation参数</a>。  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从ffmpeg -devices命令的结果可以看得出来：avfoundation属于demuxer，而不是muxer</span><br><span class="hljs-variable">$ffmpeg</span> -h demuxer=avfoundation<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="编程的方式进行录音"><a href="#编程的方式进行录音" class="headerlink" title="编程的方式进行录音"></a>编程的方式进行录音</h1><blockquote>
<p>采用<code>QT</code>跨平台的方式进行编码</p>
</blockquote>
<ol>
<li>开发录音功能的主要步骤是<ol>
<li>注册设备</li>
<li>获取输入格式对象</li>
<li>打开设备</li>
<li>采集数据</li>
<li>释放资源</li>
</ol>
</li>
</ol>
<p><img src="1.png">    </p>
<ol start="2">
<li>需要用的<code>FFMpeg</code>库有4个<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-comment">// 设备相关API</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavdevice/avdevice.h&gt;</span></span><br><span class="hljs-comment">// 格式相关API</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span><br><span class="hljs-comment">// 工具相关API（比如错误处理）</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavutil/avutil.h&gt;</span></span><br><span class="hljs-comment">// 编码相关API</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="权限申请"><a href="#权限申请" class="headerlink" title="权限申请"></a>权限申请</h2><ol>
<li>在<code>Mac</code>平台，有<code>2</code>个注意点：<ul>
<li>需要在<code>Info.plist</code>中添加麦克风的使用说明，申请麦克风的使用权限</li>
<li>使用<code>Debug</code>模式运行程序</li>
<li>不然会出现闪退的情况<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!DOCTYPE plist PUBLIC <span class="hljs-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSMicrophoneUsageDescription<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>如果不允许，你将无法使用语音控制设备、语音录入等功能<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在<code>qt</code>的<code>pro</code>文件中增加<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">mac: &#123;<br>    FFMPEG_HOME = <span class="hljs-regexp">/usr/</span>local/Cellar/ffmpeg/<span class="hljs-number">6.0_1</span><br>    # 设置头文件路径<br>    INCLUDEPATH += $$&#123;FFMPEG_HOME&#125;/include<br>    # 设置库文件路径<br>    LIBS += -L $$&#123;FFMPEG_HOME&#125;/lib \<br>            -lavdevice \<br>            -lavformat \<br>            -lavutil<br><br>    QMAKE_INFO_PLIST = Info.plist <span class="hljs-comment">//增加info.plist</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="注册设备"><a href="#注册设备" class="headerlink" title="注册设备"></a>注册设备</h2><blockquote>
<p>在整个程序的运行过程中，只需要执行1次注册设备的代码。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化libavdevice并注册所有输入和输出设备</span><br><span class="hljs-built_in">avdevice_register_all</span>();<br></code></pre></td></tr></table></figure>

<h2 id="获取输入格式对象"><a href="#获取输入格式对象" class="headerlink" title="获取输入格式对象"></a>获取输入格式对象</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><blockquote>
<p><code>Windows</code>和<code>Mac</code>环境的格式名称、设备名称都是不同的，所以使用条件编译实现跨平台。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 格式名称、设备名称目前暂时使用宏定义固定死</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br>    <span class="hljs-comment">// 格式名称</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FMT_NAME <span class="hljs-meta-string">&quot;dshow&quot;</span></span><br>    <span class="hljs-comment">// 设备名称</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEVICE_NAME <span class="hljs-meta-string">&quot;audio=麦克风阵列 (Realtek(R) Audio)&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FMT_NAME <span class="hljs-meta-string">&quot;avfoundation&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEVICE_NAME <span class="hljs-meta-string">&quot;:0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><blockquote>
<p>根据格式名称获取输入格式对象，后面需要利用输入格式对象打开设备。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">AVInputFormat *fmt = <span class="hljs-built_in">av_find_input_format</span>(FMT_NAME);<br><span class="hljs-keyword">if</span> (!fmt) &#123;<br>    <span class="hljs-comment">// 如果找不到输入格式</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;找不到输入格式&quot;</span> &lt;&lt; FMT_NAME;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="打开设备"><a href="#打开设备" class="headerlink" title="打开设备"></a>打开设备</h2><blockquote>
<p>根据格式和设备名去打开设备，在命令行指令<code>ffmpeg -f avfoundation -list_devices true -i</code>中，可以先找到可以用的设备</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 格式上下文（后面通过格式上下文操作设备）</span><br>AVFormatContext *ctx = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 打开设备</span><br><span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">avformat_open_input</span>(&amp;ctx, DEVICE_NAME, fmt, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">// 如果打开设备失败</span><br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">char</span> errbuf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// 根据函数返回的错误码获取错误信息</span><br>    <span class="hljs-built_in">av_strerror</span>(ret, errbuf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (errbuf));<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;打开设备失败&quot;</span> &lt;&lt; errbuf;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h2><h3 id="宏定义-1"><a href="#宏定义-1" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br>    <span class="hljs-comment">// PCM文件的文件名</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILENAME <span class="hljs-meta-string">&quot;F:/out.pcm&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILENAME <span class="hljs-meta-string">&quot;/Users/chenjingbo/Desktop/out.pcm&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QFile&gt;</span></span><br> <br><span class="hljs-comment">// 文件</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(FILENAME)</span></span>;<br> <br><span class="hljs-comment">// WriteOnly：只写模式。如果文件不存在，就创建文件；如果文件存在，就删除文件内容</span><br><span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QFile::WriteOnly)) &#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; FILENAME;<br>    <span class="hljs-comment">// 关闭设备</span><br>    <span class="hljs-built_in">avformat_close_input</span>(&amp;ctx);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-comment">// 暂时假定只采集50个数据包</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">50</span>;<br> <br><span class="hljs-comment">// 数据包</span><br>AVPacket *pkt = <span class="hljs-built_in">av_packet_alloc</span>();<br><span class="hljs-keyword">while</span> (count-- &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 从设备中采集数据，返回值为0，代表采集数据成功</span><br>    ret = <span class="hljs-built_in">av_read_frame</span>(ctx, pkt);<br> <br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 读取成功</span><br>        <span class="hljs-comment">// 将数据写入文件</span><br>        file.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *) pkt-&gt;data, pkt-&gt;size);<br>    <br>        <span class="hljs-comment">// 释放资源</span><br>        <span class="hljs-built_in">av_packet_unref</span>(pkt);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-built_in">AVERROR</span>(EAGAIN)) &#123; <span class="hljs-comment">// 资源临时不可用</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 其他错误</span><br>        <span class="hljs-keyword">char</span> errbuf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">av_strerror</span>(ret, errbuf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (errbuf));<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;av_read_frame error&quot;</span> &lt;&lt; errbuf &lt;&lt; ret;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 关闭文件</span><br>file.<span class="hljs-built_in">close</span>();<br> <br><span class="hljs-comment">// 释放资源</span><br><span class="hljs-built_in">av_packet_free</span>(&amp;pkt);<br> <br><span class="hljs-comment">// 关闭设备</span><br><span class="hljs-built_in">avformat_close_input</span>(&amp;ctx);<br></code></pre></td></tr></table></figure>

<h2 id="录制音频播放"><a href="#录制音频播放" class="headerlink" title="录制音频播放"></a><span id="jump1">录制音频播放</span></h2><blockquote>
<p>注意：当前代码编写下录制的音频文件中是不含有采样率、声道、位深等信息的，因此常规的播放文件是无法播放的</p>
</blockquote>
<ul>
<li><p>这里可以通过命令行<code>ffmpeg -f avfoundation -i :0 1.wav</code>,录制一段，在窗口中即可看到相关参数,<code>Input #0</code>即麦克风采集的音频格式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Input #<span class="hljs-number">0</span>, avfoundation, from <span class="hljs-string">&#x27;:0&#x27;</span>:<br>  Duration: N/A, start: <span class="hljs-number">39194.110021</span>, bitrate: <span class="hljs-number">1536</span> kb/s<br>  Stream #<span class="hljs-number">0</span>:<span class="hljs-number">0</span>: Audio: pcm_f32le, <span class="hljs-number">48000</span> Hz, mono, flt, <span class="hljs-number">1536</span> kb/s<br>Stream mapping:<br>  Stream #<span class="hljs-number">0</span>:<span class="hljs-number">0</span> -&gt; #<span class="hljs-number">0</span>:<span class="hljs-number">0</span> (<span class="hljs-built_in">pcm_f32le</span> (native) -&gt; <span class="hljs-built_in">pcm_s16le</span> (native))<br></code></pre></td></tr></table></figure></li>
<li><p>播放的方式</p>
<ul>
<li><code>-ar</code>:采样率，<code>mac</code>上默认<code>48000HZ</code></li>
<li><code>-ac</code>:声道,<code>mac</code>上默认<code>1</code>,<code>mono</code>,单声道</li>
<li><code>f</code>:是位深,其并不是简单的<code>16</code>可以通过<code>ffmpeg -formats | grep PCM</code>查看具体不同平台的位深标识,这里是<code>pcm_f32le</code>,也就是<code>f32le</code>,位深<code>32</code>的小端模式<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ffplay</span> -ar 48000 -ac 1 -f f32le out.pcm<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>ffmpeg -formats | grep PCM</code>查看不同平台的位深</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">DE alaw            PCM A-law<br>DE f32be           PCM 32-bit floating-point big-endian<br>DE f32le           PCM 32-bit floating-point little-endian<br>DE f64be           PCM 64-bit floating-point big-endian<br>DE f64le           PCM 64-bit floating-point little-endian<br>DE mulaw           PCM mu-law<br>DE s16be           PCM signed 16-bit big-endian<br>DE s16le           PCM signed 16-bit little-endian<br>DE s24be           PCM signed 24-bit big-endian<br>DE s24le           PCM signed 24-bit little-endian<br>DE s32be           PCM signed 32-bit big-endian<br>DE s32le           PCM signed 32-bit little-endian<br>DE s8              PCM signed 8-bit<br>DE u16be           PCM unsigned 16-bit big-endian<br>DE u16le           PCM unsigned 16-bit little-endian<br>DE u24be           PCM unsigned 24-bit big-endian<br>DE u24le           PCM unsigned 24-bit little-endian<br>DE u32be           PCM unsigned 32-bit big-endian<br>DE u32le           PCM unsigned 32-bit little-endian<br>DE u8              PCM unsigned 8-bit<br>DE vidc            PCM Archimedes VIDC<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="获取音频设备的采样率和编码格式"><a href="#获取音频设备的采样率和编码格式" class="headerlink" title="获取音频设备的采样率和编码格式"></a>获取音频设备的采样率和编码格式</h2><blockquote>
<p>在<a href="#jump1">录音播放那节</a>，可以通过命令行的方式，从<code>Stream</code>中可查看相关的数据， 这里说下，通过代码的方式获取到。</p>
</blockquote>
<ul>
<li>命令行获取<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$Stream</span> <span class="hljs-comment">#0:0: Audio: pcm_f32le, 48000 Hz, mono, flt, 1536 kb/s</span><br></code></pre></td></tr></table></figure></li>
<li>实际上通过<code>avformat_open_input</code>打开指定的音频设备之后，便可在<code>ctx</code>中获取的该音频设备的相关数据<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showSpec</span><span class="hljs-params">(AVFormatContext *ctx)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取输入流,这里是数组，因为打开一个音频设备，就是一种流</span><br>    AVStream *stream = ctx-&gt;streams[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取音频参数</span><br>    AVCodecParameters *params = stream-&gt;codecpar;<br>    <span class="hljs-comment">// 声道数 这里mono是单声道，1</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;声道数&quot;</span> &lt;&lt; params-&gt;ch_layout.nb_channels;<br>    <span class="hljs-comment">// 采样率，这里是48000</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;采样率&quot;</span> &lt;&lt; params-&gt;sample_rate;<br>    <span class="hljs-comment">// 采样格式,AVSampleFormat这样的枚举，是flt，并没有这种格式，是-1</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;采样格式&quot;</span> &lt;&lt; params-&gt;format;<br>    <span class="hljs-comment">// 每个样本占用多少字节，这里是单声道的数据，由于格式异常，这里是0</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">av_get_bytes_per_sample</span>((AVSampleFormat)params-&gt;format);<br>    <span class="hljs-comment">// 编码格式是AVCodecID，这里是AV_CODEC_ID_PCM_F32LE格式，也可以通过这个获取位深，这里输出32</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">av_get_bits_per_sample</span>(params-&gt;codec_id);<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><ul>
<li><a href="https://www.cnblogs.com/mjios/p/14466418.html">【秒懂音视频开发】02_重识声音 </a></li>
<li><a href="https://www.cnblogs.com/mjios/p/14466420.html">【秒懂音视频开发】03_重识音频</a></li>
<li><a href="https://www.cnblogs.com/mjios/p/14540642.html#toc_title_1">【秒懂音视频开发】08_音频录制02_编程</a></li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>泛型原理</title>
    <url>/2023/07/02/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型底层原理"><a href="#泛型底层原理" class="headerlink" title="泛型底层原理"></a>泛型底层原理</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testGenric</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">T</span>)</span> -&gt; <span class="hljs-type">T</span> &#123;<br>    <span class="hljs-keyword">let</span> tmp <span class="hljs-operator">=</span> value<br>    <span class="hljs-keyword">return</span> value<br>&#125;<br><br>testGenric(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>对于编译器来说，它不知道<code>T</code>到底是什么具体的类型（可能是值类型，也可能是引用类型）,那编译器就不知道 <code>tmp</code> / <code>value</code> 到底分配多少内存空间、步长是多少、对齐的字段是多少…只有当真正传递参数才知道真实类型。</li>
<li>那<code>tmp</code>在方法栈占据内存空间编译器是怎么决断的</li>
</ul>
<h3 id="IR分析"><a href="#IR分析" class="headerlink" title="IR分析"></a>IR分析</h3><blockquote>
<p>将代码编译成IR格式分析</p>
</blockquote>
<ul>
<li><p><code>main</code>函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define i32 <span class="hljs-keyword">@main</span>(i32 <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span><span class="hljs-type">TSi</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span><span class="hljs-type">TSi</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to i8<span class="hljs-operator">*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.start.p0i8(i64 <span class="hljs-number">8</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>)<br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.start.p0i8(i64 <span class="hljs-number">8</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">6</span>)<br>  <span class="hljs-operator">%</span>._value <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span><span class="hljs-type">TSi</span>, <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br>  store i64 <span class="hljs-number">10</span>, i64<span class="hljs-operator">*</span> <span class="hljs-operator">%</span>._value, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span><br>  <span class="hljs-comment">//调用函数</span><br>  call swiftcc void @<span class="hljs-string">&quot;$s10Genericity10testGenricyxxlF&quot;</span>(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture sret(<span class="hljs-operator">%</span>swift.opaque) <span class="hljs-operator">%</span><span class="hljs-number">7</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture <span class="hljs-operator">%</span><span class="hljs-number">8</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$sSiN&quot;</span>)<br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.end.p0i8(i64 <span class="hljs-number">8</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">9</span>)<br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.end.p0i8(i64 <span class="hljs-number">8</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">10</span>)<br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>实际泛型函数<code>s10Genericity10testGenricyxxlF</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define hidden swiftcc void @<span class="hljs-string">&quot;$s10Genericity10testGenricyxxlF&quot;</span>(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture sret(<span class="hljs-operator">%</span>swift.opaque) <span class="hljs-operator">%</span><span class="hljs-number">0</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-type">T1</span> <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span>tmp.debug <span class="hljs-operator">=</span> alloca i8<span class="hljs-operator">*</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>tmp.debug to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.memset.p0i8.i64(i8<span class="hljs-operator">*</span> align <span class="hljs-number">8</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i8 <span class="hljs-number">0</span>, i64 <span class="hljs-number">8</span>, i1 <span class="hljs-literal">false</span>)<br>  <span class="hljs-operator">%</span>value.debug <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>value.debug to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.memset.p0i8.i64(i8<span class="hljs-operator">*</span> align <span class="hljs-number">8</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span>, i8 <span class="hljs-number">0</span>, i64 <span class="hljs-number">8</span>, i1 <span class="hljs-literal">false</span>)<br>  store <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-type">T1</span>, align <span class="hljs-number">8</span><br><span class="hljs-comment">//类型T</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span> to i8<span class="hljs-operator">***</span><br><span class="hljs-operator">/</span>类型<span class="hljs-type">T向前偏移向前移动</span><span class="hljs-operator">-</span><span class="hljs-number">1</span>的位置<br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> getelementptr inbounds i8<span class="hljs-operator">**</span>, i8<span class="hljs-operator">***</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, i64 <span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-comment">//valueWitnesses是值见证表记录着size、stride、内存管理的函数</span><br>  <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses <span class="hljs-operator">=</span> load i8<span class="hljs-operator">**</span>, i8<span class="hljs-operator">***</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span>, <span class="hljs-operator">!</span>dereferenceable <span class="hljs-operator">!</span><span class="hljs-number">19</span><br><span class="hljs-comment">//将存储值的valueWitnesses转换为swift.vwtable值见证表类型</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses to <span class="hljs-operator">%</span>swift.vwtable<span class="hljs-operator">*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.vwtable, <span class="hljs-operator">%</span>swift.vwtable<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">6</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span>size <span class="hljs-operator">=</span> load i64, i64<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">7</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> alloca i8, i64 <span class="hljs-operator">%</span>size, align <span class="hljs-number">16</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.start.p0i8(i64 <span class="hljs-operator">-</span><span class="hljs-number">1</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span>)<br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span><br>  store i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>tmp.debug, align <span class="hljs-number">8</span><br>  store <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>value.debug, align <span class="hljs-number">8</span><br><span class="hljs-comment">//从值见证表中获取initializeWithCopy</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> getelementptr inbounds i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses, i32 <span class="hljs-number">2</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">11</span> <span class="hljs-operator">=</span> load i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">10</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span><br>  <span class="hljs-operator">%</span>initializeWithCopy <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">11</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> (<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">12</span> <span class="hljs-operator">=</span> call <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> <span class="hljs-operator">%</span>initializeWithCopy(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">9</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>) #<span class="hljs-number">3</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> call <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> <span class="hljs-operator">%</span>initializeWithCopy(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">0</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>) #<span class="hljs-number">3</span><br><span class="hljs-comment">//从值见证表中获取destroy</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> getelementptr inbounds i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses, i32 <span class="hljs-number">1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">15</span> <span class="hljs-operator">=</span> load i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">14</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span><br>  <span class="hljs-operator">%</span>destroy <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">15</span> to void (<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span><br>  call void <span class="hljs-operator">%</span>destroy(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">9</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>) #<span class="hljs-number">3</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">16</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">9</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.end.p0i8(i64 <span class="hljs-operator">-</span><span class="hljs-number">1</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">16</span>)<br>  ret void<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在调用<code>testGenric</code>时候可以看到一个值见证表<code>valueWitnesses</code>，并且可以看出到<code>initializeWithCopy</code>、<code>destroy</code>等函数都是从值见证表来的，所以泛型是通过<code>ValueWitnessTable</code>(<code>swift.vwtable</code>)去管理内存的。</p>
<ul>
<li>前面的几个<code>i8*</code>其实就是<code>void *</code>代表内存管理函数，剩下的就是<code>size</code>、<code>stride</code>、<code>flags</code>、<code>extraInhabitantCount</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">%</span>swift.type <span class="hljs-operator">=</span> type &#123; i64 &#125;<br><span class="hljs-operator">%</span><span class="hljs-type">TSi</span> <span class="hljs-operator">=</span> type <span class="hljs-operator">&lt;</span>&#123; i64 &#125;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">%</span>swift.opaque <span class="hljs-operator">=</span> type opaque<br><span class="hljs-operator">%</span>swift.vwtable <span class="hljs-operator">=</span> type &#123; i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i64, i64, i32, i32 &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类型<code>T</code>(<code>metaData</code>)向前偏移一个指针位置可以拿到<code>ValueWitnessTable</code>,即见证表是在<code>metaData</code>向前减1的位置</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//类型T向前偏移向前移动-1的位置</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> getelementptr inbounds i8<span class="hljs-operator">**</span>, i8<span class="hljs-operator">***</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, i64 <span class="hljs-operator">-</span><span class="hljs-number">1</span><br>  <span class="hljs-comment">//valueWitnesses是值见证表记录着size、stride、aligment、内存管理的函数</span><br>  <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses <span class="hljs-operator">=</span> load i8<span class="hljs-operator">**</span>, i8<span class="hljs-operator">***</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span>, <span class="hljs-operator">!</span>dereferenceable <span class="hljs-operator">!</span><span class="hljs-number">19</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValueWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> unknow1: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow2: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow3: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow4: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow5: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow6: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow7: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow8: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> size: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> stride: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> extraInhabitantCount: <span class="hljs-type">UInt32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>不管<code>testGenric</code>函数的参数传递的是<code>值</code>/<code>引用</code>类型，不管什么类型，总之它的<code>metadata</code>一定有<code>ValueWitnessTable</code>,并且保存着这个类型的<code>size</code>、<code>stride</code>、<code>flags</code>、<code>extraInhabitantCount</code>还有一些内存管理函数等信息。</li>
</ul>
<h3 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h3><ul>
<li><p>验证，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>        <span class="hljs-keyword">var</span> year <span class="hljs-operator">=</span> <span class="hljs-number">2023</span><br>    &#125;<br><br>    <span class="hljs-comment">// 所有类型的最终基类 Metadata</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <span class="hljs-comment">// kind用于区分类型的</span><br>&#125;<br><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br><br><span class="hljs-comment">//偏移指针的大小，8</span><br>    <span class="hljs-keyword">let</span> valueWitnessTable <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(ptr).advanced(by: <span class="hljs-operator">-</span><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size).assumingMemoryBound(to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">ValueWitnessTable</span>&gt;.<span class="hljs-keyword">self</span>).pointee<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size) <span class="hljs-comment">// 8</span><br><span class="hljs-comment">//相差0x60, 偏移的0x8 + ValueWitnessTable本身的大小是0x58</span><br><span class="hljs-built_in">print</span>(ptr,valueWitnessTable) <span class="hljs-comment">// 0x00000001000191a8 0x0000000100019148</span><br><br><span class="hljs-built_in">print</span>(valueWitnessTable.pointee.size) <span class="hljs-comment">// 16 如果只有age则是8</span><br><br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow1) <span class="hljs-comment">// 0x0000000100004b80</span><br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow2) <span class="hljs-comment">// 0x0000000100004930</span><br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow3) <span class="hljs-comment">// 0x0000000100004b80</span><br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow4)<br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow5)<br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow6)<br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow7)<br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow8) <br><br></code></pre></td></tr></table></figure></li>
<li><p>通过<code>cat address 0x0000000100004b80</code>指令打印出函数名</p>
</li>
</ul>
<h4 id="最终结构"><a href="#最终结构" class="headerlink" title="最终结构"></a>最终结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValueWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> initializeBufferWithCopyOfBuffer: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> destroy: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> initializeWithCopy: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> assignWithCopy: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> initializeWithTake: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> assignWithTake: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> getEnumTagSinglePayload: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> storeEnumTagSinglePayload: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> size: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> stride: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> extraInhabitantCount: <span class="hljs-type">UInt32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里的<code>initializeWithCopy</code>方法和<code>destroy</code>即之前，<code>IR分析</code>中对应的方法,</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>泛型是通过<code>ValueWitnessTable</code> (简称<code>VWT</code> 是由编译器产生的) 来进行内存管理，<code>VWT</code>存储了<code>size</code>、<code>stride</code>、<code>alignment</code>和一些内存管理函数等；</li>
<li>对于值类型来说，实际上是通过内存的拷贝；<code>copy/move</code>等操作；</li>
<li>对于引用类型来说，就是堆区内存块的引用，通过引用计数的方式。</li>
</ul>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><h3 id="泛型中传递的参数是泛型"><a href="#泛型中传递的参数是泛型" class="headerlink" title="泛型中传递的参数是泛型"></a>泛型中传递的参数是泛型</h3><ul>
<li>例子,编译成<code>IR</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>()</span> -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>(<span class="hljs-params">mount</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> mount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genric</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>)</span> &#123;    <br>&#125;<br><br><span class="hljs-keyword">let</span> increment <span class="hljs-operator">=</span> makeIncrementer()<br>genric(t: increment)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="IR分析-1"><a href="#IR分析-1" class="headerlink" title="IR分析"></a><code>IR</code>分析</h3><ul>
<li><p><code>main</code>函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define i32 <span class="hljs-keyword">@main</span>(i32 <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span>swift.function, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to i8<span class="hljs-operator">*</span><br>  <span class="hljs-comment">//调用makeIncrementer，生成闭包</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> call swiftcc &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; @<span class="hljs-string">&quot;$s10Genericity15makeIncrementerS2icyF&quot;</span>()<br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> extractvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">4</span>, <span class="hljs-number">0</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> extractvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">4</span>, <span class="hljs-number">1</span><br>  <br>  <span class="hljs-comment">// 将指针存储到increment(即s10Genericity9incrementyS2icvp)变量里</span><br>  store i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, i8<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s10Genericity9incrementyS2icvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), align <span class="hljs-number">8</span><br>  <br>  <span class="hljs-comment">// 将捕获的变量存储到increment(即s10Genericity9incrementyS2icvp)变量里</span><br>  store <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">6</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s10Genericity9incrementyS2icvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span>), align <span class="hljs-number">8</span><br>  <br>  <span class="hljs-comment">// 把function类型转换成void *</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.start.p0i8(i64 <span class="hljs-number">16</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">7</span>)<br>  <br>  <span class="hljs-comment">// 从increment变量取出指针和捕获的变量</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> load i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s10Genericity9incrementyS2icvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s10Genericity9incrementyS2icvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span>), align <span class="hljs-number">8</span><br>  <br>  <span class="hljs-comment">// 一些内存管理的函数</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> call <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-meta">@swift_retain</span>(<span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> returned <span class="hljs-operator">%</span><span class="hljs-number">9</span>) #<span class="hljs-number">3</span><br>  <br>  <span class="hljs-comment">// swift_allocObject创建了堆区的内存空间</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">11</span> <span class="hljs-operator">=</span> call noalias <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-meta">@swift_allocObject</span>(<span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.full_boxmetadata, <span class="hljs-operator">%</span>swift.full_boxmetadata<span class="hljs-operator">*</span> <span class="hljs-meta">@metadata</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">2</span>), i64 <span class="hljs-number">32</span>, i64 <span class="hljs-number">7</span>) #<span class="hljs-number">4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">12</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">11</span> to <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, <span class="hljs-operator">%</span>swift.function &#125;<span class="hljs-operator">&gt;*</span><br>  <br>  <span class="hljs-comment">// 取出第一个成员是function这个结构体</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, <span class="hljs-operator">%</span>swift.function &#125;<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, <span class="hljs-operator">%</span>swift.function &#125;<span class="hljs-operator">&gt;*</span> <span class="hljs-operator">%</span><span class="hljs-number">12</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br>  <br>  <span class="hljs-comment">// 从function这个结构体取出函数地址</span><br>  <span class="hljs-operator">%</span>.fn <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">13</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br>  store i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.fn, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span>.data <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">13</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br>  store <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">9</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.data, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span>.fn1 <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br>  store i8<span class="hljs-operator">*</span> bitcast (void (<span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span>, <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$sS2iIegyd_S2iIegnr_TRTA&quot;</span> to i8<span class="hljs-operator">*</span>), i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.fn1, align <span class="hljs-number">8</span><br>  <br>  <span class="hljs-operator">%</span>.data2 <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br>  store <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">11</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.data2, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span><br>  <br>  <span class="hljs-comment">// 后面又对这个function又做了一层重新的抽象</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">15</span> <span class="hljs-operator">=</span> call <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-meta">@__swift_instantiateConcreteTypeFromMangledName</span>(&#123; i32, i32 &#125;<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$sS2icMD&quot;</span>) #<span class="hljs-number">15</span><br>  call swiftcc void @<span class="hljs-string">&quot;$s10Genericity6genric1tyx_tlF&quot;</span>(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture <span class="hljs-operator">%</span><span class="hljs-number">14</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">15</span>)<br>  <span class="hljs-operator">%</span>.data3 <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">16</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.data3, align <span class="hljs-number">8</span><br>  call void <span class="hljs-meta">@swift_release</span>(<span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">16</span>) #<span class="hljs-number">4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">17</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.end.p0i8(i64 <span class="hljs-number">16</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">17</span>)<br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>可以看到<code>func genric&lt;T&gt;(t: T)</code> 当泛型参数接收一个<code>闭包/函数</code>时，会对这个<code>闭包/函数</code>原有数据结构上又抽象封装了一层。因为我们传入可能是是<code>函数</code>，也可能传入的是<code>闭包表达式</code>，编译器不知道呀，它就和协议设计一样不知道谁遵循了<code>协议</code>，所以它就抽象了<code>一层中间层</code>为了<code>泛型管理</code>统一区分类型。</p>
</li>
</ul>
<h3 id="lldb调试"><a href="#lldb调试" class="headerlink" title="lldb调试"></a>lldb调试</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genric</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>)</span> &#123;    <br>    <span class="hljs-comment">// VWT管理内存</span><br>    <span class="hljs-keyword">let</span> tmp <span class="hljs-operator">=</span> t<br>    <span class="hljs-comment">// 函数调用，抽象中间层统一管理函数/闭包</span><br>    <span class="hljs-keyword">var</span> t1 <span class="hljs-operator">=</span> t <span class="hljs-keyword">as!</span> (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span><br>    t1(<span class="hljs-number">12</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>当去调用的时候，是通过这个抽象出来的<code>中间层</code>来取调用，如果不调用而用来传值的话，依旧是通过上面的<code>ValueWitnessTable</code>进行内存管理的。（注意：<code>函数/闭包</code>也是引用类型）。<ol>
<li>下面调用<code>t1()</code>时，会先调用<code>ClosureData&lt;ReabstractionThunkContext&lt;Box&lt;Int&gt;&gt;&gt;</code>中<code>t</code>包装成的闭包的函数<code>ptr</code>去查找调用的函数，再调用<br><img src="1.png"></li>
<li>函数跳转到<code>0x100012a30</code><br><img src="2.png"></li>
<li>这里才是真正的调用函数<code>t1()</code>的地方，并且开始捕获参数<code>12</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) register read rsi<br> rsi <span class="hljs-operator">=</span> <span class="hljs-number">0x0000000100015020</span>  <span class="hljs-type">SwiftSource</span>`partial apply forwarder <span class="hljs-keyword">for</span> incrementer(mount: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at <span class="hljs-operator">&lt;</span>compiler<span class="hljs-operator">-</span>generated<span class="hljs-operator">&gt;</span><br>(lldb) register read rdi<br> rdi <span class="hljs-operator">=</span> <span class="hljs-number">0x000000000000000c</span><br></code></pre></td></tr></table></figure></li>
<li>调用闭包地址，跳转到实际函数地址<br><img src="3.png"></li>
<li>实际调用的函数<br><img src="4.png"></li>
</ol>
</li>
</ul>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>泛型参数接收闭包/函数后对其进行调用，又抽象一层封装的数据结构：<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 闭包作为泛型参数，又包装了一层</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ReabstractionThunkContext</span>&lt;<span class="hljs-title">Context</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">HeapObject</span><br>    <span class="hljs-keyword">var</span> function: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Context</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>闭包的结构<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClosureData</span>&lt;<span class="hljs-title">Box</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> ptr: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 闭包函数地址地址</span><br>    <span class="hljs-keyword">var</span> box: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Box</span>&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> object: <span class="hljs-type">HeapObject</span> <span class="hljs-comment">// 实例对象的内存地址</span><br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">T</span>  <span class="hljs-comment">//存的捕获的值</span><br>&#125;<br><br><span class="hljs-comment">///实例对象的内存地址</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> refcount1: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> refcount2: <span class="hljs-type">Int32</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>ClosureData&lt;ReabstractionThunkContext&lt;Box&lt;Int&gt;&gt;&gt;</code>,泛型闭包，<ol>
<li>先用<code>ClosureData</code>结构包住，其<code>ptr</code>用来查找具体必包中的函数</li>
<li><code>ReabstractionThunkContext</code>是<code>1</code>中闭包的<code>box</code>,其中<code>function</code>是函数必包，真正捕获存储的位置</li>
<li><code>2</code>中<code>function</code>的<code>ptr</code>存储函数,<code>box</code>包装捕获参数</li>
</ol>
</li>
</ul>
<h4 id="验证数据结构"><a href="#验证数据结构" class="headerlink" title="验证数据结构"></a>验证数据结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>()</span> -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>(<span class="hljs-params">mount</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> mount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genric</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">T</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">//给定的值初始化</span><br>    ptr.initialize(to: t)<br>    <br>    <span class="hljs-keyword">defer</span> &#123;<br>        ptr.deinitialize(count: <span class="hljs-number">1</span>)<br>        ptr.deallocate()<br>    &#125;<br>    <span class="hljs-comment">//降至进行绑定</span><br>    <span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">ReabstractionThunkContext</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt;&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; <span class="hljs-variable">$0</span> &#125;<br>    <span class="hljs-keyword">let</span> ctx <span class="hljs-operator">=</span> closure_ptr.pointee.box.pointee.function.box<br>    <span class="hljs-comment">//相比之前的block对象，包了一层</span><br>    <span class="hljs-built_in">print</span>(ctx.pointee.value) <span class="hljs-comment">// 10    得到捕获的外部变量的值</span><br>    <span class="hljs-built_in">print</span>(closure_ptr.pointee.ptr) <span class="hljs-comment">// 0x00000001000137f0 包装了一层的函数，用这个查具体的函数调用</span><br>    <span class="hljs-built_in">print</span>(closure_ptr.pointee.box.pointee.function.ptr) <span class="hljs-comment">//0x0000000100015020 实际调用的闭包地址</span><br>&#125;<br><br><span class="hljs-keyword">let</span> increment <span class="hljs-operator">=</span> makeIncrementer()<br>genric(t: increment)<br><br><span class="hljs-comment">//正常的闭包结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NoMeanStruct</span></span>&#123;<br>    <span class="hljs-keyword">var</span> closure: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-keyword">let</span> funcStruct <span class="hljs-operator">=</span> <span class="hljs-type">NoMeanStruct</span>(closure: increment)<br><span class="hljs-keyword">let</span> func_ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">NoMeanStruct</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>func_ptr.initialize(to: funcStruct)<br><br><span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> func_ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable">$0</span>.pointee &#125;<br><span class="hljs-built_in">print</span>(closure_ptr.box.pointee.value) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">print</span>(closure_ptr.ptr) <span class="hljs-comment">//0x0000000100015020 闭包地址，外面并没有包一层</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>协议分析</title>
    <url>/2023/06/26/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="协议方法调度"><a href="#协议方法调度" class="headerlink" title="协议方法调度"></a>协议方法调度</h1><blockquote>
<p>类的方法调度是通过函数表<code>v-table</code>的方式，那么类遵循协议的方法调度是如何的进行的</p>
</blockquote>
<h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">MyProtocol</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">logInfo</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">something</span>: <span class="hljs-keyword">Any</span>)</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span>: <span class="hljs-title">MyProtocol</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">logInfo</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">something</span>: <span class="hljs-keyword">Any</span>)</span> &#123;<br>        <span class="hljs-built_in">print</span>(something)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t: <span class="hljs-type">Teacher</span> <span class="hljs-operator">=</span> <span class="hljs-type">Teacher</span>()<br>t.logInfo(<span class="hljs-string">&quot;123&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="sil"><a href="#sil" class="headerlink" title="sil"></a><code>sil</code></h3><ul>
<li><p><code>swiftc ProtocolText.swift -emit-sil -o ProtocolText.sil</code>,编译成<code>Sil</code>找到调用<code>logInfo</code>的地方</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// main</span><br>sil <span class="hljs-keyword">@main</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Int32</span>, <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="hljs-type">Int32</span> &#123;<br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$Int32</span>, <span class="hljs-operator">%</span><span class="hljs-number">1</span> : <span class="hljs-variable">$UnsafeMutablePointer</span><span class="hljs-operator">&lt;</span><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;<span class="hljs-operator">&gt;</span>):<br>  alloc_global @<span class="hljs-variable">$s12ProtocolText1tAA7TeacherCvp</span>   <span class="hljs-comment">// id: %2</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s12ProtocolText1tAA7TeacherCvp</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span> <span class="hljs-comment">// users: %7, %8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>              <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-comment">// function_ref Teacher.__allocating_init()</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$s12ProtocolText7TeacherCACycfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">Teacher</span> <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">5</span>(<span class="hljs-operator">%</span><span class="hljs-number">4</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">Teacher</span> <span class="hljs-comment">// user: %7</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">6</span> to <span class="hljs-operator">%</span><span class="hljs-number">3</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                      <span class="hljs-comment">// id: %7</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> begin_access [read] [<span class="hljs-keyword">dynamic</span>] <span class="hljs-operator">%</span><span class="hljs-number">3</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span> <span class="hljs-comment">// users: %9, %11</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span><span class="hljs-number">8</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                        <span class="hljs-comment">// users: %25, %21, %22, %10</span><br>  strong_retain <span class="hljs-operator">%</span><span class="hljs-number">9</span> : <span class="hljs-variable">$Teacher</span>                     <span class="hljs-comment">// id: %10</span><br>  end_access <span class="hljs-operator">%</span><span class="hljs-number">8</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                       <span class="hljs-comment">// id: %11</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">12</span> <span class="hljs-operator">=</span> alloc_stack <span class="hljs-variable">$Any</span>                          <span class="hljs-comment">// users: %24, %23, %22, %19</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> string_literal utf8 <span class="hljs-string">&quot;123&quot;</span>                 <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-number">3</span>          <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">15</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-operator">-</span><span class="hljs-number">1</span>         <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">16</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>               <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-comment">// function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">17</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">String</span> <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">18</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">17</span>(<span class="hljs-operator">%</span><span class="hljs-number">13</span>, <span class="hljs-operator">%</span><span class="hljs-number">14</span>, <span class="hljs-operator">%</span><span class="hljs-number">15</span>, <span class="hljs-operator">%</span><span class="hljs-number">16</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">String</span> <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">19</span> <span class="hljs-operator">=</span> init_existential_addr <span class="hljs-operator">%</span><span class="hljs-number">12</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>, <span class="hljs-variable">$String</span> <span class="hljs-comment">// user: %20</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">18</span> to <span class="hljs-operator">%</span><span class="hljs-number">19</span> : $<span class="hljs-operator">*</span><span class="hljs-type">String</span>                     <span class="hljs-comment">// id: %20</span><br>  <span class="hljs-comment">//调用Teacher.logInfo 方法</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">21</span> <span class="hljs-operator">=</span> class_method <span class="hljs-operator">%</span><span class="hljs-number">9</span> : <span class="hljs-variable">$Teacher</span>, #<span class="hljs-type">Teacher</span>.logInfo : (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; (), $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; () <span class="hljs-comment">// user: %22</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">22</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">21</span>(<span class="hljs-operator">%</span><span class="hljs-number">12</span>, <span class="hljs-operator">%</span><span class="hljs-number">9</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; ()<br>  destroy_addr <span class="hljs-operator">%</span><span class="hljs-number">12</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>                        <span class="hljs-comment">// id: %23</span><br>  dealloc_stack <span class="hljs-operator">%</span><span class="hljs-number">12</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>                       <span class="hljs-comment">// id: %24</span><br>  strong_release <span class="hljs-operator">%</span><span class="hljs-number">9</span> : <span class="hljs-variable">$Teacher</span>                    <span class="hljs-comment">// id: %25</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">26</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int32</span>, <span class="hljs-number">0</span>         <span class="hljs-comment">// user: %27</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">27</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int32</span> (%26 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int32</span>)      // <span class="hljs-title">user</span>: %28</span><br><span class="hljs-class">  <span class="hljs-title">return</span> %27 : <span class="hljs-title">$Int32</span>                             // <span class="hljs-title">id</span>: %28</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">main</span>&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><p>此时<code>logInfo</code>就被声明在<code>v-Table</code>，并且可以看到还产生出了<code>sil_witness_table</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">sil_vtable <span class="hljs-type">Teacher</span> &#123;<br>  #<span class="hljs-type">Teacher</span>.logInfo: (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherC7logInfoyyypF</span>	<span class="hljs-comment">// Teacher.logInfo(_:)</span><br>  #<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">init</span><span class="hljs-operator">!</span>allocator: (<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; () -&gt; <span class="hljs-type">Teacher</span> : @<span class="hljs-variable">$s12ProtocolText7TeacherCACycfC</span>	<span class="hljs-comment">// Teacher.__allocating_init()</span><br>  #<span class="hljs-type">Teacher</span>.deinit<span class="hljs-operator">!</span>deallocator: @<span class="hljs-variable">$s12ProtocolText7TeacherCfD</span>	<span class="hljs-comment">// Teacher.__deallocating_deinit</span><br>&#125;<br><br>sil_witness_table hidden <span class="hljs-type">Teacher</span>: <span class="hljs-type">MyProtocol</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>  method #<span class="hljs-type">MyProtocol</span>.logInfo: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocol.logInfo(_:) in conformance Teacher</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="class-method"><a href="#class-method" class="headerlink" title="class_method"></a><code>class_method</code></h3><blockquote>
<p>查看<a href="https://github.com/apple/swift/blob/main/docs/SIL.rst#dynamic-dispatch">官方文档</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">class_method<br><br>sil<span class="hljs-operator">-</span>instruction ::<span class="hljs-operator">=</span> &#x27;class_method&#x27; sil<span class="hljs-operator">-</span>method<span class="hljs-operator">-</span>attributes<span class="hljs-operator">?</span><br>                      sil<span class="hljs-operator">-</span>operand &#x27;,&#x27; sil<span class="hljs-operator">-</span>decl<span class="hljs-operator">-</span>ref &#x27;:&#x27; sil<span class="hljs-operator">-</span>type<br><br><span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> class_method <span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$T</span>, #<span class="hljs-type">T</span>.method : $<span class="hljs-meta">@convention</span>(class_method) <span class="hljs-type">U</span> -&gt; <span class="hljs-type">V</span><br><span class="hljs-comment">// %0 must be of a class type or class metatype $T</span><br><span class="hljs-comment">// #T.method must be a reference to a Swift native method of T or</span><br><span class="hljs-comment">// of one of its superclasses</span><br><span class="hljs-comment">// %1 will be of type $U -&gt; V</span><br><br><span class="hljs-comment">//元类的动态类型查找方法</span><br><span class="hljs-type">Looks</span> up a method based on the <span class="hljs-keyword">dynamic</span> type of a <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">or</span> <span class="hljs-title">class</span> <span class="hljs-title">metatype</span> <span class="hljs-title">instance</span>. <span class="hljs-title">It</span> <span class="hljs-title">is</span> <span class="hljs-title">undefined</span> <span class="hljs-title">behavior</span> <span class="hljs-title">if</span> <span class="hljs-title">the</span> <span class="hljs-title">class</span> <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">null</span>.</span><br><span class="hljs-class"></span><br><span class="hljs-class">//如果类实例的静态类型是已知的，或者方法已知是最终的，则该指令是去虚拟化优化的候选者。去虚拟化通行证可以查阅模块的<span class="hljs-title">VTables</span>，以找到实现该方法的<span class="hljs-title">SIL</span>函数，并将指令提升为静态函数<span class="hljs-title">_ref</span>。</span><br><span class="hljs-class"><span class="hljs-title">If</span> <span class="hljs-title">the</span> <span class="hljs-title">static</span> <span class="hljs-title">type</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">class</span> <span class="hljs-title">instance</span> <span class="hljs-title">is</span> <span class="hljs-title">known</span>, <span class="hljs-title">or</span> <span class="hljs-title">the</span> <span class="hljs-title">method</span> <span class="hljs-title">is</span> <span class="hljs-title">known</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">final</span>, <span class="hljs-title">then</span> <span class="hljs-title">the</span> <span class="hljs-title">instruction</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">candidate</span> <span class="hljs-title">for</span> <span class="hljs-title">devirtualization</span> <span class="hljs-title">optimization</span>. <span class="hljs-title">A</span> <span class="hljs-title">devirtualization</span> <span class="hljs-title">pass</span> <span class="hljs-title">can</span> <span class="hljs-title">consult</span> <span class="hljs-title">the</span> <span class="hljs-title">module</span>&#x27;<span class="hljs-title">s</span> <span class="hljs-title">VTables</span> <span class="hljs-title">to</span> <span class="hljs-title">find</span> <span class="hljs-title">the</span> <span class="hljs-title">SIL</span> <span class="hljs-title">function</span> <span class="hljs-title">that</span> <span class="hljs-title">implements</span> <span class="hljs-title">the</span> <span class="hljs-title">method</span> <span class="hljs-title">and</span> <span class="hljs-title">promote</span> <span class="hljs-title">the</span> <span class="hljs-title">instruction</span> <span class="hljs-title">to</span> <span class="hljs-title">a</span> <span class="hljs-title">static</span> <span class="hljs-title">function_ref</span>.</span><br></code></pre></td></tr></table></figure>

<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><blockquote>
<p>如果把<code>var t: Teacher = Teacher()</code>改成<code>var t: Myprotocol = Teacher()</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> t: <span class="hljs-type">MyProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-type">Teacher</span>()<br>t.logInfo(<span class="hljs-string">&quot;123&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="sil-1"><a href="#sil-1" class="headerlink" title="sil"></a><code>sil</code></h3><ul>
<li><p><code>swiftc ProtocolText.swift -emit-sil -o ProtocolText.sil</code>,编译成<code>Sil</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// main</span><br>sil <span class="hljs-keyword">@main</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Int32</span>, <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="hljs-type">Int32</span> &#123;<br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$Int32</span>, <span class="hljs-operator">%</span><span class="hljs-number">1</span> : <span class="hljs-variable">$UnsafeMutablePointer</span><span class="hljs-operator">&lt;</span><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;<span class="hljs-operator">&gt;</span>):<br>  alloc_global @<span class="hljs-variable">$s12ProtocolText1tAA02MyA0_pvp</span>    <span class="hljs-comment">// id: %2</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s12ProtocolText1tAA02MyA0_pvp</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span> <span class="hljs-comment">// users: %9, %7</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>              <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-comment">// function_ref Teacher.__allocating_init()</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$s12ProtocolText7TeacherCACycfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">Teacher</span> <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">5</span>(<span class="hljs-operator">%</span><span class="hljs-number">4</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">Teacher</span> <span class="hljs-comment">// user: %8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> init_existential_addr <span class="hljs-operator">%</span><span class="hljs-number">3</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>, <span class="hljs-variable">$Teacher</span> <span class="hljs-comment">// user: %8</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">6</span> to <span class="hljs-operator">%</span><span class="hljs-number">7</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                      <span class="hljs-comment">// id: %8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> begin_access [read] [<span class="hljs-keyword">dynamic</span>] <span class="hljs-operator">%</span><span class="hljs-number">3</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span> <span class="hljs-comment">// users: %12, %11</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> alloc_stack <span class="hljs-variable">$any</span> <span class="hljs-type">MyProtocol</span>               <span class="hljs-comment">// users: %28, %27, %13, %11</span><br>  copy_addr <span class="hljs-operator">%</span><span class="hljs-number">9</span> to [<span class="hljs-keyword">init</span>] <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>   <span class="hljs-comment">// id: %11</span><br>  end_access <span class="hljs-operator">%</span><span class="hljs-number">9</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>                <span class="hljs-comment">// id: %12</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> open_existential_addr immutable_access <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span> to $<span class="hljs-operator">*</span><span class="hljs-meta">@opened</span>(<span class="hljs-string">&quot;29B7E2B4-1442-11EE-938A-ACDE48001122&quot;</span>, any <span class="hljs-type">MyProtocol</span>) <span class="hljs-keyword">Self</span> <span class="hljs-comment">// users: %24, %24, %23</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> alloc_stack <span class="hljs-variable">$Any</span>                          <span class="hljs-comment">// users: %26, %25, %24, %21</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">15</span> <span class="hljs-operator">=</span> string_literal utf8 <span class="hljs-string">&quot;123&quot;</span>                 <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">16</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-number">3</span>          <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">17</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-operator">-</span><span class="hljs-number">1</span>         <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">18</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>               <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-comment">// function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">19</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">String</span> <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">20</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">19</span>(<span class="hljs-operator">%</span><span class="hljs-number">15</span>, <span class="hljs-operator">%</span><span class="hljs-number">16</span>, <span class="hljs-operator">%</span><span class="hljs-number">17</span>, <span class="hljs-operator">%</span><span class="hljs-number">18</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">String</span> <span class="hljs-comment">// user: %22</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">21</span> <span class="hljs-operator">=</span> init_existential_addr <span class="hljs-operator">%</span><span class="hljs-number">14</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>, <span class="hljs-variable">$String</span> <span class="hljs-comment">// user: %22</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">20</span> to <span class="hljs-operator">%</span><span class="hljs-number">21</span> : $<span class="hljs-operator">*</span><span class="hljs-type">String</span>                     <span class="hljs-comment">// id: %22</span><br>  <span class="hljs-comment">//当前调用的是witness_method，是MyProtocol.logInfo方法</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">23</span> <span class="hljs-operator">=</span> witness_method $<span class="hljs-meta">@opened</span>(<span class="hljs-string">&quot;29B7E2B4-1442-11EE-938A-ACDE48001122&quot;</span>, any <span class="hljs-type">MyProtocol</span>) <span class="hljs-keyword">Self</span>, #<span class="hljs-type">MyProtocol</span>.logInfo : <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; (), <span class="hljs-operator">%</span><span class="hljs-number">13</span> : $<span class="hljs-operator">*</span><span class="hljs-meta">@opened</span>(<span class="hljs-string">&quot;29B7E2B4-1442-11EE-938A-ACDE48001122&quot;</span>, any <span class="hljs-type">MyProtocol</span>) <span class="hljs-keyword">Self</span> : $<span class="hljs-meta">@convention</span>(witness_method: <span class="hljs-type">MyProtocol</span>) <span class="hljs-operator">&lt;</span>τ_0_0 <span class="hljs-keyword">where</span> τ_0_0 : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@in_guaranteed</span> τ_0_0) -&gt; () <span class="hljs-comment">// type-defs: %13; user: %24</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">24</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">23</span><span class="hljs-operator">&lt;</span><span class="hljs-meta">@opened</span>(<span class="hljs-string">&quot;29B7E2B4-1442-11EE-938A-ACDE48001122&quot;</span>, any <span class="hljs-type">MyProtocol</span>) <span class="hljs-keyword">Self</span><span class="hljs-operator">&gt;</span>(<span class="hljs-operator">%</span><span class="hljs-number">14</span>, <span class="hljs-operator">%</span><span class="hljs-number">13</span>) : $<span class="hljs-meta">@convention</span>(witness_method: <span class="hljs-type">MyProtocol</span>) <span class="hljs-operator">&lt;</span>τ_0_0 <span class="hljs-keyword">where</span> τ_0_0 : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@in_guaranteed</span> τ_0_0) -&gt; () <span class="hljs-comment">// type-defs: %13</span><br>  destroy_addr <span class="hljs-operator">%</span><span class="hljs-number">14</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>                        <span class="hljs-comment">// id: %25</span><br>  dealloc_stack <span class="hljs-operator">%</span><span class="hljs-number">14</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>                       <span class="hljs-comment">// id: %26</span><br>  destroy_addr <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>             <span class="hljs-comment">// id: %27</span><br>  dealloc_stack <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>            <span class="hljs-comment">// id: %28</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">29</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int32</span>, <span class="hljs-number">0</span>         <span class="hljs-comment">// user: %30</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">30</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int32</span> (%29 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int32</span>)      // <span class="hljs-title">user</span>: %31</span><br><span class="hljs-class">  <span class="hljs-title">return</span> %30 : <span class="hljs-title">$Int32</span>                             // <span class="hljs-title">id</span>: %31</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">main</span></span><br></code></pre></td></tr></table></figure></li>
<li><p>当前调用<code>logInfo</code>就要去协议见证表<code>sil_witness_table</code>上查找实现。<code>witness_method</code>其实是记录着类实现这个协议的方法的编码信息</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">sil_witness_table hidden <span class="hljs-type">Teacher</span>: <span class="hljs-type">MyProtocol</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>  method #<span class="hljs-type">MyProtocol</span>.logInfo: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocol.logInfo(_:) in conformance Teacher</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW</code>方法实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// protocol witness for MyProtocol.logInfo(_:) in conformance Teacher</span><br>sil <span class="hljs-keyword">private</span> [transparent] [thunk] @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW</span> : $<span class="hljs-meta">@convention</span>(witness_method: <span class="hljs-type">MyProtocol</span>) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@in_guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; () &#123;<br><span class="hljs-comment">// %0                                             // user: %4</span><br><span class="hljs-comment">// %1                                             // user: %2</span><br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>, <span class="hljs-operator">%</span><span class="hljs-number">1</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>):<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span><span class="hljs-number">1</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                        <span class="hljs-comment">// users: %3, %4</span><br>  <span class="hljs-comment">//该方法实现，class_method 去调用Teacher.logInfo 方法</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> class_method <span class="hljs-operator">%</span><span class="hljs-number">2</span> : <span class="hljs-variable">$Teacher</span>, #<span class="hljs-type">Teacher</span>.logInfo : (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; (), $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; () <span class="hljs-comment">// user: %4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">3</span>(<span class="hljs-operator">%</span><span class="hljs-number">0</span>, <span class="hljs-operator">%</span><span class="hljs-number">2</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; ()<br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> tuple ()                                   <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span> : $()                                 <span class="hljs-comment">// id: %6</span><br>&#125; <span class="hljs-comment">// end sil function &#x27;$s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="witness-method"><a href="#witness-method" class="headerlink" title="witness_method"></a><code>witness_method</code></h3><blockquote>
<p>查看<a href="https://github.com/apple/swift/blob/main/docs/SIL.rst#dynamic-dispatch">官方文档</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">witness_method<br><br>sil<span class="hljs-operator">-</span>instruction ::<span class="hljs-operator">=</span> &#x27;witness_method&#x27; sil<span class="hljs-operator">-</span>method<span class="hljs-operator">-</span>attributes<span class="hljs-operator">?</span><br>                      sil<span class="hljs-operator">-</span>type &#x27;,&#x27; sil<span class="hljs-operator">-</span>decl<span class="hljs-operator">-</span>ref &#x27;:&#x27; sil<span class="hljs-operator">-</span>type<br><br><span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> witness_method <span class="hljs-variable">$T</span>, #<span class="hljs-type">Proto</span>.method \<br>  : $<span class="hljs-meta">@convention</span>(witness_method) <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span>: <span class="hljs-type">Proto</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">U</span> -&gt; <span class="hljs-type">V</span><br><span class="hljs-comment">// $T must be an archetype</span><br><span class="hljs-comment">// #Proto.method must be a reference to a method of one of the protocol</span><br><span class="hljs-comment">//   constraints on T</span><br><span class="hljs-comment">// &lt;Self: Proto&gt; U -&gt; V must be the type of the referenced method,</span><br><span class="hljs-comment">//   generic on Self</span><br><span class="hljs-comment">// %1 will be of type $@convention(thin) &lt;Self: Proto&gt; U -&gt; V</span><br><span class="hljs-comment">//查找受该协议约束的泛型类型变量的协议方法的实现。协议见证表sil_witness_table(简称PWT)上查找实现。如果引用的协议是@objc协议，则生成的类型具有objc调用约定。</span><br><span class="hljs-type">Looks</span> up the implementation of a <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">method</span> <span class="hljs-title">for</span> <span class="hljs-title">a</span> <span class="hljs-title">generic</span> <span class="hljs-title">type</span> <span class="hljs-title">variable</span> <span class="hljs-title">constrained</span> <span class="hljs-title">by</span> <span class="hljs-title">that</span> <span class="hljs-title">protocol</span>. <span class="hljs-title">The</span> <span class="hljs-title">result</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">generic</span> <span class="hljs-title">on</span> <span class="hljs-title">the</span> <span class="hljs-title">Self</span> <span class="hljs-title">archetype</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">original</span> <span class="hljs-title">protocol</span> <span class="hljs-title">and</span> <span class="hljs-title">have</span> <span class="hljs-title">the</span> <span class="hljs-title">witness_method</span> <span class="hljs-title">calling</span> <span class="hljs-title">convention</span>. <span class="hljs-title">If</span> <span class="hljs-title">the</span> <span class="hljs-title">referenced</span> <span class="hljs-title">protocol</span> <span class="hljs-title">is</span> <span class="hljs-title">an</span> @<span class="hljs-title">objc</span> <span class="hljs-title">protocol</span>, <span class="hljs-title">the</span> <span class="hljs-title">resulting</span> <span class="hljs-title">type</span> <span class="hljs-title">has</span> <span class="hljs-title">the</span> <span class="hljs-title">objc</span> <span class="hljs-title">calling</span> <span class="hljs-title">convention</span>.</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>witness_method</code>其实是记录着类实现这个协议的方法的编码信息</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>一个类实现了协议上的方法，并且创建这个类的对象时，<ol>
<li>如果把这个对象声明成<code>本身类</code>的类型，会通过<code>v-Table</code>的方式调度函数；</li>
<li>如果把这个对象声明成<code>协议类型</code>，那么在对象调用实现协议的方法的时候会先去<code>witness_table</code>查找这个对象的具体类型和具体实现(<code>v-Table</code>)，并完成当前的方法调度。</li>
</ol>
</li>
<li><strong>注意</strong>：<ol>
<li>每一个遵循协议的类，都会为其创建<code>witness_table</code>,无论是扩展实现还是类实现</li>
<li>举例<code>Person</code>类遵循了<code>ProtocolA</code>并实现了协议方法，而<code>Teacher</code>类继承于<code>Person</code>类且没有遵循<code>ProtocolA</code>，<code>Teacher</code>类就不会创建<code>witness_table</code><ul>
<li>尽管没有创建，当出现<code>Teacher</code>重写了<code>Person</code>中的协议方法时，用<code>var t: MyProtocolA = Teacher()</code>，调用重写的协议方法时，仍然是重写后的方法，而非父类方法。因为<code>witness_table</code>是将当前<code>Teacher</code>的数据转成<code>Person</code>之后再去调用的，而<code>Teacher</code>重写了方法，因此会调用重写后的方法<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">sil_vtable <span class="hljs-type">Person</span> &#123;<br>      #<span class="hljs-type">Person</span>.logInfo: (<span class="hljs-type">Person</span>) -&gt; () -&gt; () : @<span class="hljs-variable">$s12ProtocolText6PersonC7logInfoyyF</span>	<span class="hljs-comment">// Person.logInfo()</span><br>      #<span class="hljs-type">Person</span>.<span class="hljs-keyword">init</span><span class="hljs-operator">!</span>allocator: (<span class="hljs-type">Person</span>.<span class="hljs-keyword">Type</span>) -&gt; () -&gt; <span class="hljs-type">Person</span> : @<span class="hljs-variable">$s12ProtocolText6PersonCACycfC</span>	<span class="hljs-comment">// Person.__allocating_init()</span><br>      #<span class="hljs-type">Person</span>.deinit<span class="hljs-operator">!</span>deallocator: @<span class="hljs-variable">$s12ProtocolText6PersonCfD</span>	<span class="hljs-comment">// Person.__deallocating_deinit</span><br>    &#125;<br>    <br>sil_vtable <span class="hljs-type">Teatcher</span> &#123;<br>      #<span class="hljs-type">Person</span>.logInfo: (<span class="hljs-type">Person</span>) -&gt; () -&gt; () : @<span class="hljs-variable">$s12ProtocolText6PersonC7logInfoyyF</span> [inherited]	<span class="hljs-comment">// Person.logInfo()</span><br>      #<span class="hljs-type">Person</span>.<span class="hljs-keyword">init</span><span class="hljs-operator">!</span>allocator: (<span class="hljs-type">Person</span>.<span class="hljs-keyword">Type</span>) -&gt; () -&gt; <span class="hljs-type">Person</span> : @<span class="hljs-variable">$s12ProtocolText8TeatcherCACycfC</span> [<span class="hljs-keyword">override</span>]	<span class="hljs-comment">// Teatcher.__allocating_init()</span><br>      #<span class="hljs-type">Teatcher</span>.deinit<span class="hljs-operator">!</span>deallocator: @<span class="hljs-variable">$s12ProtocolText8TeatcherCfD</span>	<span class="hljs-comment">// Teatcher.__deallocating_deinit</span><br>    &#125;<br>    <br><span class="hljs-comment">//Teacher继承了Person但不会为他创建一个sil_witness_table</span><br>sil_witness_table hidden <span class="hljs-type">Person</span>: <span class="hljs-type">MyProtocolMetadata</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>      method #<span class="hljs-type">MyProtocolMetadata</span>.logInfo: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocolMetadata</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; () -&gt; () : @<span class="hljs-variable">$s12ProtocolText6PersonCAA02MyA8MetadataA2aDP7logInfoyyFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocolMetadata.logInfo() in conformance Person</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>Person</code>类遵循了<code>ProtocolA</code>和<code>ProtocolB</code>并都实现了协议方法，它会为<code>Person</code>类分别创建两个<code>Protocol Witness Table(PWT)</code> <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">sil_vtable <span class="hljs-type">Teacher</span> &#123;<br>      #<span class="hljs-type">Teacher</span>.logInfo: (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherC7logInfoyyypF</span>	<span class="hljs-comment">// Teacher.logInfo(_:)</span><br>      #<span class="hljs-type">Teacher</span>.name: (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherC4nameyyypF</span>	<span class="hljs-comment">// Teacher.name(_:)</span><br>      #<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">init</span><span class="hljs-operator">!</span>allocator: (<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; () -&gt; <span class="hljs-type">Teacher</span> : @<span class="hljs-variable">$s12ProtocolText7TeacherCACycfC</span>	<span class="hljs-comment">// Teacher.__allocating_init()</span><br>      #<span class="hljs-type">Teacher</span>.deinit<span class="hljs-operator">!</span>deallocator: @<span class="hljs-variable">$s12ProtocolText7TeacherCfD</span>	<span class="hljs-comment">// Teacher.__deallocating_deinit</span><br>    &#125;<br>    <span class="hljs-comment">//分别创建了两个sil_witness_table</span><br>    sil_witness_table hidden <span class="hljs-type">Teacher</span>: <span class="hljs-type">MyProtocolA</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>      method #<span class="hljs-type">MyProtocolA</span>.logInfo: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocolA</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA1AA2aDP7logInfoyyypFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocolA.logInfo(_:) in conformance Teacher</span><br>    &#125;<br>    <br>    sil_witness_table hidden <span class="hljs-type">Teacher</span>: <span class="hljs-type">MyProtocolB</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>      method #<span class="hljs-type">MyProtocolB</span>.name: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocolB</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA1BA2aDP4nameyyypFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocolB.name(_:) in conformance Teacher</span><br> &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="协议源码分析"><a href="#协议源码分析" class="headerlink" title="协议源码分析"></a>协议源码分析</h1><blockquote>
<p><code>Class</code>在内存中的数据结构是有一个<code>typeDescription</code>类描述器，里面记录着类的信息（属性描述器、方法<code>v-table</code>等）；那么协议在内存中又是一个什么样的东西呢</p>
</blockquote>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> area: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">Shape</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> radious: <span class="hljs-type">Int</span> <span class="hljs-comment">// 存储型属性 8</span><br>        <span class="hljs-keyword">var</span> time: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>        <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">radious</span>: <span class="hljs-type">Int</span>)</span> &#123;<br>            <span class="hljs-keyword">self</span>.radious <span class="hljs-operator">=</span> radious<br>        &#125;<br>        <br>       <br>        <span class="hljs-keyword">var</span> area: <span class="hljs-type">Int</span> &#123;<br>            <span class="hljs-keyword">get</span> &#123;<br>                <span class="hljs-keyword">return</span> radious <span class="hljs-operator">*</span> radious<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="对象内存"><a href="#对象内存" class="headerlink" title="对象内存"></a>对象内存</h3><ul>
<li>查看对象内存,注意<code>MemoryLayout.size</code>拿到的是指针的大小<code>8</code>,实际大小为<code>32</code> = <code>metaData</code> + <code>refcount</code> + <code>Int</code> + <code>Int</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>circle) &#123; <span class="hljs-variable">$0</span> &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象指针地址:&quot;</span>,ptr) <span class="hljs-comment">// 对象指针地址: 0x00007ff7bfefecd0</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">Circle</span>.<span class="hljs-keyword">self</span>)) <span class="hljs-comment">//32</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle)) <span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看对象内存中存放的值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>xg <span class="hljs-number">0x00007ff7bfefecd0</span><br><span class="hljs-comment">//堆地址</span><br><span class="hljs-number">0x7ff7bfefecd0</span>: <span class="hljs-number">0x00006000002042a0</span><br>(lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x00006000002042a0</span><br>                <span class="hljs-comment">//metaData。     refcount</span><br><span class="hljs-number">0x6000002042a0</span>: <span class="hljs-number">0x00000001000187e0</span> <span class="hljs-number">0x0000000000000003</span><br>                <span class="hljs-comment">//radious         time</span><br><span class="hljs-number">0x6000002042b0</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x6000002042c0</span>: <span class="hljs-number">0x2c656c62756f4428</span> <span class="hljs-number">0x29656c62756f4420</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="协议内存"><a href="#协议内存" class="headerlink" title="协议内存"></a>协议内存</h3><ul>
<li>查看协议内存,此时<code>MemoryLayout.size</code>获取的内存大小为<code>40</code>,<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle1: <span class="hljs-type">Shape</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">let</span> ptr1 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>circle1) &#123; <span class="hljs-variable">$0</span> &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;协议对象地址:&quot;</span>,ptr1) <span class="hljs-comment">// 协议对象地址: 0x00007ff7bfefec98</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle1)) <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看对象内存中存放的值,前<code>40</code>个字节存放的内容,<ul>
<li>第一个字节存放堆对象，即<code>Circle(10)</code>的值</li>
<li>第四个存储<code>metadata</code></li>
<li>第五个存放<code>witness table</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x00007ff7bfefec98</span><br>                <span class="hljs-comment">// 堆对象</span><br><span class="hljs-number">0x7ff7bfefec98</span>: <span class="hljs-number">0x000060000020a820</span> <span class="hljs-number">0x0000000000000000</span><br>                                    <span class="hljs-comment">//是circle的metaData</span><br><span class="hljs-number">0x7ff7bfefeca8</span>: <span class="hljs-number">0x00007ff7bfefe0d0</span> <span class="hljs-number">0x00000001000187e0</span><br>                <span class="hljs-comment">//witness table</span><br><span class="hljs-number">0x7ff7bfefecb8</span>: <span class="hljs-number">0x0000000100014df0</span> <span class="hljs-number">0x00007ff7bfefecd0</span><br>(lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x000060000020a820</span> <br><span class="hljs-number">0x60000020a820</span>: <span class="hljs-number">0x00000001000187e0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x60000020a830</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x60000020a840</span>: <span class="hljs-number">0x2c676e6972745328</span> <span class="hljs-number">0x2c676e6972745320</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>将<code>var circle:Shape = Circle(10)</code>转换成<code>IR</code>可得<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define i32 <span class="hljs-keyword">@main</span>(i32 <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to i8<span class="hljs-operator">*</span><br>  <span class="hljs-comment">// 获取Circle的Metadata</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> call swiftcc <span class="hljs-operator">%</span>swift.metadata_response @<span class="hljs-string">&quot;$s12ProtocolText6CircleCMa&quot;</span>(i64 <span class="hljs-number">0</span>) #<span class="hljs-number">9</span><br>  <span class="hljs-comment">// %4存储Metadata</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> extractvalue <span class="hljs-operator">%</span>swift.metadata_response <span class="hljs-operator">%</span><span class="hljs-number">3</span>, <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 调用allocating-init</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> call swiftcc <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCyACSicfC&quot;</span>(i64 <span class="hljs-number">10</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> swiftself <span class="hljs-operator">%</span><span class="hljs-number">4</span>)<br>  <span class="hljs-comment">// s12ProtocolText6circleAA5Shape_pvp是circle实例对象。 这一行代码意思是：把Metadata存储到circle</span><br>  store <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span>, <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6circleAA5Shape_pvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span>), align <span class="hljs-number">8</span><br>  <span class="hljs-comment">// s12ProtocolText6CircleCAA5ShapeAAW是protocol witess table它是一个数组（[2 x i8*]代表数组）</span><br>  store i8<span class="hljs-operator">**</span> getelementptr inbounds ([<span class="hljs-number">2</span> x i8<span class="hljs-operator">*</span>], [<span class="hljs-number">2</span> x i8<span class="hljs-operator">*</span>]<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeAAWP&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), i8<span class="hljs-operator">***</span> getelementptr inbounds (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span>, <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6circleAA5Shape_pvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">2</span>), align <span class="hljs-number">8</span><br>  <span class="hljs-comment">// 这里是把生成的堆对象存在Circle</span><br>  store <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">**</span> bitcast (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6circleAA5Shape_pvp&quot;</span> to <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">**</span>), align <span class="hljs-number">8</span><br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>s12ProtocolText6CircleCAA5ShapeAAW</code>是数组由<code>swift.protocol_conformance_descriptor</code>和<code>s12ProtocolText6CircleCAA5ShapeA2aDP4areaSivgTW</code>组成  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">@<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeAAWP&quot;</span> <span class="hljs-operator">=</span> hidden constant [<span class="hljs-number">2</span> x i8<span class="hljs-operator">*</span>] [i8<span class="hljs-operator">*</span> bitcast (<span class="hljs-operator">%</span>swift.protocol_conformance_descriptor<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeAAMc&quot;</span> to i8<span class="hljs-operator">*</span>), i8<span class="hljs-operator">*</span> bitcast (i64 (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">**</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span>)<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeA2aDP4areaSivgTW&quot;</span> to i8<span class="hljs-operator">*</span>)], align <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li>
<li>注意，如果协议列表中增加了一个协议，则会变成长度为3的数组<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">store i8<span class="hljs-operator">**</span> getelementptr inbounds ([<span class="hljs-number">3</span> x i8<span class="hljs-operator">*</span>], [<span class="hljs-number">3</span> x i8<span class="hljs-operator">*</span>]<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeAAWP&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), i8<span class="hljs-operator">***</span> getelementptr inbounds (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span>, <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6circleAA5Shape_pvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">2</span>), align <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li>
<li>因此<code>witness_table</code>这个数据结构：<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> protocol_conformance_descriptor: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> witnessMethod: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 协议见证里的方法的起始地址</span><br>    <span class="hljs-comment">// 如果实现了协议的多个方法，则在后面加成员</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>可以得到一个初版的<code>protocol</code>在内存上的数据结构</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow1: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow2: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> protocol_conformance_descriptor: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> witnessMethod: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 协议见证里的方法的起始地址</span><br>    <span class="hljs-comment">// 如果实现了协议的多个方法，则在后面加成员</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>下面分析最后一个成员<code>witness_table</code>内存结构到底长啥样</li>
<li>为什么第一个成员<code>heapObject</code>有<code>metadata</code>，而第四个成员还要存放一个<code>metadata</code></li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="TargetWitnessTable"><a href="#TargetWitnessTable" class="headerlink" title="TargetWitnessTable"></a><code>TargetWitnessTable</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// A witness table for a protocol.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// With the exception of the initial protocol conformance descriptor,</span><br><span class="hljs-comment">/// the layout of a witness table is dependent on the protocol being</span><br><span class="hljs-comment">/// represented.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetWitnessTable</span> &#123;</span><br>  <span class="hljs-comment">/// The protocol conformance descriptor from which this witness table</span><br>  <span class="hljs-comment">/// was generated.</span><br>  ConstTargetMetadataPointer&lt;Runtime, TargetProtocolConformanceDescriptor&gt;<br>    Description;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetProtocolConformanceDescriptor&lt;Runtime&gt; *<span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">using</span> WitnessTable = TargetWitnessTable&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>

<h3 id="TargetProtocolConformanceDescriptor"><a href="#TargetProtocolConformanceDescriptor" class="headerlink" title="TargetProtocolConformanceDescriptor"></a><code>TargetProtocolConformanceDescriptor</code></h3><blockquote>
<p>协议一致性结构</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of a protocol conformance.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This contains enough static information to recover the witness table for a</span><br><span class="hljs-comment">/// type&#x27;s conformance to a protocol.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolConformanceDescriptor</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">  :</span> <span class="hljs-keyword">public</span> swift::ABI::TrailingObjects&lt;<br>             TargetProtocolConformanceDescriptor&lt;Runtime&gt;,<br>             TargetRelativeContextPointer&lt;Runtime&gt;,<br>             TargetGenericRequirementDescriptor&lt;Runtime&gt;,<br>             TargetResilientWitnessesHeader&lt;Runtime&gt;,<br>             TargetResilientWitness&lt;Runtime&gt;,<br>             TargetGenericWitnessTable&lt;Runtime&gt;&gt; &#123;<br><br>  <span class="hljs-keyword">using</span> TrailingObjects = swift::ABI::TrailingObjects&lt;<br>                             TargetProtocolConformanceDescriptor&lt;Runtime&gt;,<br>                             TargetRelativeContextPointer&lt;Runtime&gt;,<br>                             TargetGenericRequirementDescriptor&lt;Runtime&gt;,<br>                             TargetResilientWitnessesHeader&lt;Runtime&gt;,<br>                             TargetResilientWitness&lt;Runtime&gt;,<br>                             TargetGenericWitnessTable&lt;Runtime&gt;&gt;;<br>  <span class="hljs-keyword">friend</span> TrailingObjects;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">using</span> OverloadToken = <span class="hljs-keyword">typename</span> TrailingObjects::<span class="hljs-keyword">template</span> OverloadToken&lt;T&gt;;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> GenericRequirementDescriptor =<br>    TargetGenericRequirementDescriptor&lt;Runtime&gt;;<br><br>  <span class="hljs-keyword">using</span> ResilientWitnessesHeader = TargetResilientWitnessesHeader&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> ResilientWitness = TargetResilientWitness&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> GenericWitnessTable = TargetGenericWitnessTable&lt;Runtime&gt;;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/// The protocol being conformed to.</span><br>  TargetRelativeContextPointer&lt;Runtime, TargetProtocolDescriptor&gt; Protocol;<br>  <br>  <span class="hljs-comment">// Some description of the type that conforms to the protocol.</span><br>  TargetTypeReference&lt;Runtime&gt; TypeRef;<br><br>  <span class="hljs-comment">/// The witness table pattern, which may also serve as the witness table.</span><br>  RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> TargetWitnessTable&lt;Runtime&gt;&gt; WitnessTablePattern;<br><br>  <span class="hljs-comment">/// Various flags, including the kind of conformance.</span><br>  ConformanceFlags Flags;<br><br><span class="hljs-keyword">public</span>:<br>  ConstTargetPointer&lt;Runtime, TargetProtocolDescriptor&lt;Runtime&gt;&gt;<br>  <span class="hljs-built_in">getProtocol</span>() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> Protocol;<br>  &#125;<br><br>  <span class="hljs-function">TypeReferenceKind <span class="hljs-title">getTypeKind</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getTypeReferenceKind</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">getDirectObjCClassName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TypeRef.<span class="hljs-built_in">getDirectObjCClassName</span>(<span class="hljs-built_in">getTypeKind</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetClassMetadataObjCInterop&lt;Runtime&gt; *<span class="hljs-keyword">const</span> *</span><br><span class="hljs-function">  <span class="hljs-title">getIndirectObjCClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TypeRef.<span class="hljs-built_in">getIndirectObjCClass</span>(<span class="hljs-built_in">getTypeKind</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *<span class="hljs-title">getTypeDescriptor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TypeRef.<span class="hljs-built_in">getTypeDescriptor</span>(<span class="hljs-built_in">getTypeKind</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span></span><br><span class="hljs-function">  <span class="hljs-title">getTypeRefDescriptorOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> -&gt; <span class="hljs-keyword">typename</span> Runtime::StoredSize </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">typename</span> std::remove_reference&lt;<span class="hljs-keyword">decltype</span>(*<span class="hljs-keyword">this</span>)&gt;::type, TypeRef);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span></span><br><span class="hljs-function">  <span class="hljs-title">getProtocolDescriptorOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> -&gt; <span class="hljs-keyword">typename</span> Runtime::StoredSize </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">typename</span> std::remove_reference&lt;<span class="hljs-keyword">decltype</span>(*<span class="hljs-keyword">this</span>)&gt;::type, Protocol);<br>  &#125;<br><br>  TargetContextDescriptor&lt;Runtime&gt; * __ptrauth_swift_type_descriptor *<br>  _getTypeDescriptorLocation() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getTypeKind</span>() != TypeReferenceKind::IndirectTypeDescriptor)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> TypeRef.IndirectTypeDescriptor.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the context of a retroactive conformance.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *<span class="hljs-title">getRetroactiveContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!Flags.<span class="hljs-built_in">isRetroactive</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;<br>        TargetRelativeContextPointer&lt;Runtime&gt;&gt;();<br>  &#125;<br><br>  <span class="hljs-comment">/// Whether this conformance is non-unique because it has been synthesized</span><br>  <span class="hljs-comment">/// for a foreign type.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSynthesizedNonUnique</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isSynthesizedNonUnique</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/// Whether this conformance has any conditional requirements that need to</span><br>  <span class="hljs-comment">/// be evaluated.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasConditionalRequirements</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getNumConditionalRequirements</span>() &gt; <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the conditional requirements that must also be</span><br>  <span class="hljs-comment">/// satisfied</span><br>  <span class="hljs-function">llvm::ArrayRef&lt;GenericRequirementDescriptor&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getConditionalRequirements</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;GenericRequirementDescriptor&gt;(),<br>            Flags.<span class="hljs-built_in">getNumConditionalRequirements</span>()&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/// Get the directly-referenced witness table pattern, which may also</span><br>  <span class="hljs-comment">/// serve as the witness table.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> swift::TargetWitnessTable&lt;Runtime&gt; *<span class="hljs-title">getWitnessTablePattern</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> WitnessTablePattern;<br>  &#125;<br><br>  <span class="hljs-comment">/// Get the canonical metadata for the type referenced by this record, or</span><br>  <span class="hljs-comment">/// return null if the record references a generic or universal type.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *<span class="hljs-title">getCanonicalTypeMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>  <br>  <span class="hljs-comment">/// Get the witness table for the specified type, realizing it if</span><br>  <span class="hljs-comment">/// necessary, or return null if the conformance does not apply to the</span><br>  <span class="hljs-comment">/// type.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> swift::TargetWitnessTable&lt;Runtime&gt; *</span><br><span class="hljs-function">  <span class="hljs-title">getWitnessTable</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *type)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Retrieve the resilient witnesses.</span><br>  <span class="hljs-function">llvm::ArrayRef&lt;ResilientWitness&gt; <span class="hljs-title">getResilientWitnesses</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!Flags.<span class="hljs-built_in">hasResilientWitnesses</span>())<br>      <span class="hljs-keyword">return</span> &#123; &#125;;<br><br>    <span class="hljs-keyword">return</span> llvm::ArrayRef&lt;ResilientWitness&gt;(<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;ResilientWitness&gt;(),<br>        <span class="hljs-built_in">numTrailingObjects</span>(OverloadToken&lt;ResilientWitness&gt;()));<br>  &#125;<br><br>  <span class="hljs-function">ConstTargetPointer&lt;Runtime, GenericWitnessTable&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getGenericWitnessTable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!Flags.<span class="hljs-built_in">hasGenericWitnessTable</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;GenericWitnessTable&gt;();<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(NDEBUG) &amp;&amp; SWIFT_OBJC_INTEROP</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>  <span class="hljs-comment">/// Verify that the protocol descriptor obeys all invariants.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// We currently check that the descriptor:</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// 1. Has a valid TypeReferenceKind.</span><br>  <span class="hljs-comment">/// 2. Has a valid conformance kind.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">verify</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                        OverloadToken&lt;TargetRelativeContextPointer&lt;Runtime&gt;&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isRetroactive</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;GenericRequirementDescriptor&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getNumConditionalRequirements</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;ResilientWitnessesHeader&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasResilientWitnesses</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;ResilientWitness&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasResilientWitnesses</span>()<br>      ? <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;ResilientWitnessesHeader&gt;()<br>          -&gt;NumWitnesses<br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;GenericWitnessTable&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasGenericWitnessTable</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> ProtocolConformanceDescriptor<br>  = TargetProtocolConformanceDescriptor&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolConformanceDescriptor</span> </span>&#123;<br>    <span class="hljs-comment">// TargetRelativeDirectPointer相对类型的指针，实质存放偏移量</span><br>    <span class="hljs-keyword">var</span> protocolDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">TargetProtocolDescriptor</span>&gt;<br>    <span class="hljs-keyword">var</span> typeRef: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">WitnessTablePattern</span>: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>其第一个成员变量是<code>TargetProtocolDescriptor</code></li>
</ul>
<h3 id="TargetProtocolDescriptor"><a href="#TargetProtocolDescriptor" class="headerlink" title="TargetProtocolDescriptor"></a><code>TargetProtocolDescriptor</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// A protocol descriptor.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Protocol descriptors contain information about the contents of a protocol:</span><br><span class="hljs-comment">/// it&#x27;s name, requirements, requirement signature, context, and so on. They</span><br><span class="hljs-comment">/// are used both to identify a protocol and to reason about its contents.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Only Swift protocols are defined by a protocol descriptor, whereas</span><br><span class="hljs-comment">/// Objective-C (including protocols defined in Swift as @objc) use the</span><br><span class="hljs-comment">/// Objective-C protocol layout.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolDescriptor</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">    :</span> TargetContextDescriptor&lt;Runtime&gt;,<br>      swift::ABI::TrailingObjects&lt;<br>        TargetProtocolDescriptor&lt;Runtime&gt;,<br>        TargetGenericRequirementDescriptor&lt;Runtime&gt;,<br>        TargetProtocolRequirement&lt;Runtime&gt;&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">using</span> TrailingObjects<br>    = swift::ABI::TrailingObjects&lt;<br>        TargetProtocolDescriptor&lt;Runtime&gt;,<br>        TargetGenericRequirementDescriptor&lt;Runtime&gt;,<br>        TargetProtocolRequirement&lt;Runtime&gt;&gt;;<br><br>  <span class="hljs-keyword">friend</span> TrailingObjects;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">using</span> OverloadToken = <span class="hljs-keyword">typename</span> TrailingObjects::<span class="hljs-keyword">template</span> OverloadToken&lt;T&gt;;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            OverloadToken&lt;TargetGenericRequirementDescriptor&lt;Runtime&gt;&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> NumRequirementsInSignature;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            OverloadToken&lt;TargetProtocolRequirement&lt;Runtime&gt;&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> NumRequirements;<br>  &#125;<br><br><br>  <span class="hljs-comment">/// The name of the protocol.</span><br>  TargetRelativeDirectPointer&lt;Runtime, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>, <span class="hljs-comment">/*nullable*/</span> <span class="hljs-literal">false</span>&gt; Name;<br><br>  <span class="hljs-comment">/// The number of generic requirements in the requirement signature of the</span><br>  <span class="hljs-comment">/// protocol.</span><br>  <span class="hljs-keyword">uint32_t</span> NumRequirementsInSignature;<br><br>  <span class="hljs-comment">/// The number of requirements in the protocol.</span><br>  <span class="hljs-comment">/// If any requirements beyond MinimumWitnessTableSizeInWords are present</span><br>  <span class="hljs-comment">/// in the witness table template, they will be not be overwritten with</span><br>  <span class="hljs-comment">/// defaults.</span><br>  <span class="hljs-keyword">uint32_t</span> NumRequirements;<br><br>  <span class="hljs-comment">/// Associated type names, as a space-separated list in the same order</span><br>  <span class="hljs-comment">/// as the requirements.</span><br>  RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>, <span class="hljs-comment">/*Nullable=*/</span><span class="hljs-literal">true</span>&gt; AssociatedTypeNames;<br><br>  <span class="hljs-function">ProtocolContextDescriptorFlags <span class="hljs-title">getProtocolContextDescriptorFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ProtocolContextDescriptorFlags</span>(<span class="hljs-keyword">this</span>-&gt;Flags.<span class="hljs-built_in">getKindSpecificFlags</span>());<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the requirements that make up the requirement signature of</span><br>  <span class="hljs-comment">/// this protocol.</span><br>  llvm::ArrayRef&lt;TargetGenericRequirementDescriptor&lt;Runtime&gt;&gt;<br>  <span class="hljs-built_in">getRequirementSignature</span>() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;<br>                             TargetGenericRequirementDescriptor&lt;Runtime&gt;&gt;(),<br>            NumRequirementsInSignature&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the requirements of this protocol.</span><br>  llvm::ArrayRef&lt;TargetProtocolRequirement&lt;Runtime&gt;&gt;<br>  <span class="hljs-built_in">getRequirements</span>() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;<br>                             TargetProtocolRequirement&lt;Runtime&gt;&gt;(),<br>            NumRequirements&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span></span><br><span class="hljs-function">  <span class="hljs-title">getNameOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> -&gt; <span class="hljs-keyword">typename</span> Runtime::StoredSize </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">typename</span> std::remove_reference&lt;<span class="hljs-keyword">decltype</span>(*<span class="hljs-keyword">this</span>)&gt;::type, Name);<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the requirement base descriptor address.</span><br>  ConstTargetPointer&lt;Runtime, TargetProtocolRequirement&lt;Runtime&gt;&gt;<br>  <span class="hljs-built_in">getRequirementBaseDescriptor</span>() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRequirements</span>().<span class="hljs-built_in">data</span>() - WitnessTableFirstRequirementOffset;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>  [[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;Only meant for use in the debugger&quot;</span>)]] <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *cd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Protocol;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>TargetProtocolDescriptor</code>继承自<code>TargetContextDescriptor</code>,而<code>TargetContextDescriptor</code>的结构为<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetContextDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Name</span>: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumRequirementsInSignature</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumRequirements</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">AssociatedTypeNames</span>: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Existential-Container"><a href="#Existential-Container" class="headerlink" title="Existential Container"></a>Existential Container</h2><blockquote>
<p><code>Existential Container</code>也就是本章所说的<code>ProtocolBox</code>实际上有两类,<code>Opaque Existential Container</code>和<code>ClassExistentialContainer</code></p>
</blockquote>
<h3 id="Opaque-Existential-Container"><a href="#Opaque-Existential-Container" class="headerlink" title="Opaque Existential Container"></a><code>Opaque Existential Container</code></h3><blockquote>
<p><code>Opaque Existential Container</code> — 用于没有类约束的 <code>Protocol</code> (<code>no class constraint on protocol</code>)，也就是说这种协议背后的真实类型可能是类、结构体以及枚举等。因此其存储就非常复杂</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpaqueExistentialContainer</span> &#123;</span><br>  <span class="hljs-keyword">void</span> *fixedSizeBuffer[<span class="hljs-number">3</span>];<br>  Metadata *type;<br>  WitnessTable *witnessTables[NUM_WITNESS_TABLES];<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>fixedSizeBuffer</code>:<code>3</code> 个指针大小的 <code>buffer</code> 空间，当真实类型的 <code>size</code> (内存对齐后的大小) 小于 <code>3</code> 个字时则其内容直接存储在 <code>fixedSizeBuffer</code> 中，否则在 <code>heap</code> 上另辟空间存储，并将指针存储在 <code>fixedSizeBuffer</code> 中；</li>
<li><code>type</code>:指向真实类型的 <code>Metadata</code>，最重要的就是引用其中的 <code>VWT</code> 用于完成内存的各种操作；</li>
<li><code>witnessTables</code>: 指向协议函数表 (<code>Protocol Witness Table</code>, <code>PWT</code>)，协议函数表中存储的是真实类型中对应函数的地址。</li>
</ul>
<h3 id="Class-Existential-Container"><a href="#Class-Existential-Container" class="headerlink" title="Class Existential Container"></a>Class Existential Container</h3><blockquote>
<p>用于有类约束的 <code>Protocol</code>，该协议背后真实的类型只能是类，而类的实例都是在 <code>Heap</code> 上分配内存的。<br>因此，在 <code>Existential Container</code> 中只需要一个指向堆内存的指针即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClassExistentialContainer</span> &#123;</span><br>  HeapObject *value;<br>  WitnessTable *witnessTables[NUM_WITNESS_TABLES];<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>value</code>:指向堆内存的指针；</li>
<li><code>witnessTables</code>:<code>PWT</code> 指针。</li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><blockquote>
<p>继承<code>AnyObject</code>只用于类的协议，<code>swift</code>会进行优化,其内存占用不是之前的<code>40</code>字节，而变成<code>16</code>。</p>
</blockquote>
<ul>
<li><p>如果协议只能用于类，例如协议继承了<code>AnyObject</code>，则协议的结构<code>ProtocolBox</code>会发生改变,其内存大小会变成<code>16</code>。</p>
</li>
<li><p>此外，如果是<code>BrigeProtocol.Type</code>，协议的元类也是<code>16</code>字节</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-comment">// IR分析出：它本是一个数组，就用一样大小和结构相同的结构体代替</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>如果协议能用于类、结构体、枚举，则协议的结构<code>ProtocolBox</code>会和此前分析的一致，其内存大小会变成<code>40</code></p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow1: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow2: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-comment">// IR分析出：它本是一个数组，就用一样大小和结构相同的结构体代替</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="验证协议本质"><a href="#验证协议本质" class="headerlink" title="验证协议本质"></a>验证协议本质</h1><ul>
<li><p>总的协议数据结构如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//继承了AnyObject,只用于类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolClassBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-comment">// IR分析出：它本是一个数组，就用一样大小和结构相同的结构体代替</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow1: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow2: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-comment">// IR分析出：它本是一个数组，就用一样大小和结构相同的结构体代替</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> protocol_conformance_descriptor: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolConformanceDescriptor</span>&gt;<br>    <span class="hljs-keyword">var</span> witnessMethod: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 协议见证里的方法</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolConformanceDescriptor</span> </span>&#123;<br>    <span class="hljs-comment">// TargetRelativeDirectPointer相对类型的指针，实质存放偏移量</span><br>    <span class="hljs-keyword">var</span> protocolDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">TargetProtocolDescriptor</span>&gt;<br>    <span class="hljs-keyword">var</span> typeRef: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">WitnessTablePattern</span>: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Name</span>: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumRequirementsInSignature</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumRequirements</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">AssociatedTypeNames</span>: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>验证代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle1: <span class="hljs-type">Shape</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>.<span class="hljs-keyword">init</span>(<span class="hljs-number">10.0</span>)<br><span class="hljs-comment">// 拿到circle1堆区地址，然后内存绑定ProtocolBox类型</span><br><span class="hljs-keyword">let</span> circle1_ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>circle1) &#123; ptr <span class="hljs-keyword">in</span><br>    <span class="hljs-keyword">return</span> ptr.withMemoryRebound(to: <span class="hljs-type">ProtocolBox</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; pointer <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">return</span> pointer<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> desc <span class="hljs-operator">=</span> circle1_ptr.pointee.witness_table.pointee.protocol_conformance_descriptor.pointee.protocolDescriptor.getmeasureRelativeOffset()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: desc.pointee.<span class="hljs-type">Name</span>.getmeasureRelativeOffset())) <span class="hljs-comment">// Shape</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: desc.pointee.<span class="hljs-type">AssociatedTypeNames</span>.getmeasureRelativeOffset())) <span class="hljs-comment">//无关联类型是空</span><br>    <span class="hljs-built_in">print</span>(desc.pointee.<span class="hljs-type">NumRequirements</span>) <span class="hljs-comment">// 1</span><br>    <br>    <span class="hljs-built_in">print</span>(circle1_ptr.pointee.witness_table.pointee.witnessMethod) <span class="hljs-comment">// 0x00000001000101a0</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br></code></pre></td></tr></table></figure></li>
<li><p>打印出<code>witnessMethod</code>的地址是 <code>00000001000101a0</code>就是<code>Circle</code>类实现协议<code>Shape</code>的属性<code>area</code>的地址,可以在<code>Mach-O</code>上能找到；下面这个命令还原出来</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//地址在Mach-O上是不带0x的</span><br>$  nm <span class="hljs-operator">-</span>p <span class="hljs-type">SwiftSource</span> <span class="hljs-operator">|</span> grep 00000001000101a0<br><span class="hljs-comment">// 输出了一个混写的名称</span><br>00000001000101a0 t <span class="hljs-keyword">_</span><span class="hljs-variable">$s11SwiftSource6CircleL_CAA5ShapeA2aDP4areaSivgTW</span><br><br>$ xcrun swift<span class="hljs-operator">-</span>demangle s11SwiftSource6CircleL_CAA5ShapeA2aDP4areaSivgTW<br><span class="hljs-comment">// 最后得到下面的内容</span><br><span class="hljs-variable">$s11SwiftSource6CircleL_CAA5ShapeA2aDP4areaSivgTW</span> <span class="hljs-operator">---&gt;</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">witness</span> <span class="hljs-title">for</span> <span class="hljs-title">SwiftSource</span>.<span class="hljs-title">Shape</span>.<span class="hljs-title">area</span>.get<span class="hljs-title">ter</span> : <span class="hljs-title">Swift</span>.<span class="hljs-title">Int</span> <span class="hljs-title">in</span> <span class="hljs-title">conformance</span> <span class="hljs-title">Circle</span> #1 <span class="hljs-title">in</span> <span class="hljs-title">SwiftSource</span> : <span class="hljs-title">SwiftSource</span>.<span class="hljs-title">Shape</span> <span class="hljs-title">in</span> <span class="hljs-title">SwiftSource</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>每个遵守了协议的类，都会有自己的<code>Protocol Witness Table (PWT)</code>，遵守的协议越多，<code>PWT</code>中存储的函数地址就越多；</li>
<li><code>PWT</code>的本质是一个指针数组，第一个成员存储<code>TargetProtocolConformanceDescriptor</code>，其后面存储的是实现协议函数的地址；</li>
<li><code>PWT</code>的数量与协议数量一致。</li>
</ol>
<h2 id="ProtocolBox的作用"><a href="#ProtocolBox的作用" class="headerlink" title="ProtocolBox的作用"></a><code>ProtocolBox</code>的作用</h2><blockquote>
<ul>
<li><code>Existential Container</code>即<code>ProtocolBox</code>是编译器生成的一种特殊的数据类型，用于管理<code>class</code>/<code>struct</code>/<code>enum</code>等遵守了同一个协议类型，因为这些<code>class</code>/<code>struct</code>/<code>enum</code>等类型的内存大小不一致，所以通过当前的<code>Existential Container</code>统一管理；</li>
<li>对于小容量的数据，直接存储在<code>Value Buffer</code>；(小于等于<code>24</code>字节),前三个8字节中</li>
<li>对于大容量的数据，通过堆区分配，存储堆空间的地址。（大于<code>24</code>字节）</li>
</ul>
</blockquote>
<ul>
<li>将<code>Circle</code>换成<code>struct</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">Shape</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> radious: <span class="hljs-type">Int</span> <span class="hljs-comment">// 存储型属性 8</span><br>        <span class="hljs-keyword">var</span> time: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>        <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">radious</span>: <span class="hljs-type">Int</span>)</span> &#123;<br>            <span class="hljs-keyword">self</span>.radious <span class="hljs-operator">=</span> radious<br>        &#125;<br>        <br>       <br>        <span class="hljs-keyword">var</span> area: <span class="hljs-type">Int</span> &#123;<br>            <span class="hljs-keyword">get</span> &#123;<br>                <span class="hljs-keyword">return</span> radious <span class="hljs-operator">*</span> radious<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>查看打印的<code>circle</code>对象依旧是<code>40</code>个字节。<ul>
<li>因为当实例变量声明为协议类型的时候，程序在编译时并不能推导出实例变量的真实类型，那就导致没有办法为实例变量分配具体的内存空间。</li>
<li>于是就不管它到底需要多大是什么类型统一塞到<code>40</code>字节的存在容器统一管理。</li>
<li>所以编译器就用一种特殊的数据类型<code>Existential Container</code>去统一管理遵循协议的<code>class</code>/<code>struct</code>/<code>enum</code>等（<code>Existential Container</code>本质是上面分析出的<code>ProtocolBox</code>）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle1:<span class="hljs-type">Shape</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">let</span> ptr1 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>circle1) &#123; <span class="hljs-variable">$0</span> &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;协议对象地址:&quot;</span>,ptr1) <span class="hljs-comment">// 0x00007ff7bfefec78</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle1)) <span class="hljs-comment">//40</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>前<code>24</code>个字节存放的数据,第四个<code>8</code>字节存放的是依旧是<code>metadata</code>,此时是<code>TargetStructMetadata</code>,在真实调用实现协议的方法的时候就会找到这个<code>metadata</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x00007ff7bfefec78</span><br><span class="hljs-comment">//存的radious 10            存的age 4</span><br><span class="hljs-number">0x7ff7bfefec78</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000004</span><br>                                    <span class="hljs-comment">// metaData</span><br><span class="hljs-number">0x7ff7bfefec88</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000100015050</span><br>        <span class="hljs-comment">// wentesstable</span><br><span class="hljs-number">0x7ff7bfefec98</span>: <span class="hljs-number">0x0000000100015068</span> <span class="hljs-number">0x00007ff7bfefeca8</span><br></code></pre></td></tr></table></figure></li>
<li>如果增加成员变量<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">Shape</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> radious: <span class="hljs-type">Int</span> <span class="hljs-comment">// 存储型属性 8</span><br>        <span class="hljs-keyword">var</span> radious1 <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>        <span class="hljs-keyword">var</span> radious2 <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br>        <span class="hljs-keyword">var</span> radious3 <span class="hljs-operator">=</span> <span class="hljs-number">40</span><br>        <span class="hljs-keyword">var</span> time: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>        <br>        <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">radious</span>: <span class="hljs-type">Int</span>)</span> &#123;<br>            <span class="hljs-keyword">self</span>.radious <span class="hljs-operator">=</span> radious<br>        &#125;<br>        <br>       <br>        <span class="hljs-keyword">var</span> area: <span class="hljs-type">Int</span> &#123;<br>            <span class="hljs-keyword">get</span> &#123;<br>                <span class="hljs-keyword">return</span> radious <span class="hljs-operator">*</span> radious<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看,超过三个之后，需要把所有的内容移至堆区开辟一块内存空间去存放，<code>ProtocolBox</code>第一个成员就变成了一块堆区的地址，它存放了那五个成员变量的值。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x00007ff7bfefebd0</span><br><span class="hljs-number">0x7ff7bfefebd0</span>: <span class="hljs-number">0x0000600001710140</span> <span class="hljs-number">0x00007ff7bfefebd0</span><br><span class="hljs-number">0x7ff7bfefebe0</span>: <span class="hljs-number">0x0000005002000000</span> <span class="hljs-number">0x0000000100015078</span><br><span class="hljs-number">0x7ff7bfefebf0</span>: <span class="hljs-number">0x00000001000150a0</span> <span class="hljs-number">0x00007ff7bfefec00</span><br><br>lldb) x<span class="hljs-operator">/</span>8xg <span class="hljs-number">0x0000600001710140</span><br><span class="hljs-number">0x600001710140</span>: <span class="hljs-number">0x0000000100014dd0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001710150</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000014</span><br><span class="hljs-number">0x600001710160</span>: <span class="hljs-number">0x000000000000001e</span> <span class="hljs-number">0x0000000000000028</span><br><span class="hljs-number">0x600001710170</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>闭包分析</title>
    <url>/2023/06/24/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/%E9%97%AD%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="闭包分析"><a href="#闭包分析" class="headerlink" title="闭包分析"></a>闭包分析</h1><h2 id="闭包的数据结构"><a href="#闭包的数据结构" class="headerlink" title="闭包的数据结构"></a>闭包的数据结构</h2><ul>
<li>把下面代码<code>block.swift</code>编译成<code>IR</code>,分析还原出闭包的数据结构<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>()</span> -&gt; () -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-keyword">let</span> increm <span class="hljs-operator">=</span> makeIncrementer()<br></code></pre></td></tr></table></figure></li>
<li><code>swiftc block.swift -emit-ir -o block.ll</code> 编译成<code>ir</code>文件</li>
</ul>
<h3 id="IR结构分析"><a href="#IR结构分析" class="headerlink" title="IR结构分析"></a>IR结构分析</h3><ul>
<li>主要的<code>main</code>函数<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define i32 <span class="hljs-keyword">@main</span>(i32 <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to i8<span class="hljs-operator">*</span><br><span class="hljs-comment">//返回值是个结构体 s5block15makeIncrementerSiycyF是调用的函数</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> call swiftcc &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; @<span class="hljs-string">&quot;$s5block15makeIncrementerSiycyF&quot;</span>()<br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> extractvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">3</span>, <span class="hljs-number">0</span> <span class="hljs-comment">//取第一个值i8*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> extractvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">3</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//取第二个值%swift.refcounted</span><br>  store i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, i8<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s5block6incremSiycvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), align <span class="hljs-number">8</span><br>  store <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s5block6incremSiycvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span>), align <span class="hljs-number">8</span><br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>查看混写函数<code>s5block15makeIncrementerSiycyF</code>的具体实现<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">xcrun swift<span class="hljs-operator">-</span>demangle s5block15makeIncrementerSiycyF<br><span class="hljs-variable">$s5block15makeIncrementerSiycyF</span> <span class="hljs-operator">---&gt;</span> block.makeIncrementer() -&gt; () -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="swift-refcounted"><a href="#swift-refcounted" class="headerlink" title="swift.refcounted"></a><code>swift.refcounted</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">%</span>swift.function <span class="hljs-operator">=</span> type &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125;<br><span class="hljs-operator">%</span>swift.refcounted <span class="hljs-operator">=</span> type &#123; <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>, i64 &#125;<br><span class="hljs-operator">%</span>swift.type <span class="hljs-operator">=</span> type &#123; i64 &#125;<br><span class="hljs-operator">%</span>swift.full_boxmetadata <span class="hljs-operator">=</span> type &#123; void (<span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span>, <span class="hljs-operator">%</span>swift.type, i32, i8<span class="hljs-operator">*</span> &#125;<br><span class="hljs-operator">%</span><span class="hljs-type">TSi</span> <span class="hljs-operator">=</span> type <span class="hljs-operator">&lt;</span>&#123; i64 &#125;<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>swift.refcounted</code>由<code>swift.type</code>和一个<code>64</code>位<code>int</code>组成,而<code>swift.type</code>是一个<code>i64</code>结构，因此<code>swift.refcounted</code>的结构是<code>&#123; i64,i64&#125;</code></li>
</ul>
<h3 id="初步数据结构"><a href="#初步数据结构" class="headerlink" title="初步数据结构"></a>初步数据结构</h3><blockquote>
<p>结合上面分析，初步得出闭包的最初的数据结构</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClosureData</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> unkown: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// i8*</span><br>    <span class="hljs-keyword">var</span> closureHeapObject: <span class="hljs-type">ClosureHeapObject</span> <span class="hljs-comment">// swift.refcounted</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClosureHeapObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> refcount1: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> refcount2: <span class="hljs-type">Int32</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>unkown</code>是第一个参数<code>i8</code>,<code>closureHeapObject</code>即<code>swift.refcounted</code>结构</li>
</ul>
<h4 id="闭包构建分析"><a href="#闭包构建分析" class="headerlink" title="闭包构建分析"></a>闭包构建分析</h4><blockquote>
<p>下面看下<code>s5block15makeIncrementerSiycyF</code>也就是<code>makeIncrementer</code>函数到底是怎么构造出返回的东西<code>&#123; i8*, %swift.refcounted* &#125;</code>的:</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define hidden swiftcc &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; @<span class="hljs-string">&quot;$s5block15makeIncrementerSiycyF&quot;</span>() #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span>runningTotal.debug <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">0</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">**</span> <span class="hljs-operator">%</span>runningTotal.debug to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.memset.p0i8.i64(i8<span class="hljs-operator">*</span> align <span class="hljs-number">8</span> <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8 <span class="hljs-number">0</span>, i64 <span class="hljs-number">8</span>, i1 <span class="hljs-literal">false</span>)<br><span class="hljs-comment">// %1堆空间的内存地址</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> call noalias <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-meta">@swift_allocObject</span>(<span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.full_boxmetadata, <span class="hljs-operator">%</span>swift.full_boxmetadata<span class="hljs-operator">*</span> <span class="hljs-meta">@metadata</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">2</span>), i64 <span class="hljs-number">24</span>, i64 <span class="hljs-number">7</span>) #<span class="hljs-number">1</span><br><span class="hljs-comment">// 做了一个指针类型的转换，相当于UnsafeBitcast</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, [<span class="hljs-number">8</span> x i8] &#125;<span class="hljs-operator">&gt;*</span><br><span class="hljs-comment">// 取出指向[8 x i8]的指针</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, [<span class="hljs-number">8</span> x i8] &#125;<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, [<span class="hljs-number">8</span> x i8] &#125;<span class="hljs-operator">&gt;*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br><span class="hljs-comment">// 把它转换成 %TSi* 类型  （%TSi* 其实是一个 type&lt;&#123; i64 &#125;&gt;   64位的结构体）</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> bitcast [<span class="hljs-number">8</span> x i8]<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span> to <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span><br><span class="hljs-comment">// 存储</span><br>  store <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">**</span> <span class="hljs-operator">%</span>runningTotal.debug, align <span class="hljs-number">8</span><br><span class="hljs-comment">//取出%4也就是%TSi* 类型的地址,赋值给._value</span><br>  <span class="hljs-operator">%</span>._value <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span><span class="hljs-type">TSi</span>, <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br><span class="hljs-comment">// 把10这个值放到%._value地址偏移`8字节`的内存空间里，也就是type&lt;&#123; i64 &#125;&gt;(即swift.refcounted,是它的首地址内容)，往下偏移8字节存放内容</span><br>  store i64 <span class="hljs-number">10</span>, i64<span class="hljs-operator">*</span> <span class="hljs-operator">%</span>._value, align <span class="hljs-number">8</span><br><span class="hljs-comment">// 将func里的内嵌闭包地址转换成 void * 插入到 &#123; i8*, %swift.refcounted* &#125; 的第一个元素是函数地址，第二个元素是%1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> insertvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; &#123; i8<span class="hljs-operator">*</span> bitcast (i64 (<span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s5block15makeIncrementerSiycyF11incrementerL_SiyFTA&quot;</span> to i8<span class="hljs-operator">*</span>), <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> undef &#125;, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>  ret &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">5</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="最终数据结构"><a href="#最终数据结构" class="headerlink" title="最终数据结构"></a>最终数据结构</h3><blockquote>
<p>根据上面的<code>IR</code>代码，还原出 <code>ClosureData</code> 的数据结构为：，<code>box</code>是一个在堆里面的实例对象，存放捕获的值，如果捕获的值会变，则还会创建一个堆对象，用来存放该值，赋值给<code>box</code>作为实例属性；不变则直接赋予值作为<code>box</code>作为实例属性。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClosureData</span>&lt;<span class="hljs-title">Box</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> ptr: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 闭包函数地址地址</span><br>    <span class="hljs-keyword">var</span> box: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Box</span>&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> object: <span class="hljs-type">HeapObject</span> <span class="hljs-comment">// 实例对象的内存地址</span><br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">T</span>  <span class="hljs-comment">//存的捕获的值</span><br>&#125;<br><br><span class="hljs-comment">///实例对象的内存地址</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> refcount1: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> refcount2: <span class="hljs-type">Int32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>ClosureData</code> 的数据结构 = <code>闭包的执行地址</code> + <code>捕获变量堆空间的地址</code></li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>()</span> -&gt; ()-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NoMeanStruct</span></span>&#123;<br>    <span class="hljs-keyword">var</span> closure: () -&gt; <span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> closure <span class="hljs-operator">=</span> <span class="hljs-type">NoMeanStruct</span>(closure: makeIncrementer())<br><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">NoMeanStruct</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>ptr.initialize(to: closure)<br><br><span class="hljs-comment">// 内存绑定</span><br><span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>)&#123; <span class="hljs-variable">$0</span>.pointee &#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭包地址: <span class="hljs-subst">\(closure_ptr.ptr)</span>&quot;</span>) <span class="hljs-comment">//闭包地址: 0x000000010000e100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例对象的内存地址: <span class="hljs-subst">\(closure_ptr.box)</span>&quot;</span>) <span class="hljs-comment">//实例对象的内存地址: 0x0000600000218340</span><br><br><span class="hljs-built_in">print</span>(closure_ptr.box.pointee.value) <span class="hljs-comment">//10 ,也就是0x600000218350上的值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br>ptr.deinitialize(count: <span class="hljs-number">1</span>)<br>ptr.deallocate()<br></code></pre></td></tr></table></figure>

<ul>
<li>断点查看实例对象的内存情况<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>4xg <span class="hljs-number">0x0000600000218340</span><br>                <span class="hljs-comment">// metadata.       // refcount</span><br><span class="hljs-number">0x600000218340</span>: <span class="hljs-number">0x0000000100010cf8</span> <span class="hljs-number">0x0000000200000003</span><br>                <span class="hljs-comment">//value</span><br><span class="hljs-number">0x600000218350</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li>输出的闭包地址<code>0x000000010000e100</code>一定能在<code>Mach-O</code>上面找到，所以可以使用下面的命令查找起来，可以证明输出的地址就是闭包地址：<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">$ nm <span class="hljs-operator">-</span>p <span class="hljs-type">SwiftSource</span> <span class="hljs-operator">|</span> grep <span class="hljs-number">000000010000e100</span><br>    <span class="hljs-number">000000010000e100</span> t  <span class="hljs-keyword">_</span><span class="hljs-variable">$s11SwiftSource15makeIncrementerL_SiycyF11incrementerL_SiyFTA</span><br>$ xcrun swift<span class="hljs-operator">-</span>demangle s11SwiftSource15makeIncrementerL_SiycyF11incrementerL_SiyFTA<br><br>    <span class="hljs-variable">$s11SwiftSource15makeIncrementerL_SiycyF11incrementerL_SiyFTA</span> <span class="hljs-operator">---&gt;</span> partial apply forwarder <span class="hljs-keyword">for</span> incrementer #<span class="hljs-number">1</span> () -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> makeIncrementer #<span class="hljs-number">1</span> () -&gt; () -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> <span class="hljs-type">SwiftSource</span><br></code></pre></td></tr></table></figure>
<h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h3><blockquote>
<p>如果<code>makeIncrementer</code>有参数呢？那么<code>Box</code>的数据结构就变了。但和单个参数时的<code>box</code>相似，如果是可变的，生成堆对象，赋予<code>box</code>，不可变的值直接赋予<code>box</code>作为值，</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Int</span>)</span> -&gt; ()-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> amount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>改变后的<code>Box</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> object: <span class="hljs-type">HeapObject</span>  <span class="hljs-comment">// 把value1、value2统一当成object的属性</span><br>    <span class="hljs-keyword">var</span> value1: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">T1</span>&gt;<br>    <span class="hljs-keyword">var</span> value2: <span class="hljs-type">T2</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> funcStruct <span class="hljs-operator">=</span> <span class="hljs-type">NoMeanStruct</span>(closure: makeIncrementer(<span class="hljs-number">20</span>))<br><span class="hljs-keyword">let</span> func_ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">NoMeanStruct</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>func_ptr.initialize(to: funcStruct)<br><br><span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> func_ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable">$0</span>.pointee &#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭包地址：<span class="hljs-subst">\(closure_ptr.ptr)</span>&quot;</span>) <span class="hljs-comment">// 闭包地址：0x0000000100011eb0</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例对象的内存地址: <span class="hljs-subst">\(closure_ptr.box)</span>&quot;</span>) <span class="hljs-comment">// 实例对象的内存地址: 0x00006000002084a0</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;捕获的地址：<span class="hljs-subst">\(closure_ptr.box.pointee.value1)</span>&quot;</span>) <span class="hljs-comment">// 捕获的地址：0x00006000002080a0 // 也就是0x6000002084b0上的值</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;参数的值：<span class="hljs-subst">\(closure_ptr.box.pointee.value2)</span>&quot;</span>) <span class="hljs-comment">// 参数的值：20 0x6000002084b8</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br>func_ptr.deinitialize(count: <span class="hljs-number">1</span>)<br>func_ptr.deallocate()<br></code></pre></td></tr></table></figure>
<ul>
<li>断点查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>8xg <span class="hljs-number">0x00006000002084a0</span><br>         <span class="hljs-comment">// metadata.       // refcount</span><br><span class="hljs-number">0x6000002084a0</span>: <span class="hljs-number">0x0000000100014e08</span> <span class="hljs-number">0x0000000200000003</span><br>        <span class="hljs-comment">// value</span><br><span class="hljs-number">0x6000002084b0</span>: <span class="hljs-number">0x00006000002080a0</span> <span class="hljs-number">0x0000000000000014</span><br><span class="hljs-number">0x6000002084c0</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x00007ff8540dd570</span><br><span class="hljs-number">0x6000002084d0</span>: <span class="hljs-number">0x00007ff8540dd718</span> <span class="hljs-number">0x0000000000000000</span><br><br>(lldb) x<span class="hljs-operator">/</span>8xg <span class="hljs-number">0x00006000002080a0</span><br>    <span class="hljs-comment">// metadata.       // refcount</span><br><span class="hljs-number">0x6000002080a0</span>: <span class="hljs-number">0x0000000100014de0</span> <span class="hljs-number">0x0000000000000003</span><br>    <span class="hljs-comment">// value 存的10</span><br><span class="hljs-number">0x6000002080b0</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000002080c0</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x00007ffb1ec507f8</span><br><span class="hljs-number">0x6000002080d0</span>: <span class="hljs-number">0x00007ff810ba46a8</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="闭包栈上的值，和包内值"><a href="#闭包栈上的值，和包内值" class="headerlink" title="闭包栈上的值，和包内值"></a>闭包栈上的值，和包内值</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> normalNum <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br><span class="hljs-keyword">let</span> runningPtr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>runningTotal) &#123; <span class="hljs-variable">$0</span> &#125;<br><span class="hljs-keyword">let</span> normalNumPtr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>normalNum) &#123; <span class="hljs-variable">$0</span> &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;runningPtr==&quot;</span>,runningPtr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;normalNumPtr==&quot;</span>,normalNumPtr)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Int</span>)</span> -&gt; ()-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <br>        runningTotal <span class="hljs-operator">+=</span> amount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NoMeanStruct</span></span>&#123;<br>    <span class="hljs-keyword">var</span> closure: () -&gt; <span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-keyword">let</span> funcStruct <span class="hljs-operator">=</span> <span class="hljs-type">NoMeanStruct</span>(closure: makeIncrementer(<span class="hljs-number">20</span>))<br><span class="hljs-keyword">let</span> func_ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">NoMeanStruct</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>func_ptr.initialize(to: funcStruct)<br><span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> func_ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Box1</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable">$0</span>.pointee &#125;<br>funcStruct.closure()<br>funcStruct.closure()<br><span class="hljs-keyword">let</span> runningPtr2 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>runningTotal) &#123; <span class="hljs-variable">$0</span> &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;runningPtr2==&quot;</span>,runningPtr2)<br><span class="hljs-keyword">let</span> normalNumPtr2 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>normalNum) &#123; <span class="hljs-variable">$0</span> &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;normalNumPtr2==&quot;</span>,normalNumPtr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭包地址：<span class="hljs-subst">\(closure_ptr.ptr)</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例对象的内存地址: <span class="hljs-subst">\(closure_ptr.box)</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;捕获的地址：<span class="hljs-subst">\(closure_ptr.box.pointee.value1)</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;参数的值：<span class="hljs-subst">\(closure_ptr.box.pointee.value2)</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br>func_ptr.deinitialize(count: <span class="hljs-number">1</span>)<br>func_ptr.deallocate()<br></code></pre></td></tr></table></figure>

<h4 id="输出日志，断点查看"><a href="#输出日志，断点查看" class="headerlink" title="输出日志，断点查看"></a>输出日志，断点查看</h4><ul>
<li>查看发现，将于被必包捕获的值，一开始初始化就在堆上，非栈上，而在捕获的时候再拷贝到堆中，这和<code>OC</code>中有所不同。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs swfit">// 输出地址<br>// 明显查看到，还未捕获的时候，正常的栈空间地址0x00007ff7bb0ad9c8，而runningPtr显然已开始就在堆区<br>runningPtr== 0x00006000002345d0<br>normalNumPtr== 0x00007ff7bb0ad9c8<br><br><br>// 查看后16字节的内存<br>(lldb) x/4xg 0x00006000002345c0<br>0x6000002345c0: 0x0000000104e72b60 0x0000000000000003<br>0x6000002345d0: 0x000000000000000a 0x0000000000000000<br>// 正常栈内存地址<br>(lldb) x/4xg 0x00007ff7bb0ad9c8<br>0x7ff7bb0ad9c8: 0x000000000000000c 0x00006000002345d0<br>0x7ff7bb0ad9d8: 0x0000000107c06fc0 0x00007ff85c65174f<br><br>// 执行funcStruct.closure()后的输出日志<br><br>runningPtr2== 0x00006000002345d0<br>normalNumPtr2== 0x00007ff7bb0ad9c8<br>闭包地址：0x0000000104e61220<br>实例对象的内存地址: 0x000060000022b4e0<br>捕获的地址：0x00006000002345c0<br>参数的值：20<br><br>// 必报实例对象的内存地址<br>(lldb) x/8xg 0x000060000022b4e0<br>0x60000022b4e0: 0x0000000104e730c8 0x0000000200000003<br>0x60000022b4f0: 0x00006000002345c0 0x0000000000000014<br>0x60000022b500: 0x0000000000000000 0x0000000000000000<br>0x60000022b510: 0x0000000000000000 0x0000000000000000<br><br>// 0x00006000002345c0显然和未捕获runningPtr是同一地址<br>(lldb) x/6xg 0x00006000002345c0<br>0x6000002345c0: 0x0000000104e72b60 0x0000000200000003<br>0x6000002345d0: 0x0000000000000032 0x0000000000000000<br>0x6000002345e0: 0x0000beadde8e45e0 0x000000000000004b<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="OC中Block捕获值"><a href="#OC中Block捕获值" class="headerlink" title="OC中Block捕获值"></a>OC中Block捕获值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__block int64_t runningTotal = <span class="hljs-number">10</span>;<br>int64_t normalNum = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---runningTotal:_%p,normalNum_%p&quot;</span>,&amp;runningTotal,&amp;normalNum);<br>dispatch_block_t blcok = [^&#123;<br>    runningTotal += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---runningTotal:_%p,normalNum_%p&quot;</span>,&amp;runningTotal,&amp;normalNum);<br>&#125; <span class="hljs-keyword">copy</span>];<br><br><br>runningTotal += <span class="hljs-number">20</span>;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---runningTotal:_%p,normalNum_%p&quot;</span>,&amp;runningTotal,&amp;normalNum);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------&quot;</span>);<br><br>blcok();<br></code></pre></td></tr></table></figure>

<h4 id="输出日志，断点查看-1"><a href="#输出日志，断点查看-1" class="headerlink" title="输出日志，断点查看"></a>输出日志，断点查看</h4><ul>
<li>查看发现，一开始被<code>__blcok</code>修饰的<code>runningTotal</code>是再栈上的。只有当被捕获时，才会被包装成<code>_block</code>结构的对象，是动态构建的，这与闭包不同。此外，不被修改的<code>normalNum</code>和被捕获的值是不同地址的。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">---runningTotal:_0x7ff7bf2e39b8,normalNum_0x7ff7bf2e3998<br>---runningTotal:_0x600000234178,normalNum_0x7ff7bf2e3998<br>---------<br>---runningTotal:_0x600000234178,<span class="hljs-built_in">normalNum_0x600000c5ac98</span><br><br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x7ff7bf2e39b8</span><br><span class="hljs-number">0x7ff7bf2e39b8</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000100c36fce</span><br><br><br><br><span class="hljs-comment">// normalNum的地址，往后3字节</span><br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x600000c5ac80</span><br><span class="hljs-comment">// __block_impl     、 __main_block_desc_0</span><br><span class="hljs-number">0x600000c5ac80</span>: <span class="hljs-number">0x0000000100c1b1e0</span> <span class="hljs-number">0x0000000100c3c718</span><br><span class="hljs-number">0x600000c5ac90</span>: <span class="hljs-number">0x0000600000234160</span> <span class="hljs-number">0x000000000000000c</span><br><br><span class="hljs-comment">//  0x0000600000234160这是包装了runningTotal的地址</span><br>(lldb) x/<span class="hljs-number">6</span>xg <span class="hljs-number">0x0000600000234160</span><br>                                <span class="hljs-comment">// 即__forwarding指针</span><br><span class="hljs-number">0x600000234160</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000600000234160</span><br>                            <span class="hljs-comment">//  实际 runningTotal的值</span><br><span class="hljs-number">0x600000234170</span>: <span class="hljs-number">0x0000002021000004</span> <span class="hljs-number">0x000000000000001f</span><br><span class="hljs-number">0x600000234180</span>: <span class="hljs-number">0x0000000da0080001</span> <span class="hljs-number">0x00007ff868abb5d0</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>IR语法</title>
    <url>/2023/06/20/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/IR%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IR语法"><a href="#IR语法" class="headerlink" title="IR语法"></a>IR语法</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">[<span class="hljs-operator">&lt;</span>elementnumber<span class="hljs-operator">&gt;</span> x <span class="hljs-operator">&lt;</span>elementtype<span class="hljs-operator">&gt;</span>]   <span class="hljs-comment">// 元素个数 x 元素类型</span><br><br><span class="hljs-comment">//example:</span><br>alloca [<span class="hljs-number">24</span> x i8], align <span class="hljs-number">8</span>      <span class="hljs-number">24</span>个i8都是<span class="hljs-number">0</span> <br><br>alloca [<span class="hljs-number">4</span> x i32] <span class="hljs-operator">===</span> array<br></code></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">%</span>swift.refcounted <span class="hljs-operator">=</span> type &#123; <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>, i64 &#125;<br><br><span class="hljs-comment">//example:</span><br><span class="hljs-operator">%</span><span class="hljs-type">T</span> <span class="hljs-operator">=</span> type &#123;<span class="hljs-operator">&lt;</span>type list<span class="hljs-operator">&gt;</span>&#125; <span class="hljs-comment">//这种和C语言的结构体类似</span><br></code></pre></td></tr></table></figure>

<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&lt;</span>type<span class="hljs-operator">&gt;</span> <span class="hljs-operator">*</span><br><br><span class="hljs-comment">//example:</span><br>i64<span class="hljs-operator">*</span> <span class="hljs-comment">//64位的整形</span><br></code></pre></td></tr></table></figure>

<h2 id="getelementptr-指令"><a href="#getelementptr-指令" class="headerlink" title="getelementptr 指令"></a><code>getelementptr</code> 指令</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">munger_struct</span> </span>&#123;<br>  int f1;<br>  int f2;<br>&#125;;<br><br>void munge(<span class="hljs-keyword">struct</span> munger_struct <span class="hljs-operator">*</span><span class="hljs-type">P</span>) &#123;<br>  <span class="hljs-type">P</span>[<span class="hljs-number">0</span>].f1 <span class="hljs-operator">=</span> <span class="hljs-type">P</span>[<span class="hljs-number">1</span>].f1 <span class="hljs-operator">+</span> <span class="hljs-type">P</span>[<span class="hljs-number">2</span>].f2;<br>&#125;<br><br><span class="hljs-comment">// 取出结构体首地址</span><br>getelementptr inbounds <span class="hljs-operator">%</span><span class="hljs-keyword">struct</span>.munger_struct, <span class="hljs-operator">%</span><span class="hljs-keyword">struct</span>.munger_struct <span class="hljs-operator">%</span><span class="hljs-number">1</span>, i64 <span class="hljs-number">0</span> <br><br><span class="hljs-comment">// 1.取出结构体首地址，2.然后取出结构体第一个元素</span><br>getelementptr inbounds <span class="hljs-operator">%</span><span class="hljs-keyword">struct</span>.munger_struct, <span class="hljs-operator">%</span><span class="hljs-keyword">struct</span>.munger_struct <span class="hljs-operator">%</span><span class="hljs-number">1</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 下面是一个案例：</span><br>int main(int argc, const char <span class="hljs-operator">*</span> argv[]) &#123;<br>    int array[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    int a <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>其中 int a <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>] 这句对应的<span class="hljs-type">LLVM代码应该是这样的：</span><br>a <span class="hljs-operator">=</span> getelementptr inbounds [<span class="hljs-number">4</span> x i32], [<span class="hljs-number">4</span> x i32]<span class="hljs-operator">*</span> array, i64 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>TargetFunctionTypeMetadata</title>
    <url>/2023/06/18/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/TargetFunctionTypeMetadata/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><blockquote>
<p>函数本身也有自己的类型，它由形参类型和返回类型组成。<br>引用类型，其指向的地址第一个<code>8</code>字节存储的是函数类型的<code>metadata</code></p>
</blockquote>
<h2 id="TargetFunctionTypeMetadata"><a href="#TargetFunctionTypeMetadata" class="headerlink" title="TargetFunctionTypeMetadata"></a><code>TargetFunctionTypeMetadata</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of function type metadata.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetFunctionTypeMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br>  <span class="hljs-keyword">using</span> Parameter = ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt;;<br><br><span class="hljs-comment">//标识了函数的类型</span><br>  TargetFunctionTypeFlags&lt;StoredSize&gt; Flags;<br><br>  <span class="hljs-comment">/// The type metadata for the result type.</span><br>  ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt; ResultType;<br><br>  <span class="hljs-function">Parameter *<span class="hljs-title">getParameters</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;Parameter *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>); &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> Parameter *<span class="hljs-title">getParameters</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Parameter *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-function">Parameter <span class="hljs-title">getParameter</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(index &lt; <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getParameters</span>()[index];<br>  &#125;<br><br>  <span class="hljs-function">ParameterFlags <span class="hljs-title">getParameterFlags</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(index &lt; <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">auto</span> flags = <span class="hljs-built_in">hasParameterFlags</span>() ? <span class="hljs-built_in">getParameterFlags</span>()[index] : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ParameterFlags::<span class="hljs-built_in">fromIntValue</span>(flags);<br>  &#125;<br><br>  <span class="hljs-function">StoredSize <span class="hljs-title">getNumParameters</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getNumParameters</span>();<br>  &#125;<br>  <span class="hljs-function">FunctionMetadataConvention <span class="hljs-title">getConvention</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getConvention</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAsync</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isAsync</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isThrowing</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isThrowing</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSendable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isSendable</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDifferentiable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isDifferentiable</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasParameterFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasParameterFlags</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEscaping</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isEscaping</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasGlobalActor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasGlobalActor</span>(); &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> StoredSize OffsetToFlags = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TargetMetadata&lt;Runtime&gt;);<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Function;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> *<span class="hljs-title">getParameterFlags</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(<span class="hljs-built_in">getParameters</span>() + <span class="hljs-built_in">getNumParameters</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *<span class="hljs-title">getParameterFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *&gt;(<span class="hljs-built_in">getParameters</span>() +<br>                                              <span class="hljs-built_in">getNumParameters</span>());<br>  &#125;<br><br>  <span class="hljs-function">TargetFunctionMetadataDifferentiabilityKind&lt;StoredSize&gt; *</span><br><span class="hljs-function">  <span class="hljs-title">getDifferentiabilityKindAddress</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isDifferentiable</span>());<br>    <span class="hljs-keyword">void</span> *previousEndAddr = <span class="hljs-built_in">hasParameterFlags</span>()<br>        ? <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getParameterFlags</span>() + <span class="hljs-built_in">getNumParameters</span>())<br>        : <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getParameters</span>() + <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<br>        TargetFunctionMetadataDifferentiabilityKind&lt;StoredSize&gt; *&gt;(<br>        llvm::<span class="hljs-built_in">alignAddr</span>(previousEndAddr,<br>                        llvm::<span class="hljs-built_in">Align</span>(<span class="hljs-built_in"><span class="hljs-keyword">alignof</span></span>(<span class="hljs-keyword">typename</span> Runtime::StoredPointer))));<br>  &#125;<br><br>  <span class="hljs-function">TargetFunctionMetadataDifferentiabilityKind&lt;StoredSize&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getDifferentiabilityKind</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDifferentiable</span>()) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">const_cast</span>&lt;TargetFunctionTypeMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>          -&gt;<span class="hljs-built_in">getDifferentiabilityKindAddress</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> TargetFunctionMetadataDifferentiabilityKind&lt;StoredSize&gt;<br>        ::NonDifferentiable;<br>  &#125;<br><br>  <span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt; *</span><br><span class="hljs-function">  <span class="hljs-title">getGlobalActorAddr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasGlobalActor</span>());<br>    <br>    <span class="hljs-keyword">void</span> *endAddr =<br>        <span class="hljs-built_in">isDifferentiable</span>()<br>          ? <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getDifferentiabilityKindAddress</span>() + <span class="hljs-number">1</span>) :<br>        <span class="hljs-built_in">hasParameterFlags</span>()<br>          ? <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getParameterFlags</span>() + <span class="hljs-built_in">getNumParameters</span>()) :<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getParameters</span>() + <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<br>        ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt; *&gt;(<br>          llvm::<span class="hljs-built_in">alignAddr</span>(<br>              endAddr, llvm::<span class="hljs-built_in">Align</span>(<span class="hljs-built_in"><span class="hljs-keyword">alignof</span></span>(<span class="hljs-keyword">typename</span> Runtime::StoredPointer))));<br>  &#125;<br><br>  <span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getGlobalActor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">hasGlobalActor</span>())<br>      <span class="hljs-keyword">return</span> ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt;();<br><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">const_cast</span>&lt;TargetFunctionTypeMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>      -&gt;<span class="hljs-built_in">getGlobalActorAddr</span>();<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> FunctionTypeMetadata = TargetFunctionTypeMetadata&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>
<ol>
<li><code>TargetFunctionTypeMetadata</code>继承自<code>TargetMetadata</code>说明它拥有<code>Kind</code>属性</li>
<li><code>TargetFunctionTypeFlags&lt;StoredSize&gt; Flags;</code>，作用是标识了函数的类型,具体类型如下 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// Flags in a function type metadata record.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> int_type&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetFunctionTypeFlags</span> &#123;</span><br>  <span class="hljs-comment">// If we were ever to run out of space for function flags (8 bits)</span><br>  <span class="hljs-comment">// one of the flag bits could be used to identify that the rest of</span><br>  <span class="hljs-comment">// the flags is going to be stored somewhere else in the metadata.</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> :</span> int_type &#123;<br>    NumParametersMask      = <span class="hljs-number">0x0000FFFF</span>U,<br>    ConventionMask         = <span class="hljs-number">0x00FF0000</span>U,<br>    ConventionShift        = <span class="hljs-number">16U</span>,<br>    ThrowsMask             = <span class="hljs-number">0x01000000</span>U,<br>    ParamFlagsMask         = <span class="hljs-number">0x02000000</span>U,<br>    EscapingMask           = <span class="hljs-number">0x04000000</span>U,<br>    DifferentiableMask     = <span class="hljs-number">0x08000000</span>U,<br>    GlobalActorMask        = <span class="hljs-number">0x10000000</span>U,<br>    AsyncMask              = <span class="hljs-number">0x20000000</span>U,<br>    SendableMask           = <span class="hljs-number">0x40000000</span>U,<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The next bit will need to introduce a separate flags word.</span><br>  &#125;;<br>  int_type Data;<br></code></pre></td></tr></table></figure></li>
<li><code>ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt; ResultType;</code>是返回值类型</li>
<li>实际上<code>TargetFunctionTypeMetadata</code>还拥有一个参数列表，它其实是一个连续的内存空间 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <span class="hljs-function">Parameter *<span class="hljs-title">getParameters</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;Parameter *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>); &#125;<br><span class="hljs-function"><span class="hljs-keyword">const</span> Parameter *<span class="hljs-title">getParameters</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Parameter *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>  <span class="hljs-function">Parameter <span class="hljs-title">getParameter</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(index &lt; <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getParameters</span>()[index];<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="TargetFunctionTypeMetadata数据结构"><a href="#TargetFunctionTypeMetadata数据结构" class="headerlink" title="TargetFunctionTypeMetadata数据结构"></a><code>TargetFunctionTypeMetadata</code>数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetFunctionTypeMetadata</span></span>&#123;<br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <span class="hljs-comment">// isa</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">Int</span> <span class="hljs-comment">//函数的类型</span><br>    <span class="hljs-keyword">var</span> resultType: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 返回值类型</span><br>    <span class="hljs-keyword">var</span> arguments: <span class="hljs-type">ArgumentsBuffer</span>&lt;<span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>&gt; <span class="hljs-comment">// 参数类型列表</span><br>    <span class="hljs-comment">// 获取参数个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberArguments</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x0000FFFF</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArgumentsBuffer</span>&lt;<span class="hljs-title">Element</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> element: <span class="hljs-type">Element</span><br><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buffer</span>(<span class="hljs-params">n</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeBufferPointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span>.withMemoryRebound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; start <span class="hljs-keyword">in</span><br>                <span class="hljs-keyword">return</span> start<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeBufferPointer</span>(start: ptr, count: n)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span>(<span class="hljs-params">of</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating: <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>).assumingMemoryBound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>).advanced(by: i))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>获取参数的个数，实际会调用<code>Flags</code>属性的<code>Flags.getNumParameters()</code>方法,<code>NumParametersMask</code>为<code>0x0000FFFFU</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">getNumParameters</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Data &amp; NumParametersMask; &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="验证TargetFunctionTypeMetadata数据结构"><a href="#验证TargetFunctionTypeMetadata数据结构" class="headerlink" title="验证TargetFunctionTypeMetadata数据结构"></a>验证<code>TargetFunctionTypeMetadata</code>数据结构</h2><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swift_add</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">a</span>: <span class="hljs-type">Double</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">b</span>: <span class="hljs-type">Double</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Int</span>(a <span class="hljs-operator">+</span> b)<br>&#125;<br><br><span class="hljs-keyword">let</span> functionType <span class="hljs-operator">=</span> <span class="hljs-built_in">type</span>(of: swift_add)<br><span class="hljs-keyword">let</span> functionPointer <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(functionType <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetFunctionTypeMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br><span class="hljs-comment">//参数的数量</span><br><span class="hljs-built_in">print</span>(functionPointer.pointee.numberArguments())<span class="hljs-comment">//2</span><br><span class="hljs-comment">//第一个参数的类型</span><br><span class="hljs-built_in">print</span>(functionPointer.pointee.arguments.index(of: <span class="hljs-number">0</span>).pointee) <span class="hljs-comment">// Double</span><br><span class="hljs-comment">//函数的返回结果类型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">unsafeBitCast</span>(functionPointer.pointee.resultType, to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>)) <span class="hljs-comment">// Int</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>TargetEnumMetadata</title>
    <url>/2023/06/14/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/TargetEnumMetadata/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="TargetEnumMetadata"><a href="#TargetEnumMetadata" class="headerlink" title="TargetEnumMetadata"></a><code>TargetEnumMetadata</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of type metadata for enums.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetEnumMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetValueMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br>  <span class="hljs-keyword">using</span> TargetValueMetadata&lt;Runtime&gt;::TargetValueMetadata;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetEnumDescriptor&lt;Runtime&gt; *<span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> llvm::cast&lt;TargetEnumDescriptor&lt;Runtime&gt;&gt;(<span class="hljs-keyword">this</span>-&gt;Description);<br>  &#125;<br><br>  <span class="hljs-comment">// The first trailing field of enum metadata is always the generic</span><br>  <span class="hljs-comment">// argument array.</span><br><br>  <span class="hljs-comment">/// True if the metadata records the size of the payload area.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPayloadSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">hasPayloadSizeOffset</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the size of the payload area.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// `hasPayloadSize` must be true for this to be valid.</span><br>  <span class="hljs-function">StoredSize <span class="hljs-title">getPayloadSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasPayloadSize</span>());<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">getPayloadSizeOffset</span>();<br>    <span class="hljs-keyword">const</span> StoredSize *asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> StoredSize *&gt;(<span class="hljs-keyword">this</span>);<br>    asWords += offset;<br>    <span class="hljs-keyword">return</span> *asWords;<br>  &#125;<br><br>  <span class="hljs-function">StoredSize &amp;<span class="hljs-title">getPayloadSize</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasPayloadSize</span>());<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">getPayloadSizeOffset</span>();<br>    StoredSize *asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;StoredSize *&gt;(<span class="hljs-keyword">this</span>);<br>    asWords += offset;<br>    <span class="hljs-keyword">return</span> *asWords;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span> *trailingFlags = <span class="hljs-built_in">getTrailingFlags</span>();<br>    <span class="hljs-keyword">if</span> (trailingFlags == <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> trailingFlags-&gt;<span class="hljs-built_in">isStaticSpecialization</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCanonicalStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span> *trailingFlags = <span class="hljs-built_in">getTrailingFlags</span>();<br>    <span class="hljs-keyword">if</span> (trailingFlags == <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> trailingFlags-&gt;<span class="hljs-built_in">isCanonicalStaticSpecialization</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> MetadataTrailingFlags *<span class="hljs-title">getTrailingFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">auto</span> flags = description-&gt;<span class="hljs-built_in">getFullGenericContextHeader</span>()<br>                     .DefaultInstantiationPattern-&gt;PatternFlags;<br>    <span class="hljs-keyword">if</span> (!flags.<span class="hljs-built_in">hasTrailingFlags</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> offset =<br>        <span class="hljs-built_in">getGenericArgumentOffset</span>() +<br>        description-&gt;<span class="hljs-built_in">getFullGenericContextHeader</span>().Base.<span class="hljs-built_in">getNumArguments</span>() +<br>        (<span class="hljs-built_in">hasPayloadSize</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> *&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> MetadataTrailingFlags *&gt;(asWords + offset);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">getGenericArgumentOffset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TargetEnumMetadata&lt;Runtime&gt;) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StoredPointer);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Enum<br>      || metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Optional;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> EnumMetadata = TargetEnumMetadata&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>TargetEnumMetadata</code>中没有成员变量， 其继承自<code>TargetValueMetadata</code>,该结构在<code>TargetStructMetadata分析</code>中已经介绍过了,而<code>TargetValueMetadata</code>继承<code>TargetMetadata</code>。因此<code>TargetEnumMetadata</code>数据结构体为：</li>
</ul>
<h3 id="TargetEnumMetadata数据结构"><a href="#TargetEnumMetadata数据结构" class="headerlink" title="TargetEnumMetadata数据结构"></a><code>TargetEnumMetadata</code>数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 枚举Metadata</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetEnumMetadata</span> </span>&#123;<br>    <span class="hljs-comment">//TargetValueMetadata</span><br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span><br>    <span class="hljs-comment">//TargetValueMetadata,根据不同的kind有不同的Descriptor</span><br>    <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetEnumDescriptor</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TargetEnumDescriptor"><a href="#TargetEnumDescriptor" class="headerlink" title="TargetEnumDescriptor"></a><code>TargetEnumDescriptor</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetEnumDescriptor</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">    :</span> <span class="hljs-keyword">public</span> TargetValueTypeDescriptor&lt;Runtime&gt;,<br>      <span class="hljs-keyword">public</span> TrailingGenericContextObjects&lt;TargetEnumDescriptor&lt;Runtime&gt;,<br>                            TargetTypeGenericContextDescriptorHeader,<br>                            <span class="hljs-comment">/*additional trailing objects*/</span><br>                            TargetForeignMetadataInitialization&lt;Runtime&gt;,<br>                            TargetSingletonMetadataInitialization&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasListCount&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasListEntry&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasCachingOnceToken&lt;Runtime&gt;&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> SingletonMetadataInitialization =<br>    TargetSingletonMetadataInitialization&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> ForeignMetadataInitialization =<br>    TargetForeignMetadataInitialization&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> Metadata =<br>    TargetRelativeDirectPointer&lt;Runtime, TargetMetadata&lt;Runtime&gt;, <span class="hljs-comment">/*Nullable*/</span> <span class="hljs-literal">false</span>&gt;;<br>  <span class="hljs-keyword">using</span> MetadataListCount =<br>    TargetCanonicalSpecializedMetadatasListCount&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> MetadataListEntry =<br>    TargetCanonicalSpecializedMetadatasListEntry&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> MetadataCachingOnceToken =<br>      TargetCanonicalSpecializedMetadatasCachingOnceToken&lt;Runtime&gt;;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects =<br>    swift::TrailingGenericContextObjects&lt;TargetEnumDescriptor&lt;Runtime&gt;,<br>                                        TargetTypeGenericContextDescriptorHeader,<br>                                        ForeignMetadataInitialization,<br>                                        SingletonMetadataInitialization,<br>                                        MetadataListCount,<br>                                        MetadataListEntry, <br>                                        MetadataCachingOnceToken&gt;;<br><br>  <span class="hljs-keyword">using</span> TrailingObjects =<br>    <span class="hljs-keyword">typename</span> TrailingGenericContextObjects::TrailingObjects;<br>  <span class="hljs-keyword">friend</span> TrailingObjects;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">using</span> OverloadToken = <span class="hljs-keyword">typename</span> TrailingObjects::<span class="hljs-keyword">template</span> OverloadToken&lt;T&gt;;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::numTrailingObjects;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;ForeignMetadataInitialization&gt;)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasForeignMetadataInitialization</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;SingletonMetadataInitialization&gt;)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasSingletonMetadataInitialization</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataListCount&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ?<br>      <span class="hljs-number">1</span><br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataListEntry&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ?<br>      <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListCount&gt;()-&gt;count<br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataCachingOnceToken&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericContext;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericContextHeader;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getFullGenericContextHeader;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericParams;<br><br>  <span class="hljs-comment">/// The number of non-empty cases in the enum are in the low 24 bits;</span><br>  <span class="hljs-comment">/// the offset of the payload size in the metadata record in words,</span><br>  <span class="hljs-comment">/// if any, is stored in the high 8 bits.</span><br>  <span class="hljs-comment">//有关联值枚举的数量</span><br>  <span class="hljs-keyword">uint32_t</span> NumPayloadCasesAndPayloadSizeOffset;<br><br>  <span class="hljs-comment">/// The number of empty cases in the enum.</span><br>  <span class="hljs-comment">/// 没有关联值枚举的数量</span><br>  <span class="hljs-keyword">uint32_t</span> NumEmptyCases;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">getNumPayloadCases</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> NumPayloadCasesAndPayloadSizeOffset &amp; <span class="hljs-number">0x00FFFFFF</span>U;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">getNumEmptyCases</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> NumEmptyCases;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">getNumCases</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getNumPayloadCases</span>() + NumEmptyCases;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">getPayloadSizeOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((NumPayloadCasesAndPayloadSizeOffset &amp; <span class="hljs-number">0xFF000000</span>U) &gt;&gt; <span class="hljs-number">24</span>);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPayloadSizeOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getPayloadSizeOffset</span>() != <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">getGenericArgumentOffset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TargetEnumMetadata&lt;Runtime&gt;::<span class="hljs-built_in">getGenericArgumentOffset</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> ForeignMetadataInitialization &amp;<span class="hljs-title">getForeignMetadataInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasForeignMetadataInitialization</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;ForeignMetadataInitialization&gt;();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> SingletonMetadataInitialization &amp;<span class="hljs-title">getSingletonMetadataInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasSingletonMetadataInitialization</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;SingletonMetadataInitialization&gt;();<br>  &#125;<br><br>  <span class="hljs-function">llvm::ArrayRef&lt;Metadata&gt; <span class="hljs-title">getCanonicalMetadataPrespecializations</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>()) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> *listCount = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListCount&gt;();<br>    <span class="hljs-keyword">auto</span> *list = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListEntry&gt;();<br>    <span class="hljs-keyword">return</span> llvm::ArrayRef&lt;Metadata&gt;(<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Metadata *&gt;(list),<br>        listCount-&gt;count<br>        );<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">swift_once_t</span> *<span class="hljs-title">getCanonicalMetadataPrespecializationCachingOnceToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> box = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataCachingOnceToken&gt;();<br>    <span class="hljs-keyword">return</span> box-&gt;token.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *cd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Enum;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>  [[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;Only meant for use in the debugger&quot;</span>)]] <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-keyword">using</span> EnumDescriptor = TargetEnumDescriptor&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>TargetEnumDescriptor</code>中有<code>NumPayloadCasesAndPayloadSizeOffset</code>和<code>NumEmptyCases</code>两个成员变量，其继承自<code>TargetValueTypeDescriptor</code>–&gt;<code>TargetTypeContextDescriptor</code> –&gt; <code>TargetContextDescriptor</code>的方式。这种继承方式中的属性，具体见<code>TargetStructMetadata分析</code>，其结构为</li>
</ul>
<h3 id="TargetEnumDescriptor数据结构"><a href="#TargetEnumDescriptor数据结构" class="headerlink" title="TargetEnumDescriptor数据结构"></a><code>TargetEnumDescriptor</code>数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetEnumDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumPayloadCasesAndPayloadSizeOffset</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumEmptyCases</span>: <span class="hljs-type">UInt32</span><br>    <br>    <span class="hljs-keyword">var</span> genericArgumentOffset: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="验证TargetEnumDescriptor数据结构"><a href="#验证TargetEnumDescriptor数据结构" class="headerlink" title="验证TargetEnumDescriptor数据结构"></a>验证<code>TargetEnumDescriptor</code>数据结构</h1><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a><code>验证代码</code></h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TerminalChar</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> plain(<span class="hljs-type">Bool</span>)<br>    <span class="hljs-keyword">case</span> bold(<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> empty<br>    <span class="hljs-keyword">case</span> cursor<br>&#125;<br><br><span class="hljs-keyword">let</span> enumMetadata_ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(<span class="hljs-type">TerminalChar</span>.<span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetEnumMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br><span class="hljs-comment">//拿到枚举的名字</span><br><span class="hljs-keyword">let</span> namePtr <span class="hljs-operator">=</span> enumMetadata_ptr.pointee.typeDescriptor.pointee.name.getmeasureRelativeOffset()<br><span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: namePtr)) <span class="hljs-comment">// TerminalChar</span><br><span class="hljs-comment">// 有关联值的</span><br><span class="hljs-built_in">print</span>(enumMetadata_ptr.pointee.typeDescriptor.pointee.<span class="hljs-type">NumPayloadCasesAndPayloadSizeOffset</span>) <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 无关联值的</span><br> <span class="hljs-built_in">print</span>(enumMetadata_ptr.pointee.typeDescriptor.pointee.<span class="hljs-type">NumEmptyCases</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>注意，这里必须将<code>TerminalChar.self</code>视为<code>Any.Type</code>,因为<code>unsafeBitCast</code>需要两个参数的内存大小相同，而<code>TerminalChar.Typ</code>的内存大小是<code>0</code>和<code>UnsafeMutablePointer</code>的<code>8</code>字节不等，会报错。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TerminalChar</span>.<span class="hljs-keyword">Type</span>&gt;.size,<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>&gt;.size)<br><span class="hljs-comment">// 0 8</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 拿到属性描述器指针</span><br><span class="hljs-keyword">let</span> fieldDesc_ptr <span class="hljs-operator">=</span> enumMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset()<br>   <br><span class="hljs-comment">//输出枚举的类型，有两种不同类型的关联值，所以是3，如果去掉 一个则是2</span><br><span class="hljs-built_in">print</span>(fieldDesc_ptr.pointee.kind) <span class="hljs-comment">// 3</span><br><span class="hljs-comment">//数量，有4个枚举</span><br><span class="hljs-built_in">print</span>(fieldDesc_ptr.pointee.numFields) <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>
<h4 id="FieldDescriptor中的kind"><a href="#FieldDescriptor中的kind" class="headerlink" title="FieldDescriptor中的kind"></a>FieldDescriptor中的kind</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FieldDescriptorKind</span> : <span class="hljs-title">uint16_t</span> </span>&#123;<br>  <span class="hljs-comment">// Swift nominal types.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Struct</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Class</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Enum</span><br><br>  <span class="hljs-comment">// Fixed-size multi-payload enums have a special descriptor format that</span><br>  <span class="hljs-comment">// encodes spare bits.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> Actually implement this. For now, a descriptor with this kind</span><br>  <span class="hljs-comment">// just means we also have a builtin descriptor from which we get the</span><br>  <span class="hljs-comment">// size and alignment.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">MultiPayloadEnum</span>,<br><br>  <span class="hljs-comment">// A Swift opaque protocol. There are no fields, just a record for the</span><br>  <span class="hljs-comment">// type itself.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Protocol</span>,<br><br>  <span class="hljs-comment">// A Swift class-bound protocol.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">ClassProtocol</span>,<br><br>  <span class="hljs-comment">// An Objective-C protocol, which may be imported or defined in Swift.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">ObjCProtocol</span>,<br><br>  <span class="hljs-comment">// An Objective-C class, which may be imported or defined in Swift.</span><br>  <span class="hljs-comment">// In the former case, field type metadata is not emitted, and</span><br>  <span class="hljs-comment">// must be obtained from the Objective-C runtime.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">ObjCClass</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="枚举中属性的类型"><a href="#枚举中属性的类型" class="headerlink" title="枚举中属性的类型"></a>枚举中属性的类型</h3><blockquote>
<p>注意只有有关联值的，其枚举才有类型，否则是没有的</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//泛型向量</span><br><span class="hljs-keyword">let</span> genericVector <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(enumMetadata_ptr).advanced(by: enumMetadata_ptr.pointee.typeDescriptor.pointee.genericArgumentOffset <span class="hljs-operator">*</span> <span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size).assumingMemoryBound(to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>)<br><br><span class="hljs-keyword">let</span> mangledName <span class="hljs-operator">=</span> fieldDesc_ptr.pointee.fields.index(of: <span class="hljs-number">0</span>).pointee.mangledTypeName.getmeasureRelativeOffset()<br>    <span class="hljs-keyword">let</span> fieldType <span class="hljs-operator">=</span> _getTypeByMangledNameInContext(mangledName,<br>                                                   <span class="hljs-number">256</span>,<br>                                                   genericContext: <span class="hljs-type">UnsafeRawPointer</span>(enumMetadata_ptr.pointee.typeDescriptor),<br>                                                   genericArguments: <span class="hljs-type">UnsafeRawPointer</span>(genericVector)<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.<span class="hljs-keyword">self</span>))<span class="hljs-operator">!</span><br>                                                   <br><span class="hljs-built_in">print</span>(fieldType) <span class="hljs-comment">// Bool</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: fieldDesc_ptr.pointee.fields.index(of: <span class="hljs-number">0</span>).pointee.fieldName.getmeasureRelativeOffset()))  <span class="hljs-comment">//plain</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>Mirror</title>
    <url>/2023/06/12/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/Mirror/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>对象的内存在堆中，其前<code>8</code>字节是<code>metadata</code>、随后<code>8</code>字节是引用计数，最后是成员变量<br><a href="https://github.com/apple/swift/blob/master/docs/ABI/TypeMetadata.rst">Metadata文档</a></p>
</blockquote>
<h1 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h1><blockquote>
<ul>
<li>反射就是可以动态获取 类型、成员信息，在运行时可调用方法、属性 等行为的特性。</li>
<li>基于原生<code>Swift</code>使用<code>Runtime</code>的诸多局限性，它的标准库提供了<code>反射机制</code>来让我们访问成员信息。<br><code>Swift</code>的反射机制是基于一个叫<code>Mirror</code>的结构体来实现的,(只能获取<code>swift</code>中的类，无法获取<code>OC</code>中<code>NSObject</code>的)。是比较弱的反射，不如直接从<code>metadata</code>中获取数据</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Tome&quot;</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">say</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;say hi&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> mirr:<span class="hljs-type">Mirror</span>? <span class="hljs-operator">=</span> <span class="hljs-type">Mirror</span>(reflecting: <span class="hljs-type">Person</span>())<br><span class="hljs-built_in">print</span>(mirr.displayStyle)<br><span class="hljs-built_in">print</span>(mirr.subjectType)<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> cur <span class="hljs-operator">=</span> mirr &#123;<br>    <span class="hljs-keyword">for</span> (label,value) <span class="hljs-keyword">in</span> cur.children &#123;<br>        <span class="hljs-built_in">print</span>(label,value)<br>    &#125;<br>    mirr <span class="hljs-operator">=</span> mirr<span class="hljs-operator">?</span>.superclassMirror<br>&#125;<br><br><span class="hljs-comment">//输出</span><br><span class="hljs-type">Optional</span>(<span class="hljs-type">Swift</span>.<span class="hljs-type">Mirror</span>.<span class="hljs-type">DisplayStyle</span>.class)<br><span class="hljs-type">Person</span><br><span class="hljs-type">Optional</span>(<span class="hljs-string">&quot;num&quot;</span>) <span class="hljs-number">0</span><br><span class="hljs-type">Optional</span>(<span class="hljs-string">&quot;name&quot;</span>) <span class="hljs-type">Tome</span><br></code></pre></td></tr></table></figure>
<ul>
<li>但是这种没有办法访问到当前的函数<code>teach</code>，如果想要访问函数，需要把函数定义成属性信息。<br>那我们可以简单地封装一下，得到一个对象的<code>key-value</code>：<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 调用函数直接得到一个对象的key-value</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getKeyValue</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">mirrorObj</span>: <span class="hljs-keyword">Any</span>)</span> -&gt; <span class="hljs-keyword">Any</span> &#123;<br>        <span class="hljs-keyword">let</span> mirror <span class="hljs-operator">=</span> <span class="hljs-type">Mirror</span>(reflecting: mirrorObj)<br>        <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>mirror.children.isEmpty <span class="hljs-keyword">else</span>&#123; <span class="hljs-keyword">return</span> mirrorObj &#125;<br>        <span class="hljs-keyword">var</span> result: [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] <span class="hljs-operator">=</span> [:]<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> mirror.children&#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> key <span class="hljs-operator">=</span> child.label&#123;<br>                result[key] <span class="hljs-operator">=</span> getKeyValue(child.value)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No Keys&quot;</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-built_in">print</span>(getKeyValue(<span class="hljs-type">Person</span>())) <span class="hljs-comment">//[&quot;name&quot;: &quot;Tome&quot;, &quot;num&quot;: 0]</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>TargetStructMetadata分析</title>
    <url>/2023/06/11/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/TargetStructMetadata%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TargetStructMetadata"><a href="#TargetStructMetadata" class="headerlink" title="TargetStructMetadata"></a>TargetStructMetadata</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h2 id="TargetStructMetadata-1"><a href="#TargetStructMetadata-1" class="headerlink" title="TargetStructMetadata"></a><code>TargetStructMetadata</code></h2><ul>
<li>源码声明：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of type metadata for structs.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetStructMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetValueMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> TargetValueMetadata&lt;Runtime&gt;::TargetValueMetadata;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetStructDescriptor&lt;Runtime&gt; *<span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> llvm::cast&lt;TargetStructDescriptor&lt;Runtime&gt;&gt;(<span class="hljs-keyword">this</span>-&gt;Description);<br>  &#125;<br><br>  <span class="hljs-comment">// The first trailing field of struct metadata is always the generic</span><br>  <span class="hljs-comment">// argument array.</span><br><br>  <span class="hljs-comment">/// Get a pointer to the field offset vector, if present, or null.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *<span class="hljs-title">getFieldOffsets</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;FieldOffsetVectorOffset;<br>    <span class="hljs-keyword">if</span> (offset == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span>*&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *&gt;(asWords + offset);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span> *trailingFlags = <span class="hljs-built_in">getTrailingFlags</span>();<br>    <span class="hljs-keyword">if</span> (trailingFlags == <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> trailingFlags-&gt;<span class="hljs-built_in">isStaticSpecialization</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCanonicalStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span> *trailingFlags = <span class="hljs-built_in">getTrailingFlags</span>();<br>    <span class="hljs-keyword">if</span> (trailingFlags == <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> trailingFlags-&gt;<span class="hljs-built_in">isCanonicalStaticSpecialization</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> MetadataTrailingFlags *<span class="hljs-title">getTrailingFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">auto</span> flags = description-&gt;<span class="hljs-built_in">getFullGenericContextHeader</span>()<br>                     .DefaultInstantiationPattern-&gt;PatternFlags;<br>    <span class="hljs-keyword">if</span> (!flags.<span class="hljs-built_in">hasTrailingFlags</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> fieldOffset = description-&gt;FieldOffsetVectorOffset;<br>    <span class="hljs-keyword">auto</span> offset =<br>        fieldOffset +<br>        <span class="hljs-comment">// Pad to the nearest pointer.</span><br>        ((description-&gt;NumFields * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">uint32_t</span>) + <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *) - <span class="hljs-number">1</span>) /<br>         <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *));<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> *&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> MetadataTrailingFlags *&gt;(asWords + offset);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">getGenericArgumentOffset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TargetStructMetadata&lt;Runtime&gt;) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StoredPointer);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Struct;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> StructMetadata = TargetStructMetadata&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure></li>
<li><code>TargetStructMetadata</code>没有啥的属性，看看它父类<code>TargetValueMetadata</code>。</li>
</ul>
<h2 id="TargetValueMetadata"><a href="#TargetValueMetadata" class="headerlink" title="TargetValueMetadata"></a><code>TargetValueMetadata</code></h2><ul>
<li>源码声明：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The common structure of metadata for structs and enums.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetValueMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-built_in">TargetValueMetadata</span>(MetadataKind Kind,<br>                      <span class="hljs-keyword">const</span> TargetTypeContextDescriptor&lt;Runtime&gt; *description)<br>      : TargetMetadata&lt;Runtime&gt;(Kind), <span class="hljs-built_in">Description</span>(description) &#123;&#125;<br><br>  <span class="hljs-comment">/// An out-of-line description of the type.</span><br>  TargetSignedPointer&lt;Runtime, <span class="hljs-keyword">const</span> TargetValueTypeDescriptor&lt;Runtime&gt; * __ptrauth_swift_type_descriptor&gt; Description;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Struct<br>      || metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Enum<br>      || metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Optional;<br>  &#125;<br><br>  <span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, TargetValueTypeDescriptor&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">typename</span> Runtime::StoredSignedPointer</span><br><span class="hljs-function">  <span class="hljs-title">getDescriptionAsSignedPointer</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> ValueMetadata = TargetValueMetadata&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure></li>
<li><code>TargetValueMetadata</code>继承自<code>TargetMetadata</code>,而<code>TargetMatedata</code>中只有一个属性<code>Kind</code></li>
</ul>
<h2 id="TargetStructMetadata的数据结构"><a href="#TargetStructMetadata的数据结构" class="headerlink" title="TargetStructMetadata的数据结构"></a><code>TargetStructMetadata</code>的数据结构</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetStructMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span>: <span class="hljs-type">Int</span><br>     <span class="hljs-comment">// 结构体描述器 (TargetStructDescriptor是解析后的自定义的，它可以替代TargetValueTypeDescriptor)</span><br>    <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetStructDescriptor</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="TargetStructDescriptor"><a href="#TargetStructDescriptor" class="headerlink" title="TargetStructDescriptor"></a>TargetStructDescriptor</h1><h2 id="TargetStructDescriptor-1"><a href="#TargetStructDescriptor-1" class="headerlink" title="TargetStructDescriptor"></a>TargetStructDescriptor</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetStructDescriptor</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">    :</span> <span class="hljs-keyword">public</span> TargetValueTypeDescriptor&lt;Runtime&gt;,<br>      <span class="hljs-keyword">public</span> TrailingGenericContextObjects&lt;TargetStructDescriptor&lt;Runtime&gt;,<br>                            TargetTypeGenericContextDescriptorHeader,<br>                            <span class="hljs-comment">/*additional trailing objects*/</span><br>                            TargetForeignMetadataInitialization&lt;Runtime&gt;,<br>                            TargetSingletonMetadataInitialization&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasListCount&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasListEntry&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasCachingOnceToken&lt;Runtime&gt;&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> ForeignMetadataInitialization =<br>    TargetForeignMetadataInitialization&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> SingletonMetadataInitialization =<br>    TargetSingletonMetadataInitialization&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> Metadata =<br>    TargetRelativeDirectPointer&lt;Runtime, TargetMetadata&lt;Runtime&gt;, <span class="hljs-comment">/*Nullable*/</span> <span class="hljs-literal">false</span>&gt;;<br>  <span class="hljs-keyword">using</span> MetadataListCount =<br>    TargetCanonicalSpecializedMetadatasListCount&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> MetadataListEntry =<br>    TargetCanonicalSpecializedMetadatasListEntry&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> MetadataCachingOnceToken =<br>      TargetCanonicalSpecializedMetadatasCachingOnceToken&lt;Runtime&gt;;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects =<br>      swift::TrailingGenericContextObjects&lt;TargetStructDescriptor&lt;Runtime&gt;,<br>                                           TargetTypeGenericContextDescriptorHeader,<br>                                           ForeignMetadataInitialization,<br>                                           SingletonMetadataInitialization,<br>                                           MetadataListCount,<br>                                           MetadataListEntry,<br>                                           MetadataCachingOnceToken&gt;;<br><br>  <span class="hljs-keyword">using</span> TrailingObjects =<br>    <span class="hljs-keyword">typename</span> TrailingGenericContextObjects::TrailingObjects;<br>  <span class="hljs-keyword">friend</span> TrailingObjects;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">using</span> OverloadToken = <span class="hljs-keyword">typename</span> TrailingObjects::<span class="hljs-keyword">template</span> OverloadToken&lt;T&gt;;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::numTrailingObjects;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;ForeignMetadataInitialization&gt;)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasForeignMetadataInitialization</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;SingletonMetadataInitialization&gt;)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasSingletonMetadataInitialization</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataListCount&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ?<br>      <span class="hljs-number">1</span><br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataListEntry&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ?<br>      <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListCount&gt;()-&gt;count<br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataCachingOnceToken&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericContext;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericContextHeader;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getFullGenericContextHeader;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericParams;<br><br>  <span class="hljs-comment">/// The number of stored properties in the struct.</span><br>  <span class="hljs-comment">/// If there is a field offset vector, this is its length.</span><br>  <span class="hljs-keyword">uint32_t</span> NumFields;<br>  <span class="hljs-comment">/// The offset of the field offset vector for this struct&#x27;s stored</span><br>  <span class="hljs-comment">/// properties in its metadata, if any. 0 means there is no field offset</span><br>  <span class="hljs-comment">/// vector.</span><br>  <span class="hljs-keyword">uint32_t</span> FieldOffsetVectorOffset;<br>  <br>  <span class="hljs-comment">/// True if metadata records for this type have a field offset vector for</span><br>  <span class="hljs-comment">/// its stored properties.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasFieldOffsetVector</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> FieldOffsetVectorOffset != <span class="hljs-number">0</span>; &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> ForeignMetadataInitialization &amp;<span class="hljs-title">getForeignMetadataInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasForeignMetadataInitialization</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;ForeignMetadataInitialization&gt;();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> SingletonMetadataInitialization &amp;<span class="hljs-title">getSingletonMetadataInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasSingletonMetadataInitialization</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;SingletonMetadataInitialization&gt;();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">getGenericArgumentOffset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TargetStructMetadata&lt;Runtime&gt;::<span class="hljs-built_in">getGenericArgumentOffset</span>();<br>  &#125;<br><br>  <span class="hljs-function">llvm::ArrayRef&lt;Metadata&gt; <span class="hljs-title">getCanonicalMetadataPrespecializations</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>()) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> *listCount = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListCount&gt;();<br>    <span class="hljs-keyword">auto</span> *list = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListEntry&gt;();<br>    <span class="hljs-keyword">return</span> llvm::ArrayRef&lt;Metadata&gt;(<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Metadata *&gt;(list),<br>        listCount-&gt;count<br>        );<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">swift_once_t</span> *<span class="hljs-title">getCanonicalMetadataPrespecializationCachingOnceToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> box = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataCachingOnceToken&gt;();<br>    <span class="hljs-keyword">return</span> box-&gt;token.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *cd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Struct;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetStructDescriptor</span> </span>&#123;<br>    <span class="hljs-comment">//父类TargetValueTypeDescriptor中的</span><br>    <span class="hljs-operator">....</span><br>    <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TargetValueTypeDescriptor"><a href="#TargetValueTypeDescriptor" class="headerlink" title="TargetValueTypeDescriptor"></a><code>TargetValueTypeDescriptor</code></h2><ul>
<li>源码分析：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetValueTypeDescriptor</span></span><br><span class="hljs-class">    :</span> <span class="hljs-keyword">public</span> TargetTypeContextDescriptor&lt;Runtime&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *cd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Struct ||<br>           cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Enum;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><code>TargetValueTypeDescriptor</code>是继承自<code>TargetTypeContextDescriptor</code>的。而在<code>swift类分析</code>章中可以知道，类的整个继承链是<code>TargetClassDescriptor</code> –&gt;<code>TargetTypeContextDescriptor</code> –&gt; <code>TargetContextDescriptor</code>。因此总的结构如下<br><img src="1.png"></li>
</ul>
<h3 id="TargetTypeContextDescriptor的数据结构"><a href="#TargetTypeContextDescriptor的数据结构" class="headerlink" title="TargetTypeContextDescriptor的数据结构"></a><code>TargetTypeContextDescriptor</code>的数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetStructDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 类名</span><br>    <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt; <span class="hljs-comment">// 属性描述器</span><br>    <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 每一个属性值距离当前实例对象地址的偏移量</span><br>    <br>    <span class="hljs-comment">// 泛型参数的偏移量 - 源码里是经过一系列计算 而HandyJSON直接给2</span><br>    <span class="hljs-keyword">var</span> genericArgumentOffset: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFieldOffsets</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">metadata</span>: <span class="hljs-type">UnsafeRawPointer</span>)</span> -&gt; <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">UInt32</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> offset:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">numericCast</span>(<span class="hljs-keyword">self</span>.fieldOffsetVectorOffset)<br>        <span class="hljs-comment">//int是8字节，偏移，则是8 * offset =FieldOffsets - metadata地址</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeRawPointer</span>(metadata.assumingMemoryBound(to: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>).advanced(by: offset)).assumingMemoryBound(to: <span class="hljs-type">UInt32</span>.<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>注意这里和<code>getFieldOffsets</code>返回的是<code>UnsafePointer&lt;Int32&gt;</code>确定的<code>UInt32</code>这是因为在源码中和类不同<ul>
<li>类的<code>StoredPointer</code>是种<code>泛型类型</code>，这里统一返回<code>UnsafePointer&lt;Int&gt;</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">/// Get a pointer to the field offset vector, if present, or null.</span><br><span class="hljs-function"><span class="hljs-keyword">const</span> StoredPointer *<span class="hljs-title">getFieldOffsets</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>  <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">getFieldOffsetVectorOffset</span>();<br>  <span class="hljs-keyword">if</span> (offset == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span>*&gt;(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> StoredPointer *&gt;(asWords + offset);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>结构体的<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//指定返回 uint32_t</span><br>    <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *<span class="hljs-title">getFieldOffsets</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;FieldOffsetVectorOffset;<br>    <span class="hljs-keyword">if</span> (offset == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span>*&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *&gt;(asWords + offset);<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="验证TargetStructMetadata数据结构"><a href="#验证TargetStructMetadata数据结构" class="headerlink" title="验证TargetStructMetadata数据结构"></a>验证TargetStructMetadata数据结构</h1><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a><code>验证代码</code></h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PersonStruct</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">let</span> name:<span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Test&quot;</span><br>    <span class="hljs-keyword">let</span> sex <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">var</span> address <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SZ-2023&quot;</span><br>    <span class="hljs-keyword">var</span> birthday <span class="hljs-operator">=</span> (<span class="hljs-string">&quot;2005&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;26&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> person <span class="hljs-operator">=</span> <span class="hljs-type">PersonStruct</span>()<br><span class="hljs-keyword">let</span> struct_ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(<span class="hljs-type">PersonStruct</span>.<span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetStructMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>注意，这里必须将<code>PersonStruct.self</code>视为<code>Any.Type</code>,因为<code>unsafeBitCast</code>需要两个参数的内存大小相同，而<code>PersonStruct.Typ</code>的内存大小是<code>0</code>和<code>UnsafeMutablePointer</code>的<code>8</code>字节不等，会报错。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">PersonStruct</span>.<span class="hljs-keyword">Type</span>&gt;.size,<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>&gt;.size)<br><span class="hljs-comment">// 0 8</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//类名</span><br>    <span class="hljs-keyword">let</span> name_ptr <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.name.getmeasureRelativeOffset()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: name_ptr)) <span class="hljs-comment">// PersonStruct</span><br></code></pre></td></tr></table></figure>

<h3 id="属性数量"><a href="#属性数量" class="headerlink" title="属性数量"></a>属性数量</h3><ul>
<li><code>typeDescriptor</code>内的数量，和<code>fieldDescriptor</code>的数量是一样的<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//属性的数量,下面两种方式获取的数量是一致的</span><br>    <span class="hljs-keyword">let</span> numFileds <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.numFields<br><span class="hljs-comment">//    let numFileds = struct_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.numFields</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;numFileds: <span class="hljs-subst">\(numFileds)</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="打印所有的属性"><a href="#打印所有的属性" class="headerlink" title="打印所有的属性"></a>打印所有的属性</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> bufferPtr <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.getFieldOffsets(<span class="hljs-type">UnsafeRawPointer</span>(struct_ptr))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>numFileds &#123;<br>        <span class="hljs-keyword">let</span> filedName <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.fieldName.getmeasureRelativeOffset()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;filedName: <span class="hljs-subst">\(String(cString: filedName))</span>&quot;</span>)<br>        <br>        <span class="hljs-comment">// 混写过的mangleTypeName</span><br>        <span class="hljs-keyword">let</span> mangledTypeName <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.mangledTypeName.getmeasureRelativeOffset()<br>        <br>        <span class="hljs-comment">// 泛型向量</span><br>        <span class="hljs-keyword">let</span> genericVector <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(struct_ptr).advanced(by: struct_ptr.pointee.typeDescriptor.pointee.genericArgumentOffset <span class="hljs-operator">*</span> <span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size).assumingMemoryBound(to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>)<br>        <br>        <br>        <span class="hljs-comment">// 获取属性类型:</span><br>        <span class="hljs-keyword">let</span> fieldType <span class="hljs-operator">=</span> _getTypeByMangledNameInContext(mangledTypeName,<br>                                                       <span class="hljs-number">256</span>,<br>                                                       genericContext: <span class="hljs-type">UnsafeRawPointer</span>(classMetadata_ptr.pointee.typeDescriptor),<br>                                                       genericArguments: <span class="hljs-type">UnsafeRawPointer</span>(genericVector)<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.<span class="hljs-keyword">self</span>))<span class="hljs-operator">!</span><br>        <span class="hljs-comment">// 属性类型 （</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;filedType: <span class="hljs-subst">\(fieldType)</span>&quot;</span>)<br>        <br>        <span class="hljs-comment">// 对象的起始地址</span><br>        <span class="hljs-keyword">let</span> instanceAddress <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafeMutablePointer</span>(to: <span class="hljs-operator">&amp;</span>person)&#123;<span class="hljs-variable">$0</span>&#125; <span class="hljs-comment">// Person()的起始地址</span><br>        <span class="hljs-comment">// 每个属性的偏移量</span><br>        <span class="hljs-keyword">let</span> fieldOffset <span class="hljs-operator">=</span> bufferPtr[<span class="hljs-type">Int</span>(i)]<br>        <span class="hljs-comment">// 真实属性类型</span><br>        <span class="hljs-keyword">let</span> realType <span class="hljs-operator">=</span> getBitCast(type: fieldType) <span class="hljs-comment">// 把真实类型信息，保存到protocol的metadata，再通过Self.self获取真实类型</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;realType: <span class="hljs-subst">\(realType)</span>&quot;</span>)<br>        <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> realType.get(from: <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-type">UnsafeRawPointer</span>(instanceAddress).advanced(by: <span class="hljs-built_in">numericCast</span>(fieldOffset))))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;filedValue: <span class="hljs-subst">\(value)</span>&quot;</span>)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;========================================&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">PersonStruct</span><br>numFileds: <span class="hljs-number">5</span><br>filedName: age<br>filedType: <span class="hljs-type">Int</span><br>realType: <span class="hljs-type">Int</span><br>filedValue: <span class="hljs-number">18</span><br><span class="hljs-operator">========================================</span><br>filedName: name<br>filedType: <span class="hljs-type">String</span><br>realType: <span class="hljs-type">String</span><br>filedValue: <span class="hljs-type">Test</span><br><span class="hljs-operator">========================================</span><br>filedName: sex<br>filedType: <span class="hljs-type">Bool</span><br>realType: <span class="hljs-type">Bool</span><br>filedValue: <span class="hljs-literal">false</span><br><span class="hljs-operator">========================================</span><br>filedName: address<br>filedType: <span class="hljs-type">String</span><br>realType: <span class="hljs-type">String</span><br>filedValue: <span class="hljs-type">SZ</span><span class="hljs-operator">-</span><span class="hljs-number">2023</span><br><span class="hljs-operator">========================================</span><br>filedName: birthday<br>filedType: (<span class="hljs-type">String</span>, <span class="hljs-type">String</span>, <span class="hljs-type">String</span>)<br>realType: (<span class="hljs-type">String</span>, <span class="hljs-type">String</span>, <span class="hljs-type">String</span>)<br>filedValue: (<span class="hljs-string">&quot;2005&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;26&quot;</span>)<br><span class="hljs-operator">========================================</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>TargetClassMetadata结构分析</title>
    <url>/2023/06/09/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/TargetClassMetadata%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TargetClassMetadata的完整数据结构"><a href="#TargetClassMetadata的完整数据结构" class="headerlink" title="TargetClassMetadata的完整数据结构"></a>TargetClassMetadata的完整数据结构</h1><blockquote>
<p>结合前面的类分析和属性分析，可以确定<code>TargetClassMetadata</code>的完整数据结构</p>
</blockquote>
<h2 id="TargetClassMetadata"><a href="#TargetClassMetadata" class="headerlink" title="TargetClassMetadata"></a>TargetClassMetadata</h2><blockquote>
<p>类 <code>Metadata</code>如下，无论是否继承<code>NSObject</code>，还是纯<code>swift</code>类</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 类 Metadata</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> superClass: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span><br>    <span class="hljs-keyword">var</span> cacheData: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span><br>    <br>    <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <span class="hljs-comment">// swift特有的标志</span><br>    <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 实例独享内存首地址</span><br>    <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 实例对象内存大小</span><br>    <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <span class="hljs-comment">// 实例对象内存对齐方式</span><br>    <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <span class="hljs-comment">// 运行时保留字段</span><br>    <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 类的内存大小</span><br>    <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <span class="hljs-comment">//类的内存首地址</span><br>    <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetClassDescriptor</span>&gt; <span class="hljs-comment">// 类型描述器</span><br>    <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 实例销毁器</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TargetClassDescriptor"><a href="#TargetClassDescriptor" class="headerlink" title="TargetClassDescriptor"></a>TargetClassDescriptor</h2><blockquote>
<p>类描述器</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 类描述器</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassDescriptor</span></span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;   <span class="hljs-comment">// class/struct/enum 的名称</span><br>    <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt; <span class="hljs-comment">// 属性描述器</span><br>    <br>    <span class="hljs-keyword">var</span> superClassType: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 父类类型</span><br>    <span class="hljs-keyword">var</span> metadataNegativeSizeInWords: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> metadataPositiveSizeInWords: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> numImmediateMembers: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 每一个属性值距离当前实例对象地址的偏移量</span><br>    <span class="hljs-comment">//var Offset: UInt32</span><br>    <span class="hljs-comment">// var size: UInt32</span><br>    <span class="hljs-comment">// V-Table  (methods)</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFieldOffsets</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">metadata</span>: <span class="hljs-type">UnsafeRawPointer</span>)</span> -&gt; <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> metadata.assumingMemoryBound(to: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>).advanced(by: <span class="hljs-built_in">numericCast</span>(<span class="hljs-keyword">self</span>.fieldOffsetVectorOffset))<br>    &#125;<br>    <br>    <span class="hljs-comment">// 泛型参数的偏移量 - 源码里是经过一系列计算 而HandyJSON直接给2</span><br>    <span class="hljs-keyword">var</span> genericArgumentOffset: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TargetRelativeDirectPointer"><a href="#TargetRelativeDirectPointer" class="headerlink" title="TargetRelativeDirectPointer"></a>TargetRelativeDirectPointer</h2><blockquote>
<p>相对地址指针</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 相对地址信息 - 存储的是偏移量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetRelativeDirectPointer</span>&lt;<span class="hljs-title">Pointee</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> offset: <span class="hljs-type">Int32</span><br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getmeasureRelativeOffset</span>()</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Pointee</span>&gt;&#123;<br>        <span class="hljs-keyword">let</span> offset <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.offset<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123; p <span class="hljs-keyword">in</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             获得self，变为raw，然后+offset</span><br><span class="hljs-comment">             </span><br><span class="hljs-comment">             - UnsafeRawPointer(p) 表示this</span><br><span class="hljs-comment">             - advanced(by: numericCast(offset) 表示移动的步长，即offset</span><br><span class="hljs-comment">             - assumingMemoryBound(to: T.self) 表示假定类型是T，即自己指定的类型</span><br><span class="hljs-comment">             - UnsafeMutablePointer(mutating:) 表示返回的指针类型</span><br><span class="hljs-comment">            */</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating: <span class="hljs-type">UnsafeRawPointer</span>(p).advanced(by: <span class="hljs-built_in">numericCast</span>(offset)).assumingMemoryBound(to: <span class="hljs-type">Pointee</span>.<span class="hljs-keyword">self</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="FieldDescriptor"><a href="#FieldDescriptor" class="headerlink" title="FieldDescriptor"></a>FieldDescriptor</h2><blockquote>
<p>属性描述器,通用<code>class</code>/<code>struct</code>/<code>enum</code>类 - 属性信息</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 属性描述器</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> mangledTypeName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> superclass: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">UInt16</span><br>    <span class="hljs-keyword">var</span> fieldRecordSize: <span class="hljs-type">UInt16</span><br>    <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 属性个数</span><br>    <span class="hljs-keyword">var</span> fields: <span class="hljs-type">FiledRecordBuffer</span>&lt;<span class="hljs-type">FieldRecord</span>&gt; <span class="hljs-comment">// 属性列表</span><br>&#125;<br><br><span class="hljs-comment">// 属性</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldRecord</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> mangledTypeName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 属性的类型</span><br>    <span class="hljs-keyword">var</span> fieldName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UInt8</span>&gt; <span class="hljs-comment">// 属性的名称</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FiledRecordBuffer</span>&lt;<span class="hljs-title">Element</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> element: <span class="hljs-type">Element</span><br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buffer</span>(<span class="hljs-params">n</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeBufferPointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span>.withMemoryRebound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; start <span class="hljs-keyword">in</span><br>                <span class="hljs-keyword">return</span> start<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeBufferPointer</span>(start: ptr, count: n)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span>(<span class="hljs-params">of</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating: <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>).assumingMemoryBound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>).advanced(by: i))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="验证TargetClassMetadata数据结构"><a href="#验证TargetClassMetadata数据结构" class="headerlink" title="验证TargetClassMetadata数据结构"></a>验证TargetClassMetadata数据结构</h1><blockquote>
<p>通过解析下面<code>Person</code>类的数据结构，分析下<code>Metadata</code>数据结构</p>
</blockquote>
<h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a><code>验证代码</code></h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;验证Metadata&quot;</span><br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> time <span class="hljs-operator">=</span> <span class="hljs-number">15.4</span><br>&#125;<br><span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>() <span class="hljs-comment">// 创建一个Person实例</span><br><span class="hljs-keyword">var</span> pClazz <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>.<span class="hljs-keyword">self</span> <span class="hljs-comment">// 拿到类对象</span><br><span class="hljs-comment">// 拿到ClassMetadata指针</span><br><span class="hljs-keyword">let</span> classMetadata_ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(pClazz, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetClassMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>unsafeBitCast</code>的作用：按位转换成指针 <code>UnsafeMutablePointer&lt;TargetClassMetadata&gt;</code>，就可以对指针进行操作。</li>
</ul>
<h2 id="类的名字"><a href="#类的名字" class="headerlink" title="类的名字"></a>类的名字</h2><ul>
<li><code>typeDescriptor</code>是直接指针，而其变量<code>name</code>存储的是间接指针，需要通过<code>getmeasureRelativeOffset</code>,即当前<code>name</code>的地址，加上其存储的偏移量，即为真实地址<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> name_ptr <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.name.getmeasureRelativeOffset()<br><span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: name_ptr)) <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="属性个数"><a href="#属性个数" class="headerlink" title="属性个数"></a>属性个数</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> numFileds <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.numFields<br><span class="hljs-built_in">print</span>(numFileds)  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<h2 id="输出所有的属性"><a href="#输出所有的属性" class="headerlink" title="输出所有的属性"></a>输出所有的属性</h2><h3 id="首个属性的偏移地址"><a href="#首个属性的偏移地址" class="headerlink" title="首个属性的偏移地址"></a>首个属性的偏移地址</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> offsets <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.getFieldOffsets(<span class="hljs-type">UnsafeRawPointer</span>(classMetadata_ptr))<br></code></pre></td></tr></table></figure>
<ul>
<li>在<code>TargetClassDescriptor</code>里有一个属性叫<code>fieldOffsetVectorOffset</code>，它存储的是每一个属性值距离当前<code>实例对象地址</code>的偏移量；从<code>classMetadata_ptr</code>指针偏移<code>fieldOffsetVectorOffset</code>。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//person对象的实例地址</span><br><span class="hljs-keyword">let</span> instanceAddress <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passUnretained(person).toOpaque()<br><span class="hljs-comment">// 第一个属性的偏移量</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">获取实例开始的，例如：如果继承NSObjec，并且有NSObjec内有两个8字节对象对象(加上isa,一共24)，则instanceStart则为24 - 8,首个偏移地址是8</span><br><span class="hljs-comment">如果纯swift勒，则instanceStart为16（metada和recount） - 16</span><br><span class="hljs-comment">let instanceStart = pointer.pointee.class_rw_t()?.pointee.class_ro_t()?.pointee.instanceStart - offsets[0]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">let</span> instanceStart <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> fieldOffset <span class="hljs-operator">=</span> offsets[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// valueAddess即第一个属性值存放的地址</span><br><span class="hljs-keyword">let</span> valueAddess <span class="hljs-operator">=</span> instanceAddress.advanced(by: fieldOffset)<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,获取<code>instanceStart</code>，可以通过<code>TargetClassMetadata.data</code>中<code>class_rw_t().class_ro_t().instanceStart</code>获取。<ul>
<li>如果继承<code>NSObject</code>，并且有<code>NSObject</code>内有两个<code>8</code>字节对象对象(加上<code>isa</code>,一共<code>24</code>)，则<code>instanceStart</code>则为<code>24 - 8</code></li>
<li>如果纯<code>swift</code>，则<code>instanceStart</code>为<code>16 - 16</code><ul>
<li>无论是（<code>metada</code>+<code>recount</code>）还是（<code>metada</code>+<code>sidetable</code>）均为<code>16</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="属性的类型，值"><a href="#属性的类型，值" class="headerlink" title="属性的类型，值"></a>属性的类型，值</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>numFileds &#123;<br>    <span class="hljs-comment">// 获取属性名</span><br>    <span class="hljs-keyword">let</span> fieldName <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.fieldName.getmeasureRelativeOffset()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fieldName：<span class="hljs-subst">\(String(cString: fieldName))</span>&quot;</span>)<br>    <br>    <span class="hljs-comment">// 混写过的类型名称</span><br>    <span class="hljs-keyword">let</span> mangledTypeName <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.mangledTypeName.getmeasureRelativeOffset()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mangledTypeName：<span class="hljs-subst">\(String(cString: mangledTypeName))</span>&quot;</span>)<br>    <br>    <span class="hljs-comment">// 泛型向量</span><br>    <span class="hljs-keyword">let</span> genericVector <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(classMetadata_ptr).advanced(by: classMetadata_ptr.pointee.typeDescriptor.pointee.genericArgumentOffset <span class="hljs-operator">*</span> <span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size).assumingMemoryBound(to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>)<br>                                                   <span class="hljs-type">UnsafeRawPointer</span>(genericVector)<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.<span class="hljs-keyword">self</span>))<br>    <span class="hljs-comment">//这个方式实际调用的系统方法库，去解析泛混合类型</span><br>    <span class="hljs-keyword">let</span> realType <span class="hljs-operator">=</span> _getTypeByMangledNameInContext(mangledTypeName,<br>                                                  <span class="hljs-number">256</span>,<br>                                                  genericContext: <span class="hljs-type">UnsafeRawPointer</span>(classMetadata_ptr.pointee.typeDescriptor),<br>                                                  genericArguments: <span class="hljs-type">UnsafeRawPointer</span>(genericVector)<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.<span class="hljs-keyword">self</span>))<span class="hljs-operator">!</span><br>    <span class="hljs-comment">//拿到解析后的真实类型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;realType: <span class="hljs-subst">\(realType)</span>&quot;</span>)<br>    <br>    <span class="hljs-comment">// 把真实类型信息，保存到protocol的metadata，再通过Self.self获取真实类型</span><br>    <span class="hljs-keyword">let</span> protocolType <span class="hljs-operator">=</span> getBitCast(type: realType)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;protocolType: <span class="hljs-subst">\(protocolType)</span>&quot;</span>)<br>    <span class="hljs-comment">// 对象的起始地址</span><br>    <span class="hljs-keyword">let</span> instanceAddress <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passUnretained(person).toOpaque() <span class="hljs-comment">// Teacher()的起始地址</span><br>    <span class="hljs-comment">// 每个属性的偏移量</span><br>    <span class="hljs-keyword">let</span> fieldOffset <span class="hljs-operator">=</span> offsets[<span class="hljs-type">Int</span>(i)] <span class="hljs-operator">+</span> instanceStart<br>    <br>    <span class="hljs-comment">// 获取属性的值</span><br>    <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> protocolType.get(from: instanceAddress.advanced(by: fieldOffset))<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fieldValue: <span class="hljs-subst">\(value)</span>&quot;</span>)   <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==================&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="获取属性名"><a href="#获取属性名" class="headerlink" title="获取属性名"></a>获取属性名</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> fieldName <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.fieldName.getmeasureRelativeOffset()<br></code></pre></td></tr></table></figure>
<ol>
<li><p><code>classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee</code></p>
<ul>
<li>在<code>TargetClassDescriptor</code>中的<code>fieldDescriptor</code>是相对地址信息类型，通过调用<code>getmeasureRelativeOffset()</code>来做地址偏移，才能获取到真正的<code>fieldDescriptor</code>对象</li>
</ul>
</li>
<li><p><code>classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: Int(i)).pointee</code></p>
<ul>
<li>拿到真正的<code>fieldDescriptor</code>对象后，可以找到<code>fields</code>属性列表，可以发现它是一个<code>FiledRecordBuffer&lt;FieldRecord&gt;</code>类型，通过源码可知属性列表是一片连续的内存空间，需要逐个拿出对应地址的<code>field</code>指针；再<code>.pointee</code>得到<code>FieldRecord</code>实例对象，才能继续对<code>FieldRecord</code>实例的属性进行访问。</li>
</ul>
</li>
</ol>
<h4 id="获取属性类型"><a href="#获取属性类型" class="headerlink" title="获取属性类型"></a>获取属性类型</h4><ol>
<li><code>_getTypeByMangledNameInContext</code>的作用是将混写后的<code>属性类型名</code>解析还原，调用的是同一个<code>C</code>标准库里的函数,只需要声明即可（如果系统库，没有<code>swift_getTypeByMangledNameInContext</code>函数，则会崩溃） <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@_silgen_name</span>(<span class="hljs-string">&quot;swift_getTypeByMangledNameInContext&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_getTypeByMangledNameInContext</span>(</span><br><span class="hljs-function">    <span class="hljs-keyword">_</span> <span class="hljs-params">name</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">CChar</span>&gt;,</span><br><span class="hljs-function">    <span class="hljs-keyword">_</span> <span class="hljs-params">nameLength</span>: <span class="hljs-type">Int</span>,</span><br><span class="hljs-function">    <span class="hljs-params">genericContext</span>: <span class="hljs-type">UnsafeRawPointer</span>?,</span><br><span class="hljs-function">    <span class="hljs-params">genericArguments</span>: <span class="hljs-type">UnsafeRawPointer</span>?)</span><br>    -&gt; <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span><span class="hljs-operator">?</span><br></code></pre></td></tr></table></figure></li>
<li>返回的类型是一个<code>Any.Type</code>类型,无法知道其类型，实际上可以通过把真实类型信息，保存到<code>protocol</code>的<code>metadata</code>，再通过<code>Self.self</code>获取真实类型的方式 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 将一个Any.Type转换成BrigeProtocol</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBitCast</span>(<span class="hljs-params">type</span>: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>)</span> -&gt; <span class="hljs-type">BrigeProtocol</span>.<span class="hljs-keyword">Type</span> &#123;<br>        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-type">ProtocolMetadata</span>(type: type, witness: <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">let</span> bitCast <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(container, to: <span class="hljs-type">BrigeProtocol</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">// 将struct保存到Protocol的Metadata</span><br>        <span class="hljs-keyword">return</span> bitCast<br>    &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>也可通过下面方式获取<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBitCast</span>(<span class="hljs-params">type</span>: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>)</span> -&gt; <span class="hljs-type">BrigeProtocol</span>.<span class="hljs-keyword">Type</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Extension</span>: <span class="hljs-title">BrigeProtocol</span> </span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> extensions: <span class="hljs-type">BrigeProtocol</span>.<span class="hljs-keyword">Type</span> <span class="hljs-operator">=</span> <span class="hljs-type">Extension</span>.<span class="hljs-keyword">self</span><br>    <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>extensions) &#123; pointer <span class="hljs-keyword">in</span><br>        <span class="hljs-type">UnsafeMutableRawPointer</span>(mutating: pointer).assumingMemoryBound(to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>).pointee <span class="hljs-operator">=</span> type<br>    &#125;<br><span class="hljs-keyword">return</span> extensions<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="BrigeProtocol"><a href="#BrigeProtocol" class="headerlink" title="BrigeProtocol"></a>BrigeProtocol</h5><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">BrigeProtocol</span>:<span class="hljs-title">Anyobject</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BrigeProtocol</span> </span>&#123;<br>    <span class="hljs-comment">// 获取真实类型信息的值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span>(<span class="hljs-params">from</span> <span class="hljs-params">pointer</span>: <span class="hljs-type">UnsafeRawPointer</span>)</span> -&gt; <span class="hljs-keyword">Any</span> &#123;<br>        <span class="hljs-keyword">return</span> pointer.assumingMemoryBound(to: <span class="hljs-keyword">Self</span>.<span class="hljs-keyword">self</span>).pointee<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 协议的Metadata。这里作为转换成确定类信息的协议metadata</span><br><span class="hljs-comment">// 协议见证表,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolMetadata</span> </span>&#123; <span class="hljs-comment">// TargetWitnessTable</span><br>    <span class="hljs-keyword">let</span> type: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span> <span class="hljs-comment">// 真实类型</span><br>    <span class="hljs-keyword">let</span> witness: <span class="hljs-type">Int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>元类没有成员变量之类的，因此用协议的 <code>Class Existential Container</code>类型即可，其大小只有<code>16</code>字节<ul>
<li><code>getBitCast</code>返回的是<code>元类协议</code>(<code>BrigeProtocol.Type</code>),如果是协议返回<code>BrigeProtocol</code>，则其结构要转为<code>40</code>字节大小的类型<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle1:<span class="hljs-type">Shape</span>.<span class="hljs-keyword">Type</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>.<span class="hljs-keyword">self</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle1)) <span class="hljs-comment">// 16</span><br><br><span class="hljs-keyword">var</span> circle1:<span class="hljs-type">Shape</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle1)) <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="实际输出"><a href="#实际输出" class="headerlink" title="实际输出"></a>实际输出</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">fieldName：name<br>mangledTypeName：<span class="hljs-type">SS</span><br>realType: <span class="hljs-type">String</span><br>fieldType: <span class="hljs-type">String</span><br>fieldValue: 验证<span class="hljs-type">Metadata</span><br><span class="hljs-operator">==================</span><br>fieldName：age<br>mangledTypeName：<span class="hljs-type">Si</span><br>realType: <span class="hljs-type">Int</span><br>fieldType: <span class="hljs-type">Int</span><br>fieldValue: <span class="hljs-number">18</span><br><span class="hljs-operator">==================</span><br>fieldName：time<br>mangledTypeName：<span class="hljs-type">Sd</span><br>realType: <span class="hljs-type">Double</span><br>fieldType: <span class="hljs-type">Double</span><br>fieldValue: <span class="hljs-number">15.4</span><br><span class="hljs-operator">==================</span><br></code></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>swift内存管理</title>
    <url>/2023/05/25/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/swift%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p>核心概念</p>
<ul>
<li><code>强引用</code>对象会持有这个实例，并且只要<code>强引用</code>仍然存在，就不允许对其进行释放。</li>
<li><code>弱引用</code>是一种<code>引用</code>，它不会持有所引用的实例，因此也不会阻止<code>ARC</code>销毁所引用的实例。</li>
<li><code>Unowned</code>引用方式也是<code>弱引用</code>的一种。区别是访问<code>计数器</code>为零的引用会导致运行时错误。当另一个实例的寿命相同或更长时，可以使用它。</li>
</ul>
</li>
<li><p><code>Swift</code>中的对象有三种计数器：<code>强引用</code>，<code>弱引用</code>和<code>无主引用</code>。这些<code>计数器</code>存储在<code>metadata</code>之后或者存储在<code>Side table</code>中</p>
</li>
<li><p><code>弱引用</code>和<code>无主引用</code>的计数器比强引用多<code>+1</code>。当对象执行完析构和销毁内存后，这个附加值将减小。</p>
</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ol>
<li>通过汇编调试和<code>swift</code>源码知道我们的 纯<code>swift</code>类的对象的内存分配：<code>__allocating_init</code>-&gt; <code>_swift_allocObject_</code> -&gt; <code>swift_slowAlloc</code> -&gt; <code>malloc</code><ol>
<li><code>_swift_allocObject_</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> HeapObject *_swift_allocObject_(HeapMetadata <span class="hljs-keyword">const</span> *metadata,<br>                                       <span class="hljs-keyword">size_t</span> requiredSize,<br>                                       <span class="hljs-keyword">size_t</span> requiredAlignmentMask) &#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isAlignmentMask</span>(requiredAlignmentMask));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SWIFT_STDLIB_HAS_MALLOC_TYPE</span><br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(<span class="hljs-built_in">swift_slowAllocTyped</span>(<br>      requiredSize, requiredAlignmentMask, <span class="hljs-built_in">getMallocTypeId</span>(metadata)));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(<br>      <span class="hljs-built_in">swift_slowAlloc</span>(requiredSize, requiredAlignmentMask));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this relies on the C++17 guaranteed semantics of no null-pointer</span><br>  <span class="hljs-comment">// check on the placement new allocator which we have observed on Windows,</span><br>  <span class="hljs-comment">// Linux, and macOS.</span><br>  ::<span class="hljs-keyword">new</span> (object) <span class="hljs-built_in">HeapObject</span>(metadata);<br><br>  <span class="hljs-comment">// If leak tracking is enabled, start tracking this object.</span><br>  <span class="hljs-built_in">SWIFT_LEAKS_START_TRACKING_OBJECT</span>(object);<br><br>  <span class="hljs-built_in">SWIFT_RT_TRACK_INVOCATION</span>(object, swift_allocObject);<br><br>  <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>_swift_allocObject_</code>里面创建一个 <code>HeapObject</code>对象并将其返回了，所以这个<code>HeapObject</code>就是我们实际创建的对象，来看看其初始化函数：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Initialize a HeapObject header as appropriate for a newly-allocated object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">HeapObject</span><span class="hljs-params">(HeapMetadata <span class="hljs-keyword">const</span> *newMetadata)</span> </span><br><span class="hljs-function">    : metadata(newMetadata)</span><br><span class="hljs-function">    , refCounts(InlineRefCounts::Initialized)</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="lldb调试"><a href="#lldb调试" class="headerlink" title="lldb调试"></a>lldb调试</h2><ol>
<li>调试代码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-keyword">var</span> diameter:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-keyword">let</span> cir <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br><span class="hljs-comment">//Unmanaged指定内存管理，转换成指针，</span><br><span class="hljs-comment">//passUnretained不会增加引用计数</span><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passUnretained(cir).toOpaque()<br><span class="hljs-built_in">print</span>(ptr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>调试,前<code>16</code>个字节就是<code>matadata</code>和<code>refcounts</code>,注意不要用<code>po</code>指令，会对<code>cir</code>强引用，增加引用计数<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0x00006000002013a0</span><br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x00006000002013a0</span><br><span class="hljs-number">0x6000002013a0</span>: <span class="hljs-number">0x0000000100008400</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x6000002013b0</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br><br>lldb) po cir<br>&lt;Circle: <span class="hljs-number">0x60000020d360</span>&gt;<br><br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x000060000020d360</span><br><span class="hljs-number">0x60000020d360</span>: <span class="hljs-number">0x0000000100008400</span> <span class="hljs-number">0x0000000200000003</span><br><span class="hljs-number">0x60000020d370</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br></code></pre></td></tr></table></figure></li>
<li>然后为何引用计数增加会导致计数从<code>0x0000000000000003</code> -&gt; <code>0x0000000200000003</code>,这是下面需要讨论的问题</li>
</ol>
<h1 id="引用计数的实质"><a href="#引用计数的实质" class="headerlink" title="引用计数的实质"></a>引用计数的实质</h1><h2 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h2><ol>
<li>从源码中<code>HeapObject.h</code>的找到<code>refcounts</code>的定义 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// standard Objective-C instance</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS       \</span><br><span class="hljs-meta">  InlineRefCounts refCounts</span><br><br><span class="hljs-comment">/// The Swift heap-object header.</span><br><span class="hljs-comment">/// This must match RefCountedStructTy in IRGen.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapObject</span> &#123;</span><br>  <span class="hljs-comment">/// This is always a valid pointer to a metadata object.</span><br>  HeapMetadata <span class="hljs-keyword">const</span> *__ptrauth_objc_isa_pointer metadata;<br><br>  SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __swift__</span><br>  <span class="hljs-built_in">HeapObject</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">// Initialize a HeapObject header as appropriate for a newly-allocated object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">HeapObject</span><span class="hljs-params">(HeapMetadata <span class="hljs-keyword">const</span> *newMetadata)</span> </span><br><span class="hljs-function">    : metadata(newMetadata)</span><br><span class="hljs-function">    , refCounts(InlineRefCounts::Initialized)</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
<li>从源码中<code>RefCount.h</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> RefCounts&lt;InlineRefCountBits&gt; InlineRefCounts; <span class="hljs-comment">//模版类</span><br><span class="hljs-keyword">typedef</span> RefCounts&lt;SideTableRefCountBits&gt; SideTableRefCounts;<br><br><br><span class="hljs-comment">// Barriers</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Strong refcount increment is unordered with respect to other memory locations</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Strong refcount decrement is a release operation with respect to other</span><br><span class="hljs-comment">// memory locations. When an object&#x27;s reference count becomes zero,</span><br><span class="hljs-comment">// an acquire fence is performed before beginning Swift deinit or ObjC</span><br><span class="hljs-comment">// -dealloc code. This ensures that the deinit code sees all modifications</span><br><span class="hljs-comment">// of the object&#x27;s contents that were made before the object was released.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Unowned and weak increment and decrement are all unordered.</span><br><span class="hljs-comment">// There is no deinit equivalent for these counts so no fence is needed.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Accessing the side table requires that refCounts be accessed with</span><br><span class="hljs-comment">// a load-consume. Only code that is guaranteed not to try dereferencing</span><br><span class="hljs-comment">// the side table may perform a load-relaxed of refCounts.</span><br><span class="hljs-comment">// Similarly, storing the new side table pointer into refCounts is a</span><br><span class="hljs-comment">// store-release, but most other stores into refCounts are store-relaxed.</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RefCountBits&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCounts</span> &#123;</span><br>  std::atomic&lt;RefCountBits&gt; refCounts;<br><br>  <span class="hljs-comment">// Out-of-line slow paths.</span><br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  HeapObject *<span class="hljs-title">incrementSlow</span><span class="hljs-params">(RefCountBits oldbits, <span class="hljs-keyword">uint32_t</span> inc)</span></span>;<br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">void</span> <span class="hljs-title">incrementNonAtomicSlow</span><span class="hljs-params">(RefCountBits oldbits, <span class="hljs-keyword">uint32_t</span> inc)</span></span>;<br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">bool</span> <span class="hljs-title">tryIncrementSlow</span><span class="hljs-params">(RefCountBits oldbits)</span></span>;<br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">bool</span> <span class="hljs-title">tryIncrementNonAtomicSlow</span><span class="hljs-params">(RefCountBits oldbits)</span></span>;<br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">void</span> <span class="hljs-title">incrementUnownedSlow</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inc)</span></span>;<br><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Initialized_t</span> &#123;</span> Initialized &#125;;<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Immortal_t</span> &#123;</span> Immortal &#125;;<br><br>  <span class="hljs-comment">// RefCounts must be trivially constructible to avoid ObjC++</span><br>  <span class="hljs-comment">// destruction overhead at runtime. Use RefCounts(Initialized)</span><br>  <span class="hljs-comment">// to produce an initialized instance.</span><br>  <span class="hljs-built_in">RefCounts</span>() = <span class="hljs-keyword">default</span>;<br>  <br>  <span class="hljs-comment">// Refcount of a new object is 1.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">RefCounts</span><span class="hljs-params">(Initialized_t)</span></span><br><span class="hljs-function">    : refCounts(RefCountBits(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;</span>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>RefCounts</code>就是对当前引用计数的包装类，而引用计数的具体类型取决于传递给<code>RefCounts</code>的参数 -&gt; <code>InlineRefCountBits</code>。<code>InlineRefCountBits</code>同样是个模版类。<code>RefCountIsInline</code>传递的是<code>true</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> RefCountBitsT&lt;RefCountIsInline&gt; InlineRefCountBits;<br><br><span class="hljs-comment">// RefCountIsInline: refcount stored in an object</span><br><span class="hljs-comment">// RefCountNotInline: refcount stored in an object&#x27;s side table entry</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RefCountInlinedness</span> &#123;</span> RefCountNotInline = <span class="hljs-literal">false</span>, RefCountIsInline = <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PerformDeinit</span> &#123;</span> DontPerformDeinit = <span class="hljs-literal">false</span>, DoPerformDeinit = <span class="hljs-literal">true</span> &#125;;<br></code></pre></td></tr></table></figure></li>
<li>模版类<code>RefCountBitsT</code>,<code>RefCountBitsT</code>就是真实操作引用计数的类，它只有一个属性 <code>bits</code>，它的类型定义是 <code>RefCountBitsInt</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Basic encoding of refcount and flag data into the object&#x27;s header.</span><br><span class="hljs-keyword">template</span> &lt;RefCountInlinedness refcountIsInline&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountBitsT</span> &#123;</span><br><br>  <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountBitsT</span>&lt;</span>RefCountIsInline&gt;;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountBitsT</span>&lt;</span>RefCountNotInline&gt;;<br>  <br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> RefCountInlinedness Inlinedness = refcountIsInline;<br><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> RefCountBitsInt&lt;refcountIsInline, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span>*)&gt;::Type<br>    BitsType;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> RefCountBitsInt&lt;refcountIsInline, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span>*)&gt;::SignedType<br>    SignedBitsType;<br>  <span class="hljs-keyword">typedef</span> RefCountBitOffsets&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BitsType)&gt;<br>    Offsets;<br><br>  BitsType bits;<br>......<br></code></pre></td></tr></table></figure></li>
<li><code>RefCountBitsInt&lt;refcountIsInline, sizeof(void*)&gt;::Type</code>,指针大小在<code>64</code>位是<code>8</code>可以看到,<code>BitsType</code>的具体类型为<code>uint64_t</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 64-bit inline</span><br><span class="hljs-comment">// 64-bit out of line</span><br><span class="hljs-keyword">template</span> &lt;RefCountInlinedness refcountIsInline&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RefCountBitsInt</span>&lt;</span>refcountIsInline, <span class="hljs-number">8</span>&gt; &#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> Type;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int64_t</span> SignedType;<br>&#125;;<br><br><span class="hljs-comment">// 32-bit out of line</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RefCountBitsInt</span>&lt;</span>RefCountNotInline, <span class="hljs-number">4</span>&gt; &#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> Type;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int64_t</span> SignedType;<br>&#125;;<br><br><span class="hljs-comment">// 32-bit inline</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RefCountBitsInt</span>&lt;</span>RefCountIsInline, <span class="hljs-number">4</span>&gt; &#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint32_t</span> Type;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int32_t</span> SignedType;  <br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>引用计数的实质： <code>bits</code>其实就是一个<code>uint64</code>位的位域信息，它存储了就是运行周期相关的引用计数。</li>
</ol>
<h2 id="初始引用计数"><a href="#初始引用计数" class="headerlink" title="初始引用计数"></a>初始引用计数</h2><ol>
<li>对象初始化时,默认引用计数传参数<code>InlineRefCounts::Initialized</code>，<code>refCounts</code>即为<code>InlineRefCounts</code>。实际上<code>RefCounts&lt;InlineRefCountBits&gt; InlineRefCounts</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// standard Objective-C instance</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS       \</span><br><span class="hljs-meta">      InlineRefCounts refCounts</span><br><br><span class="hljs-comment">// Initialize a HeapObject header as appropriate for a newly-allocated object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">HeapObject</span><span class="hljs-params">(HeapMetadata <span class="hljs-keyword">const</span> *newMetadata)</span> </span><br><span class="hljs-function">    : metadata(newMetadata)</span><br><span class="hljs-function">    , refCounts(InlineRefCounts::Initialized)</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>Initialized</code>实际是一个枚举,方法为<code>RefCounts(Initialized_t)</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Initialized_t</span> &#123;</span> Initialized &#125;;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Immortal_t</span> &#123;</span> Immortal &#125;;<br><br>  <span class="hljs-comment">// RefCounts must be trivially constructible to avoid ObjC++</span><br>  <span class="hljs-comment">// destruction overhead at runtime. Use RefCounts(Initialized)</span><br>  <span class="hljs-comment">// to produce an initialized instance.</span><br>  <span class="hljs-built_in">RefCounts</span>() = <span class="hljs-keyword">default</span>;<br>  <br>  <span class="hljs-comment">// Refcount of a new object is 1.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">RefCounts</span><span class="hljs-params">(Initialized_t)</span></span><br><span class="hljs-function">    : refCounts(RefCountBits(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;</span>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>RefCountBits(0, 1)</code>,实际上<code>InlineRefCountBits(0,1)</code><ol>
<li>其中<code>InlineRefCountBits</code>，其类型实际为<code>RefCountBitsT&lt;RefCountIsInline&gt; InlineRefCountBits</code>,</li>
<li>而<code>RefCountBitsT</code>是模版类 <code>template &lt;RefCountInlinedness refcountIsInline&gt; class RefCountBitsT</code>。</li>
<li>最终<code>RefCountBits</code>实际调用时<code>RefCountBitsT</code></li>
</ol>
</li>
<li><code>RefCountBitsT</code>初始化方法,这里<code>strongExtraCount</code>和<code>unownedCount</code>分别对应<code>RefCountBits(0, 1)</code>中的<code>0</code>,<code>1</code>,这里的<code>1</code>为无主引用<ul>
<li><code>0</code>左移<code>33</code>位还是<code>0</code>，<code>1</code>左移<code>1</code>位是<code>2</code>,<code>BitsType(1)</code>左移<code>0</code>为1,所以<code>refCounts</code>是<code>0x3</code>。(其他偏移见源码<code>RefCount.h</code>)</li>
<li>当声明一个引用对象，该对象没有被引用的时候，<code>refCounts</code>是<code>0x0000000000000003</code>：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">constexpr</span></span><br><span class="hljs-function">  <span class="hljs-title">RefCountBitsT</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> strongExtraCount, <span class="hljs-keyword">uint32_t</span> unownedCount)</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 33</span></span><br><span class="hljs-function">    : bits((BitsType(strongExtraCount) &lt;&lt; Offsets::StrongExtraRefCountShift) |</span><br><span class="hljs-function">           // <span class="hljs-number">0</span></span><br><span class="hljs-function">           (BitsType(<span class="hljs-number">1</span>)                &lt;&lt; Offsets::PureSwiftDeallocShift) |</span><br><span class="hljs-function">           // <span class="hljs-number">1</span></span><br><span class="hljs-function">           (BitsType(unownedCount)     &lt;&lt; Offsets::UnownedRefCountShift))</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="引用计数如何增加"><a href="#引用计数如何增加" class="headerlink" title="引用计数如何增加"></a>引用计数如何增加</h2><ol>
<li>从<code>swift</code>源码中找到<code>HeapObject.cpp</code>找到<code>_swift_retain_</code>函数实现：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SWIFT_ALWAYS_INLINE<br><span class="hljs-keyword">static</span> HeapObject *_swift_retain_(HeapObject *object) &#123;<br>  <span class="hljs-built_in">SWIFT_RT_TRACK_INVOCATION</span>(object, swift_retain);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValidPointerForNativeRetain</span>(object)) &#123;<br>    <span class="hljs-comment">// Return the result of increment() to make the eventual call to</span><br>    <span class="hljs-comment">// incrementSlow a tail call, which avoids pushing a stack frame on the fast</span><br>    <span class="hljs-comment">// path on ARM64.</span><br>    <span class="hljs-keyword">return</span> object-&gt;refCounts.<span class="hljs-built_in">increment</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>在<code>RefCount.h</code>中查找<code>increment</code>方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// This returns the enclosing HeapObject so that it the result of this call</span><br>  <span class="hljs-comment">// can be directly returned from swift_retain. This makes the call to</span><br>  <span class="hljs-comment">// incrementSlow() a tail call.</span><br>  <span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">  HeapObject *<span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inc = <span class="hljs-number">1</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>    <br>    <span class="hljs-comment">// constant propagation will remove this in swift_retain, it should only</span><br>    <span class="hljs-comment">// be present in swift_retain_n</span><br>    <span class="hljs-keyword">if</span> (inc != <span class="hljs-number">1</span> &amp;&amp; oldbits.<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">true</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>    &#125;<br>    <br>    RefCountBits newbits;<br>    <span class="hljs-keyword">do</span> &#123;<br>      newbits = oldbits;<br>      <span class="hljs-comment">//引用计数加1</span><br>      <span class="hljs-keyword">bool</span> fast = newbits.<span class="hljs-built_in">incrementStrongExtraRefCount</span>(inc);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SWIFT_UNLIKELY</span>(!fast)) &#123;<br>        <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">false</span>))<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">incrementSlow</span>(oldbits, inc);<br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                              std::memory_order_relaxed));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li>引用计数加<code>1</code>,显然，引用计数是原来的加上<code>1 &lt;&lt; 33</code>,此前引用计数啊加<code>1</code>为<code>0x0000000200000003</code>，实际上就是初始引用<code>0x3 + 1 &lt;&lt; 33</code>,在加<code>1</code>即为<code>0x0000000400000003</code>,引用计数减<code>1</code>,同样如此<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计数加1</span><br><span class="hljs-function">SWIFT_NODISCARD SWIFT_ALWAYS_INLINE <span class="hljs-keyword">bool</span></span><br><span class="hljs-function">  <span class="hljs-title">incrementStrongExtraRefCount</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inc)</span> </span>&#123;<br>    <span class="hljs-comment">// This deliberately overflows into the UseSlowRC field.</span><br>    <span class="hljs-comment">//inc左移33位</span><br>    bits += <span class="hljs-built_in">BitsType</span>(inc) &lt;&lt; Offsets::StrongExtraRefCountShift;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">SignedBitsType</span>(bits) &gt;= <span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">//计数减1</span><br>  <span class="hljs-function">SWIFT_NODISCARD SWIFT_ALWAYS_INLINE <span class="hljs-keyword">bool</span></span><br><span class="hljs-function">  <span class="hljs-title">decrementStrongExtraRefCount</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> dec)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">hasSideTable</span>() &amp;&amp; !<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">false</span>)) &#123;<br>      <span class="hljs-comment">// Can&#x27;t check these assertions with side table present.</span><br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getIsDeiniting</span>())<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">getStrongExtraRefCount</span>() &gt;= dec  &amp;&amp;<br>               <span class="hljs-string">&quot;releasing reference whose refcount is already zero&quot;</span>);<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">getStrongExtraRefCount</span>() + <span class="hljs-number">1</span> &gt;= dec  &amp;&amp;<br>               <span class="hljs-string">&quot;releasing reference whose refcount is already zero&quot;</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">// This deliberately underflows by borrowing from the UseSlowRC field.</span><br>    bits -= <span class="hljs-built_in">BitsType</span>(dec) &lt;&lt; Offsets::StrongExtraRefCountShift;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">SignedBitsType</span>(bits) &gt;= <span class="hljs-number">0</span>);<br>  &#125;PureSwiftDeallocShift<br></code></pre></td></tr></table></figure></li>
<li>其存储<code>64</code>位结构实际为</li>
</ol>
<table>
<thead>
<tr>
<th align="center">位数</th>
<th align="center">0</th>
<th align="center">1——31</th>
<th align="center">32</th>
<th align="center">33——62</th>
<th align="center">63</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">PPureSwiftDeallocShift</td>
<td align="center">UnownedRefCount</td>
<td align="center">IsDeiniting</td>
<td align="center">StrongExtraRefCount</td>
<td align="center">UseSlowRC</td>
</tr>
</tbody></table>
<h2 id="HeapObjectSideTableEntry"><a href="#HeapObjectSideTableEntry" class="headerlink" title="HeapObjectSideTableEntry"></a><span id="jump">HeapObjectSideTableEntry</span></h2><blockquote>
<p><code>Side tables</code>是实现<code>Swift</code>弱引用的核心,大多数情况，对象没有任何“弱”引用，因此为每个对象中的弱引用计数保留存储空间是浪费的。此信息存储在外部的 <code>side table</code>中，只有在确实需要时才会分配。弱引用变量不是直接指向对象，而是指向<code>side table</code>，而<code>side table</code>又指向对象.</p>
<ul>
<li>解决两个问题<ol>
<li>为<code>弱引用</code>计数节省内存，直到对象真正需要它才创建</li>
<li>允许安全地将<code>弱引用</code>归零，因为它不会直接指向对象，而是指向<code>side table</code>,并且不再是<code>竟态条件</code>(当两个<code>线程</code>竞争同一资源时，如果对资源的<code>访问顺序</code>敏感，就称存在<code>竞态</code>条件。)的主体</li>
</ol>
</li>
</ul>
</blockquote>
<ol>
<li>如果结构是<code>sidetable</code>，则会调用<code>incrementNonAtomicSlow</code>方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> fast = newbits.<span class="hljs-built_in">incrementStrongExtraRefCount</span>(inc);<span class="hljs-comment">//一直增加,看63位是否变为1</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SWIFT_UNLIKELY</span>(!fast)) &#123; <span class="hljs-comment">//为false</span><br>   <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">//如果是不可变对象直接返回</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">incrementSlow</span>(oldbits, inc);<br> &#125;<br></code></pre></td></tr></table></figure></li>
<li>首先会判断是否有<code>sidetable</code>通过<code>UseSlowRC</code>是否为1来判断。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RefCountBits&gt;<br>HeapObject *RefCounts&lt;RefCountBits&gt;::<span class="hljs-built_in">incrementSlow</span>(RefCountBits oldbits,<br>                                                   <span class="hljs-keyword">uint32_t</span> n) &#123;<br>  <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">false</span>)) &#123;<span class="hljs-comment">//不可变对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123; <span class="hljs-comment">//如果有sidtable</span><br>    <span class="hljs-comment">// Out-of-line slow path.</span><br>    <span class="hljs-keyword">auto</span> side = oldbits.<span class="hljs-built_in">getSideTable</span>();<br>    side-&gt;<span class="hljs-built_in">incrementStrong</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//没有引用越界异常</span><br>    <span class="hljs-comment">// Retain count overflow.</span><br>    swift::<span class="hljs-built_in">swift_abortRetainOverflow</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>sidetable</code>和<code>OC</code>中不不同，并非<code>全局存储</code>，而是同样存储在<code>refCount</code>指针中，通过<code>移位</code>获取真正的地址，左移动<code>3</code>位<ol>
<li><code>getSideTable</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">  HeapObjectSideTableEntry *<span class="hljs-title">getSideTable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasSideTable</span>());<br><br>    <span class="hljs-comment">// Stored value is a shifted pointer.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObjectSideTableEntry *&gt;<br>      (<span class="hljs-built_in">uintptr_t</span>(<span class="hljs-built_in">getField</span>(SideTable)) &lt;&lt; Offsets::SideTableUnusedLowBits);<br>      <span class="hljs-comment">// 0-62位，左移动 3位</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>setTable</code>,将<code>side</code>数据指针，右移<code>3</code>位后存储到<code>refCount</code>指针<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSideTable</span><span class="hljs-params">(HeapObjectSideTableEntry *side)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasSideTable</span>());<br>  <span class="hljs-comment">// Stored value is a shifted pointer.</span><br>  <span class="hljs-keyword">uintptr_t</span> value = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(side);<br>  <span class="hljs-keyword">uintptr_t</span> storedValue = value &gt;&gt; Offsets::SideTableUnusedLowBits;<br>  <span class="hljs-built_in">assert</span>(storedValue &lt;&lt; Offsets::SideTableUnusedLowBits == value);<br>  <span class="hljs-built_in">setField</span>(SideTable, storedValue);<br>  <span class="hljs-built_in">setField</span>(SideTableMark, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>也就是说，<code>HeapObject</code>的<code>RefCounts</code>实际上存在两种结构，一种是指针<code>RefCount</code>,一种是<code>HeapObjectSideTableEntry</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">HeapObject &#123;<br>    isa<br>    InlineRefCounts &#123;<br>      atomic&lt;InlineRefCountBits&gt; &#123;<br>        strong RC + unowned RC + flags<br>        OR<br>        HeapObjectSideTableEntry* <span class="hljs-comment">//列表</span><br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>HeapObjectSideTableEntry</code>的结构体如下,<code>SideTableRefCountBits</code>也是指针<code>RefCount</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">HeapObjectSideTableEntry &#123;<br>    SideTableRefCounts &#123;<br>      object pointer<br>      atomic&lt;SideTableRefCountBits&gt; &#123;<br>        strong RC + unowned RC + weak RC + flags<br>      &#125;<br>    &#125;   <br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>SideTableRefCountBits</code>是由<code>strong RC + unowned RC + weak RC + flags</code>组成，<code>32位</code> + <code>32位</code> + <code>32位</code> + <code>1位</code>组成<ol>
<li>这里<code>strong RC + unowned RC</code>的初始化和此前一样，和<code>weak</code>做了拆分<code>RefCountBitsT&lt;RefCountNotInline&gt;(strongExtraCount, unownedCount)</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//指针大小的两倍对齐</span><br><span class="hljs-function">class <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span>*) * <span class="hljs-number">2</span>)</span> SideTableRefCountBits : public RefCountBitsT&lt;RefCountNotInline&gt;</span><br><span class="hljs-function">&#123;</span><br>  <span class="hljs-keyword">uint32_t</span> weakBits;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">    <span class="hljs-title">SideTableRefCountBits</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-title">SideTableRefCountBits</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> strongExtraCount,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">uint32_t</span> unownedCount)</span></span><br><span class="hljs-function">        : RefCountBitsT&lt;RefCountNotInline&gt;(strongExtraCount, unownedCount)</span><br><span class="hljs-function">          // weak refcount starts at <span class="hljs-number">1</span> on behalf of the unowned count</span><br><span class="hljs-function">          ,</span><br><span class="hljs-function">          weakBits(<span class="hljs-number">1</span>) &#123;</span>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><code>side-&gt;incrementStrong(n);</code>本质上还是调用了<code>refCount</code>中的方法，也就是说实际上并不会扩展引用计数的大小 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incrementStrong</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inc)</span> </span>&#123;<br>refCounts.<span class="hljs-built_in">increment</span>(inc);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>sidtable</code>中实际强引用大小上是固定的<code>2^32-1</code>，而对象的总引用计数包括强引用计数、无主引用计数、弱引用计数。和<code>OC</code>不同，其主要是为来实现<code>swift</code>弱引用。一旦有弱引用指向对象，才会去创建<code>sidetable</code></li>
<li>对象最初是没有<code>Side Table</code>的，在以下情况下会自动创建：<ul>
<li>对象由弱引用指向时</li>
<li><code>unowned</code> 计数器溢出（在<code>32</code>位系统上，嵌入式计数器很小）。</li>
<li><code>strong</code>，在实际上在<code>64</code>位上超出并不会生成<code>Side Table</code>会报错,下面当最大引用计数超过<code>(1 &lt;&lt; 30) - 1</code>,超过最大强引用用数，会出现崩溃<code>Object was retained too many times</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-type">Int32</span>.max &#123;<br>    <span class="hljs-type">Unmanaged</span>.passRetained(person)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>弱引用</code>现在直接指向<code>Side Table</code>，而<code>强</code>和<code>无主</code>引用仍然直接指向对象。这样就可以完全释放对象的内存。<ul>
<li>此前类，<code>属性</code>和<code>引用计数器</code>是内联存储的。它比将数据存储在外部内存块中要快一些。但是如果有一个<code>弱引用</code>引用了这个对象，并且一段时间后，<code>强计数器</code>变为了<code>零</code>，而<code>弱计数器</code>仍然不为<code>零</code>。这种情况下，<code>自动引用计数</code>将会把该对象从内存中<code>删除</code>。尽管这样会导致对象<code>销毁</code>，但不会<code>释放</code>其内存(因为还存在<code>弱引用计数</code>)。</li>
</ul>
</li>
</ol>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><blockquote>
<p>用<code>weak</code>直接修饰<code>swift</code>类（如果继承<code>NSObject</code>则还是和<code>OC</code><a href="https://blog.csdn.net/weixin_50990189/article/details/126004836">实现弱引用一样</a>)，则会调用<code>swift_weakInit</code>函数</p>
</blockquote>
<h3 id="弱引用创建"><a href="#弱引用创建" class="headerlink" title="弱引用创建"></a>弱引用创建</h3><ul>
<li><code>swift_weakInit</code>,内实际调用了<code>nativeInit</code>,<code>WeakReference</code>指针，其内指向<code>sidetables</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">WeakReference *<span class="hljs-title">swift::swift_weakInit</span><span class="hljs-params">(WeakReference *ref, HeapObject *value)</span> </span>&#123;<br>  ref-&gt;<span class="hljs-built_in">nativeInit</span>(value);<br>  <span class="hljs-keyword">return</span> ref;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">(HeapObject *object)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> side = object ? object-&gt;refCounts.formWeakReference() : <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">//存储在弱引用表上</span><br>    nativeValue.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">WeakReferenceBits</span>(side), std::memory_order_relaxed);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>formWeakReference</code>,从<code>sidetable</code>中直接增加弱引用计数和上面强引用一样<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::formWeakReference()<br>&#123;<br>  <span class="hljs-keyword">auto</span> side = <span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (side)<br>    <span class="hljs-keyword">return</span> side-&gt;<span class="hljs-built_in">incrementWeak</span>();<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// Increment the weak reference count.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incrementWeak</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>    RefCountBits newbits;<br>    <span class="hljs-keyword">do</span> &#123;<br>      newbits = oldbits;<br>      <span class="hljs-built_in">assert</span>(newbits.<span class="hljs-built_in">getWeakRefCount</span>() != <span class="hljs-number">0</span>);<br>      newbits.<span class="hljs-built_in">incrementWeakRefCount</span>();<br>      <br>      <span class="hljs-keyword">if</span> (newbits.<span class="hljs-built_in">getWeakRefCount</span>() &lt; oldbits.<span class="hljs-built_in">getWeakRefCount</span>())<br>        <span class="hljs-built_in">swift_abortWeakRetainOverflow</span>();<br>    &#125; <span class="hljs-keyword">while</span> (!refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                              std::memory_order_relaxed));<br>  &#125;<br>  <br>  <span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">    <span class="hljs-keyword">void</span> <span class="hljs-title">incrementWeakRefCount</span><span class="hljs-params">()</span> </span>&#123; weakBits++; &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>allocateSideTable</code>,如果有<code>sidatable</code>则返回，没有则生成<ol>
<li>拿到原有的<code>64</code>位引用计数</li>
<li>没有则会创建一个<code>sidetable</code>，并保存原有的数据，<code>sidetable</code>中存储的数据即为<a href="#jump">HeapObjectSideTableEntry</a><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::<span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-keyword">bool</span> failIfDeiniting)<br>&#123;<br>    <span class="hljs-comment">//1. 拿到原有的64位引用计数</span><br>  <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>  <br>  <span class="hljs-comment">// Preflight failures before allocating a new side table.</span><br>  <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>    <span class="hljs-comment">// Already have a side table. Return it.</span><br>    <span class="hljs-keyword">return</span> oldbits.<span class="hljs-built_in">getSideTable</span>();<br>  &#125; <br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>    <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Preflight passed. Allocate a side table.</span><br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> custom side table allocator</span><br>  <span class="hljs-number">2.</span> 创建一个sidetable表<br>  <span class="hljs-keyword">auto</span> side = swift_cxx_newObject&lt;HeapObjectSideTableEntry&gt;(<span class="hljs-built_in">getHeapObject</span>());<br>  <br>  <span class="hljs-keyword">auto</span> newbits = <span class="hljs-built_in">InlineRefCountBits</span>(side);<span class="hljs-number">2.</span> 将创建的sidetable的地址进行初始化<br>  <br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>      <span class="hljs-comment">// Already have a side table. Return it and delete ours.</span><br>      <span class="hljs-comment">// Read before delete to streamline barriers.</span><br>      <span class="hljs-keyword">auto</span> result = oldbits.<span class="hljs-built_in">getSideTable</span>();<br>      <span class="hljs-built_in">swift_cxx_deleteObject</span>(side);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>      <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    side-&gt;<span class="hljs-built_in">initRefCounts</span>(oldbits); <span class="hljs-comment">//3. 将原来的sidetable保存</span><br>    <br>  &#125; <span class="hljs-keyword">while</span> (! refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                             std::memory_order_release,<br>                                             std::memory_order_relaxed));<br>  <span class="hljs-keyword">return</span> side;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="弱引用管理"><a href="#弱引用管理" class="headerlink" title="弱引用管理"></a>弱引用管理</h3><ul>
<li><p>获取<code>弱引用对象</code>的方式是通过<code>swift_weakLoadStrong</code>获取的，如果没释放就返回对象，否则返回<code>nil</code>。(并非直接指向原来的对象)<code>弱引用</code>的对象释放，而<code>弱引用</code>还在实际上并非立即设置为<code>nil</code>，完全释放<code>弱引用</code>的<code>sidetable</code>要调用<code>swift_weakDestroy</code>。在调用<code>弱引用</code>的方法，在其<code>get</code>方法中会通过调用<code>swift_weakLoadStrong</code>，返回<code>nil</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HeapObject *<span class="hljs-title">swift::swift_weakLoadStrong</span><span class="hljs-params">(WeakReference *ref)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ref-&gt;<span class="hljs-built_in">nativeLoadStrong</span>();<br>&#125;<br><br><span class="hljs-function">HeapObject *<span class="hljs-title">nativeLoadStrong</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> bits = nativeValue.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">nativeLoadStrongFromBits</span>(bits);<br>&#125;<br>  <br><span class="hljs-function">HeapObject *<span class="hljs-title">nativeLoadStrongFromBits</span><span class="hljs-params">(WeakReferenceBits bits)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> side = bits.<span class="hljs-built_in">getNativeOrNull</span>();<br>    <span class="hljs-keyword">return</span> side ? side-&gt;<span class="hljs-built_in">tryRetain</span>() : <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//已经deinit，则无法retain了，返回nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>完全释放<code>弱引用</code>,则会调用<code>swift_weakDestroy</code>-&gt;<code>nativeDestroy</code>,将<code>nativeValue</code>保存的弱引用<code>sidetable</code>删除（而弱引用实际指向<code>sidetable</code>）,置为<code>nil</code>。代表最终的释放由<code>free</code>-&gt;<code>DEAD</code>。此时如果无主引用还未释放，自会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nativeDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> oldBits = nativeValue.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    nativeValue.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>    <span class="hljs-built_in">destroyOldNativeBits</span>(oldBits);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroyOldNativeBits</span><span class="hljs-params">(WeakReferenceBits oldBits)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> oldSide = oldBits.<span class="hljs-built_in">getNativeOrNull</span>();<br>    <span class="hljs-keyword">if</span> (oldSide)<br>      oldSide-&gt;<span class="hljs-built_in">decrementWeak</span>();<span class="hljs-comment">//sidetable销毁，设置为nil</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrementWeak</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> assertions</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> optimize barriers</span><br>    <span class="hljs-keyword">bool</span> cleanup = refCounts.<span class="hljs-built_in">decrementWeakShouldCleanUp</span>();<br>    <span class="hljs-keyword">if</span> (!cleanup)<br>      <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// Weak ref count is now zero. Delete the side table entry.</span><br>    <span class="hljs-comment">// FREED -&gt; DEAD</span><br>    <span class="hljs-built_in">assert</span>(refCounts.<span class="hljs-built_in">getUnownedCount</span>() == <span class="hljs-number">0</span>);<span class="hljs-comment">//存在无主引用则会崩溃</span><br>    <span class="hljs-built_in">swift_cxx_deleteObject</span>(<span class="hljs-keyword">this</span>);<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="lldb调试验证"><a href="#lldb调试验证" class="headerlink" title="lldb调试验证"></a>lldb调试验证</h2><ol>
<li><code>let cir = Circle()</code>初始化<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x0000600000206540</span><br><span class="hljs-number">0x600000206540</span>: <span class="hljs-number">0x0000000100008110</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000206550</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br></code></pre></td></tr></table></figure></li>
<li><code>let t = cir</code>增加强引用<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x0000600000206540</span><br><span class="hljs-number">0x600000206540</span>: <span class="hljs-number">0x0000000100008110</span> <span class="hljs-number">0x0000000200000003</span><br><span class="hljs-number">0x600000206550</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br></code></pre></td></tr></table></figure></li>
<li><code>weak var t1 = cir</code>修饰弱引用,地址变为<code>0xc0000c0000040d5c</code>,这是个内存地址，而非引用计数,需要将其还原<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x0000600000206540</span><br><span class="hljs-number">0x600000206540</span>: <span class="hljs-number">0x0000000100008110</span> <span class="hljs-number">0xc0000c0000040d5c</span><br><span class="hljs-number">0x600000206550</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br></code></pre></td></tr></table></figure></li>
<li>得到<code>sidetable</code>地址需要左移动3位,先将最前面的<code>62</code>，<code>63</code>的<code>1</code>设置为<code>0</code>,不然越界无法左移,弱引用默认有<code>1</code>个。显然和<code>HeapObjectSideTableEntry</code>数据结构体一致(采用的是<code>2</code>位指针的对齐，即<code>16</code>字节对齐),<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) p/x <span class="hljs-number">0x0000c0000040d5c</span> &lt;&lt; <span class="hljs-number">3</span><br>(Int) $R2 = <span class="hljs-number">0x0000600000206ae0</span><br>(lldb) x/<span class="hljs-number">6</span>xg <span class="hljs-number">0x0000600000206ae0</span><br><span class="hljs-comment">//先存的堆对象</span><br><span class="hljs-number">0x600000206ae0</span>: <span class="hljs-number">0x0000600000206540</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-comment">//强引用，无主引用，弱引用</span><br><span class="hljs-number">0x600000206af0</span>: <span class="hljs-number">0x0000000200000003</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x600000206b00</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br>(lldb) <br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h1><p><img src="1.png"></p>
<ol>
<li>在<code>Live</code>状态时，对象处于活动状态。其引用计数被初始化为 <code>strong：1</code>， <code>unown：1</code>和 <code>weak：1</code>（<code>side table</code>从<code>+1</code>开始）。 一旦有弱引用指向对象，便会创建<code>side table</code>。<strong>弱引用</strong>指向<code>side table</code>而不是对象。</li>
<li>一旦强引用计数达到零，则对象从<code>Live</code>状态进入<code>Deiniting</code>状态。处于<code>Deiniting</code>状态表示<code>deinit</code>正在进行中。<ul>
<li>如果存在关联的<code>side table</code>，通过弱引用访问将返回<code>nil</code>。</li>
<li>在<code>deinit</code>中，全局强引用，引用<code>self</code>，在释放之后，会触发断言失败。</li>
<li>在<code>deinit</code>中，通过全局的<code>unowned</code>引用仍然可以存储，在释放之后，也不会触发断言失败。但是通过<code>unowned</code>访问将触发断言失败。</li>
</ul>
</li>
<li>从此状态开始，可能选择两条分支：<ol>
<li>快速判断如果没有<code>weak</code>，<code>unowned</code>的引用和<code>side table</code>。该对象将转换为<code>Dead</code>状态，并<strong>立即</strong>从内存中删除。</li>
<li>否则对象将变为<code>Deinited</code>状态</li>
</ol>
</li>
<li>在<code>Deinited</code>状态下，<code>deinit</code>已经执行完成，该对象还有未完成的无主引用（至少是初始值：<code>1</code>）,此时，通过<code>强</code>、<code>无主引用</code>以及<code>弱引用</code>进行存储和读取无法发生(<code>强制会崩溃</code>)。通过<code>Unown</code>读取会触发断言错误,但是还留<code>Unown</code>的对象可以访问(代码直接无法访问，<code>lldb</code>可以)（对象还未释放）。如果<code>Unown</code>引用变为<code>0</code>,该对象可以从此处进入两条分支：<ol>
<li>如果无无主引用和弱引用，则可以立即释放该对象。它过渡到<code>Dead</code>状态。</li>
<li>否则，仍然有一个<code>side table</code>要移除，并且对象进入<code>Freed</code>状态,在<code>Freed</code>状态之前，对象已完全释放，但它的 <code>side table</code>仍处于活动状态,此时弱引用变量加载将返回<code>nil</code>,当弱引用计数变为<code>0</code>时，<code>side table</code>会被销毁。对象将转换为<code>DEAD</code></li>
</ol>
</li>
<li>除指向对象的指针外，在<code>Dead</code>状态下对象已被全部销毁。指向<code>HeapObject</code>的指针也从堆中释放出来，在内存中找不到该对象的任何痕迹。</li>
</ol>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><a href="https://www.jianshu.com/p/37f8d75f150d">Swift底层进阶–006：内存管理</a></li>
</ul>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>SwiftC相关指令</title>
    <url>/2023/05/21/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/SwiftC%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SwiftC相关指令"><a href="#SwiftC相关指令" class="headerlink" title="SwiftC相关指令"></a><code>SwiftC</code>相关指令</h1><ol>
<li><p>语法分析分析输出<code>AST</code>(抽象语法树)</p>
<ul>
<li><code>swiftc main.swift -dump-parse</code></li>
</ul>
</li>
<li><p>语义分析并且检查类型输出<code>AST</code></p>
<ul>
<li><code>swiftc main.swift -dump-ast</code></li>
</ul>
</li>
<li><p>生成<code>swift</code>中间体语言（<code>SIL</code>）未优化</p>
<ul>
<li><code>swiftc main.swift -emit-silgen</code></li>
</ul>
</li>
<li><p>生成<code>swift</code>中间体语言（<code>SIL</code>）已优化</p>
<ul>
<li><code>swiftc main.swift -emit-sil</code></li>
</ul>
</li>
<li><p>生成<code>LLVM</code>中间体语言 （<code>.ll</code>文件）</p>
<ul>
<li><code>swiftc main.swift -emit-ir</code></li>
</ul>
</li>
<li><p>生成<code>LLVM</code>中间体语言 （<code>.bc</code>文件）</p>
<ul>
<li><code>swiftc main.swift -emit-bc</code></li>
</ul>
</li>
<li><p>生成汇编</p>
<ul>
<li><code>swiftc main.swift -emit-assembly</code></li>
</ul>
</li>
<li><p>编译生成可执行<code>.out</code>文件 （<code>x86</code>、<code>arm64</code>….）</p>
<ul>
<li><code>swiftc -o main.o main.swift</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>属性分析</title>
    <url>/2023/05/21/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h1><blockquote>
<p>存储属性是一个作为特定类和结构体实例一部分的常量或变量。存储属性要么是变量存储属性 （由 <code>var</code> 关键字引入）要么是常量存储属性（由 <code>let</code> 关键字引入）</p>
</blockquote>
<h2 id="let-和-var-的区别："><a href="#let-和-var-的区别：" class="headerlink" title="let 和 var 的区别："></a><code>let</code> 和 <code>var</code> 的区别：</h2><ul>
<li>测试验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;断点&quot;</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="从定义上"><a href="#从定义上" class="headerlink" title="从定义上"></a>从定义上</h3><ul>
<li><code>let</code>:用来声明常量，常量的值一旦设置好便不能再被更改；</li>
<li><code>var</code>:用来声明变量，变量的值可以在将来设置为不同的值。</li>
</ul>
<h3 id="汇编角度"><a href="#汇编角度" class="headerlink" title="汇编角度"></a>汇编角度</h3><ul>
<li>汇编查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">SwiftSource</span>`main:<br>    <span class="hljs-number">0x100003df0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:   pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003df1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:   movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003df4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:   subq   <span class="hljs-variable">$0</span>x30, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003df8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:   movq   <span class="hljs-variable">$0</span>xa, <span class="hljs-number">0x41fd</span>(<span class="hljs-operator">%</span>rip)<br>    <span class="hljs-number">0x100003e03</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">19</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-variable">$0</span>x14, <span class="hljs-number">0x41fa</span>(<span class="hljs-operator">%</span>rip)       ; <span class="hljs-type">SwiftSource</span>.age : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">4</span><br>-&gt;  <span class="hljs-number">0x100003e0e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">30</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edi<br></code></pre></td></tr></table></figure></li>
<li>两者并没有任何差别，无非把值赋值给对应的寄存器</li>
</ul>
<h3 id="SIL角度"><a href="#SIL角度" class="headerlink" title="SIL角度"></a><code>SIL</code>角度</h3><ul>
<li><p><code>swiftc xxx.swift -emit-sil // 生成sil（已优化</code></p>
</li>
<li><p>生成的<code>SIL</code></p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//存储型属性  有初始值</span><br><span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br><br><span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">let</span> name: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br><br><span class="hljs-comment">//全局变量声明</span><br><span class="hljs-comment">// age</span><br>sil_global hidden @<span class="hljs-variable">$s4main3ageSivp</span> : <span class="hljs-variable">$Int</span><br><br><span class="hljs-comment">// name</span><br>sil_global hidden [<span class="hljs-keyword">let</span>] @<span class="hljs-variable">$s4main4nameSivp</span> : <span class="hljs-variable">$Int</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>存储属性</code>在编译的时候，编译器默认会合成<code>get</code>/<code>set</code>方式，而我们<code>访问</code>/<code>赋值</code>存储属性的时候，实际上就是调用<code>get</code>/<code>set</code>。</p>
</li>
<li><p><code>let</code>声明的属性默认不会提供<code>setter</code>,无法调用<code>set</code>方法，因此无法赋值</p>
</li>
</ul>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><blockquote>
<p>类、结构体和枚举也能够定义计算属性，计算属性并不存储值，他们提供 <code>getter</code> 和 <code>setter</code> 来修改和获取值。</p>
</blockquote>
<ul>
<li>测试验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> diameter:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> radius <span class="hljs-operator">*</span> <span class="hljs-number">2</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">set</span> &#123;<br>            radius <span class="hljs-operator">=</span> newValue <br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">10</span>)<br>s.diameter <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="汇编角度-1"><a href="#汇编角度-1" class="headerlink" title="汇编角度"></a>汇编角度</h2><ul>
<li>汇编查看,实际会直接调用<code>setter</code>方法，采用<code>直接派发</code>静态调用的方式<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0x100003b94</span> &lt;+<span class="hljs-number">52</span>&gt;:  movl   $<span class="hljs-number">0x1e</span>, %edi<br>    <span class="hljs-number">0x100003b99</span> &lt;+<span class="hljs-number">57</span>&gt;:  leaq   <span class="hljs-number">0x4460</span>(%rip), %r13        ; SwiftSource.s : SwiftSource.Circle<br>    <span class="hljs-number">0x100003ba0</span> &lt;+<span class="hljs-number">64</span>&gt;:  callq  <span class="hljs-number">0x100003d50</span>               ; SwiftSource.Circle.diameter.setter : Swift.Int at main.swift:<span class="hljs-number">18</span><br></code></pre></td></tr></table></figure></li>
<li><code>setter</code>方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SwiftSource`Circle.diameter.setter:<br>-&gt;  <span class="hljs-number">0x100003d50</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  %rbp<br>    <span class="hljs-number">0x100003d51</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   %rsp, %rbp<br>    <span class="hljs-number">0x100003d54</span> &lt;+<span class="hljs-number">4</span>&gt;:  movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003d5c</span> &lt;+<span class="hljs-number">12</span>&gt;: movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x10</span>(%rbp)<br>    <span class="hljs-number">0x100003d64</span> &lt;+<span class="hljs-number">20</span>&gt;: movq   %rdi, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003d68</span> &lt;+<span class="hljs-number">24</span>&gt;: movq   %r13, <span class="hljs-number">-0x10</span>(%rbp)<br>    <span class="hljs-number">0x100003d6c</span> &lt;+<span class="hljs-number">28</span>&gt;: movq   %rdi, (%r13)<br>    <span class="hljs-number">0x100003d70</span> &lt;+<span class="hljs-number">32</span>&gt;: popq   %rbp<br>    <span class="hljs-number">0x100003d71</span> &lt;+<span class="hljs-number">33</span>&gt;: retq   <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="SIL角度-1"><a href="#SIL角度-1" class="headerlink" title="SIL角度"></a>SIL角度</h2><ul>
<li><p><code>swiftc xxx.swift -emit-sil</code></p>
</li>
<li><p>生成的<code>SIL</code></p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>  <span class="hljs-meta">@_hasStorage</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-keyword">var</span> diameter: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>计算属性非<code>@_hasStorage</code>属性，但是具有<code>getter</code>和<code>sertter</code>方法，不占用实例的内存</li>
</ul>
<h1 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h1><blockquote>
<ul>
<li>属性观察者会观察用来观察属性值的变化：<ul>
<li><code>willSet</code> 当属性将被改变调用，即使这个值与 原有的值相同；</li>
<li><code>didSet</code> 在属性已经改变之后调用。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>测试验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            radius <span class="hljs-operator">=</span> <span class="hljs-number">15</span><br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            radius <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">10</span>)<br>s.radius <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br><span class="hljs-built_in">print</span>(s.radius) <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="汇编角度-2"><a href="#汇编角度-2" class="headerlink" title="汇编角度"></a>汇编角度</h2><ul>
<li><p>调用初始化方式</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100003bda</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>xa, <span class="hljs-operator">%</span>edi<br>    <span class="hljs-number">0x100003bdf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003ea0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.<span class="hljs-keyword">init</span>(radius: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span> at main.swift:<span class="hljs-number">11</span><br><span class="hljs-operator">.....</span><br><br><br><span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Circle</span>.<span class="hljs-keyword">init</span>(radius:):<br>-&gt;  <span class="hljs-number">0x100003ea0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>: pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003ea1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003ea4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">%</span>rax <span class="hljs-comment">//简单赋值</span><br>    <span class="hljs-number">0x100003ea7</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">7</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003ea8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
<li><p>修改值,调用<code>setter</code>方法</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-number">0x100003c04</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">52</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x1e, <span class="hljs-operator">%</span>edi <span class="hljs-comment">//值存在rdi寄存器中</span><br>    <span class="hljs-number">0x100003c09</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">57</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0x43f0</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>r13        ; <span class="hljs-type">SwiftSource</span>.s : <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span><br>-&gt;  <span class="hljs-number">0x100003c10</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">64</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003c70</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.setter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">12</span><br><span class="hljs-operator">......</span><br><br><br><span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Circle</span>.radius.setter:<br>-&gt;  <span class="hljs-number">0x100003c70</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003c71</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003c74</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003c76</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">6</span><span class="hljs-operator">&gt;</span>:  subq   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003c7a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp) <span class="hljs-comment">//r13是对象s</span><br>    <span class="hljs-number">0x100003c7e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">14</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp) <span class="hljs-comment">//30存放在栈空间</span><br>    <span class="hljs-number">0x100003c82</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c8a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">26</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c92</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">34</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c96</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">38</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c9a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">42</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003cc0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.willset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">13</span><br>    <span class="hljs-number">0x100003c9f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">47</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003ca3</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">51</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi <span class="hljs-comment">//这里取栈空间之前存的30值，因此在willSet中修改为15，这里又会赋值为30</span><br>    <span class="hljs-number">0x100003ca7</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">55</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, (<span class="hljs-operator">%</span>r13) <span class="hljs-comment">//这里将30实际赋值给了对象s的radius</span><br>    <span class="hljs-number">0x100003cab</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">59</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003ce0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.didset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">16</span><br>    <span class="hljs-number">0x100003cb0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">64</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003cb4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">68</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003cb6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">70</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003cb7</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">71</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
<li><p><code>willSet</code>方法,这里再对<code>radius</code>进行修改，不会在触发<code>setter</code>方法(因此也不会触发属性观察器)，是直接赋值</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SwiftSource`Circle.radius.willset:<br>-&gt;  <span class="hljs-number">0x100003c00</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  %rbp<br>    <span class="hljs-number">0x100003c01</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   %rsp, %rbp<br>    <span class="hljs-number">0x100003c04</span> &lt;+<span class="hljs-number">4</span>&gt;:  movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003c0c</span> &lt;+<span class="hljs-number">12</span>&gt;: movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x10</span>(%rbp)<br>    <span class="hljs-number">0x100003c14</span> &lt;+<span class="hljs-number">20</span>&gt;: movq   %rdi, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003c18</span> &lt;+<span class="hljs-number">24</span>&gt;: movq   %r13, <span class="hljs-number">-0x10</span>(%rbp)<br>    <span class="hljs-number">0x100003c1c</span> &lt;+<span class="hljs-number">28</span>&gt;: movq   $<span class="hljs-number">0xf</span>, (%r13) <span class="hljs-comment">//将15赋值给了s的radius</span><br>    <span class="hljs-number">0x100003c24</span> &lt;+<span class="hljs-number">36</span>&gt;: popq   %rbp<br>    <span class="hljs-number">0x100003c25</span> &lt;+<span class="hljs-number">37</span>&gt;: retq       <br></code></pre></td></tr></table></figure></li>
<li><p><code>didSetter</code>方法,这里再对<code>radius</code>进行修改，不会在触发<code>setter</code>方法，是直接赋值</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SwiftSource`Circle.radius.didset:<br>-&gt;  <span class="hljs-number">0x100003ce0</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  %rbp<br>    <span class="hljs-number">0x100003ce1</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   %rsp, %rbp<br>    <span class="hljs-number">0x100003ce4</span> &lt;+<span class="hljs-number">4</span>&gt;:  movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003cec</span> &lt;+<span class="hljs-number">12</span>&gt;: movq   %r13, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003cf0</span> &lt;+<span class="hljs-number">16</span>&gt;: movq   $<span class="hljs-number">0x14</span>, (%r13)<br>    <span class="hljs-number">0x100003cf8</span> &lt;+<span class="hljs-number">24</span>&gt;: popq   %rbp <span class="hljs-comment">//将20赋值给了s的radius</span><br>    <span class="hljs-number">0x100003cf9</span> &lt;+<span class="hljs-number">25</span>&gt;: retq   <br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>,<code>willSet</code>、<code>didSetter</code>方法中不会触发，其对于属性的观察器，但是在设置其他属性的，同样会触发属性观察器,下面这种写法会陷入<strong>死循环</strong></p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> diameters:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>  &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            radius <span class="hljs-operator">=</span> <span class="hljs-number">15</span><br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            radius <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            diameters <span class="hljs-operator">=</span> <span class="hljs-number">21</span><br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            diameters <span class="hljs-operator">=</span> <span class="hljs-number">21</span><br>        &#125;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="重写父类观察器"><a href="#重写父类观察器" class="headerlink" title="重写父类观察器"></a>重写父类观察器</h3><blockquote>
<p>和重新方法逻辑一样,其实际调用的<code>getter</code>和<code>setter</code>是父类的方式，只是重写了<code>属性观察器</code></p>
</blockquote>
<ul>
<li>调用顺序是<ol>
<li>子类<code>will set</code></li>
<li>父类<code>will set</code></li>
<li>设置存储值</li>
<li>父类<code>did set</code></li>
<li>子类<code>did set</code></li>
</ol>
</li>
</ul>
<h3 id="汇编查看"><a href="#汇编查看" class="headerlink" title="汇编查看"></a>汇编查看</h3><ul>
<li>验证源码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>           <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>:<span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <br>        &#125;<br>    &#125;<br>   <br>&#125;<br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br>s.radius <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure></li>
<li>汇编查看子类<code>setter</code>，方法中会调用父类的的<code>setter</code>方法，因此会触发父类的设置的属性观察器<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Circle</span>.radius.setter:<br>    <span class="hljs-number">0x100003a90</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003a91</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003a94</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003a96</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">6</span><span class="hljs-operator">&gt;</span>:  subq   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003a9a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003a9e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">14</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003aa2</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003aaa</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">26</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003ab2</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">34</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003ab6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">38</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br>-&gt;  <span class="hljs-number">0x100003aba</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">42</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000039f0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.willset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">22</span><br>    <span class="hljs-number">0x100003abf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">47</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003ac3</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">51</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100003ac6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">54</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003dd4</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_retain<br>    <span class="hljs-number">0x100003acb</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">59</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100003acf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">63</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000037f0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Base</span>.radius.setter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">11</span> <span class="hljs-comment">//这里调用了父类的setter方法，因此会触发父类的属性观察器</span><br>    <span class="hljs-number">0x100003ad4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">68</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003ad8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">72</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100003adb</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">75</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003dce</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_release<br>    <span class="hljs-number">0x100003ae0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">80</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003a10</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.didset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">25</span><br>    <span class="hljs-number">0x100003ae5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">85</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003ae9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">89</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003aeb</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">91</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003aec</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">92</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h1><ul>
<li><p>必须有初始值</p>
</li>
<li><p>延迟存储属性的初始值是在它第一次被使用时才进行计算</p>
</li>
<li><p>用关键字<code>lazy</code>来标识一个延迟存储属性</p>
</li>
<li><p>测试验证</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>&#125;<br><br><br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br><span class="hljs-keyword">let</span> ds <span class="hljs-operator">=</span> s.radius<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="SIL查看"><a href="#SIL查看" class="headerlink" title="SIL查看"></a>SIL查看</h2><ul>
<li><p><code>swiftc xxx.swift -emit-sil</code></p>
</li>
<li><p>生成的<code>SIL</code></p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">var</span> <span class="hljs-variable">$__lazy_storage_</span><span class="hljs-variable">$_radius</span>: <span class="hljs-type">Int</span>? &#123; <span class="hljs-keyword">get</span>       <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">init</span>()</span><br>  <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>懒加载属性第一次访问前没有值，访问后就有值，其本质就是在编译后生成一个可选型存储属性</p>
</li>
</ul>
<h3 id="getter方法分析"><a href="#getter方法分析" class="headerlink" title="getter方法分析"></a>getter方法分析</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Circle.radius.getter</span><br>sil hidden [lazy_getter] [noinline] @<span class="hljs-variable">$s4main6CircleV6radiusSivg</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@inout</span> <span class="hljs-type">Circle</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br><span class="hljs-comment">// %0 &quot;self&quot;                                      // users: %2, %12, %1</span><br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Circle</span>): <span class="hljs-comment">//初始化的时候</span><br>  debug_value <span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Circle</span>, <span class="hljs-keyword">var</span>, name <span class="hljs-string">&quot;self&quot;</span>, argno <span class="hljs-number">1</span>, implicit, expr op_deref <span class="hljs-comment">// id: %1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> struct_element_addr <span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Circle</span>, #<span class="hljs-type">Circle</span>.<span class="hljs-variable">$__lazy_storage_</span><span class="hljs-variable">$_radius</span> <span class="hljs-comment">// user: %3</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span><span class="hljs-number">2</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">Int</span>&gt;                  <span class="hljs-comment">// user: %4 //取出内存中可选Int?的值</span><br>  switch_enum <span class="hljs-operator">%</span><span class="hljs-number">3</span> : <span class="hljs-variable">$Optional</span><span class="hljs-operator">&lt;</span><span class="hljs-type">Int</span><span class="hljs-operator">&gt;</span>, <span class="hljs-keyword">case</span> #<span class="hljs-type">Optional</span>.some<span class="hljs-operator">!</span>enumelt: bb1, <span class="hljs-keyword">case</span> #<span class="hljs-type">Optional</span>.none<span class="hljs-operator">!</span>enumelt: bb2 <span class="hljs-comment">// id: %4 //如果有值则走bb1,没有值走bb2</span><br><br><span class="hljs-comment">// %5       有值已经加载过                          // users: %7, %6</span><br>bb1(<span class="hljs-operator">%</span><span class="hljs-number">5</span> : <span class="hljs-variable">$Int</span>):                                   <span class="hljs-comment">// Preds: bb0 </span><br>  debug_value <span class="hljs-operator">%</span><span class="hljs-number">5</span> : <span class="hljs-variable">$Int</span>, <span class="hljs-keyword">let</span>, name <span class="hljs-string">&quot;tmp1&quot;</span>, implicit <span class="hljs-comment">// id: %6</span><br>  br bb3(<span class="hljs-operator">%</span><span class="hljs-number">5</span> : <span class="hljs-variable">$Int</span>)                               <span class="hljs-comment">// id: %7</span><br><br>bb2: 没有值，未加载过                              <span class="hljs-comment">// Preds: bb0</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int64</span>, <span class="hljs-number">9</span>          <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int</span> (%8 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int64</span>)          // <span class="hljs-title">users</span>: %16, %11, %10</span><br><span class="hljs-class">  <span class="hljs-title">debug_value</span> %9 : <span class="hljs-title">$Int</span>, <span class="hljs-title">let</span>, <span class="hljs-title">name</span> &quot;<span class="hljs-title">tmp2</span>&quot;, <span class="hljs-title">implicit</span> // <span class="hljs-title">id</span>: %10</span><br><span class="hljs-class">  %11 = <span class="hljs-title">enum</span> <span class="hljs-title">$Optional</span>&lt;<span class="hljs-title">Int</span>&gt;, #<span class="hljs-title">Optional</span>.some!<span class="hljs-title">enumelt</span>, %9 : <span class="hljs-title">$Int</span> // <span class="hljs-title">user</span>: %14</span><br><span class="hljs-class">  %12 = <span class="hljs-title">begin_access</span> [<span class="hljs-title">modify</span>] [<span class="hljs-title">static</span>] %0 : <span class="hljs-title">$</span>*<span class="hljs-title">Circle</span> // <span class="hljs-title">users</span>: %15, %13</span><br><span class="hljs-class">  %13 = <span class="hljs-title">struct_element_addr</span> %12 : <span class="hljs-title">$</span>*<span class="hljs-title">Circle</span>, #<span class="hljs-title">Circle</span>.<span class="hljs-title">$__lazy_storage_$_radius</span> // <span class="hljs-title">user</span>: %14</span><br><span class="hljs-class">  <span class="hljs-title">store</span> %11 <span class="hljs-title">to</span> %13 : <span class="hljs-title">$</span>*<span class="hljs-title">Optional</span>&lt;<span class="hljs-title">Int</span>&gt;              // <span class="hljs-title">id</span>: %14</span><br><span class="hljs-class">  <span class="hljs-title">end_access</span> %12 : <span class="hljs-title">$</span>*<span class="hljs-title">Circle</span>                       // <span class="hljs-title">id</span>: %15</span><br><span class="hljs-class">  <span class="hljs-title">br</span> <span class="hljs-title">bb3</span>(%9 : <span class="hljs-title">$Int</span>)                               // <span class="hljs-title">id</span>: %16</span><br><span class="hljs-class"></span><br><span class="hljs-class">// %17  统一返回<span class="hljs-title">Int</span>                                // <span class="hljs-title">user</span>: %18</span><br><span class="hljs-class"><span class="hljs-title">bb3</span>(%17 : <span class="hljs-title">$Int</span>):                                  // <span class="hljs-title">Preds</span>: <span class="hljs-title">bb2</span> <span class="hljs-title">bb1</span></span><br><span class="hljs-class">  <span class="hljs-title">return</span> %17 : <span class="hljs-title">$Int</span>                               // <span class="hljs-title">id</span>: %18</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">$s4main6CircleV6radiusSivg</span>&#x27;</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure>
<ol>
<li>在初始化的时候,<code>$__lazy_storage_$_radius</code>设置的<code>nil</code></li>
<li>拿到生成的属性 <code>$__lazy_storage_$_radius</code>的地址，然后去<code>switch</code>：如果有值，走<code>bb1</code>的代码块；如果没有值走<code>bb2</code>代码块</li>
<li><code>bb2</code>没有加载过：去构建初始值，给到变量$<code>$__lazy_storage_$_radius</code></li>
<li><code>bb1</code>已加载过：已经有值了，直接给他返回出去</li>
</ol>
<h1 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h1><blockquote>
<ul>
<li>类型属性本质上就是一个全局变量</li>
<li>类型属性只会被初始化一次,（使用的时候）</li>
</ul>
</blockquote>
<ul>
<li>测试验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>&#125;<br><span class="hljs-type">Circle</span>.radius <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="SIL查看-1"><a href="#SIL查看-1" class="headerlink" title="SIL查看"></a>SIL查看</h2><ul>
<li><code>swiftc xxx.swift -emit-silgen</code></li>
<li>编译后的<code>sil</code>里多了两个全局变量<ul>
<li><code>sil_global private @$s4main6CircleV6radius_Wz</code>,<code>token for radius</code></li>
<li><code>$s4main6CircleV6radiusSivpZ</code>,<code>static Circle.radius</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>  <span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">init</span>()</span><br>&#125;<br><br><span class="hljs-comment">// one-time initialization token for radius</span><br>sil_global <span class="hljs-keyword">private</span> @<span class="hljs-variable">$s4main6CircleV6radius_Wz</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Word</span><br><br><span class="hljs-comment">// static Circle.radius</span><br>sil_global hidden @<span class="hljs-variable">$s4main6CircleV6radiusSivpZ</span> : <span class="hljs-variable">$Int</span> <span class="hljs-operator">=</span> &#123;<br>  <span class="hljs-operator">%</span><span class="hljs-number">0</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int64</span>, <span class="hljs-number">9</span>          <span class="hljs-comment">// user: %1</span><br>  <span class="hljs-operator">%</span>initval <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int</span> (%0 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int64</span>)</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>main</code>函数中，<code>@$s4main6CircleV6radiusSivau</code>函数做了一个全局变量内存地址的转换  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// main</span><br>sil [ossa] <span class="hljs-keyword">@main</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Int32</span>, <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="hljs-type">Int32</span> &#123;<br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$Int32</span>, <span class="hljs-operator">%</span><span class="hljs-number">1</span> : <span class="hljs-variable">$UnsafeMutablePointer</span><span class="hljs-operator">&lt;</span><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;<span class="hljs-operator">&gt;</span>):<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">Circle</span>.<span class="hljs-keyword">Type</span><br>  <span class="hljs-comment">// function_ref Circle.radius.unsafeMutableAddressor</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$s4main6CircleV6radiusSivau</span> : $<span class="hljs-meta">@convention</span>(thin) () -&gt; <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span> <span class="hljs-comment">// user: %4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">3</span>() : $<span class="hljs-meta">@convention</span>(thin) () -&gt; <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span> <span class="hljs-comment">// user: %5</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> pointer_to_address <span class="hljs-operator">%</span><span class="hljs-number">4</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span> to [strict] $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// user: %10</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-number">20</span>    <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>                   <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-comment">// function_ref Int.init(_builtinIntegerLiteral:)</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$sSi22_builtinIntegerLiteralSiBI_tcfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">8</span>(<span class="hljs-operator">%</span><span class="hljs-number">6</span>, <span class="hljs-operator">%</span><span class="hljs-number">7</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-comment">// user: %11</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> begin_access [modify] [<span class="hljs-keyword">dynamic</span>] <span class="hljs-operator">%</span><span class="hljs-number">5</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// users: %12, %11</span><br>  assign <span class="hljs-operator">%</span><span class="hljs-number">9</span> to <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span>                        <span class="hljs-comment">// id: %11</span><br>  end_access <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span>                          <span class="hljs-comment">// id: %12</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int32</span>, <span class="hljs-number">0</span>         <span class="hljs-comment">// user: %14</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int32</span> (%13 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int32</span>)      // <span class="hljs-title">user</span>: %15</span><br><span class="hljs-class">  <span class="hljs-title">return</span> %14 : <span class="hljs-title">$Int32</span>                             // <span class="hljs-title">id</span>: %15</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">main</span>&#x27;</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure></li>
<li>全局变量内存地址的转换的函数<code>s4main6CircleV6radiusSivau</code>,<code>builtin &quot;once&quot;</code>底层源码调用的是<code>swift_once</code>，其底层实际是<code>dispatch_once</code>，这里的<code>token</code>则是<code>dispatch_once_t</code>,这里返回全局变量的地址  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Circle.radius.unsafeMutableAddressor</span><br>sil hidden [global_init] [ossa] @<span class="hljs-variable">$s4main6CircleV6radiusSivau</span> : $<span class="hljs-meta">@convention</span>(thin) () -&gt; <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span> &#123;<br>bb0:<br>    <span class="hljs-comment">//拿到token的全局变量</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">0</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s4main6CircleV6radius_Wz</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span> <span class="hljs-comment">// user: %1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> address_to_pointer <span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span> to <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span> <span class="hljs-comment">// user: %3</span><br>  <span class="hljs-comment">// function_ref one-time initialization function for radius //</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$s4main6CircleV6radius_WZ</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>) -&gt; () <span class="hljs-comment">// user: %3</span><br>  <span class="hljs-comment">//builtin &quot;once&quot;中执行s4main6CircleV6radius_WZ方法</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> builtin <span class="hljs-string">&quot;once&quot;</span>(<span class="hljs-operator">%</span><span class="hljs-number">1</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-operator">%</span><span class="hljs-number">2</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>) -&gt; ()) : $()<br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s4main6CircleV6radiusSivpZ</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// user: %5</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> address_to_pointer <span class="hljs-operator">%</span><span class="hljs-number">4</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> to <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span> <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span>                 <span class="hljs-comment">// id: %6</span><br>&#125; <span class="hljs-comment">// end sil function &#x27;$s4main6CircleV6radiusSivau&#x27;</span><br><br></code></pre></td></tr></table></figure></li>
<li><code>s4main6CircleV6radius_WZ</code>方法，由<code>builtin &quot;once&quot;</code>保证只执行一次。在该方法中对<code>radius</code>进行了赋值。并且该赋值操作只在使用的时候才会进行操作  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// one-time initialization function for radius</span><br>sil <span class="hljs-keyword">private</span> [global_init_once_fn] [ossa] @<span class="hljs-variable">$s4main6CircleV6radius_WZ</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>) -&gt; () &#123;<br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span>):<br>  alloc_global @<span class="hljs-variable">$s4main6CircleV6radiusSivpZ</span>       <span class="hljs-comment">// id: %1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s4main6CircleV6radiusSivpZ</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// user: %7</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-number">9</span>     <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>                   <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-comment">// function_ref Int.init(_builtinIntegerLiteral:)</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$sSi22_builtinIntegerLiteralSiBI_tcfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">5</span>(<span class="hljs-operator">%</span><span class="hljs-number">3</span>, <span class="hljs-operator">%</span><span class="hljs-number">4</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-comment">// user: %7</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">6</span> to [trivial] <span class="hljs-operator">%</span><span class="hljs-number">2</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span>                <span class="hljs-comment">// id: %7</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> tuple ()                                   <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span> : $()                                 <span class="hljs-comment">// id: %9</span><br>&#125; <span class="hljs-comment">// end sil function &#x27;$s4main6CircleV6radius_WZ&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="属性源码分析"><a href="#属性源码分析" class="headerlink" title="属性源码分析"></a>属性源码分析</h1><blockquote>
<p>在<code>swift类分析</code>中介绍了<code>Metadata</code>的元数据结构，和<code>typeDescriptor</code>类的描述  </p>
</blockquote>
<ol>
<li><code>Metadata</code>的元数据结构 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Metadata</span> </span>&#123; <br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <br>    <span class="hljs-keyword">var</span> superClass: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span> <br>    <span class="hljs-keyword">var</span> cacheData: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) <br>    <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span> <br>    <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <br>    <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <br>    <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <br>    <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutableRawPointer</span> <br>    <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>typeDescriptor</code>是记录类的描述： <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassDescriptor</span></span>&#123; <br><br>     <span class="hljs-comment">//继承至TargetContextDescriptor</span><br>      <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>      <br>      <span class="hljs-comment">//继承至TargetTypeContextDescriptor</span><br>      <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;   <span class="hljs-comment">// class/struct/enum 的名称</span><br>      <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>      <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt; <span class="hljs-comment">//属性描述器</span><br><br>      <span class="hljs-comment">//TargetClassDescriptor具有的</span><br>      <span class="hljs-keyword">var</span> superClassType: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;  <span class="hljs-comment">//父类类型指针</span><br>      <span class="hljs-keyword">var</span> metadataNegativeSizeInWords: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> metadataPositiveSizeInWords: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> numImmediateMembers: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 每一个属性值距离当前实例对象地址的偏移量</span><br>      <span class="hljs-keyword">var</span> <span class="hljs-type">Offset</span>: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-comment">// var size: UInt32 </span><br>      <span class="hljs-comment">// V-Table  (methods) </span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>其中 <code>fieldDescriptor</code> 记录了当前的属性信息，经分析后<code>fieldDescriptor</code> (位于<code>swift-main/include/swift/RemoteInspection/Records.h</code>)在源码中的数据结构，下面对<code>FieldDescriptor</code>属性描述器进行分析</li>
</ol>
<h2 id="FieldDescriptor属性描述器"><a href="#FieldDescriptor属性描述器" class="headerlink" title="FieldDescriptor属性描述器"></a><code>FieldDescriptor属性描述器</code></h2><ul>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Field descriptors contain a collection of field records for a single</span><br><span class="hljs-comment">// class, struct or enum declaration.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldDescriptor</span> &#123;</span><br><span class="hljs-comment">//属性列表紧跟之后，可以认为是连着一起的，认为FieldDescriptor的属性是包含了一个属性列表</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> FieldRecord *<span class="hljs-title">getFieldRecordBuffer</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> FieldRecord *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>);<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">const</span> RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt; MangledTypeName;<br>  <span class="hljs-keyword">const</span> RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt; Superclass;<br><br>  <span class="hljs-built_in">FieldDescriptor</span>() = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-keyword">const</span> FieldDescriptorKind Kind;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> FieldRecordSize;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> NumFields;<br><br>  <span class="hljs-keyword">using</span> const_iterator = FieldRecordIterator;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEnum</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Kind == FieldDescriptorKind::Enum ||<br>            Kind == FieldDescriptorKind::MultiPayloadEnum);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Kind == FieldDescriptorKind::Class ||<br>            Kind == FieldDescriptorKind::ObjCClass);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isProtocol</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Kind == FieldDescriptorKind::Protocol ||<br>            Kind == FieldDescriptorKind::ClassProtocol ||<br>            Kind == FieldDescriptorKind::ObjCProtocol);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStruct</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Kind == FieldDescriptorKind::Struct;<br>  &#125;<br><br>  <span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> Begin = <span class="hljs-built_in">getFieldRecordBuffer</span>();<br>    <span class="hljs-keyword">auto</span> End = Begin + NumFields;<br>    <span class="hljs-keyword">return</span> const_iterator &#123; Begin, End &#125;;<br>  &#125;<br><br>  <span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> Begin = <span class="hljs-built_in">getFieldRecordBuffer</span>();<br>    <span class="hljs-keyword">auto</span> End = Begin + NumFields;<br>    <span class="hljs-keyword">return</span> const_iterator &#123; End, End &#125;;<br>  &#125;<br>    <span class="hljs-comment">//返回属性列表</span><br>  <span class="hljs-function">llvm::ArrayRef&lt;FieldRecord&gt; <span class="hljs-title">getFields</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">getFieldRecordBuffer</span>(), NumFields&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasMangledTypeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> MangledTypeName;<br>  &#125;<br><br>  <span class="hljs-function">StringRef <span class="hljs-title">getMangledTypeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Demangle::<span class="hljs-built_in">makeSymbolicMangledNameStringRef</span>(MangledTypeName.<span class="hljs-built_in">get</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasSuperclass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Superclass;<br>  &#125;<br><br>  <span class="hljs-function">StringRef <span class="hljs-title">getSuperclass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Demangle::<span class="hljs-built_in">makeSymbolicMangledNameStringRef</span>(Superclass.<span class="hljs-built_in">get</span>());<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>其结构可以还原如下，接下来查看具体属性的结构<code>FieldRecord</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldDescriptor</span> </span>&#123; <br>    <span class="hljs-keyword">var</span> mangledTypeName : <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 混写后的类型名称</span><br>    <span class="hljs-keyword">var</span> superclass : <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span> : uint16 <span class="hljs-comment">// 判断是结构体，类，还是枚举，协议等</span><br>    <span class="hljs-keyword">var</span> fieldRecordSize:uint16 <br>    <span class="hljs-keyword">var</span> numFields:uint32 <span class="hljs-comment">// 属性个数</span><br>    <span class="hljs-keyword">var</span> fields: <span class="hljs-type">FiledRecordBuffer</span>&lt;<span class="hljs-type">FieldRecord</span>&gt;  <span class="hljs-comment">// 记录了每个属性的信息</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FiledRecordBuffer</span>&lt;<span class="hljs-title">Element</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> element: <span class="hljs-type">Element</span><br><br>     <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buffer</span>(<span class="hljs-params">n</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeBufferPointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>             <span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span>.withMemoryRebound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>, capacity:<span class="hljs-number">1</span>) &#123;<span class="hljs-variable">$0</span>&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeBufferPointer</span>(start: ptr, count: n)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span>(<span class="hljs-params">of</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating:      <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>).assumingMemoryBound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>).advanced(by: i))<br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="FieldRecord"><a href="#FieldRecord" class="headerlink" title="FieldRecord"></a><code>FieldRecord</code></h3><ul>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldRecord</span> &#123;</span><br>  <span class="hljs-keyword">const</span> FieldRecordFlags Flags;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">const</span> RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt; MangledTypeName;<br>  <span class="hljs-keyword">const</span> RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt; FieldName;<br><br>  <span class="hljs-built_in">FieldRecord</span>() = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasMangledTypeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> MangledTypeName;<br>  &#125;<br><br>  <span class="hljs-function">StringRef <span class="hljs-title">getMangledTypeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Demangle::<span class="hljs-built_in">makeSymbolicMangledNameStringRef</span>(MangledTypeName.<span class="hljs-built_in">get</span>());<br>  &#125;<br><br>  <span class="hljs-function">StringRef <span class="hljs-title">getFieldName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> FieldName.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIndirectCase</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isIndirectCase</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVar</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isVar</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>其结构还原的结构体如下,主要这里的类型和名称实际上都是<code>间距指针</code>，而非直接指针  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldRecord</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> mangledTypeName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 属性的类型</span><br>    <span class="hljs-keyword">var</span> fieldName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UInt8</span>&gt; <span class="hljs-comment">// 属性的名称</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="验证Mach-o位置"><a href="#验证Mach-o位置" class="headerlink" title="验证Mach-o位置"></a>验证Mach-o位置</h2><ul>
<li>测试代码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-keyword">let</span> diameter:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li><p>在<code>data</code>区找到<code>__TEXT,__swift5_types</code> 这是记录所有的 <code>struct/enum/类</code>的<code>Descriptor</code>的信息,这里查找<code>typeDescriptor</code><br> <img src="1.png"></p>
</li>
<li><p>拿到<code>Circle类</code>的<code>Descriptor</code>在 <code>Mach-O</code> 里的位置:</p>
<pre><code> <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x3F8C</span> <span class="hljs-operator">+</span> <span class="hljs-number">0xFFFFFF2C</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x100003EB8</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>Dscriptor</code>在<code>mach-o</code>的<code>data</code>区的偏移量，需要再减去<code>_pagezero</code>内存地址：</p>
<pre><code> <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100003EB8</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x100000000</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3EB8</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>在<code>data</code>区找到 <code>__TEXT,__const</code>里边，去找<code>0x3EB8</code>的位置：<br><img src="2.png"></p>
<ul>
<li>接下来要找到 <code>fieldDescriptor</code>它的地址，因为<code>fieldDescriptor</code>在<code>TargetClassDescriptor</code>(<code>typeDescriptor</code>)的数据结构前面还有<code>4</code>个<code>UInt32</code>的成员,<code>fieldDescriptor</code>在<code>Mach-O</code>的信息是<pre><code>  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x3EB8</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x10</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x9c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3F64</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>而属性存放<code>data</code>区的<code>__TEXT,__swift5_fieldmd</code>，并在上面找到<code>0x3F64</code><br> <img src="3.png"></p>
</li>
<li><p><code>0x3F64</code>开始是<code>FieldDescriptor</code>属性描述的成员内容</p>
</li>
<li><p><code>FieldRecord</code>的数据结构：</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldRecord</span></span>&#123; <br>    <span class="hljs-type">Flags</span>           uint32 <span class="hljs-comment">// 标志位</span><br>    <span class="hljs-type">MangledTypeName</span> int32 <span class="hljs-comment">// 属性的类型名称</span><br>    <span class="hljs-type">FieldName</span>       int32 <span class="hljs-comment">// 属性名称</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>第一个<code>FieldRecord</code> 的<code>FieldName</code>属性名称在<code>Mach-O</code>上的信息<code>0x100003F53</code>减去基地址，<code>0x3F53</code><br> <img src="4.png"></p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x3F74</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x8</span> <span class="hljs-operator">+</span> <span class="hljs-number">0xFFFFFFD7</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x100003F53</span><br></code></pre></td></tr></table></figure></li>
<li><p>在去找<code>data</code>区中的 <code>__TEXT,__swift5_reflstr</code>找到<code>0x3F53</code>,其上字符串正是<code>radius</code><br><img src="5.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>swift类分析</title>
    <url>/2023/05/13/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/swift%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h1><h2 id="纯swift类"><a href="#纯swift类" class="headerlink" title="纯swift类"></a>纯<code>swift</code>类</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Man&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Person</code>是纯<code>swift</code>类，在创建实例的时候，会调用<code>SwiftTest.Person.__allocating_init()</code>；;底层会调用<code>swift_allocObject</code>和<code>SwiftTest.Person.init()</code>。  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Person</span>.__allocating_init():<br>-&gt;  <span class="hljs-number">0x100004580</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004581</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004584</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100004586</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">6</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x100004587</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">7</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x10000458a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>esi<br>    <span class="hljs-number">0x10000458f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x7, <span class="hljs-operator">%</span>edx<br>    <span class="hljs-number">0x100004594</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">20</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000077d8</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_allocObject<br>    <span class="hljs-number">0x100004599</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x10000459c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">28</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000045d0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Person</span>.<span class="hljs-keyword">init</span>() -&gt; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Person</span> at main.swift:<span class="hljs-number">11</span><br>    <span class="hljs-number">0x1000045a1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">33</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x8, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x1000045a5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">37</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x1000045a7</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">39</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x1000045a8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">40</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="继承NSObject的swift类"><a href="#继承NSObject的swift类" class="headerlink" title="继承NSObject的swift类"></a>继承<code>NSObject</code>的<code>swift</code>类</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:<span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Man&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>Person</code>是继承<code>NSObject</code>的类，在创建实例的时候，会调用<code>SwiftTest.Person.__allocating_init()</code>;底层会调用<code>objc_allocWithZone</code>和<code>objc_msgSend</code> 发送<code>init</code>消息。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Person</span>.__allocating_init():<br>-&gt;  <span class="hljs-number">0x100004420</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004421</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004424</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100004427</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">7</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x1000077a2</span>               ; symbol stub <span class="hljs-keyword">for</span>: objc_allocWithZone<br>    <span class="hljs-number">0x10000442c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">12</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x10000442f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-number">0x7c62</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rsi        ; <span class="hljs-string">&quot;init&quot;</span><br>    <span class="hljs-number">0x100004436</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">22</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000077a8</span>               ; symbol stub <span class="hljs-keyword">for</span>: objc_msgSend<br>    <span class="hljs-number">0x10000443b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">27</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x10000443c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">28</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure>

<h1 id="swift源码"><a href="#swift源码" class="headerlink" title="swift源码"></a>swift源码</h1><h2 id="swift-allocObject"><a href="#swift-allocObject" class="headerlink" title="swift_allocObject"></a><code>swift_allocObject</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> HeapObject *_swift_allocObject_(HeapMetadata <span class="hljs-keyword">const</span> *metadata,<br>                                       <span class="hljs-keyword">size_t</span> requiredSize,<br>                                       <span class="hljs-keyword">size_t</span> requiredAlignmentMask) &#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isAlignmentMask</span>(requiredAlignmentMask));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SWIFT_STDLIB_HAS_MALLOC_TYPE</span><br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(<span class="hljs-built_in">swift_slowAllocTyped</span>(<br>      requiredSize, requiredAlignmentMask, <span class="hljs-built_in">getMallocTypeId</span>(metadata)));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(<br>      <span class="hljs-built_in">swift_slowAlloc</span>(requiredSize, requiredAlignmentMask));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this relies on the C++17 guaranteed semantics of no null-pointer</span><br>  <span class="hljs-comment">// check on the placement new allocator which we have observed on Windows,</span><br>  <span class="hljs-comment">// Linux, and macOS.</span><br>  ::<span class="hljs-keyword">new</span> (object) <span class="hljs-built_in">HeapObject</span>(metadata);<br><br>  <span class="hljs-comment">// If leak tracking is enabled, start tracking this object.</span><br>  <span class="hljs-built_in">SWIFT_LEAKS_START_TRACKING_OBJECT</span>(object);<br><br>  <span class="hljs-built_in">SWIFT_RT_TRACK_INVOCATION</span>(object, swift_allocObject);<br><br>  <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><blockquote>
<p><code>swift</code>对象内存分配: <code>__allocating_init</code> -&gt; <code>swift_allocObject</code> -&gt; <code>_swift_allocObject_</code> -&gt; <code>swift_slowAlloc</code> -&gt; <code>malloc</code></p>
</blockquote>
<ul>
<li>调用了<code>swift_slowAlloc</code>函数返回了一个<code>堆对象</code>。这个函数位于<code>Heap.cpp</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">swift::swift_slowAlloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> alignMask)</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> *p;<br>  <span class="hljs-comment">// This check also forces &quot;default&quot; alignment to use AlignedAlloc.</span><br>  <span class="hljs-keyword">if</span> (alignMask &lt;= MALLOC_ALIGN_MASK) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__APPLE__) &amp;&amp; SWIFT_STDLIB_HAS_DARWIN_LIBMALLOC</span><br>    p = <span class="hljs-built_in">malloc_zone_malloc</span>(<span class="hljs-built_in">DEFAULT_ZONE</span>(), size);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    p = <span class="hljs-built_in">malloc</span>(size);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">size_t</span> alignment = <span class="hljs-built_in">computeAlignment</span>(alignMask);<br>    p = <span class="hljs-built_in">AlignedAlloc</span>(size, alignment);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!p) swift::<span class="hljs-built_in">crash</span>(<span class="hljs-string">&quot;Could not allocate memory.&quot;</span>);<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>在<code>p = malloc(size)</code>; 进行了内存分配，最后并返回了<code>p</code></li>
</ul>
<h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><blockquote>
<p>调用了<code>::new (object) HeapObject(metadata);</code>对<code>objc</code>对象进行初始化</p>
</blockquote>
<ul>
<li><code>HeapObject</code>的结构<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">HeapObject</span><span class="hljs-params">(HeapMetadata <span class="hljs-keyword">const</span> *newMetadata)</span> </span><br><span class="hljs-function">    : metadata(newMetadata)</span><br><span class="hljs-function">    , refCounts(InlineRefCounts::Initialized)</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>swift</code>对象的内存结构： <code>HeapObject</code> ，有两个属性各占<code>8</code>字节： <code>Metadata</code> 和 <code>RefCount</code>，默认占用 <code>16</code> 字节大小。</li>
</ul>
<h2 id="TargetHeapMetadata对象分析"><a href="#TargetHeapMetadata对象分析" class="headerlink" title="TargetHeapMetadata对象分析"></a><code>TargetHeapMetadata</code>对象分析</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> HeapMetadata = TargetHeapMetadata&lt;InProcess&gt;;<br><br><span class="hljs-comment">/// The common structure of all metadata for heap-allocated types.  A</span><br><span class="hljs-comment">/// pointer to one of these can be retrieved by loading the &#x27;isa&#x27;</span><br><span class="hljs-comment">/// field of any heap object, whether it was managed by Swift or by</span><br><span class="hljs-comment">/// Objective-C.  However, when loading from an Objective-C object,</span><br><span class="hljs-comment">/// this metadata may not have the heap-metadata header, and it may</span><br><span class="hljs-comment">/// not be the Swift type metadata for the object&#x27;s dynamic type.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetHeapMetadata</span> :</span> TargetMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> HeaderType = TargetHeapMetadataHeader&lt;Runtime&gt;;<br><br>  <span class="hljs-built_in">TargetHeapMetadata</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetHeapMetadata</span><span class="hljs-params">(MetadataKind kind)</span></span><br><span class="hljs-function">    : TargetMetadata&lt;Runtime&gt;(kind) &#123;</span>&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetHeapMetadata</span><span class="hljs-params">(TargetAnyClassMetadataObjCInterop&lt;Runtime&gt; *isa)</span></span><br><span class="hljs-function">    : TargetMetadata&lt;Runtime&gt;(isa) &#123;</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>swift</code>类的 <code>HeapMetadata / TargetHeapMetadata</code> 是通过 <code>kind</code>进行初始化的。<code>TargetMatedata</code>中只有一个属性<code>Kind</code>,其结构实际为  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span>:<span class="hljs-type">StoredPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>MetadataKind</code>的定义：  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">_MetadataKind</span>: <span class="hljs-title">UInt</span> </span>&#123;<br>  <span class="hljs-comment">// With &quot;flags&quot;:</span><br>  <span class="hljs-comment">// runtimePrivate = 0x100</span><br>  <span class="hljs-comment">// nonHeap = 0x200</span><br>  <span class="hljs-comment">// nonType = 0x400</span><br>  <br>  <span class="hljs-keyword">case</span> `class` <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">case</span> `struct` <span class="hljs-operator">=</span> <span class="hljs-number">0x200</span>     <span class="hljs-comment">// 0 | nonHeap</span><br>  <span class="hljs-keyword">case</span> `enum` <span class="hljs-operator">=</span> <span class="hljs-number">0x201</span>       <span class="hljs-comment">// 1 | nonHeap</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-keyword">optional</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x202</span>     <span class="hljs-comment">// 2 | nonHeap</span><br>  <span class="hljs-keyword">case</span> foreignClass <span class="hljs-operator">=</span> <span class="hljs-number">0x203</span> <span class="hljs-comment">// 3 | nonHeap</span><br>  <span class="hljs-keyword">case</span> opaque <span class="hljs-operator">=</span> <span class="hljs-number">0x300</span>       <span class="hljs-comment">// 0 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> tuple <span class="hljs-operator">=</span> <span class="hljs-number">0x301</span>        <span class="hljs-comment">// 1 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> function <span class="hljs-operator">=</span> <span class="hljs-number">0x302</span>     <span class="hljs-comment">// 2 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> existential <span class="hljs-operator">=</span> <span class="hljs-number">0x303</span>  <span class="hljs-comment">// 3 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> metatype <span class="hljs-operator">=</span> <span class="hljs-number">0x304</span>     <span class="hljs-comment">// 4 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> objcClassWrapper <span class="hljs-operator">=</span> <span class="hljs-number">0x305</span>     <span class="hljs-comment">// 5 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> existentialMetatype <span class="hljs-operator">=</span> <span class="hljs-number">0x306</span>  <span class="hljs-comment">// 6 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> heapLocalVariable <span class="hljs-operator">=</span> <span class="hljs-number">0x400</span>    <span class="hljs-comment">// 0 | nonType</span><br>  <span class="hljs-keyword">case</span> heapGenericLocalVariable <span class="hljs-operator">=</span> <span class="hljs-number">0x500</span> <span class="hljs-comment">// 0 | nonType | runtimePrivate</span><br>  <span class="hljs-keyword">case</span> errorObject <span class="hljs-operator">=</span> <span class="hljs-number">0x501</span>  <span class="hljs-comment">// 1 | nonType | runtimePrivate</span><br>  <span class="hljs-keyword">case</span> unknown <span class="hljs-operator">=</span> <span class="hljs-number">0xffff</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">type</span>: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> v <span class="hljs-operator">=</span> _metadataKind(type)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> _MetadataKind(rawValue: v) &#123;<br>      <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> result<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> .unknown<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><code>TargetMetadata</code>里面的函数,获取<code>Metadata</code>描述的<code>context</code>,这个函数的作用是根据<code>kind</code>的不同类型，去获取描述器<code>descriptor</code>。所以可以分析出:<ul>
<li>对于<code>class</code>来说它的<code>Metadata</code>是<code>TargetClassMetadata</code>;</li>
<li>对于<code>struct</code>、<code>enum</code>、<code>optional</code>来说它的<code>Metadata</code>是<code>TargetValueMetadata</code>，但是它们都有自己类型的<code>Metadata</code>去继承于<code>TargetValueMetadata</code>。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">/// Get the nominal type descriptor if this metadata describes a nominal type,</span><br><span class="hljs-comment">/// or return null if it does not.</span><br><span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, TargetTypeContextDescriptor&gt;</span><br><span class="hljs-function"><span class="hljs-title">getTypeContextDescriptor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (<span class="hljs-built_in">getKind</span>()) &#123;<br>  <span class="hljs-keyword">case</span> MetadataKind::Class: &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cls =<br>      <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TargetClassMetadataType&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (!cls-&gt;<span class="hljs-built_in">isTypeMetadata</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (cls-&gt;<span class="hljs-built_in">isArtificialSubclass</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> cls-&gt;<span class="hljs-built_in">getDescription</span>();<br>  &#125;<br>  <span class="hljs-keyword">case</span> MetadataKind::Struct:<br>  <span class="hljs-keyword">case</span> MetadataKind::Enum:<br>  <span class="hljs-keyword">case</span> MetadataKind::Optional:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TargetValueMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>        -&gt;Description;<br>  <span class="hljs-keyword">case</span> MetadataKind::ForeignClass:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TargetForeignClassMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>        -&gt;Description;<br>  <span class="hljs-keyword">case</span> MetadataKind::ForeignReferenceType:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TargetForeignReferenceTypeMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>        -&gt;Description;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="TargetClassMetadata"><a href="#TargetClassMetadata" class="headerlink" title="TargetClassMetadata"></a>TargetClassMetadata</h3><ul>
<li><code>TargetClassMetadataType</code>即<code>TargetClassMetadata</code>是所有<code>swift</code>所有<code>类类型</code>的最终<code>基类</code>，类似于<code>OC</code>中的<code>objc_class</code>。  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> TargetClassMetadata = TargetClassMetadataType&lt;Runtime&gt;;<br><span class="hljs-comment">/// The structure of all class metadata.  This structure is embedded</span><br><span class="hljs-comment">/// directly within the class&#x27;s heap metadata structure and therefore</span><br><span class="hljs-comment">/// cannot be extended without an ABI break.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Note that the layout of this type is compatible with the layout of</span><br><span class="hljs-comment">/// an Objective-C class.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// If the Runtime supports Objective-C interoperability, this class inherits</span><br><span class="hljs-comment">/// from TargetAnyClassMetadataObjCInterop, otherwise it inherits from</span><br><span class="hljs-comment">/// TargetAnyClassMetadata.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime, <span class="hljs-keyword">typename</span> TargetAnyClassMetadataVariant&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetAnyClassMetadataVariant &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br><br>  <span class="hljs-built_in">TargetClassMetadata</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-comment">//这里将一个父类的类型传进来了，显然，这里base实际表示元类</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetClassMetadata</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetAnyClassMetadataVariant &amp;base,</span></span><br><span class="hljs-params"><span class="hljs-function">                                ClassFlags flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                                ClassIVarDestroyer *ivarDestroyer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoredPointer size, StoredPointer addressPoint,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoredPointer alignMask,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoredPointer classSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoredPointer classAddressPoint)</span></span><br><span class="hljs-function">      : TargetAnyClassMetadataVariant(base), Flags(flags),</span><br><span class="hljs-function">        InstanceAddressPoint(addressPoint), InstanceSize(size),</span><br><span class="hljs-function">        InstanceAlignMask(alignMask), Reserved(<span class="hljs-number">0</span>), ClassSize(classSize),</span><br><span class="hljs-function">        ClassAddressPoint(classAddressPoint), Description(nullptr),</span><br><span class="hljs-function">        IVarDestroyer(ivarDestroyer) &#123;</span>&#125;<br><br>  <span class="hljs-comment">// The remaining fields are valid only when isTypeMetadata().</span><br>  <span class="hljs-comment">// The Objective-C runtime knows the offsets to some of these fields.</span><br>  <span class="hljs-comment">// Be careful when accessing them.</span><br><br>  <span class="hljs-comment">/// Swift-specific class flags.</span><br>  ClassFlags Flags;<br><br>  <span class="hljs-comment">/// The address point of instances of this type.</span><br>  <span class="hljs-keyword">uint32_t</span> InstanceAddressPoint;<br><br>  <span class="hljs-comment">/// The required size of instances of this type.</span><br>  <span class="hljs-comment">/// &#x27;InstanceAddressPoint&#x27; bytes go before the address point;</span><br>  <span class="hljs-comment">/// &#x27;InstanceSize - InstanceAddressPoint&#x27; bytes go after it.</span><br>  <span class="hljs-keyword">uint32_t</span> InstanceSize;<br><br>  <span class="hljs-comment">/// The alignment mask of the address point of instances of this type.</span><br>  <span class="hljs-keyword">uint16_t</span> InstanceAlignMask;<br><br>  <span class="hljs-comment">/// Reserved for runtime use.</span><br>  <span class="hljs-keyword">uint16_t</span> Reserved;<br><br>  <span class="hljs-comment">/// The total size of the class object, including prefix and suffix</span><br>  <span class="hljs-comment">/// extents.</span><br>  <span class="hljs-keyword">uint32_t</span> ClassSize;<br><br>  <span class="hljs-comment">/// The offset of the address point within the class object.</span><br>  <span class="hljs-keyword">uint32_t</span> ClassAddressPoint;<br><br>  <span class="hljs-comment">// Description is by far the most likely field for a client to try</span><br>  <span class="hljs-comment">// to access directly, so we force access to go through accessors.</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/// An out-of-line Swift-specific description of the type, or null</span><br>  <span class="hljs-comment">/// if this is an artificial subclass.  We currently provide no</span><br>  <span class="hljs-comment">/// supported mechanism for making a non-artificial subclass</span><br>  <span class="hljs-comment">/// dynamically.</span><br>  TargetSignedPointer&lt;Runtime, <span class="hljs-keyword">const</span> TargetClassDescriptor&lt;Runtime&gt; * __ptrauth_swift_type_descriptor&gt; Description;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/// A function for destroying instance variables, used to clean up after an</span><br>  <span class="hljs-comment">/// early return from a constructor. If null, no clean up will be performed</span><br>  <span class="hljs-comment">/// and all ivars must be trivial.</span><br>  TargetSignedPointer&lt;Runtime, ClassIVarDestroyer * __ptrauth_swift_heap_object_destructor&gt; IVarDestroyer;<br><br>  <span class="hljs-comment">// After this come the class members, laid out as follows:</span><br>  <span class="hljs-comment">//   - class members for the superclass (recursively)</span><br>  <span class="hljs-comment">//   - metadata reference for the parent, if applicable</span><br>  <span class="hljs-comment">//   - generic parameters for this class</span><br>  <span class="hljs-comment">//   - class variables (if we choose to support these)</span><br>  <span class="hljs-comment">//   - &quot;tabulated&quot; virtual methods</span><br><br>  <span class="hljs-keyword">using</span> TargetAnyClassMetadataVariant::isTypeMetadata;<br><br>  <span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, TargetClassDescriptor&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">typename</span> Runtime::StoredSignedPointer</span><br><span class="hljs-function">  <span class="hljs-title">getDescriptionAsSignedPointer</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDescription</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetClassDescriptor&lt;Runtime&gt; *description)</span> </span>&#123;<br>    Description = description;<br>  &#125;<br><br>  <span class="hljs-comment">// [<span class="hljs-doctag">NOTE:</span> Dynamic-subclass-KVO]</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Using Objective-C runtime, KVO can modify object behavior without needing</span><br>  <span class="hljs-comment">// to modify the object&#x27;s code. This is done by dynamically creating an</span><br>  <span class="hljs-comment">// artificial subclass of the object&#x27;s type.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The isa pointer of the observed object is swapped out to point to</span><br>  <span class="hljs-comment">// the artificial subclass, which has the following properties:</span><br>  <span class="hljs-comment">// - Setters for observed keys are overridden to additionally post</span><br>  <span class="hljs-comment">// notifications.</span><br>  <span class="hljs-comment">// - The `-class` method is overridden to return the original class type</span><br>  <span class="hljs-comment">// instead of the artificial subclass type.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// For more details, see:</span><br>  <span class="hljs-comment">// https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html</span><br><br>  <span class="hljs-comment">/// Is this class an artificial subclass, such as one dynamically</span><br>  <span class="hljs-comment">/// created for various dynamic purposes like KVO?</span><br>  <span class="hljs-comment">/// See [<span class="hljs-doctag">NOTE:</span> Dynamic-subclass-KVO]</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isArtificialSubclass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Description == <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setArtificialSubclass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    Description = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-function">ClassFlags <span class="hljs-title">getFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Flags;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFlags</span><span class="hljs-params">(ClassFlags flags)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    Flags = flags;<br>  &#125;<br><br>  <span class="hljs-function">StoredSize <span class="hljs-title">getInstanceSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> InstanceSize;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInstanceSize</span><span class="hljs-params">(StoredSize size)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    InstanceSize = size;<br>  &#125;<br><br>  <span class="hljs-function">StoredPointer <span class="hljs-title">getInstanceAddressPoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> InstanceAddressPoint;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInstanceAddressPoint</span><span class="hljs-params">(StoredSize size)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    InstanceAddressPoint = size;<br>  &#125;<br><br>  <span class="hljs-function">StoredPointer <span class="hljs-title">getInstanceAlignMask</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> InstanceAlignMask;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInstanceAlignMask</span><span class="hljs-params">(StoredSize mask)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    InstanceAlignMask = mask;<br>  &#125;<br><br>  <span class="hljs-function">StoredPointer <span class="hljs-title">getClassSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> ClassSize;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setClassSize</span><span class="hljs-params">(StoredSize size)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    ClassSize = size;<br>  &#125;<br><br>  <span class="hljs-function">StoredPointer <span class="hljs-title">getClassAddressPoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> ClassAddressPoint;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setClassAddressPoint</span><span class="hljs-params">(StoredSize offset)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    ClassAddressPoint = offset;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint16_t</span> <span class="hljs-title">getRuntimeReservedData</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Reserved;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRuntimeReservedData</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> data)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    Reserved = data;<br>  &#125;<br><br>  <span class="hljs-comment">/// Get a pointer to the field offset vector, if present, or null.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> StoredPointer *<span class="hljs-title">getFieldOffsets</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">getFieldOffsetVectorOffset</span>();<br>    <span class="hljs-keyword">if</span> (offset == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span>*&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> StoredPointer *&gt;(asWords + offset);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">getSizeInWords</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">uint32_t</span> size = <span class="hljs-built_in">getClassSize</span>() - <span class="hljs-built_in">getClassAddressPoint</span>();<br>    <span class="hljs-built_in">assert</span>(size % <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StoredPointer) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> size / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StoredPointer);<br>  &#125;<br><br>  <span class="hljs-comment">/// Given that this class is serving as the superclass of a Swift class,</span><br>  <span class="hljs-comment">/// return its bounds as metadata.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// Note that the ImmediateMembersOffset member will not be meaningful.</span><br>  <span class="hljs-function">TargetClassMetadataBounds&lt;Runtime&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getClassBoundsAsSwiftSuperclass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> Bounds = TargetClassMetadataBounds&lt;Runtime&gt;;<br><br>    <span class="hljs-keyword">auto</span> rootBounds = Bounds::forSwiftRootClass();<br><br>    <span class="hljs-comment">// If the class is not type metadata, just use the root-class bounds.</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isTypeMetadata</span>())<br>      <span class="hljs-keyword">return</span> rootBounds;<br><br>    <span class="hljs-comment">// Otherwise, pull out the bounds from the metadata.</span><br>    <span class="hljs-keyword">auto</span> bounds = Bounds::forAddressPointAndSize(<span class="hljs-built_in">getClassAddressPoint</span>(),<br>                                                 <span class="hljs-built_in">getClassSize</span>());<br><br>    <span class="hljs-comment">// Round the bounds up to the required dimensions.</span><br>    <span class="hljs-keyword">if</span> (bounds.NegativeSizeInWords &lt; rootBounds.NegativeSizeInWords)<br>      bounds.NegativeSizeInWords = rootBounds.NegativeSizeInWords;<br>    <span class="hljs-keyword">if</span> (bounds.PositiveSizeInWords &lt; rootBounds.PositiveSizeInWords)<br>      bounds.PositiveSizeInWords = rootBounds.PositiveSizeInWords;<br><br>    <span class="hljs-keyword">return</span> bounds;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SWIFT_OBJC_INTEROP</span><br>  <span class="hljs-comment">/// Given a statically-emitted metadata template, this sets the correct</span><br>  <span class="hljs-comment">/// &quot;is Swift&quot; bit for the current runtime. Depending on the deployment</span><br>  <span class="hljs-comment">/// target a binary was compiled for, statically emitted metadata templates</span><br>  <span class="hljs-comment">/// may have a different bit set from the one that this runtime canonically</span><br>  <span class="hljs-comment">/// considers the &quot;is Swift&quot; bit.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAsTypeMetadata</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// If the wrong &quot;is Swift&quot; bit is set, set the correct one.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Note that the only time we should see the &quot;new&quot; bit set while</span><br>    <span class="hljs-comment">// expecting the &quot;old&quot; one is when running a binary built for a</span><br>    <span class="hljs-comment">// new OS on an old OS, which is not supported, however we do</span><br>    <span class="hljs-comment">// have tests that exercise this scenario.</span><br>    <span class="hljs-keyword">auto</span> otherSwiftBit = (<span class="hljs-number">3ULL</span> - SWIFT_CLASS_IS_SWIFT_MASK);<br>    <span class="hljs-built_in">assert</span>(otherSwiftBit == <span class="hljs-number">1ULL</span> || otherSwiftBit == <span class="hljs-number">2ULL</span>);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>-&gt;Data &amp; <span class="hljs-number">3</span>) == otherSwiftBit) &#123;<br>      <span class="hljs-keyword">this</span>-&gt;Data ^= <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Otherwise there should be nothing to do, since only the old &quot;is</span><br>    <span class="hljs-comment">// Swift&quot; bit is used for backward-deployed runtimes.</span><br>    <br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Flags &amp; ClassFlags::IsStaticSpecialization;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCanonicalStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Flags &amp; ClassFlags::IsCanonicalStaticSpecialization;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Class;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> ClassMetadata = TargetClassMetadataType&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>
</li>
<li><code>template</code>是<code>c++</code>的泛型写法,<code>TargetClassMetadata</code>的父类,如果<code>Runtime</code>支持<code>Objective-C</code>互操作性，则此类继承<code>TargetAnyClassMetadataObjCInterop</code>(实际上该类的父类就是<code>TargetAnyClassMetadata</code>)，否则继承自<code>TargetAnyClassMetadata</code></li>
<li>其中均有<code>assert(isTypeMetadata())</code>断言，显然，这里的属性值是元类才会有的。元类的元类是没有的</li>
<li>其结构实际为 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassMetadata</span></span>&#123;<br>         <span class="hljs-operator">......//</span><span class="hljs-type">TargetAnyClassMetadataObjCInterop或TargetAnyClassMetadata的数据</span><br>       <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <br>       <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 类实例中存储的数据的起始地址在类实例内存布局中的偏移量</span><br>       <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <br>       <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <br>       <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <br>       <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <br>       <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 类实例的引用地址在类实例内存布局中的编译量</span><br>       <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutableRawPointer</span> <br>       <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="TargetAnyClassMetadata"><a href="#TargetAnyClassMetadata" class="headerlink" title="TargetAnyClassMetadata"></a>TargetAnyClassMetadata</h3><blockquote>
<p><code>TargetAnyClassMetadata</code>继承了<code>TargetHeapMetadata</code>,即，最开始的基类<br>理解成<code>Swift</code>的<code>元类</code>，<code>isTypeMetadata</code>始终返回<code>true</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The portion of a class metadata object that is compatible with</span><br><span class="hljs-comment">/// all classes, even non-Swift ones.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetAnyClassMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetHeapMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br>  <span class="hljs-keyword">using</span> TargetClassMetadata = TargetClassMetadataType&lt;Runtime&gt;;<br><br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetAnyClassMetadata</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetAnyClassMetadataObjCInterop&lt;Runtime&gt; *isa,</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetClassMetadata *superclass)</span></span><br><span class="hljs-function">      : TargetHeapMetadata&lt;Runtime&gt;(isa), Superclass(superclass) &#123;</span>&#125;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetAnyClassMetadata</span><span class="hljs-params">(TargetClassMetadata *superclass)</span></span><br><span class="hljs-function">      : TargetHeapMetadata&lt;Runtime&gt;(MetadataKind::Class),</span><br><span class="hljs-function">        Superclass(superclass) &#123;</span>&#125;<br><br>  <span class="hljs-comment">// Note that ObjC classes do not have a metadata header.</span><br><br>  <span class="hljs-comment">/// The metadata for the superclass.  This is null for the root class.</span><br>  TargetSignedPointer&lt;Runtime, <span class="hljs-keyword">const</span> TargetClassMetadata *<br>                                   __ptrauth_swift_objc_superclass&gt;<br>      Superclass;<br><br>  <span class="hljs-comment">/// Is this object a valid swift type metadata?  That is, can it be</span><br>  <span class="hljs-comment">/// safely downcast to ClassMetadata?</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTypeMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">/// A different perspective on the same bit.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPureObjC</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">isTypeMetadata</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>该类中有个<code>superclass</code>属性，并且由于继承<code>TargetHeapMetadata</code>,因此有<code>kind</code>属性，其结构为  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetAnyClassMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span>:<span class="hljs-type">StoredPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Superclass</span>:<span class="hljs-type">TargetSignedPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="TargetAnyClassMetadataObjCInterop"><a href="#TargetAnyClassMetadataObjCInterop" class="headerlink" title="TargetAnyClassMetadataObjCInterop"></a>TargetAnyClassMetadataObjCInterop</h3><blockquote>
<p><code>TargetAnyClassMetadataObjCInterop</code>继承了<code>TargetAnyClassMetadata</code><br>实际的<code>类数据</code>，其包含了<code>kind</code>（可以和<code>isa</code>转换）、<code>superclass</code>、<code>CacheData</code>、<code>StoredSize Data</code>,和<code>objc_class</code>中的<code>isa</code>、<code>superclass</code>、<code>cache_t cache</code>、<code>class_data_bits_t bits</code>类似。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// This is the class metadata object for all classes (Swift and ObjC) in a</span><br><span class="hljs-comment">/// runtime that has Objective-C interoperability.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetAnyClassMetadataObjCInterop</span></span><br><span class="hljs-class">    :</span> <span class="hljs-keyword">public</span> TargetAnyClassMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br>  <span class="hljs-keyword">using</span> TargetClassMetadataObjCInterop =<br>    <span class="hljs-comment">// swift:: qualifier works around an MSVC quirk</span><br>    swift::TargetClassMetadata&lt;Runtime, TargetAnyClassMetadataObjCInterop&lt;Runtime&gt;&gt;;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetAnyClassMetadataObjCInterop</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetAnyClassMetadataObjCInterop&lt;Runtime&gt; *isa,</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetClassMetadataObjCInterop *superclass)</span></span><br><span class="hljs-function">      : TargetAnyClassMetadata&lt;Runtime&gt;(isa, superclass),</span><br><span class="hljs-function">        CacheData&#123;</span><span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>&#125;,<br>        <span class="hljs-built_in">Data</span>(SWIFT_CLASS_IS_SWIFT_MASK) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetAnyClassMetadataObjCInterop</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetClassMetadataObjCInterop *superclass)</span></span><br><span class="hljs-function">      : TargetAnyClassMetadata&lt;Runtime&gt;(superclass), CacheData&#123;</span><span class="hljs-literal">nullptr</span>,<br>                                                               <span class="hljs-literal">nullptr</span>&#125;,<br>        <span class="hljs-built_in">Data</span>(SWIFT_CLASS_IS_SWIFT_MASK) &#123;&#125;<br><br>  <span class="hljs-comment">// Allow setting the metadata kind to a class ISA on class metadata.</span><br>  <span class="hljs-keyword">using</span> TargetMetadata&lt;Runtime&gt;::getClassISA;<br>  <span class="hljs-keyword">using</span> TargetMetadata&lt;Runtime&gt;::setClassISA;<br><br>  <span class="hljs-comment">/// The cache data is used for certain dynamic lookups; it is owned</span><br>  <span class="hljs-comment">/// by the runtime and generally needs to interoperate with</span><br>  <span class="hljs-comment">/// Objective-C&#x27;s use.</span><br>  TargetPointer&lt;Runtime, <span class="hljs-keyword">void</span>&gt; CacheData[<span class="hljs-number">2</span>]; <br>  <span class="hljs-comment">// 占16字节，1个是bucket *,另一个4字节是mask（长度减1），occupied(缓存的方法数量)</span><br><br>  <span class="hljs-comment">/// The data pointer is used for out-of-line metadata and is</span><br>  <span class="hljs-comment">/// generally opaque, except that the compiler sets the low bit in</span><br>  <span class="hljs-comment">/// order to indicate that this is a Swift metatype and therefore</span><br>  <span class="hljs-comment">/// that the type metadata header is present.</span><br>  StoredSize Data;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> StoredPointer <span class="hljs-title">offsetToData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(TargetAnyClassMetadataObjCInterop, Data);<br>  &#125;<br><br>  <span class="hljs-comment">/// Is this object a valid swift type metadata?  That is, can it be</span><br>  <span class="hljs-comment">/// safely downcast to ClassMetadata?</span><br>  <span class="hljs-comment">//当前对象是有效的Swift类型元数据，并且可以安全地向下转换为ClassMetadata，则该函数应该返回true。否则，如果当前对象无效，则该函数应该返回false。</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTypeMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Data &amp; SWIFT_CLASS_IS_SWIFT_MASK);<br>  &#125;<br>  <span class="hljs-comment">/// A different perspective on the same bit</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPureObjC</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">isTypeMetadata</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>isa</code>和<code>kind</code>的转换方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> TargetAnyClassMetadata&lt;Runtime&gt; *<span class="hljs-title">getClassISA</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> TargetAnyClassMetadata&lt;Runtime&gt; *&gt;(Kind);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setClassISA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetAnyClassMetadata&lt;Runtime&gt; *isa)</span> </span>&#123;<br>    Kind = <span class="hljs-keyword">reinterpret_cast</span>&lt;StoredPointer&gt;(isa);<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li>由于<code>TargetAnyClassMetadataObjCInterop</code>继承<code>TargetAnyClassMetadata</code>，其实际数据结构为<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetAnyClassMetadataObjCInterop</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span>:<span class="hljs-type">StoredPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Superclass</span>:<span class="hljs-type">TargetSignedPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">CacheData</span>:(<span class="hljs-type">TargetSignedPointer</span>,<span class="hljs-type">TargetSignedPointer</span>)<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Data</span>:<span class="hljs-type">StoredSize</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="swift-类的数据结构"><a href="#swift-类的数据结构" class="headerlink" title="swift 类的数据结构"></a>swift 类的数据结构</h3><ul>
<li><p>结合<code>TargetClassMetadata</code>和<code>TargetAnyClassMetadataObjCInterop</code>的数据结构，最终<code>swift</code>类的数据结构为。实际调试发现，无论是纯<code>swift</code>类还是继承了<code>NSObject</code>,他的结构，均为<code>ObjCInterop</code>。</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Metadata</span> </span>&#123; <br>  <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <br>  <span class="hljs-keyword">var</span> superClass: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span> <br>  <span class="hljs-keyword">var</span> cacheData: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) <span class="hljs-comment">//ObjCInterop 才有的</span><br>  <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span>  <span class="hljs-comment">//ObjCInterop 才有的</span><br>  <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <br>  <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <br>  <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <br>  <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutableRawPointer</span> <br>  <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>其中需要关注<code>typeDescriptor</code>，不管是<code>class</code>/<code>struct</code>/<code>enum</code>都有自己的<code>Descriptor</code>，它就是对类的一个详细描述。</p>
<ul>
<li>而类中主要是<code>TargetClassDescriptor</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">TargetSignedPointer&lt;Runtime, <span class="hljs-keyword">const</span> TargetClassDescriptor&lt;Runtime&gt; *     __ptrauth_swift_type_descriptor&gt; Description;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>下面用图描述，一个对象的内存结构<br>  <img src="7.png"></p>
</li>
</ul>
<h2 id="TargetClassDescriptor"><a href="#TargetClassDescriptor" class="headerlink" title="TargetClassDescriptor"></a><span id="jump"><code>TargetClassDescriptor</code></span></h2><blockquote>
<p><code>TargetClassDescriptor</code>是<code>TargetClassMetadata</code>中主要描述类信息的属性</p>
</blockquote>
<ul>
<li>其数据结构如下，<code>TargetClassDescriptor</code>本身的结构是没有 <code>V-Table</code>和<code>size</code><ul>
<li>整个继承链是<code>TargetClassDescriptor</code> –&gt;<code>TargetTypeContextDescriptor</code> –&gt; <code>TargetContextDescriptor</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassDescriptor</span></span>&#123; <br><br>     <span class="hljs-comment">//继承至TargetContextDescriptor</span><br>      <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>      <br>      <span class="hljs-comment">//继承至TargetTypeContextDescriptor</span><br>      <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;   <span class="hljs-comment">// class/struct/enum 的名称</span><br>      <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>      <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt; <span class="hljs-comment">//属性描述器</span><br><br>      <span class="hljs-comment">//TargetClassDescriptor具有的</span><br>      <span class="hljs-keyword">var</span> superClassType: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;  <span class="hljs-comment">//父类类型指针</span><br>      <span class="hljs-keyword">var</span> metadataNegativeSizeInWords: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> metadataPositiveSizeInWords: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> numImmediateMembers: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 每一个属性值距离当前实例对象地址的偏移量</span><br>      <span class="hljs-keyword">var</span> <span class="hljs-type">Offset</span>: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-comment">// var size: UInt32 </span><br>      <span class="hljs-comment">// V-Table  (methods) </span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注意，<code>superClassType</code>的类型是<code>TargetRelativeDirectPointer&lt;Runtime, const char&gt;</code>,它是一个相对地址信息，并且存储的是偏移量。(<code>swift</code>中在数据结构存储数据都是通过<code>偏移量</code>去访问内存地址)</li>
</ul>
<h3 id="TargetRelativeDirectPointer"><a href="#TargetRelativeDirectPointer" class="headerlink" title="TargetRelativeDirectPointer"></a><code>TargetRelativeDirectPointer</code></h3><ul>
<li><p>源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// TargetRelativeDirectPointer其实是RelativeDirectPointer的别名</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime, <span class="hljs-keyword">typename</span> Pointee, <span class="hljs-keyword">bool</span> Nullable = <span class="hljs-literal">true</span>&gt;<br><span class="hljs-keyword">using</span> TargetRelativeDirectPointer<br>  = <span class="hljs-keyword">typename</span> Runtime::<span class="hljs-keyword">template</span> RelativeDirectPointer&lt;Pointee, Nullable&gt;;<br><br><span class="hljs-comment">/// A direct relative reference to an object that is not a function pointer.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">bool</span> Nullable, <span class="hljs-keyword">typename</span> Offset&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RelativeDirectPointer</span>&lt;</span>T, Nullable, Offset,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;!std::is_function&lt;T&gt;::value&gt;::type&gt;<br>    : <span class="hljs-keyword">private</span> RelativeDirectPointerImpl&lt;T, Nullable, Offset&gt;<br>&#123;<br>  <span class="hljs-keyword">using</span> super = RelativeDirectPointerImpl&lt;T, Nullable, Offset&gt;;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> super::get;<br>  <span class="hljs-keyword">using</span> super::super;<br>  <br>  RelativeDirectPointer &amp;<span class="hljs-keyword">operator</span>=(T *absolute) &amp; &#123;<br>    super::<span class="hljs-keyword">operator</span>=(absolute);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-keyword">typename</span> <span class="hljs-title">super::PointerTy</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp; </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> super::ValueTy *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &amp; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> super::ValueTy* <span class="hljs-title">getRelative</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *base)</span> <span class="hljs-keyword">const</span> &amp; </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;super::<span class="hljs-built_in">getRelative</span>(base);<br>  &#125;<br><br>  <span class="hljs-keyword">using</span> super::isNull;<br>  <span class="hljs-keyword">using</span> super::resolve;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>其获取方法是<code>get</code>实际调用了父类<code>RelativeDirectPointerImpl</code>中的方法其源码为</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-function">PointerTy <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp; </span>&#123;<br>  <span class="hljs-comment">// Check for null.</span><br>  <span class="hljs-keyword">if</span> (Nullable &amp;&amp; RelativeOffset == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <br>  <span class="hljs-comment">// The value is addressed relative to `this`.</span><br>  <span class="hljs-comment">//该类的地址加上相对地址</span><br>  <span class="hljs-keyword">uintptr_t</span> absolute = detail::<span class="hljs-built_in">applyRelativeOffset</span>(<span class="hljs-keyword">this</span>, RelativeOffset);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;PointerTy&gt;(absolute);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在<code>swift</code>中引用一个对象有两种情况，</p>
<ul>
<li>一种是<code>地址A</code>上直接存储了对象的<code>地址B</code></li>
<li>另一个就是<code>地址A</code>上存储了<code>相对地址C</code>，该对象的地址<code>B = A + C</code>,这里的<code>TargetRelativeDirectPointer</code>就是相对地址</li>
</ul>
</li>
<li><p><code>TargetRelativeDirectPointer</code>实际等比表示如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 相对地址信息 - 存储的是偏移量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetRelativeDirectPointer</span>&lt;<span class="hljs-title">Pointee</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> offset: <span class="hljs-type">Int32</span><br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getmeasureRelativeOffset</span>()</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Pointee</span>&gt;&#123;<br>        <span class="hljs-keyword">let</span> offset <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.offset<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123; p <span class="hljs-keyword">in</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             获得self，变为raw，然后+offset</span><br><span class="hljs-comment">             - UnsafeRawPointer(p) 表示this</span><br><span class="hljs-comment">             - advanced(by: numericCast(offset) 表示移动的步长，即offset</span><br><span class="hljs-comment">             - assumingMemoryBound(to: T.self) 表示假定类型是T，即自己指定的类型</span><br><span class="hljs-comment">             - UnsafeMutablePointer(mutating:) 表示返回的指针类型</span><br><span class="hljs-comment">            */</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating: <span class="hljs-type">UnsafeRawPointer</span>(p).advanced(by: <span class="hljs-built_in">numericCast</span>(offset)).assumingMemoryBound(to: <span class="hljs-type">Pointee</span>.<span class="hljs-keyword">self</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="ClassContextDescriptorBuilder"><a href="#ClassContextDescriptorBuilder" class="headerlink" title="ClassContextDescriptorBuilder"></a><code>ClassContextDescriptorBuilder</code></h3><blockquote>
<p><code>ClassContextDescriptorBuilder</code>这个类是用来<code>创建</code>当前的<code>Matedata</code>和<code>Descriptor</code>用的,其核心方法是<code>layout</code>函数：</p>
</blockquote>
<ol>
<li><code>ClassContextDescriptorBuilder</code>的<code>layout</code>函数 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">()</span> </span>&#123;<br>      super::<span class="hljs-built_in">layout</span>();<br>      <span class="hljs-built_in">addVTable</span>();<br>      <span class="hljs-built_in">addOverrideTable</span>();<br>      <span class="hljs-built_in">addObjCResilientClassStubInfo</span>();<br>      <span class="hljs-built_in">maybeAddCanonicalMetadataPrespecializations</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>父类是<code>TypeContextDescriptorBuilderBase</code>的<code>layout</code>函数 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">computeIdentity</span>();<br>    <br>  super::<span class="hljs-built_in">layout</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addName</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addAccessFunction</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addReflectionFieldDescriptor</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addLayoutInfo</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addGenericSignature</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">maybeAddResilientSuperclass</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">maybeAddMetadataInitialization</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>最终的基类是<code>ContextDescriptorBuilderBase</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addFlags</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addParent</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>在构建过程中实际上是<code>TargetClassDescriptor</code>数据的构建，由1可知，实际上构建了<code>addVTable()</code>和<code>addOverrideTable()</code><ul>
<li><code>addVTable()</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addVTable</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">LLVM_DEBUG</span>(<br>    llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;VTable entries for &quot;</span> &lt;&lt; <span class="hljs-built_in">getType</span>()-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry : VTableEntries) &#123;<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>      entry.<span class="hljs-built_in">print</span>(llvm::<span class="hljs-built_in">dbgs</span>());<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>  );<br>    <br>  <span class="hljs-comment">// Only emit a method lookup function if the class is resilient</span><br>  <span class="hljs-comment">// and has a non-empty vtable, as well as no elided methods.</span><br>  <span class="hljs-keyword">if</span> (IGM.<span class="hljs-built_in">hasResilientMetadata</span>(<span class="hljs-built_in">getType</span>(), ResilienceExpansion::Minimal)<br>      &amp;&amp; (HasNonoverriddenMethods || !VTableEntries.<span class="hljs-built_in">empty</span>()))<br>    IGM.<span class="hljs-built_in">emitMethodLookupFunction</span>(<span class="hljs-built_in">getType</span>());<br>    <br>  <span class="hljs-keyword">if</span> (VTableEntries.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br>  <br>  <span class="hljs-keyword">auto</span> offset = MetadataLayout-&gt;<span class="hljs-built_in">hasResilientSuperclass</span>()<br>                  ? MetadataLayout-&gt;<span class="hljs-built_in">getRelativeVTableOffset</span>()<br>                  : MetadataLayout-&gt;<span class="hljs-built_in">getStaticVTableOffset</span>();<br><span class="hljs-comment">//将偏移量添加到B结构体</span><br>  B.<span class="hljs-built_in">addInt32</span>(offset / IGM.<span class="hljs-built_in">getPointerSize</span>());<br>  B.<span class="hljs-built_in">addInt32</span>(VTableEntries.<span class="hljs-built_in">size</span>());<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> fn : VTableEntries)<br>  <span class="hljs-comment">//遍历函数表添加函数指针</span><br>    <span class="hljs-built_in">emitMethodDescriptor</span>(fn);<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">emitMethodDescriptor</span><span class="hljs-params">(SILDeclRef fn)</span> </span>&#123;<br>    <br>  <span class="hljs-comment">// Define the method descriptor to point to the current position in the</span><br>  <span class="hljs-comment">// nominal type descriptor, if it has a well-defined symbol name.</span><br>  IGM.<span class="hljs-built_in">defineMethodDescriptor</span>(<br>      fn, Type, B.<span class="hljs-built_in">getAddrOfCurrentPosition</span>(IGM.MethodDescriptorStructTy),<br>      IGM.MethodDescriptorStructTy);<br>    <br>  <span class="hljs-keyword">if</span> (IGM.<span class="hljs-built_in">getOptions</span>().VirtualFunctionElimination) &#123;<br>    <span class="hljs-keyword">auto</span> offset = B.<span class="hljs-built_in">getNextOffsetFromGlobal</span>() +<br>                  <span class="hljs-comment">// 1st field of MethodDescriptorStructTy</span><br>                  <span class="hljs-built_in">Size</span>(IGM.DataLayout.<span class="hljs-built_in">getTypeAllocSize</span>(IGM.Int32Ty));<br>    VTableEntriesForVFE.<span class="hljs-built_in">push_back</span>(std::pair&lt;Size, SILDeclRef&gt;(offset, fn));<br>  &#125;<br>    <br>  <span class="hljs-comment">// Actually build the descriptor.</span><br>  <span class="hljs-keyword">auto</span> descriptor = B.<span class="hljs-built_in">beginStruct</span>(IGM.MethodDescriptorStructTy);<br>  <span class="hljs-built_in">buildMethodDescriptorFields</span>(IGM, VTable, fn, descriptor);<br>  descriptor.<span class="hljs-built_in">finishAndAddTo</span>(B);<br>    <br>  <span class="hljs-comment">// Emit method dispatch thunk if the class is resilient.</span><br>  <span class="hljs-keyword">auto</span> *func = cast&lt;AbstractFunctionDecl&gt;(fn.<span class="hljs-built_in">getDecl</span>());<br>    <br>  <span class="hljs-keyword">if</span> ((Resilient &amp;&amp; func-&gt;<span class="hljs-built_in">getEffectiveAccess</span>() &gt;= AccessLevel::Public) ||<br>      IGM.<span class="hljs-built_in">getOptions</span>().VirtualFunctionElimination) &#123;<br>    IGM.<span class="hljs-built_in">emitDispatchThunk</span>(fn);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>addOverrideTable()</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addOverrideTable</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">LLVM_DEBUG</span>(<br>    llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;Override Table entries for &quot;</span> &lt;&lt; <span class="hljs-built_in">getType</span>()-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry : OverrideTableEntries) &#123;<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>      entry.first.<span class="hljs-built_in">print</span>(llvm::<span class="hljs-built_in">dbgs</span>());<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>      entry.second.<span class="hljs-built_in">print</span>(llvm::<span class="hljs-built_in">dbgs</span>());<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>  );<br>    <br>  <span class="hljs-keyword">if</span> (OverrideTableEntries.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br>    <br>  B.<span class="hljs-built_in">addInt32</span>(OverrideTableEntries.<span class="hljs-built_in">size</span>());<br>    <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair : OverrideTableEntries)<br>    <span class="hljs-built_in">emitMethodOverrideDescriptor</span>(pair.first, pair.second);<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">emitMethodOverrideDescriptor</span><span class="hljs-params">(SILDeclRef baseRef, SILDeclRef declRef)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (IGM.<span class="hljs-built_in">getOptions</span>().VirtualFunctionElimination) &#123;<br>    <span class="hljs-keyword">auto</span> offset =<br>        B.<span class="hljs-built_in">getNextOffsetFromGlobal</span>() +<br>        <span class="hljs-comment">// 1st field of MethodOverrideDescriptorStructTy</span><br>        <span class="hljs-built_in">Size</span>(IGM.DataLayout.<span class="hljs-built_in">getTypeAllocSize</span>(IGM.RelativeAddressTy)) +<br>        <span class="hljs-comment">// 2nd field of MethodOverrideDescriptorStructTy</span><br>        <span class="hljs-built_in">Size</span>(IGM.DataLayout.<span class="hljs-built_in">getTypeAllocSize</span>(IGM.RelativeAddressTy));<br>    VTableEntriesForVFE.<span class="hljs-built_in">push_back</span>(<br>        std::pair&lt;Size, SILDeclRef&gt;(offset, baseRef));<br>  &#125;<br>    <br>  <span class="hljs-keyword">auto</span> descriptor = B.<span class="hljs-built_in">beginStruct</span>(IGM.MethodOverrideDescriptorStructTy);<br>    <br>  <span class="hljs-comment">// The class containing the base method.</span><br>  <span class="hljs-keyword">auto</span> *baseClass = cast&lt;ClassDecl&gt;(baseRef.<span class="hljs-built_in">getDecl</span>()-&gt;<span class="hljs-built_in">getDeclContext</span>());<br>  IGM.IRGen.<span class="hljs-built_in">noteUseOfTypeContextDescriptor</span>(baseClass, DontRequireMetadata);<br>  <span class="hljs-keyword">auto</span> baseClassEntity = LinkEntity::forNominalTypeDescriptor(baseClass);<br>  <span class="hljs-keyword">auto</span> baseClassDescriptor =<br>    IGM.<span class="hljs-built_in">getAddrOfLLVMVariableOrGOTEquivalent</span>(baseClassEntity);<br>  descriptor.<span class="hljs-built_in">addRelativeAddress</span>(baseClassDescriptor);<br>    <br>  <span class="hljs-comment">// The base method.</span><br>  <span class="hljs-keyword">auto</span> baseMethodEntity = LinkEntity::forMethodDescriptor(baseRef);<br>  <span class="hljs-keyword">auto</span> baseMethodDescriptor =<br>    IGM.<span class="hljs-built_in">getAddrOfLLVMVariableOrGOTEquivalent</span>(baseMethodEntity);<br>  descriptor.<span class="hljs-built_in">addRelativeAddress</span>(baseMethodDescriptor);<br>    <br>  <span class="hljs-comment">// The implementation of the override.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> entry = VTable-&gt;<span class="hljs-built_in">getEntry</span>(IGM.<span class="hljs-built_in">getSILModule</span>(), baseRef)) &#123;<br>    <span class="hljs-built_in">assert</span>(entry-&gt;<span class="hljs-built_in">getKind</span>() == SILVTable::Entry::Kind::Override);<br>    <br>    <span class="hljs-keyword">auto</span> *impl = entry-&gt;<span class="hljs-built_in">getImplementation</span>();<br>    <span class="hljs-keyword">if</span> (impl-&gt;<span class="hljs-built_in">isAsync</span>()) &#123;<br>      llvm::Constant *implFn = IGM.<span class="hljs-built_in">getAddrOfAsyncFunctionPointer</span>(impl);<br>      descriptor.<span class="hljs-built_in">addRelativeAddress</span>(implFn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      llvm::Function *implFn = IGM.<span class="hljs-built_in">getAddrOfSILFunction</span>(impl, NotForDefinition);<br>      descriptor.<span class="hljs-built_in">addCompactFunctionReference</span>(implFn);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// The method is removed by dead method elimination.</span><br>    <span class="hljs-comment">// It should be never called. We add a pointer to an error function.</span><br>    descriptor.<span class="hljs-built_in">addRelativeAddressOrNull</span>(<span class="hljs-literal">nullptr</span>);<br>  &#125;<br>    <br>  descriptor.<span class="hljs-built_in">finishAndAddTo</span>(B);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Mach-O方式验证"><a href="#Mach-O方式验证" class="headerlink" title="Mach-O方式验证"></a>Mach-O方式验证</h2><h3 id="mach-O介绍"><a href="#mach-O介绍" class="headerlink" title="mach-O介绍"></a>mach-O介绍</h3><blockquote>
<p><code>Mach-O</code> 其实是<code>Mach Object</code>文件格式的缩写，是 <code>mac</code> 以及 <code>iOS</code> 上可执行文件的格式。常见的 <code>.o</code>,<code>.a</code>,<code>.dylib Framework</code>，<code>dyld .dsym</code></p>
</blockquote>
<p><img src="4.jpg"></p>
<ul>
<li>文件头<code>Header</code>，表明该文件是 <code>Mach-O</code> 格式，指定目标架构，还有一些其他的文件属性信息，文件头信息影响后续的文件结构安排。</li>
<li><code>Load commands</code>是一张包含很多内容的表。内容包括区域的位置、符号表、动态符号表等。</li>
<li><code>Data</code> 区主要就是负责代码和数据记录的。<code>Mach-O</code> 是以 <code>Segment</code> 这种结构来组织数据的，一个 <code>Segment</code> 可以包含 <code>0</code> 个或多个<code>Section</code>。根据 <code>Segment</code> 是映射的哪一个 <code>Load Command</code>，<code>Segment</code> 中 <code>section</code> 就可以被解读为是是代码，常量或者一些其他的数据类型。在装载在内存中时，也是根据 <code>Segment</code> 做内存映射的。</li>
</ul>
<h3 id="编译成sil"><a href="#编译成sil" class="headerlink" title="编译成sil"></a>编译成sil</h3><ul>
<li><code>swiftc ViewController.swift -emit-silgen -o ViewController.sil</code>,编译成<code>sil</code>,在<code>sil</code>中可以看到编译的中间语言中存在函数表  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">sil_vtable Teacher &#123;<br>  #Teacher.teach: (Teacher) -&gt; () -&gt; () : @$s14ViewController7TeacherC5teachyyF	<span class="hljs-comment">// Teacher.teach()</span><br>  #Teacher.teach1: (Teacher) -&gt; () -&gt; () : @$s14ViewController7TeacherC6teach1yyF	<span class="hljs-comment">// Teacher.teach1()</span><br>  #Teacher.teach2: (Teacher) -&gt; () -&gt; () : @$s14ViewController7TeacherC6teach2yyF	<span class="hljs-comment">// Teacher.teach2()</span><br>  #Teacher.init!allocator: (Teacher.Type) -&gt; () -&gt; Teacher : @$s14ViewController7TeacherCACycfC	<span class="hljs-comment">// Teacher.__allocating_init()</span><br>  #Teacher.deinit!deallocator: @$s14ViewController7TeacherCfD	<span class="hljs-comment">// Teacher.__deallocating_deinit</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol>
<li><p>验证的源码，将该源码编译，并用<code>MachOView</code>打开可执行文件</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;teach&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach1</span>()</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;teach1&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach2</span>()</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;teach2&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span>()</span> &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        <span class="hljs-keyword">let</span> t <span class="hljs-operator">=</span> <span class="hljs-type">Teacher</span>()<br>            t.teach()<br>            t.teach1()<br>            t.teach2()<br>             <span class="hljs-comment">//metadata + offset</span><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在<code>Mach-O</code>的<code>data</code>区里的<code>__TEXT</code>,<code>__swift5_types</code>就是存放 所有的<code>struct</code>/<code>enum</code>/<code>类的Descriptor</code>的地址信息；以每<code>4</code>个字节来做区分。第一个<code>4</code>字节就是<code>Teacher</code>的<code>Descriptor</code>:<br> <img src="1.png"></p>
</li>
<li><p><code>Teacher</code>的<code>Descriptor</code>在<code>mach-o</code>上的地址,减去<code>lg_segment_64</code>上虚拟内存的基地址<code>0x100000000</code>得出<code>Descriptor</code>在<code>mach-o</code>的<code>data</code>区的偏移量：</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0xb01C</span> <span class="hljs-operator">+</span> <span class="hljs-number">0xFFFFFBA4</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x10000ABC0</span><br><span class="hljs-number">0x10000ABC0</span> <span class="hljs-operator">-</span> <span class="hljs-number">0x100000000</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xABC0</span><br></code></pre></td></tr></table></figure>
<p> <img src="2.png"><img src="3.png"></p>
</li>
<li><p>在<code>data</code>区域里面<code>__TEXT</code>,<code>__const</code>代码区，查看<code>ABC0</code>,该位置即为<a href="#jump">TargetClassDescriptor</a>,该数据结构已有成员<code>12</code>个,需要往后偏移<code>12</code>个<code>4</code>字节,再往后<code>4</code>字节里面的内容是<code>size</code>。</p>
<ul>
<li><code>size</code>后面的<code>8</code>个就是<code>teach()</code>方法的内容，再往后<code>8</code>个就是<code>teach1()</code>方法的内容，再往后<code>8</code>个就是<code>teach2()</code>的内容：<br><img src="5.png"></li>
<li><code>teach1()</code>的存储地址的偏移地址是<code>ABF4</code>,</li>
</ul>
</li>
<li><p>通过<code>image list</code>指令获取当前偏移基地址<code>0x0000000104ea8000</code>。得出<code>teach1()</code>的地址是<code>0x00000001024ec000 + ABF4 = 0x1024F6BF4</code>,该地址上存放了<code>TargetMethodDescriptor</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) image list<br>    [  <span class="hljs-number">0</span>] <span class="hljs-number">471326</span>D4<span class="hljs-number">-83</span>D7<span class="hljs-number">-317F</span>-B08E-DCF8ADCF0875 <span class="hljs-number">0x00000001024ec000</span> /Users/chenjingpo/Library/Developer/Xcode/DerivedData/TextFunc-awqwaeqvhhvlsuhdujvflpzzqipk/Build/Products/Debug-iphoneos/TextFunc.app/TextFunc <br>    [  <span class="hljs-number">1</span>] <span class="hljs-number">41605</span>DC7-F412<span class="hljs-number">-37</span>D1-B51B-FEE1A26701E9 <span class="hljs-number">0x00000001d104f000</span> /Users/chenjingpo/Library/Developer/Xcode/iOS DeviceSupport/<span class="hljs-number">16.4</span><span class="hljs-number">.1</span> (<span class="hljs-number">20E252</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>TargetMethodDescriptor</code>的源码如下，其前<code>4</code>个字节是<code>flags</code>,后<code>4</code>个字节存放的是<code>IMP</code>,(<strong>注意</strong>,<code>imp</code>指针其实是一个相对指针，它存储的其实是<code>offset</code>)<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetMethodDescriptor</span> &#123;</span><br>  <span class="hljs-comment">/// Flags describing the method.</span><br>  MethodDescriptorFlags Flags;<br><br>  <span class="hljs-comment">/// The method implementation.</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    TargetCompactFunctionPointer&lt;Runtime, <span class="hljs-keyword">void</span>&gt; Impl;<br>    TargetRelativeDirectPointer&lt;Runtime, <span class="hljs-keyword">void</span>&gt; AsyncImpl;<br>  &#125;;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add method types or anything else needed for reflection.</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">getImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Flags.<span class="hljs-built_in">isAsync</span>()) &#123;<br>      <span class="hljs-keyword">return</span> AsyncImpl.<span class="hljs-built_in">get</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> Impl.<span class="hljs-built_in">get</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li>
<li>结合<code>3</code>，实际<code>offset</code>存储的值是<code>FFFFCD50</code>(该内存上存上的，地址的偏移)，在加上<code>flag</code>的偏移4字节，实际<code>tech</code>方法的地址是  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x1024F6BF4</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x4</span> <span class="hljs-operator">+</span> <span class="hljs-type">FFFFCD50</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x2024F3948</span><br></code></pre></td></tr></table></figure></li>
<li>注意<code>0x2024F3948</code> 还需减去 <code>Mach-O</code>的基地址<code>0x100000000</code>，即<code>0x1024F3948</code>是<code>teach</code>方法的地址<br>  <img src="6.png"></li>
<li>代码查看，运行地址和计算的一样。验证成功，最后两个存放的是<code>size</code>和<code>V-Tabl</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>arm64汇编</title>
    <url>/2023/04/18/iOS%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/arm64%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>汇编主要了解三个方面</p>
<ul>
<li>寄存器</li>
<li>指令</li>
<li>堆栈</li>
</ul>
</blockquote>
<h2 id="arm64汇编"><a href="#arm64汇编" class="headerlink" title="arm64汇编"></a>arm64汇编</h2><ul>
<li>生成汇编文件<ul>
<li><code>xcrun --sdk iphoneos clang -S -arch arm64 main.c -o main.s</code></li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>汇编代码,<code>test.s</code>,汇编中<code>;</code>是注解，等于<code>//</code><figure class="highlight as"><table><tr><td class="code"><pre><code class="hljs as">.text ;函数位置，在代码端<br>.global _test,_add ;使函数公有，外界可以访问<br>_test:<br>mov x0,#<span class="hljs-number">0x8</span>  ;将<span class="hljs-number">8</span>赋值给寄存器x0<br>ret   ;函数返回<br><br>;add函数的调用<br>_add:<br>add x0,x0,x1 ;x0 = x0 + x1<br>ret<br></code></pre></td></tr></table></figure></li>
<li>调用,汇编中的方法会多个<code>_</code><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">test();<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">//输出11</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul>
<li><code>64bit</code>的: <code>x0 ~ x28</code></li>
<li><code>32bit</code>的: <code>w0 ~ w28</code>(属于<code>x0 ~ x28</code>的低<code>32bit</code>)</li>
<li><code>x0 ~ x7</code>通常拿来存放<strong>函数的参数</strong>，更多的阐述使用<strong>堆栈</strong>来传递</li>
<li><code>x0</code>通常拿来存放函数的<strong>返回值</strong></li>
</ul>
<h3 id="程序状态寄存器"><a href="#程序状态寄存器" class="headerlink" title="程序状态寄存器"></a>程序状态寄存器</h3><blockquote>
<ul>
<li><code>cpsr</code> <code>(Current Program Status Register)</code></li>
<li><code>spsr(Saved Program Status Register)</code>,异常状态下使用</li>
</ul>
</blockquote>
<h4 id="cpsr寄存器"><a href="#cpsr寄存器" class="headerlink" title="cpsr寄存器"></a><span id="jump"><code>cpsr</code>寄存器</span></h4><p><img src="1.png"></p>
<table>
<thead>
<tr>
<th align="center">标志位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">N</td>
<td align="center">当用两个补码表示的带符 号数进行运算时，N=1 表示运算的结果为负数；N=0 表示运算的结果为正数或零；</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">Z=1 表示运算的结果为零；z=0 表示运算的结果为非零；</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">可以有4种方法设置C的值：1. 加法运算(包括比较指令 CMN）：当运算结果产生了进位时（无符号数溢出），C=1，否则 C=0。2. 减法运算（包括比较指令CMP）：当运算时产生了借位（无符号数溢出），C=0，否则 C=1。3. 对于包含移位操作的非加/减运算指令，C为移出值的最后一位。4. 对于其他的非加/减运算指令，c的值通常不改变。</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">可以有2种方法设置 V的值：1. 对于加/减法运算指令，当操作数和运算结果为二进制的补码表示的带符号数时，V=1 表示符号位溢出。2. 对于其他的非加/减运算指令，V的值通常不改变。</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center">在 ARM N5 及以上版本的已系列处理器中，用Q标志位指示增强的 DSP 运算指令是否发生了溢出。在其他版本的处理器中，Q标志位无定义。</td>
</tr>
</tbody></table>
<h3 id="零寄存器"><a href="#零寄存器" class="headerlink" title="零寄存器"></a>零寄存器</h3><blockquote>
<p>零寄存器，里面存储的是0。因为无法将立即数0直接赋值给寄存器。要先赋值寄存器后，再赋值，考虑操作比较频繁，因此有专门的寄存器做这个。</p>
</blockquote>
<ul>
<li><code>wzr</code>(<code>32bit,Word Zero Register</code>)</li>
<li><code>xzr</code>(<code>64bit</code>)</li>
<li>注意，该寄存器无法读取(<code>register read wzr</code>无法获取)和写入</li>
</ul>
<h3 id="程序计数器pc-Program-Counter）"><a href="#程序计数器pc-Program-Counter）" class="headerlink" title="程序计数器pc(Program Counter）"></a>程序计数器pc(Program Counter）</h3><blockquote>
<ul>
<li>记录<code>cpu</code>当前指令的是哪一条指令</li>
<li>存储着当前<code>CPU</code>正在执行的指令的地址</li>
<li>类似<code>8086</code>汇编的<code>rip</code>寄存器</li>
</ul>
</blockquote>
<h3 id="链接寄存器"><a href="#链接寄存器" class="headerlink" title="链接寄存器"></a>链接寄存器</h3><ul>
<li><code>lr(Link Register)</code>,也就是<code>x30</code>,但他是特殊寄存器，是没有<code>w30</code>的</li>
<li>存储着函数地址。<code>BL</code>跳转函数地址是，<code>lr</code>会记录当前<code>pc</code>的指令地址，等函数地址返回<code>ret</code>后，会取出<code>lr</code>寄存器中的<code>pc</code>指令，跳转到标记中。因此<code>BL</code>,跳转返回后，能返回到原指令的下一个指令。</li>
</ul>
<h3 id="堆栈寄存器"><a href="#堆栈寄存器" class="headerlink" title="堆栈寄存器"></a>堆栈寄存器</h3><ul>
<li><code>sp</code>寄存器,也叫栈顶指针</li>
<li><code>fp</code>寄存器，也是<code>x29</code>,也叫栈低指针。<code>sp</code>和<code>fp</code>之间是可用的。</li>
</ul>
<h4 id="叶子函数"><a href="#叶子函数" class="headerlink" title="叶子函数"></a>叶子函数</h4><blockquote>
<p>函数内不会再调用其他函数，称为叶子函数</p>
</blockquote>
<ul>
<li>堆栈平衡示例代码<ul>
<li>原代码<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>转成汇编<figure class="highlight as"><table><tr><td class="code"><pre><code class="hljs as">sub sp,sp, #<span class="hljs-number">16</span> ; sp = sp - <span class="hljs-number">16</span>,sp寄存器，留出<span class="hljs-number">16</span>字节的空间<br><br>orr w8,wzr,#<span class="hljs-number">0x3</span> ;和<span class="hljs-number">0</span>进行按位或<br>orr w9,wzr,#<span class="hljs-number">0x2</span><br><br>str w9,[sp,#<span class="hljs-number">12</span>] ; 分配到栈空间，在之前分配的内,由高到低分配<br>str w8,[sp, #<span class="hljs-number">8</span>] ;  分配到栈空间，在之前分配的内<br><br>add sp,sp,#<span class="hljs-number">16</span> ; 所谓的回收栈空间实际上是sp寄存器，回到之前分配的位置处，期间已经分配的并不会清零，变成了垃圾数据，等新的值覆盖。<br>ret<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="非叶子函数"><a href="#非叶子函数" class="headerlink" title="非叶子函数"></a>非叶子函数</h4><blockquote>
<p>函数内还会调用其他函数，称为非叶子函数,会先将lr和fp寄存器缓存起来，等函数内其他函数调用完之后，再返回，回到本函数调用的地方</p>
</blockquote>
<ul>
<li>堆栈平衡示例代码<ul>
<li>原代码<code>test2()</code><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br>    test();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>转成汇编<figure class="highlight as"><table><tr><td class="code"><pre><code class="hljs as">sub sp, sp, #<span class="hljs-number">32</span> ; sp寄存器,留出<span class="hljs-number">32</span>字节的空间<br>stp x29, x30, [sp, #<span class="hljs-number">16</span>] ; 将fp寄存器(x29),lr链接寄存器(x30)中存的数据，存放到sp后<span class="hljs-number">16</span>个字节的位置，先进行缓存(因为后续bl调用函数，会用到lr)<br>add x29, sp, #<span class="hljs-number">16</span> ; 将sp+<span class="hljs-number">16</span>的地址赋值给fp<br><br>mov w8, #<span class="hljs-number">5</span> <br>orr w9, wzr, #<span class="hljs-number">0x4</span><br>stur w9, [x29,#<span class="hljs-number">-4</span>] ; a = <span class="hljs-number">4</span>,局部变量赋值,fp比较近，用的fp<br>str w8, [sp, #<span class="hljs-number">8</span>] ; b = <span class="hljs-number">5</span>,sp比较近，用的sp(编译器的优化)<br>bl _test ; 调用test函数，此时lr会存储当前pc的值，等待后需ret返回<br><br>ldp x29, x30, [sp, #<span class="hljs-number">16</span>] ; 将原来存在sp后<span class="hljs-number">16</span>字节的数据取回,fp、lr取出原来的,<br>add sp, sp, #<span class="hljs-number">32</span> ; 收回堆栈空间<br>ret ; 根据lr回到函数调用的地方<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a><span id="jump2">寻址方式</span></h2><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><blockquote>
<p>立即寻址也叫立即数寻址，这是一种特殊的寻址方式，操作数本身就在*指令中给出，只要取出指令也就取到了操作数。这个操作数被称为<strong>立即数</strong>，对应的寻址方式也就叫做<strong>立即寻址</strong>。例如以下</p>
</blockquote>
<ul>
<li>指令：<ul>
<li><code>ADD xO, xO，＃1</code> : <code>xO = xO+1</code></li>
<li><code>ADD xO, x0， #0x3f</code> :  <code>xO = xO+0x3f</code></li>
<li>在以上两条指令中，第二个源操作数即为立即数，要求以<code>＃</code>为前缀，对于以十六进制表示的立即数，还要求在<code>＃</code> 后加上<code>0x</code>或<code>＆</code>。</li>
</ul>
</li>
</ul>
<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><blockquote>
<p>奇存器寻址就是利用寄存器中的数值作为操作数，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式。</p>
</blockquote>
<ul>
<li>以下指令：<ul>
<li><code>ADD xO, x1, x2 </code> : <code>xO = x1+x2</code></li>
<li>该指令的执行效果是将寄存器<code>x1</code>和<code>x2</code>的内容相加，其结果存放在寄存器<code>xO</code>中。</li>
</ul>
</li>
</ul>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><blockquote>
<p>寄存器间接寻址就是以寄存器中的值作为操作数的地址，而操作数本身存放在存储器中.</p>
</blockquote>
<ul>
<li>以下指令：<ul>
<li><code>ADD x0, x1, [x2]</code> : <code>xO = x1+[x2]</code>,以寄存器<code>x2</code>的值作为操作数的地址，在存储器中取得一个操作数后与<code>x1</code>相加，结果存入寄存器<code>xO</code>中。</li>
<li><code>LDR xO, [x1]</code> : <code>xO = [x1]</code>,将以 <code>x1</code> 的值为地址的存储器中的数据传送到<code>xO </code>中</li>
<li><code>STR xO, [x1]</code> : <code>[x1] = xO</code>,将<code>xO</code> 的值传送到以 <code>x1</code> 的值为地址的存储器中。</li>
</ul>
</li>
</ul>
<h3 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h3><blockquote>
<p>基址变址寻址就是将寄存器(该寄存器一般称作基址寄存器）的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。变址寻址方式常用于访问某基地址附近的地址单元。采用变址寻址方式的指令常见有以下几种形式，</p>
</blockquote>
<ul>
<li>如下所示：<ul>
<li><code>LDR xO, [x1，#4]</code> : <code>xO = [x1+4J</code>,将寄存器 <code>x1</code> 的内容加上<code>4</code>形成操作数的<strong>有效地址</strong>，从而取得操作数存入寄存器<code>xO</code>中。</li>
<li><code>LDR xO, [x1, #4]!</code> :<code>xO = [x1+4]</code>、<code>x1 = x1+4</code>,将寄存器 <code>x1</code> 的内容加上 <code>4 </code>形成操作数的<strong>有效地址</strong>，从而取得操作数存入寄存器<code>xO</code> 中，然后，<code>x1</code> 的内容自增<code>4</code>个字节。</li>
<li><code>LDR xO, [x1]，＃4</code> : <code>xO = [x1]、x1 = x1+4</code>,以寄存器<code>x1</code>的内容作为操作数的<strong>有效地址</strong>，从而取得操作数存入寄存器 <code>xO</code>中，然后，<code>x1</code>的内容自增<code>4</code>个字节。</li>
<li><code>LDR xO, [x1, x2]</code> : <code>xO = [x1+x2]</code>,将寄存器 <code>x1</code> 的内容加上寄存器<code>x2</code>的内容形成操作数的<strong>有效地址</strong>，从而取得操作数存入寄存器<code>xO</code>中。</li>
</ul>
</li>
</ul>
<h3 id="多寄存器寻址"><a href="#多寄存器寻址" class="headerlink" title="多寄存器寻址"></a>多寄存器寻址</h3><blockquote>
<p>采用多寄存器寻址方式，一条指令可以完成多个寄存器值的传送。这种寻址方式可以用一条指令完成传送最多<code>16</code>个通用寄存器的值。</p>
</blockquote>
<ul>
<li>以下指令：<ul>
<li><code>LDMIA xO, &#123;x1, x2, x3， x4&#125;</code>: <code>x1 = [x0]</code>、<code>x2 = [x0 + 4]</code>、<code>x3 = [x0 + 8]</code>、<code>x4 = [x0 + 12]</code></li>
<li>该指令的后缀<code>IA</code> 表示在每次执行完加载/存储操作后，<code>xO</code> 按字长度增加，因此，指令可将连续存储单元的值传送到<code>x1</code> ~ <code>x4</code>。</li>
</ul>
</li>
</ul>
<h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><blockquote>
<p>与基址变址寻址方式相类似，相对寻址以程序计数器 <code>PC</code> 的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。</p>
</blockquote>
<ul>
<li>以下程序段完成子程序的调用和返回，跳转指令 <code>BL</code>采用了相对寻址方式：  <figure class="highlight as"><table><tr><td class="code"><pre><code class="hljs as">    BL, NEXT ; 跳转到子程序 `NEXT` 处执行<br>    ......<br>NEXT<br>    ......<br>    MOV PC. LR ; 从子程序返回<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><blockquote>
<ul>
<li>堆栈是一种数据结构，按先进后出 (<code>First In Last Out, FILO</code>）的方式工作，使用一个称作堆栈指针的专用寄存器指示当前的操作位置，堆栈指针总是指向栈顶。</li>
<li>当堆栈指针指向最后压入堆栈的数据时，称为满堆栈 (<code>Full Stack</code>），而当堆栈指针指向下一个将要放入数据的空位置时，称为空堆栈 <code>(Empty Stack</code>)。</li>
<li>同时，根据堆栈的生成方式，又可以分为递增堆栈 (<code>Ascending Stack</code>）和递减堆栈 (<code>DecendingStack</code>），当堆栈由低地址向高地址生成时，称为递增堆栈，当堆栈由高地址向低地址生成时，称为递减堆栈。</li>
</ul>
</blockquote>
<ul>
<li>这样就有四种类型的堆栈工作方式，<code>ARM</code> 微处理器支持这四种类型的堆栈工作方式，即：<ul>
<li>满递增堆栈：堆栈指针指向最后压入的数据，且由低地址向高地址生成。</li>
<li>满递减堆栈：堆栈指针指向最后压入的数据，且由高地址向低地址生成。</li>
<li>空递增堆栈：堆栈指针指向下一个将要放入数据的空位置，且由低地址向高地址生成。</li>
<li>空递减堆栈：堆栈指针指向下一个将要放入数据的空位置，且由高地址向低地址生成。</li>
</ul>
</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="指令的条件域"><a href="#指令的条件域" class="headerlink" title="指令的条件域"></a><span id="jump1">指令的条件域</span></h3><ul>
<li>当处理器工作在<code>ARM</code>状态时，几乎所有的指令均根据<code>CPSR</code>中条件码的状态和指令的条件域有<br>条件的执行。当指令的执行条件满足时，指令被执行，否则指令被忽略。</li>
<li>每一条<code>ARM</code>指令包含<code>4</code>位的条件码(条件码是指令的，而非<code>cpsr</code>寄存器的)，位于指令的最高<code>4</code>位<code>[31:28]</code>。条件码共有<code>16</code>种，每种条件码可用两个字符表示，这两个字符可以添加在<code>指令助记符</code>的后面和指令同时使用。例如，跳转指令<code>B</code>可以加上后缀<code>EQ</code>变为<code>BEQ</code>表示<strong>相等则跳转</strong>，即当<code>CPSR</code>中的<code>Z</code>标志置位时发生跳转。</li>
<li>在<code>16</code>种条件标志码中，只有<code>15</code>种可以使用，如下表所示，第<code>16</code>种（<code>1111</code>）为系统保留，</li>
</ul>
<table>
<thead>
<tr>
<th align="center">条件码</th>
<th align="center">助记符后缀</th>
<th align="center">标 志</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">EQ</td>
<td align="center">Z置位</td>
<td align="center">相等</td>
</tr>
<tr>
<td align="center">0001</td>
<td align="center">NE</td>
<td align="center">Z清零</td>
<td align="center">不相等</td>
</tr>
<tr>
<td align="center">0011</td>
<td align="center">CS</td>
<td align="center">C置位</td>
<td align="center">无符号数大于或等于</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">MI</td>
<td align="center">N置位</td>
<td align="center">负数</td>
</tr>
<tr>
<td align="center">0101</td>
<td align="center">PL</td>
<td align="center">N清零</td>
<td align="center">正数或零</td>
</tr>
<tr>
<td align="center">0110</td>
<td align="center">VS</td>
<td align="center">V置位</td>
<td align="center">溢出</td>
</tr>
<tr>
<td align="center">0111</td>
<td align="center">VC</td>
<td align="center">V清零</td>
<td align="center">未溢出</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">HI</td>
<td align="center">C置位Z清零</td>
<td align="center">无符号数大于</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">LS</td>
<td align="center">C清零Z置位</td>
<td align="center">无符号数小于或等于</td>
</tr>
<tr>
<td align="center">1010</td>
<td align="center">GE</td>
<td align="center">N等于V</td>
<td align="center">带符号数大于或等于</td>
</tr>
<tr>
<td align="center">1011</td>
<td align="center">LT</td>
<td align="center">N 不等于V</td>
<td align="center">带符号数小于</td>
</tr>
<tr>
<td align="center">1100</td>
<td align="center">GT</td>
<td align="center">Z清零且(N等于V)</td>
<td align="center">带符号数大于</td>
</tr>
<tr>
<td align="center">1101</td>
<td align="center">LE</td>
<td align="center">Z置位或(N不等于V)</td>
<td align="center">带符号数小于或等于</td>
</tr>
<tr>
<td align="center">1110</td>
<td align="center">AL</td>
<td align="center">忽略</td>
<td align="center">无条件执行</td>
</tr>
</tbody></table>
<h3 id="move指令"><a href="#move指令" class="headerlink" title="move指令"></a>move指令</h3><ul>
<li><code>MOV</code>指令的格式为：<ul>
<li><code>MOV&#123;条件&#125;&#123;S&#125;目的寄存器，源操作数</code></li>
<li><code>MOV</code> 指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。其中<code>S</code>选项决定指令的操作是否影响 <code>CPSR</code> 中条件标志位的值，当没有<code>S</code>时指令不更新<code>CPSR </code>中条件标志位的值。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>mov x1,x0</code> :将寄存器<code> x0</code> 的值传送到寄存器 <code>x1</code>。</li>
<li><code>mov x1,x0,LSL#0x3</code> : 将寄存器<code>x0</code>的值左移<code>3</code>位后传送到<code>x1</code>。</li>
</ul>
</li>
</ul>
<h3 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h3><ul>
<li><code>ADD</code> 指令的格式为：<ul>
<li><code>ADD&#123;条件&#125;&#123;S&#125; 目的备存器，操作数1，操作数2</code></li>
<li><code>ADD</code> 指令用于把两个操作数相加，并将结果存放到目的寄存器中。<code>操作数1</code>应是一个寄存器，<code>操作数2</code>可以是一个寄存器，被<code>移位的寄存器</code>，或<code>一个立即数</code>。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>ADD xO, x1, x2</code> : <code>xO = x1+x2</code></li>
<li><code>ADD xO, x1, #256</code> : <code>xO = x1+256</code></li>
<li><code>ADD xO, x2, x3, LSL#1</code> : <code>xO = x2 + (x3 &lt;&lt; 1)</code></li>
</ul>
</li>
</ul>
<h3 id="sub-指令"><a href="#sub-指令" class="headerlink" title="sub 指令"></a>sub 指令</h3><ul>
<li><code>SUB</code> 指令的格式为：<ul>
<li><code>SUB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</code></li>
<li><code>SUB</code> 指令用于把<code>操作数1</code>减去<code>操作数2</code>，并将结果存放到<code>目的寄存器</code>中。<code>操作数1</code>应是一个<code>寄存存器</code>，<code>操作数2</code>可以是一个<code>寄存器</code>、<code>被移位的寄存器</code>或一个<code>立即数</code>。该指令可用于<code>有符号数</code>或<code>无符号数</code>的减法运算。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>sub xO, x1,x2</code> :<code>xO =x1- x2</code>。</li>
<li><code>sub xO, x1,#0x8</code> :<code>xO =x1- 8</code>。</li>
<li><code>sub xO, x2，x3，LSL#1</code> : <code>xO =x2- (x3 &lt;&lt; 1)</code>。</li>
</ul>
</li>
</ul>
<h3 id="CMP-指令"><a href="#CMP-指令" class="headerlink" title="CMP 指令"></a>CMP 指令</h3><ul>
<li><code>CMP 指令的格式为</code><ul>
<li><code>CMP&#123;条件&#125;操作数1，操作数 2</code></li>
<li><code>CMP</code>指令用于把一个<code>寄存器</code>的内容和另一个<code>奇存器</code>的内容或<code>立即数</code>进行比较，同时更新 <a href="#jump">CPSR</a>中条件标志位的值。</li>
<li>该指令进行一次<strong>减法运算</strong>，但不存储结果，只更改条件标志位。标志位表示的是<code>操作数1</code>与<code>操作数2</code>的关系（大、小、相等），例如，当<code>操作数1</code>大于<code>操作数2</code>，则此后的有GT后缀的指令将可以执行。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>cmp x1, xO</code> : 将寄存器 <code>x1</code> 的值与寄存器<code>xO</code> 的值相减，并根据结果设置 <a href="#jump">CPSR</a>的标志位</li>
<li><code>cmp x1, #100</code> :将寄存器 <code>x1</code> 的值与立即数 <code>100</code>相减，并根据结果设置 <a href="#jump">CPSR</a> 的标志位</li>
</ul>
</li>
</ul>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h4 id="B指令"><a href="#B指令" class="headerlink" title="B指令"></a>B指令</h4><ul>
<li><code>B</code>指令的格式为：<ul>
<li><code>B&#123;条件&#125;  目标地址</code></li>
<li><code>B</code>指令是最简单的跳转指令。一旦遇到一个<code>B</code>指令，<code>ARM</code> 处理器将立即跳转到给定的目标地址，从那里继续执行。</li>
<li><strong>注意</strong>,存储在跳转指令中的实际值是相对当前<code>PC</code>值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是<code>24</code>位有符号数，左移两位后有符号扩展为 <code>32</code> 位，表示的有效偏移为 <code>26</code>位(前后 <code>32MB</code> 的地址空间）。以下指令：</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>B Label</code> : 程序无条件跳转到标号 <code>Label</code> 处执行  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">CMP x1，#0<br>b.eq Label<br></code></pre></td></tr></table></figure></li>
<li>上面指令是当 <code>CPSR</code> 寄存器中的<code>z</code>条件码置位时，程序跳转到标号 <code>Label</code> 处执行,见<a href="#jump1">条件</a></li>
</ul>
</li>
</ul>
<h4 id="BL指令"><a href="#BL指令" class="headerlink" title="BL指令"></a>BL指令</h4><ul>
<li><code>BL</code>指令的格式为：<ul>
<li><code>BL&#123;条件&#125;目标地址</code></li>
<li><code>BL</code> 是另一个跳转指令，但跳转之前，会在寄存器<code>lr</code>中保存 <code>PC</code> 的当前内容，因此，可以通过将<code>lr</code> 的内容重新加载到 <code>PC</code> 中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本但常用的手段。</li>
<li><strong>注意</strong>，只有使用<code>BL</code>调用有<code>ret</code>返回的才会回到原来的位置，类似函数调用。<code>B</code>指令是没有这个效果的。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>BL Labe1</code> : 当程序无条件跳转到标号 <code>Label</code> 处执行时，同时将当前的 <code>PC</code>值保存到 <code>lr</code>中</li>
</ul>
</li>
</ul>
<h4 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h4><blockquote>
<p>函数返回，结合<code>BL</code>指令使用</p>
</blockquote>
<ul>
<li>其本质是将<code>lr(x30)</code>寄存器的值赋值给<code>pc</code>,就是原来<code>BL</code>指令调用的下一条指令，调用前会存到<code>lr(x30)</code>中。<code>ret</code>的时候会将<code>lr(x30)</code>赋值给<code>pc</code>,这样回到了原来<code>BL</code>的调用的指令处</li>
</ul>
<h4 id="内存读操作指令"><a href="#内存读操作指令" class="headerlink" title="内存读操作指令"></a>内存读操作指令</h4><blockquote>
<p>从内存中<code>读取数据</code></p>
</blockquote>
<h5 id="ldr指令"><a href="#ldr指令" class="headerlink" title="ldr指令"></a>ldr指令</h5><ul>
<li><code>LDR</code> 指令的格式为：<ul>
<li><code>LDR&#123;条件&#125; 目的寄存器，&lt;存储器地址〉</code></li>
<li><code>LDR</code> 指令用于从存储器中将一个<code>32</code>位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取 <code>32</code> 位的字节数据到通用寄存器，然后对数据进行处理。当程序计数器<code>PC</code> 作为目的寄存器时，指令从存储器中读取的字节数据被当作目的地址，从而可以实现程序流程的跳转。该指令在程序设计中比较常用，且<a href="#jump2">寻址方式</a>灵活多样</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>ldr xO, [x1]</code> : 将存储器地址为 <code>x1</code> 的8字节数据读入寄存器<code>xO</code>。</li>
<li><code>ldr wO, [w1]</code> : 将存储器地址为 <code>w1</code> 的4字节数据读入寄存器<code>wO</code>。//根据寄存器是8字节取值还是4字节</li>
<li><code>ldr xO, [x1, x2]</code> : 将存储器地址为 <code>x1+x2</code> 的字数据读入寄存器<code>xO</code>。</li>
<li><code>ldr xO, [x1, #8]</code> : 将存储器地址为 <code>x1+8</code> 的字数据读入寄存器<code>xO</code>。</li>
<li><code>LDR xO,[x1, x2]!</code> : 将存储器地址为 <code>x1+x2</code> 的字数据读入寄存器<code>xO</code>，并将新地址 <code>x1 + x2</code>写入<code>x1</code></li>
<li><code>LDR xO, [x1. #8]!</code> : 将存储器地址为 <code>x1+8</code> 的字数据读入寄存器<code>xO</code>，并将新地址 <code>x1 + 8</code>写入<code>x1</code></li>
<li><code>LDR xO. [x1],x2</code> : 将存储器地址为 <code>x1</code> 的字数据读入寄存器<code>xO</code>，并将新地址<code>x1+x2</code>写入<code>x1</code></li>
<li><code>LDR xO, [x1，x2，LSL#2]!</code> : 将存储器地址为<code>x1+x2x4</code>字数据读入寄存器<code>xO</code>，并将新地址<code>x1+x2×4</code>写入<code>x1</code>,<code>LSL#2</code>即 <code>&lt;&lt; 2</code>。</li>
<li><code>LDR xO, [x1]，x2，LSL＃2</code> : 将存储器地址为 <code>x1</code> 的字数据读入寄存器<code>xO</code>，并将新地址 <code>x1+x2x4</code>写入<code>x1</code></li>
</ul>
</li>
<li><code>ldur</code>指令，也是内存中读取数据，一般是<code>ldr xO, [x1, #-8]</code>,立即数为负数，具体用法和ldr一样</li>
</ul>
<h5 id="ldp指令"><a href="#ldp指令" class="headerlink" title="ldp指令"></a>ldp指令</h5><blockquote>
<p>将内存中的一对数据赋值给一对寄存器</p>
</blockquote>
<ul>
<li><code>ldp w0,w1,[x2,#10]</code>,将<code>x2,#10</code>上存储的前<code>4</code>个字节数据给<code>w0</code>,后<code>4</code>个字节赋值给<code>w1</code></li>
</ul>
<h4 id="内存写入操作"><a href="#内存写入操作" class="headerlink" title="内存写入操作"></a>内存写入操作</h4><h5 id="STR-指令"><a href="#STR-指令" class="headerlink" title="STR 指令"></a>STR 指令</h5><ul>
<li><code>STR</code> 指令的格式为：<ul>
<li><code>STR&#123;条件&#125;源寄存器，&lt;存储器地址〉</code></li>
<li><code>STR</code> 指令用于从源寄存器中将字节数据传送到存储器中。该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令 <code>LDR</code>。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>STR wO, [x1]</code>: 将<code>w0</code>的<code>4</code>个字节数据，写入<code>x1</code>的前<code>4</code>个字节</li>
<li><code>STR wO, [x1]，＃8</code> : 将<code>wO</code> 中的字数据写入以<code>x1</code>为地址的前<code>4</code>个字节存储器中，并将新地址 <code>x1+8</code>写入<code>x1</code>。</li>
<li><code>STR wO, [x1, #8]</code> : 将<code>wO</code> 中的字数据写入以 <code>x1十8</code>为地址的前<code>4</code>个字节存储器中。</li>
</ul>
</li>
<li><code>stur</code>指令和<code>ldur</code>指令一样，<code>stp</code>指令和<code>ldp</code>指令一样</li>
<li><strong>注意</strong>不能用<code>STR #8, [x1]</code>,第一个必须是寄存器,因为寄存器才知道会覆盖多少字节</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>lldb指令</title>
    <url>/2023/04/10/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E5%B8%B8%E7%94%A8lldb%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lldb指令"><a href="#lldb指令" class="headerlink" title="lldb指令"></a>lldb指令</h1><ul>
<li>指令的格式是,<code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...])</code><ul>
<li><code>&lt;command&gt;</code>: 命令</li>
<li><code>&lt;subcommand&gt;</code>: 子命令</li>
<li><code>&lt;action&gt;</code>: 命令操作</li>
<li><code>&lt;options&gt;</code>: 命令选项</li>
<li><code>&lt;argument&gt;</code>: 命令参数</li>
<li>例如给<code>test</code>函数设置断点,<code>breakpoint set -n test</code><ul>
<li><code>breakpoint</code>是<code>&lt;command&gt;</code></li>
<li><code>set</code>是<code>&lt;action&gt;</code></li>
<li><code>-n</code>是<code>&lt;options&gt;</code>,这里是函数名称<code>name</code></li>
<li><code>test</code>是<code>&lt;argument&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="lldb常用指令"><a href="#lldb常用指令" class="headerlink" title="lldb常用指令"></a>lldb常用指令</h2><h3 id="查看指令的用法"><a href="#查看指令的用法" class="headerlink" title="查看指令的用法"></a>查看指令的用法</h3><ul>
<li><code>help &lt;command&gt;</code>,例如:<code>help breakpoint</code>、<code>help breakpoint set</code></li>
</ul>
<h3 id="读取寄存器的值"><a href="#读取寄存器的值" class="headerlink" title="读取寄存器的值"></a>读取寄存器的值</h3><ul>
<li><code>register read rbp</code> ,读取<code>rbp</code>中的值（<code>lldb</code>可以不用加%）</li>
<li><code>register read/o rbp</code>,读取值，以<code>8</code>进制显示，默认<code>16</code>进制</li>
<li><code>register read</code>,获取当前所有的寄存器的值</li>
</ul>
<h3 id="修改寄存器的值"><a href="#修改寄存器的值" class="headerlink" title="修改寄存器的值"></a>修改寄存器的值</h3><ul>
<li><code>register write 寄存器名称 数值</code></li>
<li><code>register write rax O</code></li>
</ul>
<h3 id="读取内存中的值"><a href="#读取内存中的值" class="headerlink" title="读取内存中的值"></a>读取内存中的值</h3><ul>
<li><code>x/数量-格式-字节大小 内存地址</code></li>
<li><code>x/3xw 0x000010</code>,显示内存中的数据，<code>3</code>组数据，每组<code>4</code>个字节以<code>16</code>进制显示</li>
<li>格式<ul>
<li><code>x</code>是<code>16</code>进制，</li>
<li><code>f</code>是浮点，</li>
<li><code>d</code>是十进制</li>
</ul>
</li>
<li>字节大小<ul>
<li><code>b-byte</code> 1字节</li>
<li><code>h-half word</code> 2字节</li>
<li><code>W-word</code> 4字节</li>
<li><code>g- giant word</code> 8字节</li>
</ul>
</li>
</ul>
<h3 id="修改内存中的值"><a href="#修改内存中的值" class="headerlink" title="修改内存中的值"></a>修改内存中的值</h3><ul>
<li><code>memory write 内存地址 数值</code></li>
<li><code>memory write 0x0000010 10</code></li>
</ul>
<h3 id="expression-cmd-options-–-expr"><a href="#expression-cmd-options-–-expr" class="headerlink" title="expression [cmd-options] – [expr]"></a>expression [cmd-options] – [expr]</h3><blockquote>
<p>执行一个表达式,调试过程中动态执行代码</p>
</blockquote>
<ul>
<li><code>expression</code>,可以简写：<code>expr</code><ul>
<li><code>cmd-options</code>: 命令选项</li>
<li><code>--</code>: 命令选项结束符，表示所有的命令已经设置完毕，如果没有命令选项，<code>--</code>可以省略</li>
<li><code>expr</code>: 需要执行的表达是 </li>
<li>例如，<code>expression self.view.backgroudColor = [UIColor redColor]</code></li>
</ul>
</li>
<li><code>expression</code>、<code>expression --</code>和指令<code>print</code>、<code>p</code>、<code>call</code>的效果一样，都可以打印对象的内存</li>
<li><code>expression -O --</code>和指令<code>po</code>的效果一样</li>
</ul>
<h3 id="po-表达式"><a href="#po-表达式" class="headerlink" title="po 表达式"></a>po 表达式</h3><ul>
<li><code>po 表达式</code><ul>
<li><code>print</code> 表达式</li>
<li><code>po/x $rax</code></li>
<li><code>po (int)$rax</code></li>
</ul>
</li>
</ul>
<h3 id="thread-backtrace"><a href="#thread-backtrace" class="headerlink" title="thread backtrace"></a>thread backtrace</h3><ul>
<li>打印线程的堆栈信息</li>
<li>和指令<code>bt</code>的效果一样</li>
</ul>
<h3 id="thread-return-expr"><a href="#thread-return-expr" class="headerlink" title="thread return [expr]"></a>thread return [expr]</h3><ul>
<li>让函数直接返回某个值，不会执行断点后面的方法</li>
</ul>
<h3 id="frame-variable-variable-name"><a href="#frame-variable-variable-name" class="headerlink" title="frame variable[variable-name]"></a>frame variable[variable-name]</h3><ul>
<li>打印当前栈帧的所有变量,<code>frame variable -L p1</code>,打印p1结构体的存储情况</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul>
<li><code>thread continue</code>、<code>continue</code>、<code>c</code>: 程序继续运行</li>
<li><code>thread step-over</code>、 <code>next</code>、<code>n</code>（全称和简写）<ul>
<li>单步运行，把子函数当做整体一步执行（源码级别）</li>
</ul>
</li>
<li><code>thread step-in</code>、 <code>step</code>、<code>s</code><ul>
<li>单步运行，遇到子函数会进入子函数（源码级别），与si不同，可能会跳过好几句汇编代码</li>
</ul>
</li>
<li><code>thread step-inst-over</code>、 <code>nexti</code>、<code>ni</code><ul>
<li>单步运行，把子函数当做整体一步执行（汇编级别）</li>
</ul>
</li>
<li><code>thread step-inst</code>, <code>stepi</code>、<code>si</code><ul>
<li>单步运行，遇到子函数会进入子函数（汇编级别）</li>
</ul>
</li>
<li><code>thread step-out</code>, <code>finish</code><ul>
<li>直接执行完当前函数的所有代码，返回到上一个函数（遇到断点会卡住）</li>
</ul>
</li>
</ul>
<h3 id="breakpoint-set"><a href="#breakpoint-set" class="headerlink" title="breakpoint set"></a>breakpoint set</h3><blockquote>
<p>设置断点</p>
</blockquote>
<ul>
<li><code>breakpoint set -a 函数地址</code></li>
<li><code>breakpoint set -n 函数名</code><ul>
<li><code>breakpoint set -n test</code></li>
<li><code>breakpoint set -n touchBegan:withEvent:</code></li>
<li><code>breakpoint set -n &quot;-[ViewController touchBegan:withEvent:]&quot;</code></li>
</ul>
</li>
<li><code>breakpoint set -r 正则表达式</code><ul>
<li><code>breakpoint set -r est</code>,对所有函数名包含<code>est</code>的函数打断点</li>
</ul>
</li>
<li><code>breakpoint set -s 动态库 -n 函数名</code></li>
<li><code>breakpoint list</code>,列出所有的断点（每个断点都有自己的编号）<ul>
<li><code>breakpoint disable 断点编号</code>: 禁用断点</li>
<li><code>breakpoint enable 断点编号</code>: 启用断点</li>
<li><code>breakpoint delete 断点编号</code>: 删除断点</li>
</ul>
</li>
</ul>
<h3 id="breakpoint-command"><a href="#breakpoint-command" class="headerlink" title="breakpoint command"></a>breakpoint command</h3><blockquote>
<p>在断点的时候，执行某些命令</p>
</blockquote>
<ul>
<li><code>breakpoint command add 断点编号</code>，执行后需要添加后续要执行的指令<ul>
<li>给断点预先设置需要执行的命令，到触发断点时，就会按顺序执行命令</li>
</ul>
</li>
<li><code>breakpoint command list 断点编号</code><ul>
<li>查看某个断点设置的命令</li>
</ul>
</li>
<li><code>breakpoint command delete 断点编号</code><ul>
<li>删除某个断点设置的命令</li>
</ul>
</li>
</ul>
<h3 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h3><blockquote>
<p>在内存数据发生改变的时候触发</p>
</blockquote>
<ul>
<li><code>watchpoint set variable 变量</code><ul>
<li><code>watchpoint set variable self-&gt;age</code></li>
</ul>
</li>
<li><code>watchpoint set expression 地址</code><ul>
<li><code>watchpoint set expression &amp;(self-&gt;_age)</code></li>
</ul>
</li>
<li><code>watchpoint list</code></li>
<li><code>watchpoint disable 断点编号</code> </li>
<li><code>watchpoint enable 断点编号</code></li>
<li><code>watchpoint delete 断点编号</code></li>
<li> <code>watchpoint command add 断点编号</code></li>
<li> <code>watchpoint command list 断点编号</code> </li>
<li> <code>watchpoint command delete 断点编号</code> </li>
</ul>
<h3 id="模块查找"><a href="#模块查找" class="headerlink" title="模块查找"></a>模块查找</h3><ul>
<li><code>image lookup</code><ul>
<li><code>image lookup -t 类型</code>: 查找某个类型的信息</li>
<li><code>image lookup -a 地址</code>: 根据内存地址查找在模块中的位置,查看在对应源码的哪一行</li>
<li> <code>image lookup -n 符号或者函数名</code>: 查找某个符号或函数的位置</li>
</ul>
</li>
<li><code>image list</code><ul>
<li> 列出所加载的模块信息</li>
<li> <code>image list -o -f</code>,打印出模块的偏移地址、全路径</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>应用技巧</category>
      </categories>
      <tags>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>swift派发机制</title>
    <url>/2023/04/03/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="swift派发机制"><a href="#swift派发机制" class="headerlink" title="swift派发机制"></a><code>swift</code>派发机制</h1><blockquote>
<p><code>swift</code>派发机制分：静态派发和动态派发</p>
</blockquote>
<ul>
<li><code>内联</code>（<code>inline</code>）,属于<code>静态派发</code>的一种，最快的派发方式，在函数调用的地方，编译器直接展开函数的代码。</li>
<li><code>静态派发</code>：（又叫：<code>直接调用</code>）<ul>
<li><code>静态派发</code>机制，同时支持<code>值类型</code>和<code>引用类型</code>；<code>静态派发</code>是最快的, 不止是因为需要调用的<code>指令集</code>会更少, 并且编译器还能够有很大的优化空间,<code>静态派发</code>也有人称为<code>直接调用</code>.</li>
<li><code>结构体</code>中以及<code>extension</code>的方法，默认都是<code>直接派发</code></li>
<li>然后，<code>直接调用</code>也是最大的局限, 而且因为缺乏<code>动态性</code>所以没办法支持<strong>继承</strong></li>
</ul>
</li>
<li><code>消息派发</code>：<ul>
<li><code>消息派发</code>是<code>动态派发</code>机制的一种，仅支持<code>引用类型</code>(<code>reference types</code>) 比如：<code>Class</code>，对于<code>动态性</code>或者<code>动态派发</code>，我们需要使用到<code>继承特性</code>，而这是<code>值类型</code>不支持的。</li>
<li><code>消息派发</code>是调用函数最动态的方式. 也是<code>Cocoa</code>的基石, 这样的机制催生了 <code>KVO</code>,<code>消息转发</code> 等功能. </li>
<li>这种运作方式的关键在于开发者可以在运行时改变函数的行为. 不止可以通过<code>swizzling</code>来改变, 甚至可以用<code>isa-swizzling</code>修改对象的继承关系, 可以在面向对象的基础上实现自定义派发.</li>
</ul>
</li>
<li><code>函数表派发</code>：<ul>
<li><code>函数表派发</code>是<code>编译型</code>语言实现<code>动态行为</code>最常见的实现方式. 函数表使用了一个<code>数组</code>来存储类声明的每一个函数的<code>指针</code>. 大部分语言把这个称为 <code>virtual table</code>(<code>虚函数表</code>), <code>Swift</code> 里称为 <code>witness table</code>. 每一个<code>类</code>都会维护一个<code>函数表</code>, 里面记录着<code>类所有的函数</code>, 如果<code>父类函数</code>被 <code>override</code> 的话, 表里面只会保存被 <code>override</code> 之后的函数. 一个子类新添加的函数, 都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数.</li>
<li>查表是一种简单, 易实现, 而且性能可预知的方式. 然而, 这种派发方式比起<code>静态派发</code>还是慢一点. 从字节码角度来看, 多了<code>两次读</code>(读<code>函数表地址</code>，以及<code>函数地址</code>)和<code>一次跳转</code>, 由此带来了性能的损耗. 另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化. (如果函数带有副作用的话)</li>
<li>这种基于数组的实现, 缺陷在于<code>函数表无法拓展</code>。子类会在虚数函数表的最后插入新的函数, 没有位置可以让 <code>extension</code> 安全地<code>插入函数</code>，因此<code>extension</code>中的方法是不会加到<code>函数表内</code>的，属于静态派发</li>
</ul>
</li>
</ul>
<p>这四种派发技术，由编译器来决定使用哪种。</p>
<h1 id="静态派发VS动态派发（Swift-VS-OC）"><a href="#静态派发VS动态派发（Swift-VS-OC）" class="headerlink" title="静态派发VS动态派发（Swift VS OC）"></a>静态派发VS动态派发（<code>Swift</code> VS <code>OC</code>）</h1><ul>
<li><p><code>OC</code>默认支持动态派发，这种派发形式以<code>多态</code>的形式为开发人员提供了灵活性。</p>
<ul>
<li>比如：子类可以重写父类的方法</li>
</ul>
</li>
<li><p><code>动态派发</code>以一定的<code>运行时开销</code>为代价，提供了语言的<code>灵活性</code>。</p>
</li>
<li><p>在<code>动态派发机制</code>下，对于每个方法的调用，编译器必须在<code>方法列表</code>中查找执行方法的实现。</p>
</li>
<li><p><code>编译器</code>需要判断<code>调用方</code>，是选择<code>父类的实现</code>还是<code>子类的实现</code>，而且由于所有对象的内存都是在<code>运行时分配的</code>，因此编译器只能在<code>运行时执行检查</code>。</p>
</li>
<li><p>而<code>静态调用</code>则没有这个问题。在编译期的时候，编译器就知道要为<code>某个方法</code>调用某种实现。因此编译器可以<code>执行某些优化</code>，甚至在可能的情况下，可以将某些代码转换成<code>inline</code>函数，从而使整体执行速度更快</p>
</li>
</ul>
<h2 id="swift中实现动态派发和静态派发"><a href="#swift中实现动态派发和静态派发" class="headerlink" title="swift中实现动态派发和静态派发"></a>swift中实现动态派发和静态派发</h2><h3 id="动态派发"><a href="#动态派发" class="headerlink" title="动态派发"></a>动态派发</h3><ul>
<li><code>函数表派发</code><ul>
<li><code>类</code>中定义的方法默认是<code>函数表派发</code></li>
<li><code>协议</code>中定义的方法，在调用协议时，会去<code>协议的函数表</code>中查询（这种查询过程，也是<code>函数派发</code>)，注意编器可以优化，可能会去除去<code>协议函数表查询</code>的过程。</li>
</ul>
</li>
<li><code>消息派发</code><ul>
<li>方法前加上<code>@objc</code>，<code>OC</code>中的代码调用<code>swift</code>方法，属于消息派发，但是如果是<ul>
<li><code>class</code>内部定义的方法，<code>swift</code>调用还是<strong>函数调用</strong></li>
<li><code>extension</code>内部定义的方法，则是<strong>消息派发</strong></li>
<li>此外，<strong>注意</strong>，一般而言<code>extension</code>中定义的方法，子类是无法重写的，但是由于加了<code>@objc</code>为消息转发机制，和<code>OC</code>类中方法一样，可以在子类中<code>重写</code>(无论是在<code>类中</code>还是<code>extension</code>均可重写)，并且<code>重写</code>后的方法，同样是<code>消息派发机制</code></li>
</ul>
</li>
<li>在类中，方法前加上<code>@objc dynamic</code>，<code>swift</code>和<code>OC</code>中调用，均为<code>消息派发</code></li>
</ul>
</li>
</ul>
<h3 id="静态派发"><a href="#静态派发" class="headerlink" title="静态派发"></a>静态派发</h3><ul>
<li><code>内联</code><ul>
<li>编译器会自动将<code>静态派发</code>的某些函数变成<code>内联函数</code><ul>
<li><code>@inline</code>,内联注解， <code>Apple</code> 的文档中是找不到，不建议使用<ul>
<li><code>@inline(__always) func test(i:Int) &#123;  &#125;</code>,开启编译优化后，即使代码很长也会被内联（递归调用,动态派发除外）</li>
<li><code>@inline(never) func test(i:Int) &#123;  &#125;</code>,永远不会被内联，即使开启了编译器优化（有时不起作用,还是会转为内联）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>直接调用</code><ul>
<li>值类型、引用类型以及协议的<code>extension</code>中定义的方法，一般默认是<code>静态派发</code></li>
<li>值类型中定义的方法</li>
<li>引用类型中用<code>final</code>修饰的方法</li>
<li>所有用<code>static</code>修饰的方法</li>
</ul>
</li>
</ul>
<h2 id="派发机制和重写的关系"><a href="#派发机制和重写的关系" class="headerlink" title="派发机制和重写的关系"></a>派发机制和重写的关系</h2><ul>
<li><code>直接派发</code>由于是直接跳到<code>函数地址</code>去执行，因此<code>直接派发</code>的方法是无法进行重写的<ul>
<li>类中<code>extension</code>中的方法，默认是<code>直接派发</code>，因此无法重写</li>
<li><code>extension</code>中的方法，用<code>@objc</code>修饰会变成<code>消息派发</code>，子类可以<code>重写</code></li>
</ul>
</li>
<li>函数派发和消息派发都可以由子类进行重写<ul>
<li>函数派发的重写，只能在子类的<code>非extension</code>中，也就是声明处</li>
<li>消息派发的重写，是可以在子类的<code>extension</code>中进行重写的，类似<code>OC</code>中的分类</li>
</ul>
</li>
</ul>
<h2 id="一些特殊情况"><a href="#一些特殊情况" class="headerlink" title="一些特殊情况"></a>一些特殊情况</h2><ol>
<li><code>LoudPerson</code>实现的函数前面没有 <code>override</code> 修饰, 这是一个提示, 也许代码不会像我们设想的那样运行<ul>
<li><code>LoudPerson</code> 没有在 <code>Greetable</code> 的协议记录表(<code>Protocol Witness Table</code>)里<code>成功注册</code>, 当 <code>sayHi()</code> 通过<code>Greetable</code> 协议派发时, 默认的实现就会被调用</li>
<li>解决的方法就是, 在<code>Person</code>类声明的作用域里<code>就要</code>提供所有协议里定义的函数, 即使已经有默认实现. 或者, 你可以在类的前面加上一个 <code>final</code> 修饰符, 保证这个类不会被继承.<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Greetable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHi</span>()</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Greetable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHi</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Greetable Hello&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greetings</span>(<span class="hljs-params">greeter</span>: <span class="hljs-type">Greetable</span>)</span> &#123;<br>    greeter.sayHi()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>: <span class="hljs-title">Greetable</span> </span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoudPerson</span>: <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHi</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LoudPerson HELLO&quot;</span>)<br>    &#125;<br>&#125;<br><br>greetings(greeter: <span class="hljs-type">LoudPerson</span>())<span class="hljs-comment">//输出Greetable Hello</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>代码混淆</title>
    <url>/2023/04/02/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<ul>
<li>什么是加固<ul>
<li>加固是为了增加应用的安全性，防止应用被破解、盗版、二次打包、注入、反编译等</li>
</ul>
</li>
<li>常见的加固方式有<ul>
<li>数据加密（字符串、网络数据、敏感数据等）</li>
<li>应用加壳（二进制加密）</li>
<li>代码混淆（类名、方法名、代码逻辑等）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><ul>
<li><p>iOS程序可以通过class-dump、Hopper、IDA等获取类名、方法名、以及分析程序的执行逻辑</p>
<ul>
<li>如果进行代码混淆，可以加大别人的分析难度</li>
</ul>
</li>
<li><p>iOS的代码混淆方案</p>
<ul>
<li><p>源码的混淆</p>
<ul>
<li>类名</li>
<li>方法名</li>
<li>协议名</li>
</ul>
</li>
<li><p>LLVM中间代码<code>IR</code>的混淆（容易产生BUG）</p>
<ul>
<li>自己编写<code>Pass</code></li>
<li><a href="https://github.com/obfuscator-llvm/obfuscator">ollvm</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="源码的混淆-通过宏定义混淆方法名、类名"><a href="#源码的混淆-通过宏定义混淆方法名、类名" class="headerlink" title="源码的混淆 - 通过宏定义混淆方法名、类名"></a>源码的混淆 - 通过宏定义混淆方法名、类名</h3><ul>
<li><p>注意点</p>
<ul>
<li>不能混淆系统方法</li>
<li>不能混淆<code>init</code>开头的等初始化方法</li>
<li>混淆属性时需要额外注意<code>set</code>方法</li>
<li>如果<code>xib</code>、<code>storyboard</code>中用到了混淆的内容，需要手动修正</li>
<li>可以考虑把需要混淆的符号都加上前缀，跟系统自带的符号进行区分</li>
<li>混淆过多可能会被<code>AppStore</code>拒绝上架，需要说明用途</li>
</ul>
</li>
<li><p>建议</p>
<ul>
<li>给需要混淆的符号加上了一个特定的前缀</li>
<li><a href="https://github.com/CoderMJLee/MJCodeObfuscation">工具参考</a></li>
</ul>
</li>
</ul>
<h3 id="ios-class-guard"><a href="#ios-class-guard" class="headerlink" title="ios-class-guard"></a>ios-class-guard</h3><blockquote>
<ul>
<li>它是基于<code>class-dump</code>的扩展</li>
<li>用<code>class-dump</code>扫描出可执行文件中的类名、方法名、属性名等并做替换，会更新<code>xib</code>和<code>storyboard</code>的名字等等<br>会将所有的类进行替换(包括系统的方法)</li>
</ul>
</blockquote>
<ul>
<li><a href="https://github.com/Polidea/ios-class-guard">源码</a></li>
<li>用法<ul>
<li>安装,<code>brew install ios-class-guard</code></li>
<li><code>ios-class-guard [options] &lt;mach-o-file&gt;</code></li>
<li>常用参数<ul>
<li><code>--sdk-root &lt;path&gt;</code>：用于指定SDK路径，如果是模拟器SDK，一般路径就是<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk</li>
<li><code>--sdk-ios</code>：相当于指定<code>SDK</code>路径为<code>真机设备SDK</code></li>
<li> <code>-X &lt;path&gt;</code>：用于指定<code>xib、storyboard</code>所在目录，它会递归搜索</li>
<li><code>-O &lt;path&gt;</code>：生成的混淆头文件路径</li>
<li><code>-m &lt;path&gt;</code>：符号映射表（默认是<code>symbols.json</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h3><ul>
<li>很多时候，可执行文件中的字符串信息，对破解者来说，非常关键，是破解的捷径之一</li>
<li>为了加大破解、逆向难度，可以考虑对字符串进行加密</li>
<li>字符串的加密技术有很多种，可以根据自己的需要自行制定算法<ul>
<li>例如，对每个字符进行异或（^）处理，需要使用字符串时，对异或（^）过的字符再进行一次异或（^），就可以获得原字符</li>
</ul>
</li>
<li><a href="https://github.com/CoderMJLee/MJCodeObfuscation">工具参考</a></li>
</ul>
]]></content>
      <categories>
        <category>应用技巧</category>
      </categories>
      <tags>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title>llvm</title>
    <url>/2023/03/30/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/llvm%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<blockquote>
<p>一般可以将编程语言分为两种，编译语言和直译式语言<br>编译语言: 像<code>C++</code>、<code>OC</code>都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在<code>CPU</code>上执行，所以执行效率较高。<br>解释语言：<code>javaScript</code>、<code>Python</code>都是直译式语言。直译式语言不需要经过编译的过程，而是在执行的时候通过一个中间的解释器将代码解释为<code>CPU</code>可以执行的代码。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活。<br><code>OC</code>和<code>Swift</code>。二者都是编译语言。<code>OC</code>编译都是依赖于<code>Clang+LLVM</code>,<code>Swift</code>赖于<code>Swiftc+LLVM</code>。</p>
</blockquote>
<h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><ul>
<li><a href="https://llvm.org/">官网</a></li>
<li><code>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.</code></li>
<li> <code>LLVM</code>项目是模块化、可重用的编译器以及工具链技术的集合</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="传统的编译器架构"><a href="#传统的编译器架构" class="headerlink" title="传统的编译器架构"></a>传统的编译器架构</h2><p><img src="1.png"></p>
<ul>
<li><code>Frontend</code>:前端<ul>
<li>词法分析、语法分析、语义分析、生成中间代码</li>
</ul>
</li>
<li><code>Optimizer</code>:优化器<ul>
<li>中间代码优化</li>
</ul>
</li>
<li><code>Backend</code>:后端<ul>
<li>生成机器码</li>
</ul>
</li>
</ul>
<h2 id="LLVM架构"><a href="#LLVM架构" class="headerlink" title="LLVM架构"></a>LLVM架构</h2><p><img src="2.png"></p>
<ul>
<li>不同的前端后端使用统一的中间代码<code>LLVM Intermediate Representation (LLVM IR)</code></li>
<li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li>
<li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</li>
<li>优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</li>
<li>相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就 变得特别困难</li>
<li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)</li>
</ul>
<h3 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h3><ul>
<li>什么是<code>Clang</code>?<ul>
<li>LLVM项目的一个子项目</li>
<li>基于LLVM架构的C/C++/Objective-C编译器前端 p <a href=":http://clang.llvm.org/">官网</a></li>
</ul>
</li>
<li>相比于<code>GCC</code>，<code>Clang</code>具有如下优点<ul>
<li>编译速度快:在某些平台上，<code>Clang</code>的编译速度显著的快过<code>GCC</code>(Debug模式下编译OC速度比GGC快3倍)</li>
<li>占用内存小:<code>Clang</code>生成的<code>AST</code>所占用的内存是<code>GCC</code>的五分之一左右</li>
<li>模块化设计:<code>Clang</code>采用基于库的模块化设计，易于<code>IDE</code> 集成及其他用途的重用</li>
<li>诊断信息可读性强:在编译过程中，<code>Clang</code> 创建并保留了大量详细的元数据 (<code>metadata</code>)，有利于调试和错误报告</li>
<li>设计清晰简单，容易理解，易于扩展增强</li>
</ul>
</li>
</ul>
<h2 id="Clang与LLVM"><a href="#Clang与LLVM" class="headerlink" title="Clang与LLVM"></a>Clang与LLVM</h2><p><img src="3.png"></p>
<h1 id="OC源文件的编译过程"><a href="#OC源文件的编译过程" class="headerlink" title="OC源文件的编译过程"></a>OC源文件的编译过程</h1><p><img src="4.jpg"></p>
<ul>
<li>命令行查看编译的过程:<code>$ clang -ccc-print-phases main.m</code>  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">              +- <span class="hljs-number">0</span>: input, <span class="hljs-string">&quot;main.m&quot;</span>, objective-c<br>             +- <span class="hljs-number">1</span>: preprocessor, &#123;<span class="hljs-number">0</span>&#125;, objective-c-cpp-output<br>          +- <span class="hljs-number">2</span>: compiler, &#123;<span class="hljs-number">1</span>&#125;, ir<br>       +- <span class="hljs-number">3</span>: backend, &#123;<span class="hljs-number">2</span>&#125;, assembler<br>    +- <span class="hljs-number">4</span>: assembler, &#123;<span class="hljs-number">3</span>&#125;, object<br> +- <span class="hljs-number">5</span>: linker, &#123;<span class="hljs-number">4</span>&#125;, image<br>+- <span class="hljs-number">6</span>: bind-arch, <span class="hljs-string">&quot;x86_64&quot;</span>, &#123;<span class="hljs-number">5</span>&#125;, image<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ul>
<li>编译代码  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug 0</span><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> debug</span><br>        <span class="hljs-comment">// insert code here...</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Hello, World!&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>        <span class="hljs-comment">// insert code here...</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Hello, debug\n!&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="preprocessor-预处理"><a href="#preprocessor-预处理" class="headerlink" title="preprocessor(预处理)"></a>preprocessor(预处理)</h3><blockquote>
<p>在预处理的时候，注释被删除，条件编译被处理。</p>
</blockquote>
<ul>
<li>执行<code>$ xcrun clang -E main.m</code>  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123; <span class="hljs-keyword">@autoreleasepool</span>  &#123; <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Hello, debug\n!&quot;</span>); &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="词法分析-lexical-anaysis"><a href="#词法分析-lexical-anaysis" class="headerlink" title="词法分析(lexical anaysis)"></a>词法分析(lexical anaysis)</h3><blockquote>
<p>词法分析器读入源文件的字符流，将他们组织成有意义的词素（<code>lexeme</code>）序列，对于每个词素，词法分析器产生的词法单元（<code>token</code>）作为输出。</p>
</blockquote>
<ul>
<li><p><code>Clang</code>会对代码进行词法分析，将代码切分成<code>Token</code>，显示每个 <code>Token</code> 的类型、值，以及位置, <a href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def">clang定义了所有的token类型</a>，这些<code>token</code>类型分为以下四类：</p>
<ol>
<li>关键字：语法中的关键字，比如<code>if</code>、<code>else</code>、<code>while</code>、<code>for</code>等；</li>
<li>标识符：变量名；</li>
<li>字面量：值、数字、字符串；</li>
<li>特殊符号：加减乘除等符号。</li>
</ol>
</li>
<li><p>执行<code>$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</code></p>
<ul>
<li>其中<code>loc=main.m:1:1</code>表示这个<code>token</code>位于源文件<code>main.c</code>的第1行，从第1个字符开始。保存<code>token</code>在源文件中的位置，是方便后续<code>clang</code>分析的时候能够找到出错的原始位置  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c"><span class="hljs-string">&#x27;#import &lt;Foundation/Foundation.h&gt;</span><br><span class="hljs-string">#&#x27;</span>		Loc=&lt;main.m:<span class="hljs-number">1</span>:<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">int</span> <span class="hljs-string">&#x27;int&#x27;</span>	 [StartOfLine]	Loc=&lt;main.m:<span class="hljs-number">3</span>:<span class="hljs-number">1</span>&gt;<br>identifier <span class="hljs-string">&#x27;main&#x27;</span>	 [LeadingSpace]	      Loc=&lt;main.m:<span class="hljs-number">3</span>:<span class="hljs-number">5</span>&gt;<br>l_paren <span class="hljs-string">&#x27;(&#x27;</span>		Loc=&lt;main.m:<span class="hljs-number">3</span>:<span class="hljs-number">9</span>&gt;<br><span class="hljs-keyword">int</span> <span class="hljs-string">&#x27;int&#x27;</span>		Loc=&lt;main.m:<span class="hljs-number">3</span>:<span class="hljs-number">10</span>&gt;<br>....<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="语法分析-semantic-analysis"><a href="#语法分析-semantic-analysis" class="headerlink" title="语法分析(semantic analysis)"></a>语法分析(semantic analysis)</h3><blockquote>
<p>语法分析的<code>token</code>流会被解析成一颗抽象的语法树(先按语法组合成语义，生成类似 VarDecl 这样的节点，然后将这些节点按照层级关系构成抽象语法树（AST）)（<code>abstract syntax tree - AST</code>）</p>
</blockquote>
<ul>
<li>执行<code>$ xcrun clang -cc1 -ast-dump JBPerson.m</code>  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">.....<br>|-ObjCImplementationDecl <span class="hljs-number">0x7fa731c6b500</span> &lt;MJPerson.m:<span class="hljs-number">10</span>:<span class="hljs-number">1</span>, line:<span class="hljs-number">32</span>:<span class="hljs-number">1</span>&gt;    line:<span class="hljs-number">10</span>:<span class="hljs-number">17</span> JBPerson<br>| |-ObjCInterface <span class="hljs-number">0x7fa731c69d70</span> <span class="hljs-string">&#x27;JBPerson&#x27;</span><br>| |-ObjCMethodDecl <span class="hljs-number">0x7fa731c6b5d0</span> &lt;line:<span class="hljs-number">11</span>:<span class="hljs-number">1</span>, line:<span class="hljs-number">17</span>:<span class="hljs-number">1</span>&gt; line:<span class="hljs-number">11</span>:<span class="hljs-number">1</span> - initWithAge:name: <span class="hljs-string">&#x27;instancetype&#x27;</span>:<span class="hljs-string">&#x27;id&#x27;</span><br>| | |-ImplicitParamDecl <span class="hljs-number">0x7fa731c6c9c0</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit used <span class="hljs-keyword">self</span> <span class="hljs-string">&#x27;JBPerson *&#x27;</span><br>| | |-ImplicitParamDecl <span class="hljs-number">0x7fa731c6ca28</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit _cmd <span class="hljs-string">&#x27;SEL&#x27;</span>:<span class="hljs-string">&#x27;SEL *&#x27;</span><br>| | |-ParmVarDecl <span class="hljs-number">0x7fa731c6b660</span> &lt;col:<span class="hljs-number">31</span>, col:<span class="hljs-number">42</span>&gt; col:<span class="hljs-number">42</span> used age <span class="hljs-string">&#x27;NSInteger&#x27;</span>:<span class="hljs-string">&#x27;long&#x27;</span><br>| | |-ParmVarDecl <span class="hljs-number">0x7fa731c6b6c8</span> &lt;col:<span class="hljs-number">53</span>, col:<span class="hljs-number">65</span>&gt; col:<span class="hljs-number">65</span> used name <span class="hljs-string">&#x27;NSString *&#x27;</span><br>| | `-CompoundStmt <span class="hljs-number">0x7fa731c6cef0</span> &lt;col:<span class="hljs-number">70</span>, line:<span class="hljs-number">17</span>:<span class="hljs-number">1</span>&gt;<br>| |   |-IfStmt <span class="hljs-number">0x7fa731c6ce70</span> &lt;line:<span class="hljs-number">12</span>:<span class="hljs-number">5</span>, line:<span class="hljs-number">15</span>:<span class="hljs-number">5</span>&gt;<br>| |   | |-BinaryOperator <span class="hljs-number">0x7fa731c6cae0</span> &lt;line:<span class="hljs-number">12</span>:<span class="hljs-number">9</span>, col:<span class="hljs-number">27</span>&gt; <span class="hljs-string">&#x27;JBPerson *&#x27;</span> <span class="hljs-string">&#x27;=&#x27;</span><br>| |   | | |-DeclRefExpr <span class="hljs-number">0x7fa731c6ca90</span> &lt;col:<span class="hljs-number">9</span>&gt; <span class="hljs-string">&#x27;JBPerson *&#x27;</span> lvalue ImplicitParam <span class="hljs-number">0x7fa731c6c9c0</span> <span class="hljs-string">&#x27;self&#x27;</span> <span class="hljs-string">&#x27;JBPerson *&#x27;</span><br>| |   | | `-ObjCMessageExpr <span class="hljs-number">0x7fa731c6cab0</span> &lt;col:<span class="hljs-number">16</span>, col:<span class="hljs-number">27</span>&gt; <span class="hljs-string">&#x27;JBPerson *&#x27;</span> selector=init <span class="hljs-keyword">super</span> (instance)<br>| |   | `-CompoundStmt <span class="hljs-number">0x7fa731c6ce50</span> &lt;col:<span class="hljs-number">30</span>, line:<span class="hljs-number">15</span>:<span class="hljs-number">5</span>&gt;<br>| |   |   |-PseudoObjectExpr <span class="hljs-number">0x7fa731c6cc70</span> &lt;line:<span class="hljs-number">13</span>:<span class="hljs-number">9</span>, col:<span class="hljs-number">20</span>&gt; <span class="hljs-string">&#x27;NSInteger&#x27;</span>:<span class="hljs-string">&#x27;long&#x27;</span><br>| |   |   | |-BinaryOperator <span class="hljs-number">0x7fa731c6cbe8</span> &lt;col:<span class="hljs-number">9</span>, col:<span class="hljs-number">20</span>&gt; <span class="hljs-string">&#x27;NSInteger&#x27;</span>:<span class="hljs-string">&#x27;long&#x27;</span> lvalue <span class="hljs-string">&#x27;=&#x27;</span><br>| |   |   | | |-ObjCPropertyRefExpr <span class="hljs-number">0x7fa731c6cba0</span> &lt;col:<span class="hljs-number">9</span>, col:<span class="hljs-number">14</span>&gt; <span class="hljs-string">&#x27;&lt;pseudo-object type&gt;&#x27;</span> lvalue objcproperty Kind=PropertyRef Property=<span class="hljs-string">&quot;age&quot;</span> Messaging=Setter<br>| |   |   | | | `-OpaqueValueExpr <span class="hljs-number">0x7fa731c6cb88</span> &lt;col:<span class="hljs-number">9</span>&gt; <span class="hljs-string">&#x27;JBPerson *&#x27;</span><br>.....<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="CodeGen"><a href="#CodeGen" class="headerlink" title="CodeGen"></a>CodeGen</h3><blockquote>
<p>codeGen遍历语法树，生成<code>LLVM IR</code>代码。<code>LLVM IR</code>是前端的输出，后端的输入</p>
</blockquote>
<ul>
<li>遍历语法树生成<code>LLVM IR</code>,<code>LLVM IR</code>有3种表示形式,但本质是等价的<ol>
<li><code>text</code>:便于阅读的文本格式，类似于汇编语言，拓展名.ll， <code>$ clang -S -emit-llvm main.m</code></li>
<li><code>bitcode</code>:二进制格式，拓展名.bc， <code>$ clang -c -emit-llvm main.m</code></li>
<li><code>memory</code>:内存格式</li>
</ol>
</li>
<li>执行<code>$ xcrun clang -S -emit-llvm main.m -o main.ll</code>  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">.....<br>define i32 @main(i32 %<span class="hljs-number">0</span>, i8** %<span class="hljs-number">1</span>) #<span class="hljs-number">1</span> &#123;<br>  %<span class="hljs-number">3</span> = alloca i32, align <span class="hljs-number">4</span><br>  %<span class="hljs-number">4</span> = alloca i32, align <span class="hljs-number">4</span><br>  %<span class="hljs-number">5</span> = alloca i8**, align <span class="hljs-number">8</span><br>  store i32 <span class="hljs-number">0</span>, i32* %<span class="hljs-number">3</span>, align <span class="hljs-number">4</span><br>  store i32 %<span class="hljs-number">0</span>, i32* %<span class="hljs-number">4</span>, align <span class="hljs-number">4</span><br>  store i8** %<span class="hljs-number">1</span>, i8*** %<span class="hljs-number">5</span>, align <span class="hljs-number">8</span><br>  %<span class="hljs-number">6</span> = call i8* @llvm.objc.autoreleasePoolPush() #<span class="hljs-number">2</span><br>  notail call <span class="hljs-keyword">void</span> (i8*, ...) @<span class="hljs-built_in">NSLog</span>(i8* bitcast (%<span class="hljs-keyword">struct</span>.__NSConstantString_tag* @_unnamed_cfstring_ to i8*))<br>  call <span class="hljs-keyword">void</span> @llvm.objc.autoreleasePoolPop(i8* %<span class="hljs-number">6</span>)<br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br>.....<br></code></pre></td></tr></table></figure></li>
<li><code>objective-C</code>代码在这一步会进行<code>runtime</code>的桥接：<code>property</code>合成，<code>ARC</code>处理等。</li>
<li><code>LLVM</code>会对生成的<code>IR</code>进行优化，优化会调用相应的<code>Pass</code>进行处理。<code>Pass</code>由多个节点组成，都是<code>Pass</code>类的子类，每个节点负责做特定的优化，具体细节见，</li>
</ul>
<h3 id="生成汇编代码"><a href="#生成汇编代码" class="headerlink" title="生成汇编代码"></a>生成汇编代码</h3><blockquote>
<p><code>LLVM</code>对<code>IR</code>进行优化后，会针对不同架构形成不同的目标代码，最后以汇编代码的格式输出.</p>
</blockquote>
<ul>
<li><p>执行<code>$ xcrun clang -S main.m -o main.s</code></p>
  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">_main:                                  ## @main<br>	.cfi_startproc<br>## %bb<span class="hljs-number">.0</span>:<br>	pushq	%rbp<br>	.cfi_def_cfa_offset <span class="hljs-number">16</span><br>	.cfi_offset %rbp, <span class="hljs-number">-16</span><br>	movq	%rsp, %rbp<br>	.cfi_def_cfa_register %rbp<br>	subq	$<span class="hljs-number">32</span>, %rsp<br>	movl	$<span class="hljs-number">0</span>, <span class="hljs-number">-4</span>(%rbp)<br>	movl	%edi, <span class="hljs-number">-8</span>(%rbp)<br>	movq	%rsi, <span class="hljs-number">-16</span>(%rbp)<br></code></pre></td></tr></table></figure>
<h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><blockquote>
<p>汇编器,以汇编代码作为输入，将汇编代码转换为机器码</p>
</blockquote>
</li>
<li><p>执行<code>$ xcrun clang -fmodules -c main.m -o main.o</code></p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">.....<br>(undefined) external _NSLog<br>                   (undefined) external ___CFConstantStringClassReference<br>                   (undefined) external _objc_autoreleasePoolPop<br>                   (undefined) external _objc_autoreleasePoolPush<br><span class="hljs-number">0000000000000000</span> (__TEXT,__text) external _main<br>.....<br></code></pre></td></tr></table></figure></li>
<li><p><code>_NSLog</code>是一个<code>undefined external</code>的。<code>undefined</code>表示在当前文件找不到符号<code>_NSLog</code>,而<code>external</code>表示这个符号是外部可以访问的，对应文件私有符号是<code>non-exrernal</code></p>
</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote>
<p>链接器把编译产生的.o文件和（dylib，a，tbd）文件(动态库文件)，生成一个mach-0文件(a.out文件的替代) </p>
</blockquote>
<ul>
<li><p>执行<code>$ xcrun clang main.o -o main</code></p>
<ul>
<li><code>_NSLog</code>仍然是<code>undefined</code>,但是后面多了一些信息，<code>from Foundation</code>,表示这个符号来自于<code>libSystem</code>，会在运行时动态绑定<figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">$ nm -nm main<br>                 (undefined) external _NSLog (from Foundation)<br>                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)<br>                 (undefined) external _objc_autoreleasePoolPop (from libobjc)<br>                 (undefined) external _objc_autoreleasePoolPush (from libobjc)<br>                 (undefined) external dyld_stub_binder (from libSystem)<br><span class="hljs-number">0000000100000000</span> (__TEXT,__text) [referenced dynamically] external __mh_execute_header<br><span class="hljs-number">0000000100003</span>f20 (__TEXT,__text) external _main<br><span class="hljs-number">0000000100008018</span> (__DATA,__data) non-external __dyld_private<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>就得到了一个<code>mach-o</code>格式的可执行文件</p>
  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">$ file main<br>main: Mach-O <span class="hljs-number">64</span>-bit executable x86_64<br>$ ./main <br>hello debug<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul>
<li>下载<code>LLVM</code>,<code>git clone https://github.com/llvm/llvm-project.git</code></li>
<li>将<code>llvm-project</code>工程下的<code>clang</code>，移动到<code>llvm-project/llvm/tools</code></li>
</ul>
<h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><ul>
<li><p>安装<code>cmake</code>和<code>ninja</code>(先安装<a href="https://brew.sh/">brew</a>)</p>
<ul>
<li><code>brew install cmake</code></li>
<li><code>brew install ninja</code></li>
</ul>
</li>
<li><p>在LLVM源码同级目录下新建一个【<code>llvm_build</code>】目录(最终会在【<code>llvm_build</code>】目录下生成【<code>build.ninja</code>】</p>
<ul>
<li><code>cd llvm_build</code></li>
<li><code>cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=生成的目录 -DLLVM_ENABLE_PROJECTS=&quot;clang;clang-tools-extra&quot; -G Ninja ../llvm</code></li>
<li><code>ninja</code>,依次执行编译、安装指令</li>
<li> <code>ninja install</code>,安装完成，出现在生成的目录</li>
</ul>
</li>
<li><p>也可以生成<code>Xcode</code>项目再进行编译，但是速度很慢</p>
<ul>
<li>在<code>llvm-project</code>同级目录下新建一个【<code>llvm_xcode</code>】目录</li>
<li><code>cd llvm_xcode</code></li>
<li><code>cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang;clang-tools-extra&quot; -G Xcode ../llvm-project/llvm</code></li>
</ul>
</li>
</ul>
<h1 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h1><ul>
<li><code>libclang</code>、<code>libTooling</code><ul>
<li><a href="https://clang.llvm.org/docs/Tooling.html">官方参考</a> </li>
<li>应用:语法树分析、语言转换等</li>
</ul>
</li>
<li><code>Clang</code>插件开发<ul>
<li>官方参考<ul>
<li><a href="https://clang.llvm.org/docs/ClangPlugins.html">https://clang.llvm.org/docs/ClangPlugins.html</a></li>
<li><a href="https://clang.llvm.org/docs/ExternalClangExamples.html">https://clang.llvm.org/docs/ExternalClangExamples.html</a></li>
<li><a href="https://clang.llvm.org/docs/RAVFrontendAction.html">https://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
</ul>
</li>
<li>应用:代码检查(命名规范、代码规范)等</li>
</ul>
</li>
<li><code>Pass</code>开发<ul>
<li><a href="https://llvm.org/docs/WritingAnLLVMPass.html">官方参考</a></li>
<li>应用:代码优化、代码混淆等</li>
</ul>
</li>
<li>开发新的编程语言<ul>
<li><a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html">https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html</a></li>
<li><a href="https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/">https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/</a></li>
</ul>
</li>
</ul>
<h2 id="Clang插件开发"><a href="#Clang插件开发" class="headerlink" title="Clang插件开发"></a><code>Clang</code>插件开发</h2><ol>
<li>在【<code>clang/tools</code>】源码目录下新建一个插件目录，例如<code>jb-plugin</code></li>
</ol>
<p><img src="5.png"></p>
<ol start="2">
<li><p>在<code>clang/tools/CMakeLists.txt</code>最后加入内容: <code>add_clang_subdirectory(jb-plugin)</code>，小括号里是插件目录名</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">add_clang_subdirectory(amdgpu-arch)<br>add_clang_subdirectory(nvptx-arch)<br>add_clang_subdirectory(jb-plugin)<br></code></pre></td></tr></table></figure></li>
<li><p>在<code>jb-plugin</code>目录下新建一个<code>CMakeLists.txt</code>，文件内容是</p>
<ul>
<li><code>JBPlugin</code>是插件名，<code>JBPlugin.cpp</code>是源代码文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">add_llvm_library(JBPlugin MODULE BUILDTREE_ONLY<br>JBPlugin.cpp)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>JBPlugin.cpp</code>的源码</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <br>    <br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/AST.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> llvm;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;<br><br><span class="hljs-keyword">namespace</span>  JBPlugin &#123;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JBHandler</span>:</span> <span class="hljs-keyword">public</span> MatchFinder::MatchCallback &#123;<br><span class="hljs-keyword">private</span>:<br>    CompilerInstance &amp;ci;<br>    <span class="hljs-keyword">bool</span> isClass;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUserSourceCode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string filename)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (filename.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 非Xcode中的源码都认为是用户源码</span><br>        <span class="hljs-keyword">if</span> (filename.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;/Applications/Xcode.app/&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isShouldUseCopy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string typeStr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (typeStr.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;NSString&quot;</span>) != string::npos ||<br>            typeStr.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;NSArray&quot;</span>) != string::npos ||<br>            typeStr.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;NSDictionary&quot;</span>) != string::npos) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//检查类名</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkClassName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> ObjCInterfaceDecl *decl = Result.Nodes.getNodeAs&lt;ObjCInterfaceDecl&gt;(<span class="hljs-string">&quot;objcInterfaceDecl&quot;</span>);<br>        string filename = ci.<span class="hljs-built_in">getSourceManager</span>().<span class="hljs-built_in">getFilename</span>(decl-&gt;<span class="hljs-built_in">getSourceRange</span>().<span class="hljs-built_in">getBegin</span>()).<span class="hljs-built_in">str</span>();<br><br>        <span class="hljs-keyword">if</span> (decl &amp;&amp; <span class="hljs-built_in">isUserSourceCode</span>(filename))&#123;<br>            <span class="hljs-keyword">size_t</span> pos = decl-&gt;<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;_&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (pos != StringRef::npos) &#123;<br>                DiagnosticsEngine &amp;D = ci.<span class="hljs-built_in">getDiagnostics</span>();<br>                <span class="hljs-comment">//找到报错的位置</span><br>                SourceLocation loc = decl -&gt;<span class="hljs-built_in">getLocation</span>().<span class="hljs-built_in">getLocWithOffset</span>(pos);<br>                D.<span class="hljs-built_in">Report</span>(loc, D.<span class="hljs-built_in">getCustomDiagID</span>(DiagnosticsEngine::Error, <span class="hljs-string">&quot;类名不允许下划线&quot;</span>));<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkProperty</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchFinder::MatchResult &amp;Result)</span></span>&#123;<br>        <span class="hljs-keyword">const</span> ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs&lt;ObjCPropertyDecl&gt;(<span class="hljs-string">&quot;objcPropertyDecl&quot;</span>);<br>        string filename = ci.<span class="hljs-built_in">getSourceManager</span>().<span class="hljs-built_in">getFilename</span>(propertyDecl-&gt;<span class="hljs-built_in">getSourceRange</span>().<span class="hljs-built_in">getBegin</span>()).<span class="hljs-built_in">str</span>();<br>        string typeStr = propertyDecl-&gt;<span class="hljs-built_in">getType</span>().<span class="hljs-built_in">getAsString</span>(); <span class="hljs-comment">// 拿到属性的类型</span><br>        ObjCPropertyAttribute::Kind attrKind = propertyDecl-&gt;<span class="hljs-built_in">getPropertyAttributes</span>();<span class="hljs-comment">// 拿到节点的描述信息</span><br>        <span class="hljs-keyword">if</span> (propertyDecl &amp;&amp; <span class="hljs-built_in">isUserSourceCode</span>(filename))&#123;<br>            <span class="hljs-comment">// 如果应该使用copy但是却没有使用，那么就报出警告</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isShouldUseCopy</span>(typeStr) &amp;&amp; !(attrKind &amp; ObjCPropertyDecl::SetterKind::Copy)) &#123;<br>                DiagnosticsEngine &amp;diag = ci.<span class="hljs-built_in">getDiagnostics</span>(); <span class="hljs-comment">// 诊断引擎</span><br>                diag.<span class="hljs-built_in">Report</span>(propertyDecl-&gt;<span class="hljs-built_in">getBeginLoc</span>(), diag.<span class="hljs-built_in">getCustomDiagID</span>(DiagnosticsEngine::Warning, <span class="hljs-string">&quot;%0这个地方推荐用Copy&quot;</span>))&lt;&lt;typeStr;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">JBHandler</span>(CompilerInstance &amp;ci,<span class="hljs-keyword">bool</span> isclass):<span class="hljs-built_in">ci</span>(ci),<span class="hljs-built_in">isClass</span>(isclass)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;<br>        <span class="hljs-comment">//根据标识符号</span><br>        <span class="hljs-comment">//从声明中找到之前标识符号的声名</span><br>        <span class="hljs-keyword">if</span>(isClass) &#123;<br>            <span class="hljs-built_in">checkClassName</span>(Result);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">checkProperty</span>(Result);<br>        &#125;<br>        <br>        <br>    &#125;<br>&#125;;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JBASTConsumer</span>:</span> <span class="hljs-keyword">public</span> ASTConsumer &#123;<br>    <span class="hljs-keyword">private</span>:<br>        MatchFinder matcher;<br>        JBHandler handler;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">JBASTConsumer</span>(CompilerInstance &amp;ci,<span class="hljs-keyword">bool</span> isClass) :<span class="hljs-built_in">handler</span>(ci,isClass)&#123;<br>            <span class="hljs-comment">//告诉 matcher去语法树找什么东西，并传入handler（调用其中的run方法）</span><br>            <span class="hljs-keyword">if</span> (isClass) &#123;<br>                matcher.<span class="hljs-built_in">addMatcher</span>(<span class="hljs-built_in">objcInterfaceDecl</span>().<span class="hljs-built_in">bind</span>(<span class="hljs-string">&quot;objcInterfaceDecl&quot;</span>), &amp;handler);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                matcher.<span class="hljs-built_in">addMatcher</span>(<span class="hljs-built_in">objcPropertyDecl</span>().<span class="hljs-built_in">bind</span>(<span class="hljs-string">&quot;objcPropertyDecl&quot;</span>), &amp;handler);<br>            &#125;<br>            <br>        &#125;<br>        <br>        <span class="hljs-comment">//在整个文件都解析完后被调用</span><br>        <span class="hljs-comment">//当clang遍历解析完一次语法树之后，就会调用,ctx包含语法树的信息</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(ASTContext &amp;ctx)</span> </span>&#123;<br>            <span class="hljs-comment">//matcher会去语法树查找东西</span><br>            matcher.<span class="hljs-built_in">matchAST</span>(ctx);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//将来加载插件的时候执行的动作</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JBClassAction</span>:</span> <span class="hljs-keyword">public</span> PluginASTAction &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//2.指定action后，会创建一个Consumer对象</span><br>    <span class="hljs-function">unique_ptr&lt;ASTConsumer&gt; <span class="hljs-title">CreateASTConsumer</span><span class="hljs-params">(CompilerInstance &amp;ci, StringRef iFile)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> unique_ptr&lt;JBASTConsumer&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">JBASTConsumer</span>(ci,<span class="hljs-literal">true</span>));<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParseArgs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CompilerInstance &amp;ci, <span class="hljs-keyword">const</span> vector&lt;string&gt; &amp;args)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JBPropertyAction</span>:</span> <span class="hljs-keyword">public</span> PluginASTAction &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//2.指定action后，会创建一个Consumer对象</span><br>    <span class="hljs-function">unique_ptr&lt;ASTConsumer&gt; <span class="hljs-title">CreateASTConsumer</span><span class="hljs-params">(CompilerInstance &amp;ci, StringRef iFile)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> unique_ptr&lt;JBASTConsumer&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">JBASTConsumer</span>(ci,<span class="hljs-literal">false</span>));<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParseArgs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CompilerInstance &amp;ci, <span class="hljs-keyword">const</span> vector&lt;string&gt; &amp;args)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">//1.注册插件，指定action</span><br><span class="hljs-keyword">static</span> clang::<span class="hljs-function">FrontendPluginRegistry::Add&lt;JBPlugin::JBClassAction&gt; <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-string">&quot;JBPlugin&quot;</span>, <span class="hljs-string">&quot;The JBPlugin is my Class clang-plugin.&quot;</span>)</span></span>;<br><span class="hljs-keyword">static</span> clang::<span class="hljs-function">FrontendPluginRegistry::Add&lt;JBPlugin::JBPropertyAction&gt; <span class="hljs-title">Y</span><span class="hljs-params">(<span class="hljs-string">&quot;JBPlugin&quot;</span>, <span class="hljs-string">&quot;The JBPlugin is my Property clang-plugin.&quot;</span>)</span></span>;<br><br></code></pre></td></tr></table></figure></li>
<li><p>利用<code>cmake</code>生成的<code>Xcode</code>项目来编译插件(第一次编写完插件，需要利用<code>cmake</code>重新生成一下<code>Xcode</code>项目) </p>
<ul>
<li>插件源代码在<code>Sources/Loadable modules</code>目录下可以找到，这样就可以直接在Xcode里编写插件代码<br><img src="6.png"></li>
<li>选择<code>JBPlugin</code>这个<code>target</code>进行编译，编译完会生成一个动态库文件</li>
</ul>
</li>
<li><p>加载插件,在Xcode项目中指定加载插件动态库:<code>BuildSettings</code> &gt; <code>OTHER_CFLAGS</code></p>
<ul>
<li><code>-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称</code></li>
<li><code>-Xclang -load -Xclang /Users/chenjingpo/Desktop/源码/LLVVM/llvm_xcode/Debug/lib/JBPlugin.dylib -Xclang -add-plugin -Xclang JBPlugin</code></li>
<li></li>
</ul>
</li>
</ol>
<p><img src="7.png"></p>
<ol start="7">
<li>在<code>xcode</code>中使用编译好的<code>clang</code>,<code>xcode</code>自带的是不允许的</li>
</ol>
<ul>
<li>增加2个<code>User-Defined</code>，为<code>CC</code>和<code>CCX</code>，指定编译好的<code>clang</code>指令</li>
</ul>
<p><img src="8.png"></p>
<ul>
<li>将<code>Enable Index-While-Building Functionality</code>设置为<code>NO</code></li>
</ul>
<p><img src="9.png"></p>
<ol start="8">
<li>编译项目</li>
</ol>
<p><img src="10.png"></p>
]]></content>
      <categories>
        <category>应用技巧</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2023/03/26/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><blockquote>
<ul>
<li>函数式编程 ( <code>Funtional Programming</code>，简称<code>FP</code>）是一种编程范式，也就是如何编写程序的方法论<ul>
<li>主要思想：把计算过程尽量分解成一系列可复用函数的调用</li>
<li>主要特征：函数是“第一等公民〞<ul>
<li>函数与其他数据类型一样的地位，可以赋值给其他变量，也可以作为函数参数、函数返回值</li>
</ul>
</li>
</ul>
</li>
<li>函数式编程最早出现在<code>LISP</code>语言 ，绝大部分的现代编程语言也对函数式编程做了不同程度的支持，比如<ul>
<li><code>Haskell</code>. <code>Javascript</code>. <code>Python</code>. <code>Swift</code>、<code>Kotlin</code>、<code>Scala</code>等</li>
</ul>
</li>
<li>函数式编程中几个常用的概念<ul>
<li><code>Higher-Order Function</code>, <code>Function Currying</code></li>
<li><code>Functor.</code> <code>Applicative Functor</code>,<code>Monad</code></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li>传统写法，实现假设要实现：<code>var num = 1; [(num + 3）*5-1] % 10 / 2</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">+</span> v2 &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">V2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">-</span> v2 &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiple</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-params">_v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">*</span> v2 &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">/</span> v2 &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mod</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">%</span> v2&#125;<br><br>divide (mod (sub (mult iple(add (num, <span class="hljs-number">3</span>)， <span class="hljs-number">5</span>)， <span class="hljs-number">1</span>)， <span class="hljs-number">10</span>）， <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
</li>
<li>函数式写法<ul>
<li>将函数拆分成只接受一个参数   <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> -&gt; (<span class="hljs-type">Int</span>) 一<span class="hljs-operator">&gt;</span><span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">+</span> v &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">-</span> v &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiple</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> 一<span class="hljs-operator">&gt;</span>（<span class="hljs-type">Int）</span> 一<span class="hljs-operator">&gt;</span><span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">*</span> v &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> -&gt;（<span class="hljs-type">Int）</span> 一<span class="hljs-operator">&gt;</span> <span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">/</span> v &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mod</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">%</span> v &#125; &#125;<br></code></pre></td></tr></table></figure></li>
<li>定义一个合并函数运算符 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">infix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">&gt;&gt;&gt;</span> : <span class="hljs-type">AdditionPrecedence</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">&gt;&gt;&gt;&lt;</span></span><span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span><span class="hljs-operator">&gt;</span>(<br><span class="hljs-keyword">_</span> f1:<span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>) -&gt; <span class="hljs-type">B</span>,<br><span class="hljs-keyword">_</span> f2:<span class="hljs-keyword">@escaping</span> (<span class="hljs-type">B</span>)-&gt;<span class="hljs-type">C</span>) -&gt;(<span class="hljs-type">A</span>)-&gt; <span class="hljs-type">C</span> &#123; &#123; f2(f1(<span class="hljs-variable">$0</span>)) &#125; &#125;<br></code></pre></td></tr></table></figure></li>
<li>写法 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> fn <span class="hljs-operator">=</span> add(<span class="hljs-number">3</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> multiple(<span class="hljs-number">5</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> sub (<span class="hljs-number">1</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> mod (<span class="hljs-number">10</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> divide (<span class="hljs-number">2</span>)<br>fn(num)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="高阶函数-Higher-Order-Function"><a href="#高阶函数-Higher-Order-Function" class="headerlink" title="高阶函数 ( Higher-Order Function )"></a>高阶函数 ( <code>Higher-Order Function</code> )</h2><blockquote>
<ul>
<li>高阶函数是至少满足下列一个条件的函数：</li>
<li>接受一个或多个函数作为输入 （<code>map</code>、<code>filter</code>、<code>reduce</code>等）</li>
<li>返回一个函数</li>
</ul>
</blockquote>
<h2 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化 (Currying)"></a>柯里化 (<code>Currying</code>)</h2><blockquote>
<p>什么是柯里化？</p>
<ul>
<li>将一个接受多参数的函数变换为一系列只接受单个参数的函数</li>
<li><code>Array</code>、<code>Optional</code>的<code>ma</code>p方法接收的参数就是一个柯里化函数</li>
</ul>
</blockquote>
<ul>
<li>柯里化转换的方法,和方法合并的实践，上面的例子可以改写成<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">+</span> v2 &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">V2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">-</span> v2 &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiple</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-params">_v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">*</span> v2 &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">/</span> v2 &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mod</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">%</span> v2&#125;<br><br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&lt;</span></span><span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span><span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">_</span> fn: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) -&gt; <span class="hljs-type">C</span>)<br>-&gt; (<span class="hljs-type">B</span>) -&gt; (<span class="hljs-type">A</span>) -&gt; <span class="hljs-type">C</span> &#123; &#123; b <span class="hljs-keyword">in</span> &#123; a <span class="hljs-keyword">in</span> fn(a, b) &#125; &#125; &#125;<br>    <br><span class="hljs-keyword">infix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">&gt;&gt;&gt;</span> : <span class="hljs-type">AdditionPrecedence</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">&gt;&gt;&gt;&lt;</span></span><span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span><span class="hljs-operator">&gt;</span>(<br><span class="hljs-keyword">_</span> f1: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>) -&gt; <span class="hljs-type">B</span>,<br><span class="hljs-keyword">_</span> f2: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">B</span>) -&gt;<span class="hljs-type">C</span>) -&gt;（<span class="hljs-type">A</span>)-&gt;<span class="hljs-type">C</span> &#123; &#123; f2(f1(<span class="hljs-variable">$0</span>)) &#125; &#125;<br><br><br><span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> fn <span class="hljs-operator">=</span> (<span class="hljs-operator">~</span>add) (<span class="hljs-number">3</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> (<span class="hljs-operator">~</span>multiple) (<span class="hljs-number">5</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> (<span class="hljs-operator">~</span>sub) (<span class="hljs-number">1</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> (<span class="hljs-operator">~</span>mod) (<span class="hljs-number">10</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> (<span class="hljs-operator">~</span>divide)(<span class="hljs-number">2</span>)<br>fn (num)<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="函子-（Functor"><a href="#函子-（Functor" class="headerlink" title="函子 （Functor)"></a>函子 （<code>Functor</code>)</h2><blockquote>
<ul>
<li> 像<code>Array</code>、<code>Optional</code>这样支持<code>map</code>运算的类型，称为函子 ( Functor)</li>
<li><code>public func mapsT&gt;(_ transform: (Element) -&gt; T) -&gt; Array&lt;T&gt;</code></li>
<li><code>public func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; Optional&lt;U&gt;</code></li>
</ul>
</blockquote>
<h2 id="适用函子-Applicative-Functor"><a href="#适用函子-Applicative-Functor" class="headerlink" title="适用函子 ( Applicative Functor)"></a>适用函子 ( <code>Applicative Functor</code>)</h2><blockquote>
<ul>
<li>对任意一个函子F，如果能支持以下运算，该函子就是一个适用函子</li>
<li><code>func puresA&gt;( value: A) -&gt;F&lt;A&gt;</code></li>
<li><code>func &lt;*&gt;&lt;A, B&gt;(fn: F&lt;(A) -&gt;B&gt;, value: F&lt;A&gt;)一＞F&lt;B&gt;</code></li>
</ul>
</blockquote>
<h4 id="单子（Monad"><a href="#单子（Monad" class="headerlink" title="单子（Monad)"></a>单子（<code>Monad</code>)</h4><blockquote>
<ul>
<li>对任意一个类型F，如果能支持以下运算，那么就可以称为是一个单子(<code>Monad</code>)<ul>
<li><code>func pure&lt;A&gt;(_ value: A) -&gt; F&lt;A&gt;</code></li>
<li><code>func flatMap&lt;A, B&gt;(_ value: F&lt;A&gt;,_ fn:(A) -&gt; F&lt;B&gt;) -&gt; F&lt;B&gt;</code></li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>swift和OC</title>
    <url>/2023/03/19/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E5%92%8COC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h1><ul>
<li><code>@_silgen_name</code>可以对<code>c</code>函数进行重命名<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-meta">@_silgen_name</span>(<span class="hljs-string">&quot;sum&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swift_sum</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int32</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int32</span>)</span> -&gt; <span class="hljs-type">Int32</span><br></code></pre></td></tr></table></figure></li>
<li>此外，还可以类似<code>extern</code>，声明系统内部函数，并进行使用。如果该函数不存在，则无法编译通过<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-meta">@_silgen_name</span>(<span class="hljs-string">&quot;swift_retainCount&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swift_elk_retainCount</span>(<span class="hljs-operator">...</span>)</span><span class="hljs-comment">//这里要具体的函数</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a><code>dynamic</code></h1><ul>
<li><code>@objc dynamic</code>修饰的内容会具有动态性，比如,在<code>swift</code>中调用方法会走<code>runtime</code>那一套流程<ul>
<li>只通过<code>@objc</code>修饰的，在<code>OC</code>调用，是<code>objc_msg</code>,在<code>swift</code>中调用：如果是<code>extension</code>中,则是<code>objc_msg</code>，否则还是<code>虚表</code>的方式。</li>
<li>要让<code>swift</code>类中的方法，在<code>swift</code>中调用还是<code>objc_msg</code>，需要加上<code>dynamic</code></li>
</ul>
</li>
</ul>
<h1 id="KVC-KVO"><a href="#KVC-KVO" class="headerlink" title="KVC/KVO"></a><code>KVC</code>/<code>KVO</code></h1><ul>
<li><code>Swift</code>支持 <code>KVC\KVO</code> 的条件<ul>
<li>属性所在的<code>类</code>、<code>监听器</code>最终继承自 <code>NSObject</code></li>
<li>用 <code>@objc dynamic</code> 修饰对应的<code>属性</code></li>
</ul>
</li>
<li>示例<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> ob:<span class="hljs-type">NSKeyValueObservation</span>?<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">init</span>()</span> &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        ob <span class="hljs-operator">=</span> observe(\.age,options: [.new,.old]) &#123; <span class="hljs-keyword">_</span>, change <span class="hljs-keyword">in</span><br>            <span class="hljs-built_in">print</span>(change.newValue,change.oldValue)<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Array中lazy优化"><a href="#Array中lazy优化" class="headerlink" title="Array中lazy优化"></a><code>Array</code>中<code>lazy</code>优化</h2><ul>
<li>下面<code>map</code>操作，会在使用的时候在<code>map</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].lazy.map &#123; num <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mapping <span class="hljs-subst">\(num)</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> num<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br><span class="hljs-comment">// 输出</span><br><span class="hljs-operator">----</span><br>mapping <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>mapping <span class="hljs-number">2</span><br><span class="hljs-number">4</span><br>mapping <span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-operator">----</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>自定义模式匹配，条件编译</title>
    <url>/2023/03/19/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自定义模式匹配"><a href="#自定义模式匹配" class="headerlink" title="自定义模式匹配"></a>自定义模式匹配</h1><blockquote>
<p>在<code>switch</code>的<code>case</code>中，较为复杂的表达式模式匹配，实际上实现了<code>～=</code> 方法，因此，可以通过重载运算符，自定义表达是模式的匹配规则</p>
</blockquote>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> score <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:<span class="hljs-type">Int</span>,<span class="hljs-params">value</span>:<span class="hljs-type">Student</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; value.score <span class="hljs-operator">&gt;=</span> pattern &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:<span class="hljs-type">ClosedRange</span>&lt;<span class="hljs-type">Int</span>&gt;,<span class="hljs-params">value</span>:<span class="hljs-type">Student</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; pattern.contains(value.score) &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:<span class="hljs-type">Range</span>&lt;<span class="hljs-type">Int</span>&gt;,<span class="hljs-params">value</span>:<span class="hljs-type">Student</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; pattern.contains(value.score) &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> stu <span class="hljs-operator">=</span> <span class="hljs-type">Student</span>(score: <span class="hljs-number">80</span>)<br><span class="hljs-keyword">switch</span> stu &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">90</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=90&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">80</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">90</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[80,90)&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">60</span><span class="hljs-operator">...</span><span class="hljs-number">79</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[60,79]&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=0&quot;</span>)<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> <span class="hljs-number">60</span> <span class="hljs-operator">=</span> stu &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=60&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">String</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:(<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span>,<span class="hljs-params">value</span>:<span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; pattern(value) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPrefix</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">prefix</span>:<span class="hljs-type">String</span>)</span> -&gt; ((<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span>.hasPrefix(<span class="hljs-keyword">prefix</span>) &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasSuffix</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">suffix</span>:<span class="hljs-type">String</span>)</span> -&gt; ((<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span>.hasSuffix(suffix) &#125; &#125;<br><br><span class="hljs-keyword">var</span> str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jack&quot;</span><br><span class="hljs-keyword">switch</span> str &#123;<br><span class="hljs-keyword">case</span> hasPrefix(<span class="hljs-string">&quot;j&quot;</span>),hasSuffix(<span class="hljs-string">&quot;k&quot;</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;以j开头，以k结尾&quot;</span>)<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Int</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:(<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Bool</span>,<span class="hljs-params">value</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; pattern(value) &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEven</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; i<span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isOdd</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; i<span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>&#125;<br><span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br><span class="hljs-keyword">switch</span> age &#123;<br><span class="hljs-keyword">case</span> isEven:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;偶数&quot;</span>)<br><span class="hljs-keyword">case</span> isOdd:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;奇数&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;其他&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">~&gt;</span><br><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">~&gt;=</span><br><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">~&lt;</span><br><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">~&lt;=</span><br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&gt;</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; ((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;</span> i &#125;  &#125;<br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&gt;=</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; ((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;=</span> i &#125;  &#125;<br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&lt;</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; ((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&lt;</span> i &#125;  &#125;<br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&lt;=</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; ((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&lt;=</span> i &#125;  &#125;<br><br><span class="hljs-keyword">switch</span> age &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-operator">~&gt;=</span><span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=0&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-operator">~&gt;=</span><span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=10&quot;</span>)<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h1><blockquote>
<p><code>swift中</code>是没有宏定义的，但是有相关的条件编译</p>
</blockquote>
<ul>
<li><p><code>swift</code>中以下条件编译</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><span class="hljs-comment">//操作系统：macos\iositvosiwatchos\Linux\And roidiWindows\FreeBsD</span><br><span class="hljs-keyword">#if</span> os (macos) 1l os(ios)<br><span class="hljs-number">1</span><span class="hljs-operator">/</span> <span class="hljs-type">CPU架构：13861x86_64</span>\armlarm64<br><span class="hljs-keyword">#elseif</span> arch(<span class="hljs-operator">×</span><span class="hljs-number">86_64</span>) <span class="hljs-operator">||</span> arch (arm64)<br><span class="hljs-comment">// swift版本</span><br><span class="hljs-keyword">#elseif</span> swift(<span class="hljs-operator">&lt;</span><span class="hljs-number">5</span>) <span class="hljs-operator">&amp;&amp;</span> swift(<span class="hljs-operator">&gt;=</span><span class="hljs-number">3</span>)<br><span class="hljs-comment">//模拟器</span><br><span class="hljs-keyword">#elseif</span> targetEnvironment (simulator)<br><span class="hljs-number">1</span><span class="hljs-operator">/</span>可以导入某模块<br><span class="hljs-keyword">#elseif</span> canImport (<span class="hljs-type">Foundat</span> ion)<br><span class="hljs-keyword">#else</span> <span class="hljs-keyword">#endif</span><br></code></pre></td></tr></table></figure></li>
<li><p>条件编译，通过下面的配置标记，可以实现条件编译</p>
</li>
</ul>
<p><img src="1.png"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">#if</span> <span class="hljs-type">TEST</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-keyword">#endif</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>字面量</title>
    <url>/2023/03/19/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%AD%97%E9%9D%A2%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><ul>
<li><code>iOS</code>中字面量默认类型是由于下面定义决定的，下面常见类型<ul>
<li><code>public typealias IntegerLiteralType = Int</code></li>
<li><code>public typealias FloatLiteralType = Double</code></li>
<li><code>public typealias BooleanLiteralType = Bool</code></li>
<li><code>Opublic typealias StringLiteralType = String</code></li>
</ul>
</li>
<li>可以通过<code>typealias</code>修改字面量的默认类型,<code>typealias FloatLiteralType = Float</code>、<code>typealias IntegerLiteralType = UInt8</code></li>
</ul>
<h2 id="字面量协议"><a href="#字面量协议" class="headerlink" title="字面量协议"></a>字面量协议</h2><ul>
<li><code>Swif</code>自带类型之所以能够通过字面量初始化，是因为它们遵守了对应的协议<ul>
<li><code>Bool: ExpressibleByBooleanLiteral</code></li>
<li><code>Int : ExpressibleByIntegerLiteral</code></li>
<li><code>Float. Double : ExpressibleByIntegerLiteral. ExpressibleByFloatLiteral</code></li>
<li><code>Dictionary : ExpressibleByDictionaryLiteral</code></li>
<li><code>String: ExpressibleByStringLiteral</code></li>
<li><code>Array. Set: ExpressibleByArrayLiteral</code></li>
<li><code>Optional: ExpressibleByNilLiteral</code></li>
</ul>
</li>
</ul>
<h2 id="字面量协议的应用"><a href="#字面量协议的应用" class="headerlink" title="字面量协议的应用"></a>字面量协议的应用</h2><ul>
<li>字面量<code>bool</code>给<code>Int</code>赋值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Int</span>: <span class="hljs-title">ExpressibleByBooleanLiteral</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">booleanLiteral</span> <span class="hljs-params">value</span>: <span class="hljs-type">Bool</span>)</span> &#123;<br>        <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> value <span class="hljs-operator">?</span> <span class="hljs-number">1</span>:<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> num:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br><span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure></li>
<li>字面量给对象赋值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:<span class="hljs-title">ExpressibleByIntegerLiteral</span>,<span class="hljs-title">ExpressibleByStringLiteral</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Chen&quot;</span><br>    <span class="hljs-comment">//协议要求的，必须required</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">integerLiteral</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int</span>)</span> &#123; <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> value&#125;<br>    <span class="hljs-keyword">required</span> <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">stringLiteral</span> <span class="hljs-params">value</span>: <span class="hljs-type">String</span>)</span> &#123; <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> value &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> student:<span class="hljs-type">Student</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(student.name,student.age) <span class="hljs-comment">//Chen 20</span><br>student <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Jack&quot;</span><br><span class="hljs-built_in">print</span>(student.name,student.age) <span class="hljs-comment">// Jack 0</span><br></code></pre></td></tr></table></figure></li>
<li>用数组/字典，字面量给结构体/类赋值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Point</span>: <span class="hljs-title">ExpressibleByArrayLiteral</span>,<span class="hljs-title">ExpressibleByDictionaryLiteral</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">arrayLiteral</span> <span class="hljs-params">elements</span>: <span class="hljs-type">Int</span>...)</span> &#123;<br>        <span class="hljs-keyword">for</span> (i,value) <span class="hljs-keyword">in</span> elements.enumerated() &#123;<br>            <span class="hljs-keyword">if</span> i <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123; x <span class="hljs-operator">=</span> value &#125;<br>            <span class="hljs-keyword">if</span> i <span class="hljs-operator">==</span> <span class="hljs-number">1</span> &#123; y <span class="hljs-operator">=</span> value &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">dictionaryLiteral</span> <span class="hljs-params">elements</span>: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)<span class="hljs-operator">...</span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (k,value) <span class="hljs-keyword">in</span> elements &#123;<br>            <span class="hljs-keyword">switch</span> k &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;x&quot;</span>: x <span class="hljs-operator">=</span> value<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;y&quot;</span>:y <span class="hljs-operator">=</span> value<br>                <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> p:<span class="hljs-type">Point</span> <span class="hljs-operator">=</span> [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(p) <span class="hljs-comment">//Point(x: 10, y: 20)</span><br>p <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;x&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;y&quot;</span>:<span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(p) <span class="hljs-comment">//Point(x: 11, y: 20)</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理、作用域、指针</title>
    <url>/2023/03/15/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul>
<li>跟<code>OC</code>一样，<code>Swift</code>也是采取基于引用计数的<code>ARC</code>内存管理方案(针对堆空间）</li>
<li><code>Swift</code>的<code>ARC</code>中有<code>3</code>种引用<ul>
<li>强引用 (<code>strong reference</code> ）：默认情况下，引用都是强引用</li>
<li>弱引用(<code>weak reference</code>）：通过<code>weak</code>定义弱引用<ul>
<li>必须是可选类型的<code>var</code>，因为实例销毁后，<code>ARC</code>会自动将弱引用设置为<code>nil</code></li>
<li><code>ARC</code>自动给弱引用设置<code>nil</code>时，不会<code>触发</code><strong>属性观察器</strong></li>
</ul>
</li>
<li>无主引用 (<code>unowned reference</code>）：通过<code>unowned</code>定义无主引用<ul>
<li>不会产生强引用，实例销毁后仍然存储着实例的内存地址（类似于OC中的<code>unsafe_unretained</code>）</li>
<li>试图在实例销毀后访问无主引用，会产生运行时错误（野指针）</li>
</ul>
</li>
</ul>
</li>
<li><code>weak</code>、<code>unowned</code>只能用在类实例上面</li>
</ul>
<h2 id="内存访问冲突"><a href="#内存访问冲突" class="headerlink" title="内存访问冲突"></a>内存访问冲突</h2><ul>
<li>内存访问冲突会在两个访问满足下列条件时发生：<ol>
<li>至少一个是写入操作</li>
<li>它们访问的是同一块内存</li>
<li>它们的访问时间重叠（比如在同一个函数内）</li>
</ol>
</li>
<li>例子<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> ad <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-comment">//出现内存访问冲突</span><br><span class="hljs-comment">//Thread 1: Simultaneous accesses to 0x10000c870, but modification requires exclusive access</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>(<span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">+=</span> ad<br>&#125;<br>test1(num: <span class="hljs-operator">&amp;</span>ad)<br></code></pre></td></tr></table></figure></li>
<li>解决方式,用一个临时变量取值，这样同一个函数中，就有两个地址了<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> temp <span class="hljs-operator">=</span> ad<br>test1(num: <span class="hljs-operator">&amp;</span>temp)<br>ad <span class="hljs-operator">=</span> temp<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="结构体和元祖的特殊情况"><a href="#结构体和元祖的特殊情况" class="headerlink" title="结构体和元祖的特殊情况"></a>结构体和元祖的特殊情况</h2><ul>
<li><strong>注意</strong>,元组和结构体的内存地址均在一块， 如果在<code>全局区</code>，苹果设计，不能<code>同时访问</code>其成员内存<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>(<span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>,<span class="hljs-params">num2</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">+=</span> num2<br>&#125;<br><br><span class="hljs-comment">//出现内存访问冲突</span><br><span class="hljs-keyword">var</span> temp <span class="hljs-operator">=</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>test1(num: <span class="hljs-operator">&amp;</span>temp.<span class="hljs-number">0</span>, num2: <span class="hljs-operator">&amp;</span>temp.<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//出现内存访问冲突</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Num</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> num2:<span class="hljs-type">Int</span><br>&#125;<br><span class="hljs-keyword">var</span> temp <span class="hljs-operator">=</span> <span class="hljs-type">Num</span>(num1: <span class="hljs-number">1</span>, num2: <span class="hljs-number">2</span>)<br>test1(num: <span class="hljs-operator">&amp;</span>temp.num1, num2: <span class="hljs-operator">&amp;</span>temp.num2)<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,如果满足下面的条件，则可以<code>同时访问</code>。（在<code>swift</code>的安全限制中，因为是<code>局部变量</code>，只在函数作用域，不像<code>全局变量</code>一样，存在被<code>其他函数访问</code>的风险）<ul>
<li>你只访问<code>实例存储属性</code>，<ul>
<li>如果是<code>计算属性</code>或者<code>类属性</code>，编译器会直接报错<code>Overlapping accesses to &#39;temp2&#39;, but modification requires exclusive access; consider copying to a local variable</code></li>
</ul>
</li>
<li>结构体是<code>局部变量</code>而<code>非全局变量</code><ul>
<li>全局变量，则会出现内存访问的错误， 非全局不会</li>
</ul>
</li>
<li>结构体要么没有被<code>闭包捕获</code>要么只被<code>非逃逸闭包</code>捕获<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//局部变量，没有被闭包捕获</span><br>    <span class="hljs-keyword">var</span> temp <span class="hljs-operator">=</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>    test1(num: <span class="hljs-operator">&amp;</span>temp.<span class="hljs-number">0</span>, num2: <span class="hljs-operator">&amp;</span>temp.<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">//局部变量，没有被闭包捕获</span><br>    <span class="hljs-keyword">var</span> temp2 <span class="hljs-operator">=</span> <span class="hljs-type">Num</span>(num1: <span class="hljs-number">1</span>, num2: <span class="hljs-number">2</span>)<br>    test1(num: <span class="hljs-operator">&amp;</span>temp2.num1, num2: <span class="hljs-operator">&amp;</span>temp2.num2)<br>    <br>    text1 &#123;<br>        <span class="hljs-comment">// 非逃逸闭包捕获局部变量的结构体，下面执行不会出现内存访问的错误</span><br>        test1(num: <span class="hljs-operator">&amp;</span>temp2.num1, num2: <span class="hljs-operator">&amp;</span>temp2.num2)<br>    &#125;<br>    <br>    <span class="hljs-comment">// text2代码报错</span><br>    text2 &#123;<br>        <span class="hljs-comment">// 逃逸闭包捕获局部变量的结构体，下面代码出现了内存访问的错误</span><br>        test1(num: <span class="hljs-operator">&amp;</span>temp2.num1, num2: <span class="hljs-operator">&amp;</span>temp2.num2)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;text2&quot;</span>,temp2)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">text1</span>(<span class="hljs-params">handler</span>:()-&gt;<span class="hljs-type">Void</span>)</span> &#123;<br>    handler()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">text2</span>(<span class="hljs-params">handler</span>:<span class="hljs-keyword">@escaping</span> ()-&gt;<span class="hljs-type">Void</span>)</span> &#123;<br>    handler()<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><blockquote>
<p><code>do</code>不仅可以和<code>catch</code>一起用，还可以单独使用，作为局部作用域，和<code>OC</code>不同不能用单纯的<code>&#123;&#125;</code>作为局部作用域</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="子类重写父类成员需要注意的是"><a href="#子类重写父类成员需要注意的是" class="headerlink" title="子类重写父类成员需要注意的是"></a>子类重写父类成员需要注意的是</h2><ul>
<li>子类重写成员的访问级别必须 <code>≥</code>子类的访问级别，或者<code>≥</code>父类被重写成员的访问级别<ul>
<li>这里<code>TestH</code>定义为<code>private</code>但是和<code>Test</code>在同一文件，实际可以认为是<code>fileprivate</code></li>
<li>子类重写父类，其访问基本必须大于等于子类，或者父类的，因此显示添加<code>private</code>无法编译，因为<code>TestH</code>实际是<code>fileprivate</code>。<code>override func test</code>的权限要大于等于<code>fileprivate</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestH</span>: <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>父类的成员不能被成员作用域外定义的<code>子类重写</code><ul>
<li>子类<code>无法访问</code>到父类成员，因此不会重写<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-operator">----</span> 不会重写<span class="hljs-operator">----</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestH</span>: <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-operator">----</span> 会重写<span class="hljs-operator">----</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestH</span>: <span class="hljs-title">Test</span> </span>&#123;<br>         <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="不安全的指针"><a href="#不安全的指针" class="headerlink" title="不安全的指针"></a>不安全的指针</h2><ul>
<li>为什么说指针不安全？<ol>
<li>⽐如我们在创建⼀个对象的时候，是需要在堆分配内存空间的。但是这个内存空间的声明周期是有限的，也就意味着如果我们使⽤指针指向这块内容空间，如果当前内存空间的⽣命周期到了（引⽤计数为<code>0</code>），那么我们当前的指针是不是就变成了未定义的⾏为了（野指针）</li>
<li>我们创建的内存空间是有边界的，⽐如我们创建⼀个⼤⼩为<code>10</code>的数组，这个时候我们通过指针访问 到了 <code>index = 11</code> 的位置，这个时候是不是就越界了，访问了⼀个未知的内存空间。</li>
<li>指针类型与内存的值类型不⼀致，也是不安全的。（<code>Int *</code> 和 <code>Int8 *</code>类型容易造成精度缺失）</li>
</ol>
</li>
</ul>
<h2 id="指针的类别"><a href="#指针的类别" class="headerlink" title="指针的类别"></a>指针的类别</h2><ul>
<li><code>Swift</code>中也有专门的指针类型，这些都被定性为“<code>Unsafe</code>”（不安全的），常见的有以下<code>4</code>种类型<ul>
<li><code>UnsafePointer&lt;Pointee&gt;</code>类似于 <code>const Pointee *</code></li>
<li><code>UnsafeMutablePointercPointee&gt;</code>类似于 <code>Pointee *</code></li>
<li><code>UnsafeRawPointer</code> 类似于 <code>const void *</code></li>
<li><code>UnsafeMutableRawPointer</code> 类似于 <code>void *</code></li>
</ul>
</li>
<li>一些指针的方法,类型指针，不需要管理内存<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 值类型</span><br><span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-comment">//创建一个指针</span><br><span class="hljs-keyword">var</span> ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafeMutablePointer</span>(to: <span class="hljs-operator">&amp;</span>age) &#123;<span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>)&#125;<br><br><span class="hljs-comment">// 引用类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br><br><span class="hljs-comment">//拿到的是person指针变量的地址</span><br><span class="hljs-keyword">var</span> ptr2 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>person) &#123; <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>) &#125;<br><br><span class="hljs-comment">//获取地址上存储的数据</span><br><span class="hljs-keyword">let</span> bitPattern <span class="hljs-operator">=</span> ptr2.load(as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<br><span class="hljs-comment">//根据传入的值，生成地址，这里ptr3 == person，和person指针相同，都指向堆地址</span><br><span class="hljs-keyword">var</span> ptr3 <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(bitPattern: bitPattern)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建原生指针"><a href="#创建原生指针" class="headerlink" title="创建原生指针"></a>创建原生指针</h3><blockquote>
<ul>
<li>对于原生指针的内存管理是需要手动管理</li>
<li>原生指针在使用完需要手动释放</li>
</ul>
</blockquote>
<h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> ptr4 <span class="hljs-operator">=</span> malloc(<span class="hljs-number">16</span>)<br><br><span class="hljs-comment">//存</span><br>ptr4<span class="hljs-operator">?</span>.storeBytes(of: <span class="hljs-number">11</span>, as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>) <br>ptr4<span class="hljs-operator">?</span>.storeBytes(of: <span class="hljs-number">22</span>, toByteOffset: <span class="hljs-number">8</span>,as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<br><br><span class="hljs-comment">//取</span><br><span class="hljs-built_in">print</span>(ptr4<span class="hljs-operator">?</span>.load(as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<span class="hljs-operator">!</span>) <span class="hljs-comment">// 11</span><br><span class="hljs-comment">//偏移8字节存储</span><br><span class="hljs-built_in">print</span>(ptr4<span class="hljs-operator">?</span>.load(fromByteOffset: <span class="hljs-number">8</span>, as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<span class="hljs-operator">!</span>) <span class="hljs-comment">// 22</span><br><span class="hljs-comment">//销毁</span><br>free(ptr4)<br></code></pre></td></tr></table></figure>
</code></pre>
<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> ptr5 <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="hljs-number">16</span>, alignment: <span class="hljs-number">1</span>)<br>ptr5.storeBytes(of: <span class="hljs-number">11</span>, as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<br>ptr5.advanced(by: <span class="hljs-number">8</span>).storeBytes(of: <span class="hljs-number">22</span>, as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<br>ptr5.deallocate()<br></code></pre></td></tr></table></figure>
</code></pre>
<h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> ptr6 <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int</span>&gt;.allocate(capacity: <span class="hljs-number">2</span>)<br><span class="hljs-comment">//对两个int重复赋予 11</span><br><span class="hljs-comment">//ptr6.initialize(repeating: 11, count: 2)</span><br>ptr6.initialize(to: <span class="hljs-number">11</span>)<br><span class="hljs-comment">//下一个存储的int</span><br>ptr6.successor().initialize(to: <span class="hljs-number">20</span>)<br><span class="hljs-comment">// (ptr6 + 1).initialize(to: 20)</span><br><span class="hljs-comment">// ptr6[1].initialize(to: 20)</span><br><br><span class="hljs-comment">//已经确定是int的，所以1就是8字节</span><br><span class="hljs-built_in">print</span>(ptr6.pointee) <span class="hljs-comment">// 11</span><br><span class="hljs-built_in">print</span>((ptr6 <span class="hljs-operator">+</span> <span class="hljs-number">1</span>).pointee) <span class="hljs-comment">// 20</span><br><span class="hljs-built_in">print</span>(ptr6[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 11</span><br><span class="hljs-built_in">print</span>(ptr6[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 20</span><br><br><span class="hljs-comment">//和第二种相比，要反初始化,否则会存在内存泄漏</span><br>ptr6.deinitialize(count: <span class="hljs-number">2</span>)<br>ptr6.deallocate() <br></code></pre></td></tr></table></figure>
  
</code></pre>
<h3 id="指针转换"><a href="#指针转换" class="headerlink" title="指针转换"></a>指针转换</h3><ul>
<li><code>unsafeBitcast</code>是忽略数据类型的强制转换，不会因为数据类型的变化而改变原来的内存数据<ul>
<li>例如<code>var age:Int = 10, age2:Double = Double(age)</code>,<code>Int</code>转换成<code>Double</code>时，其存储的数据是会发生改变的。但是用<code>unsafeBitcast</code>转换是不会的，也就是<code>10</code>转换成<code>Double</code>后，其<code>Double</code>上的数据是<code>0xa</code>，其<code>Double</code>但并不表示<code>10</code></li>
<li><code>var ptr8 = unsafeBitCast(person, to: UnsafeRawPointer.self)</code>,<code>ptr8</code>和<code>person</code>指针一样，指向堆地址<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> ptr7 <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="hljs-number">16</span>, alignment: <span class="hljs-number">1</span>)<br><br>ptr7.assumingMemoryBound(to: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>).pointee <span class="hljs-operator">=</span> <span class="hljs-number">11</span><br><span class="hljs-comment">//这里因为不知到什么类型，+8，实际是偏移8字节</span><br>(ptr7 <span class="hljs-operator">+</span> <span class="hljs-number">8</span>).assumingMemoryBound(to: <span class="hljs-type">Double</span>.<span class="hljs-keyword">self</span>).pointee <span class="hljs-operator">=</span> <span class="hljs-number">22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">unsafeBitCast</span>(ptr7, to: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt;.<span class="hljs-keyword">self</span>).pointee) <span class="hljs-comment">//11</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">unsafeBitCast</span>(ptr7 <span class="hljs-operator">+</span> <span class="hljs-number">8</span>, to: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt;.<span class="hljs-keyword">self</span>).pointee) <span class="hljs-comment">// 4626885667169763328</span><br><br>ptr7.deallocate()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="内存绑定"><a href="#内存绑定" class="headerlink" title="内存绑定"></a>内存绑定</h2><blockquote>
<ul>
<li><code>swift</code> 提供了三种不同的 <code>API</code> 来绑定/重新绑定指针：<ol>
<li><code>assumingMemoryBound(to:)</code></li>
<li><code>bindMemory(to: capacity:)</code></li>
<li><code>withMemoryRebound(to: capacity: body:)</code></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="assumingMemoryBound-to"><a href="#assumingMemoryBound-to" class="headerlink" title="assumingMemoryBound(to:)"></a><code>assumingMemoryBound(to:)</code></h3><blockquote>
<p>只是让编译器绕过类型检查，并没有发⽣实际类型的转换,一种假定绑定的状态，实际绑定要用<code>bindMemory(to: capacity:)</code></p>
</blockquote>
<ol>
<li>有些时候我们处理代码的过程中，只有<code>原始指针</code>（没有保留<code>指针类型</code>），但此刻对于处理代码的我们来 说明确知道指针的类型，我们就可以使⽤ <code>assumingMemoryBound(to:)</code> 来告诉编译器预期的类型。 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tuple <span class="hljs-operator">=</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>tuple) &#123; tuplePtr <span class="hljs-keyword">in</span><br>    testPointer(tuplePtr)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testPointer</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">p</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt;)</span> &#123;<br>    <span class="hljs-built_in">print</span>(p[<span class="hljs-number">0</span>])<br>    <span class="hljs-built_in">print</span>(p[<span class="hljs-number">1</span>])<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>此时在调用<code>testPointer</code>会报编译器错误 <code>Cannot convert value of type &#39;UnsafePointer&lt;(Int, Int)&gt;&#39; to expected argument type &#39;UnsafePointer&lt;Int&gt;&#39;</code>,修改如下: <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tuple <span class="hljs-operator">=</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>tuple) &#123; tuplePtr <span class="hljs-keyword">in</span><br>    testPointer(<span class="hljs-type">UnsafeRawPointer</span>(tuplePtr).assumingMemoryBound(to: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testPointer</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">p</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt;)</span> &#123;<br>    <span class="hljs-built_in">print</span>(p[<span class="hljs-number">0</span>])<br>    <span class="hljs-built_in">print</span>(p[<span class="hljs-number">1</span>])<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>元组是值类型，在本质上这块内存空间是连续的，存放Int类型数据。先把元组转化成指针指向元组的首地址<code>tuple[0]</code>，通过<code>assumingMemoryBound(to:)</code>告诉编译器，当前元组的内存已经绑定过<code>Int</code>了，这时就能骗过编译器检查。</li>
</ol>
<h3 id="bindMemory-to-capacity"><a href="#bindMemory-to-capacity" class="headerlink" title="bindMemory(to: capacity:)"></a><code>bindMemory(to: capacity:)</code></h3><blockquote>
<p>⽤于更改内存绑定的类型，如果当前内存还没有类型绑定，则将⾸次绑定为该类型；否则重新绑定该类型，并且内存中所有的值都会变成该类型。</p>
</blockquote>
<h4 id="class实例绑定成class的底层数据结构"><a href="#class实例绑定成class的底层数据结构" class="headerlink" title="class实例绑定成class的底层数据结构"></a><code>class</code>实例绑定成<code>class</code>的底层数据结构</h4><ol>
<li><code>swift</code>源码可知<code>clas</code>的底层结构是<code>HeapObject</code> <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapObject</span> </span>&#123;<br><span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 定义一个未知类型的指针</span><br><span class="hljs-keyword">var</span> refCounts: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 引用计数</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>metadata</code>其实也是一个结构体 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Metadata</span> </span>&#123; <br>  <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <br>  <span class="hljs-keyword">var</span> superClass: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span> <br>  <span class="hljs-keyword">var</span> cacheData: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) <br>  <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span> <br>  <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <br>  <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <br>  <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <br>  <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutableRawPointer</span> <br>  <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span><br> &#125;<br></code></pre></td></tr></table></figure></li>
<li>将<code>Circle</code>绑定到结构体内存中: <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-keyword">let</span> diameter:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>通过<code>Unmanaged</code>指定内存管理,类似于<code>OC</code>与<code>CF</code>的桥接交互方式,通过<code>bindMemory</code>进行内存绑定<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br><span class="hljs-comment">// 通过Unmanaged指定内存管理，类似于OC与CF的交互方式（所有权的转换 __bridge）</span><br><span class="hljs-comment">// passUnretained 不增加引用计数，即不需要获取所有权</span><br><span class="hljs-comment">// passRetained 增加引用技术，即需要获取所有权</span><br><span class="hljs-comment">// toOpaque 不透明的指针</span><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passUnretained(circle).toOpaque()<br><span class="hljs-comment">// bindMemory更改当前UnsafeMutableRawPointer的指针类型，绑定到具体类型值</span><br><span class="hljs-comment">// - 如果没有绑定，则绑定</span><br><span class="hljs-comment">// - 如果已经绑定，则重定向到 HeapObject类型上</span><br><span class="hljs-keyword">let</span> heapObject <span class="hljs-operator">=</span> ptr.bindMemory(to: <span class="hljs-type">HeapObject</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(heapObject.pointee.metadata) <span class="hljs-comment">// 0x0000000100008110</span><br><span class="hljs-built_in">print</span>(heapObject.pointee.refCounts) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">let</span> metadataPtr <span class="hljs-operator">=</span> heapObject.pointee.metadata.bindMemory(to: <span class="hljs-type">Metadata</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(metadataPtr.pointee) <span class="hljs-comment">// Metadata(kind: 4295000280, superClass: _TtCs12_SwiftObject, cacheData: (140703243243968, -9212113037786349568), data: -9223266483736374430, classFlags: 2, instanceAddressPoint: 0, instanceSize: 32, instanceAlignmentMask: 7, reserved: 0, classSize: 144, classAddressPoint: 16, typeDescriptor: 0x0000000100003cb8, iVarDestroyer: 0x0000000000000000)</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="withMemoryRebound-to-capacity-body"><a href="#withMemoryRebound-to-capacity-body" class="headerlink" title="withMemoryRebound(to: capacity: body:)"></a><code>withMemoryRebound(to: capacity: body:)</code></h3><ol>
<li>当我们在给外部函数传递参数时，不免会有⼀些数据类型上的差距。如果我们进⾏类型转换，必然要来回复制数据；这个时候我们就可以使⽤ <code>withMemoryRebound(to: capacity: body:)</code> 来临时更 改内存绑定类型，<code>block</code>中临时绑定完后返回原来的状态。 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>num) &#123; ptr: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt; <span class="hljs-keyword">in</span><br>    testPointer2(ptr)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testPointer2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">p</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;)</span> &#123;<br>    <span class="hljs-built_in">print</span>(p)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>此时编译器报错因为类型不匹配。使用<code>withMemoryRebound(to: capacity: body:)</code>修改后： <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> ptr1 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>num) &#123;<span class="hljs-variable">$0</span>&#125;<br>ptr1.withMemoryRebound(to: <span class="hljs-type">Int8</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; (ptr: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;)  <span class="hljs-keyword">in</span><br>    testPointer2(ptr)<br>    <span class="hljs-comment">// 超过了闭包作用域，则不是UnsafePointer&lt;Int8&gt;类型</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testPointer2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">p</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;)</span> &#123;<br>    <span class="hljs-built_in">print</span>(p)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>高级运算符和扩展</title>
    <url>/2023/03/14/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h1><ul>
<li>在全局作用域使用<code>operator</code>进行声明<ul>
<li><code>prefix operator</code> 前缀运算符</li>
<li><code>suffix operator</code> 后缀运算符</li>
<li><code>infix operator</code> 中缀运算符：优先级组</li>
</ul>
</li>
<li>自定义优先组<ul>
<li><code>associativity</code>,结合性，指多个运算符能否一起用，类似<code>1 + 1 + 1</code>,<code>left</code>和<code>right</code>指多个运算符，从哪个方向开始算</li>
<li><code>higherThan</code>和<code>1owerThan</code>,比系统的优先级高或低，<a href="https://developer.apple.com/documentation/swift/operator-declarations">系统运算符参考</a></li>
<li><code>assignment</code>支持出现可选链出现<code>nil</code>的情况，例如<code>p1?.point +- Point(x: 1, y: 3)</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift">precedenceqroup 优先级组&#123;<br>    associativity：结合性(left\rightinone)<br>    higherThan：比谁的优先级高<br>    1owerThan：比谁的优先級低<br>    assignment：<span class="hljs-literal">true</span> 代表在可选链操作中拥有跟赋值运算符一样的优先級<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><blockquote>
<p><code>Swif</code>中的扩展，有点类似于<code>OC</code>中的分类 (<code>Category</code>)</p>
</blockquote>
<ul>
<li><p>扩展可以为枚举、结构体、类、协议添加新功能</p>
<ul>
<li>可以添加方法、计算属性、下标、（便捷）初始化器、嵌套类型、协议等等</li>
</ul>
</li>
<li><p>扩展不能办到的事情</p>
<ul>
<li>不能覆盖原有的功能</li>
<li>不能重写父类中的方法</li>
<li>不能添加存储属性 ，不能向已有的属性添加属性观察器</li>
<li>不能添加父类</li>
<li>不能添加指定初始化器，不能添加反初始化器</li>
</ul>
</li>
<li><p>注意，扩展中的方法的调用是采用<code>静态派发</code>的方式（类似<code>结构体</code>中的<code>方法</code>），扩展中的方法是不会加到<code>类的虚表</code>中的（因此在扩展中不能重写<code>父类的方法</code>）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Array</title>
    <url>/2023/03/13/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/Array/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Array的内存"><a href="#Array的内存" class="headerlink" title="Array的内存"></a>Array的内存</h1><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.stride(ofValue: arr)) <span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure>
<ul>
<li>数组是结构体，但其内存占用是<code>8</code>字节，而并非，其数组内<code>int</code>存储的总和，<ul>
<li>实际上数组生成在堆空间，其<code>8</code>字节是堆空间</li>
<li>汇编查看,显然在数组初始化的时候，调用了<code>alloc</code>，在堆空间中创建了内存<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">  <span class="hljs-operator">*</span> thread #<span class="hljs-number">1</span>, queue <span class="hljs-operator">=</span> &#x27;com.apple.main<span class="hljs-operator">-</span>thread&#x27;, stop reason <span class="hljs-operator">=</span> breakpoint <span class="hljs-number">4.1</span><br><span class="hljs-operator">*</span> frame #<span class="hljs-number">0</span>: <span class="hljs-number">0x00007ff81a193e62</span> libswiftCore.dylib`swift_allocObject <span class="hljs-operator">+</span> <span class="hljs-number">34</span><br>  frame #<span class="hljs-number">1</span>: <span class="hljs-number">0x00007ff819e9e533</span> libswiftCore.dylib`<span class="hljs-type">Swift</span>._allocateUninitializedArray<span class="hljs-operator">&lt;</span>τ_0_0<span class="hljs-operator">&gt;</span>(<span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>) -&gt; (<span class="hljs-type">Swift</span>.<span class="hljs-type">Array</span>&lt;τ_0_0&gt;, <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>) <span class="hljs-operator">+</span> <span class="hljs-number">83</span><br>  frame #<span class="hljs-number">2</span>: <span class="hljs-number">0x0000000100004275</span> <span class="hljs-type">SwiftDText</span>`main at main.swift:<span class="hljs-number">26</span>:<span class="hljs-number">7</span><br>  frame #<span class="hljs-number">3</span>: <span class="hljs-number">0x00007ff80b6fd310</span> dyld`start <span class="hljs-operator">+</span> <span class="hljs-number">2432</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数组在堆中的内存数据查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-comment">//&amp;arr</span><br>x<span class="hljs-operator">/</span>4xg <span class="hljs-number">0x10000C3A0</span><br><span class="hljs-number">0x10000c3a0</span>: <span class="hljs-number">0x0000600002104000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x10000c3b0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-comment">// 数组上内存的情况</span><br>x<span class="hljs-operator">/</span>10xg <span class="hljs-number">0x0000600002104000</span><br><span class="hljs-number">0x600002104000</span>: <span class="hljs-number">0x00007ff84e38f7b0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600002104010</span>: <span class="hljs-number">0x0000000000000005</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600002104020</span>: <span class="hljs-number">0x0000000000000001</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x600002104030</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600002104040</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li>显然，数组和引用类型相似，其真正存储的值在堆空间，该堆空间，<ul>
<li>第一个<code>8</code>字节是<code>metaData</code>,</li>
<li>第二个<code>8</code>字节存放是引用计数</li>
<li>第三个<code>8</code>字节存放是数组长度，第四个<code>8</code>字节是数组的容量，（<code>长度</code>大于容量的<code>一半</code>，则容量会进行倍数扩容）</li>
<li>往后字节存放数组中存放的值，上面介绍的是整型，下面介绍其他类型的<ul>
<li>注意如果是<code>Any</code>，则除数据本身外，还会有介绍数据类型相关的字节，每个内容占<code>4</code><strong>字节</strong><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//字符串</span><br><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]<br><span class="hljs-number">0x60000260c000</span>: <span class="hljs-number">0x00007ff84e38eaa0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x60000260c010</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000008</span><br><span class="hljs-number">0x60000260c020</span>: <span class="hljs-number">0x0000000000000031</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x60000260c030</span>: <span class="hljs-number">0x0000000000000032</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x60000260c040</span>: <span class="hljs-number">0x0000000000000033</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x60000260c050</span>: <span class="hljs-number">0x0000000000000034</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-comment">// Any  var arr = [&quot;1&quot;,2,3,&quot;4&quot;]</span><br><span class="hljs-number">0x6000033080a0</span>: <span class="hljs-number">0x00007ff84e38eb70</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x6000033080b0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000008</span><br><span class="hljs-number">0x6000033080c0</span>: <span class="hljs-number">0x0000000000000031</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x6000033080d0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x00007ff84ef72ad8</span><br><span class="hljs-number">0x6000033080e0</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000033080f0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x00007ff84ef74a40</span><br><span class="hljs-number">0x600003308100</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x600003308110</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x00007ff84ef74a40</span><br><span class="hljs-number">0x600003308120</span>: <span class="hljs-number">0x0000000000000034</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x600003308130</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x00007ff84ef72ad8</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>扩容方式查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>]()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">3</span> &#123;<br>    arr.append(i)<br>&#125;<br><span class="hljs-comment">// 数组地址 0x000000010000c260</span><br><span class="hljs-comment">// [0]</span><br>x<span class="hljs-operator">/</span>xg <span class="hljs-number">0x000000010000c260</span><br><span class="hljs-number">0x10000c260</span>: <span class="hljs-number">0x0000600000c00bd0</span><br>x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x0000600000c00bd0</span><br><span class="hljs-number">0x600000c00bd0</span>: <span class="hljs-number">0x00007ff84e38f7b0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000c00be0</span>: <span class="hljs-number">0x0000000000000001</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600000c00bf0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><br><span class="hljs-comment">// [0,1]</span><br>x<span class="hljs-operator">/</span>xg <span class="hljs-number">0x000000010000c260</span><br><span class="hljs-number">0x10000c260</span>: <span class="hljs-number">0x0000600000c00bd0</span><br>x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x0000600000c00bd0</span><br><span class="hljs-number">0x600000c14000</span>: <span class="hljs-number">0x00007ff84e38f7b0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000c14010</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600000c14020</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000001</span><br><br><span class="hljs-comment">// [0,1,2]</span><br>x<span class="hljs-operator">/</span>xg <span class="hljs-number">0x000000010000c260</span><br><span class="hljs-number">0x10000c260</span>: <span class="hljs-number">0x0000600001700600</span><br>x<span class="hljs-operator">/</span>8xg <span class="hljs-number">0x0000600001700600</span><br><span class="hljs-number">0x600001700600</span>: <span class="hljs-number">0x00007ff84e38f7b0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001700610</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000008</span><br><span class="hljs-number">0x600001700620</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000001</span><br><span class="hljs-number">0x600001700630</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li>显然扩容在数组实际长度达到容量值的<code>一半以上</code>之后，就会进行扩容，此时会重新申请堆空间构建数组</li>
<li><strong>注意</strong>,<code>Array</code>在<code>swift</code>中是值类型，但其本质实际上是<code>引用类型</code>，其内存存储在<code>堆空间</code>中，在<code>swift</code>中设置为<code>struct</code>只是表明<code>Array</code>在<code>swift</code>中使用的<code>行为</code>是按结构体的方式来编写代码的,其本质仍是引用类型。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p><code>Swift</code>中有三种数组类型，分别是<code>Array</code>、<code>ContiguousArray</code>和<code>ArraySlice</code>，每一种数组都有一个用来保存数组元素的连续内存区块，那么它们之间有什么联系或者区别呢？主要有以下几点：</p>
</blockquote>
<ul>
<li>大多数<code>Array</code>所能支持的属性，<code>ContiguousArray</code>同样也能支持，因为<code>ContiguousArray</code>和<code>Array</code>共享很多协议；</li>
<li><code>ContiguousArray</code>和<code>Array</code>之间最主要的不同是，<code>ContiguousArray</code>不支持和<code>Objective-C</code>之间的桥接；<ul>
<li>如果你准备在数组中存储类型为类或者<code>@objc协议</code>类型的元素，使用<code>ContiguousArray</code>效率可能会更高(不需要将数组桥接到<code>NSArray</code>或将数组传递到<code>Objective-C</code>,在纯<code>swift</code>中使用的情况)</li>
</ul>
</li>
<li><code>ArraySlice</code>是<code>Array</code>、<code>ContiguousArray</code>，或者其它<code>ArraySlice</code>的子序列。和<code>ContiguousArray</code>一样，<code>ArraySlice</code>同样也不支持与<code>Objective-C</code>之间的桥接</li>
<li>正因为<code>ArraySlice</code>是表示一个已经存在的、更大的数组的子序列，所以在使用<code>ArraySlice</code>的时候一定要特别注意。如果原始数组的生命周期已经结束，并且不能再访问元素时，使用<code>ArraySlice</code>可能会出现内存泄漏。因此，<code>ArraySlice</code>并不适用于长期存储数据的场合。</li>
</ul>
<h2 id="ArraySlice对可变数组的影响"><a href="#ArraySlice对可变数组的影响" class="headerlink" title="ArraySlice对可变数组的影响"></a><code>ArraySlice</code>对<code>可变数组的影响</code></h2><ul>
<li><strong>注意上述</strong>,可变数组添加中，如果有<code>ArraySlice</code>指向。那边当可变数组改变时，会触发写拷贝(尽管容量足够，不会扩容)，生成一个新的数组内存。这主要是为了避免影响<code>ArraySlice</code>所指向的内存<ul>
<li><code>ArraySlice</code>占有<code>4 * 8</code>字节，相比原有<code>Array</code>指针的<code>8</code>字节，分别为<ul>
<li>原<code>Array</code>的指针</li>
<li>数组中存放数据的开始位置</li>
<li><code>ArraySlice</code>的左边界位置，包括左边界</li>
<li>右移动<code>1</code>位，为其右边界<code>[左边界，右边界)</code>,不包括右边界<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>arr.<span class="hljs-built_in">reserveCapacity</span>(<span class="hljs-number">20</span>)<br>var subArr1 = arr[<span class="hljs-number">2.</span>.<span class="hljs-number">.2</span>]<br>var subArr2 = arr[<span class="hljs-number">3.</span>.<span class="hljs-number">.5</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">withUnsafePointer</span>(to: &amp;arr, &#123; $<span class="hljs-number">0</span> &#125;)) <span class="hljs-comment">//0x00000001001e8268</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">withUnsafePointer</span>(to: &amp;subArr1, &#123; $<span class="hljs-number">0</span> &#125;)) <span class="hljs-comment">// 0x00000001001e8270</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">withUnsafePointer</span>(to: &amp;subArr2, &#123; $<span class="hljs-number">0</span> &#125;)) <span class="hljs-comment">// 0x00000001001e8290</span><br><br>(lldb) x/<span class="hljs-number">11</span>xg <span class="hljs-number">0x00000001001e8268</span><br><span class="hljs-number">0x1001e8268</span>: <span class="hljs-number">0x0000600001f7c000</span> <span class="hljs-number">0x0000600001f7c000</span><br><span class="hljs-number">0x1001e8278</span>: <span class="hljs-number">0x0000600001f7c020</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x1001e8288</span>: <span class="hljs-number">0x0000000000000007</span> <span class="hljs-number">0x0000600001f7c000</span><br><span class="hljs-number">0x1001e8298</span>: <span class="hljs-number">0x0000600001f7c020</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x1001e82a8</span>: <span class="hljs-number">0x000000000000000d</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x1001e82b8</span>: <span class="hljs-number">0x0000000000000000</span><br><br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x0000600001f7c020</span><br><span class="hljs-number">0x600001f7c020</span>: <span class="hljs-number">0x0000000000000001</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x600001f7c030</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><br>arr.<span class="hljs-built_in">append</span>(<span class="hljs-number">11</span>) <span class="hljs-comment">// 数组存放地址变成了0x000060000078c000</span><br>(lldb) x/<span class="hljs-number">10</span>xg <span class="hljs-number">0x00000001001e8268</span><br><span class="hljs-number">0x1001e8268</span>: <span class="hljs-number">0x000060000078c000</span> <span class="hljs-number">0x0000600001f7c000</span><br><span class="hljs-number">0x1001e8278</span>: <span class="hljs-number">0x0000600001f7c020</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x1001e8288</span>: <span class="hljs-number">0x000000000000000d</span> <span class="hljs-number">0x0000600001f7c000</span><br><span class="hljs-number">0x1001e8298</span>: <span class="hljs-number">0x0000600001f7c020</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x1001e82a8</span>: <span class="hljs-number">0x000000000000000d</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong>,切片后，<code>subArr1[0]</code>是无法取出值的，会报错。正确做法是<code>subArr1[subArr1.startIndex]</code></li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">internal <span class="hljs-title">init</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    owner: AnyObject, subscriptBaseAddress: UnsafeMutablePointer&lt;Element&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    indices: Range&lt;Int&gt;, hasNativeBuffer: Bool</span></span><br><span class="hljs-params"><span class="hljs-function">  )</span> </span>&#123;<br>    self.owner = owner<br>    self.subscriptBaseAddress = subscriptBaseAddress<br>    self.startIndex = indices.lowerBound<br>    let bufferFlag = <span class="hljs-built_in">UInt</span>(hasNativeBuffer ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)<br>    self.endIndexAndFlags = (<span class="hljs-built_in">UInt</span>(indices.upperBound) &lt;&lt; <span class="hljs-number">1</span>) | bufferFlag<br>    _invariantCheck()<br>  &#125;<br></code></pre></td></tr></table></figure>

<h1 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h1><ul>
<li><code>NSArray</code>查看内存，第一个是<code>isa</code>，接下来是<code>count</code>，后续即存放的数据内容<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Printing description of arr:<br>&lt;__NSArrayI <span class="hljs-number">0x60000177f300</span>&gt;(<br><span class="hljs-number">11</span>,<br><span class="hljs-number">22</span>,<br><span class="hljs-number">33</span>,<br><span class="hljs-number">44</span>,<br><span class="hljs-number">55</span><br>)<br><br>(lldb) x/<span class="hljs-number">8</span>xg <span class="hljs-number">0x60000177f300</span><br><span class="hljs-number">0x60000177f300</span>: <span class="hljs-number">0x00007ff8653df738</span> <span class="hljs-number">0x0000000000000005</span><br><span class="hljs-number">0x60000177f310</span>: <span class="hljs-number">0x0000000108697f60</span> <span class="hljs-number">0x0000000108697f80</span><br><span class="hljs-number">0x60000177f320</span>: <span class="hljs-number">0x0000000108697fa0</span> <span class="hljs-number">0x0000000108697fc0</span><br><span class="hljs-number">0x60000177f330</span>: <span class="hljs-number">0x0000000108697fe0</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a>可变数组</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>arr) &#123; <span class="hljs-variable">$0</span> &#125;) <span class="hljs-comment">// 0x00000001001e8260</span><br>(lldb) x<span class="hljs-operator">/</span>2xg <span class="hljs-number">0x00000001001e8260</span><br><span class="hljs-number">0x1001e8260</span>: <span class="hljs-number">0x0000600001850730</span> <span class="hljs-number">0x0000000000000000</span><br><br>(lldb) x<span class="hljs-operator">/</span>10xg <span class="hljs-number">0x0000600001850730</span><br><span class="hljs-number">0x600001850730</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850740</span>: <span class="hljs-number">0x0000000000000005</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600001850750</span>: <span class="hljs-number">0x0000000000000001</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x600001850760</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600001850770</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>查看删除<code>removeFirst</code>,显然在<code>swift</code>中删除实际将整个数组内存前移</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">arr.removeFirst()<br><br>(lldb) x<span class="hljs-operator">/</span>10xg <span class="hljs-number">0x0000600001850730</span><br><span class="hljs-number">0x600001850730</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850740</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600001850750</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850760</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600001850770</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br><br>arr.removeFirst()<br>(lldb) x<span class="hljs-operator">/</span>10xg <span class="hljs-number">0x0000600001850730</span><br><span class="hljs-number">0x600001850730</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850740</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600001850750</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600001850760</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600001850770</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>arr) &#123; <span class="hljs-variable">$0</span> &#125;) <span class="hljs-comment">// 0x00000001001e8260</span><br></code></pre></td></tr></table></figure></li>
<li><p>查看<code>append</code>,在不超过容量一半的情况下，添加也是在后面增加内存，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">arr.<span class="hljs-built_in">append</span>(<span class="hljs-number">3</span>)<br><br>(lldb) x/<span class="hljs-number">10</span>xg <span class="hljs-number">0x0000600001850730</span><br><span class="hljs-number">0x600001850730</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850740</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600001850750</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600001850760</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850770</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br><br>arr.<span class="hljs-built_in">append</span>(<span class="hljs-number">4</span>)<br>(lldb) x/<span class="hljs-number">10</span>xg <span class="hljs-number">0x0000600001850730</span><br><span class="hljs-number">0x600001850730</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850740</span>: <span class="hljs-number">0x0000000000000005</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600001850750</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600001850760</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850770</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">withUnsafePointer</span>(to: &amp;arr) &#123; $<span class="hljs-number">0</span> &#125;) <span class="hljs-comment">// 0x00000001001e8260</span><br></code></pre></td></tr></table></figure></li>
<li><p>查看<code>removeLast</code>,删除最后，实际上只改变了数组长度，数组中的内容保持原样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">arr.<span class="hljs-built_in">removeLast</span>()<br>(lldb) x/<span class="hljs-number">10</span>xg <span class="hljs-number">0x0000600001850730</span><br><span class="hljs-number">0x600001850730</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850740</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600001850750</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600001850760</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850770</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br><br>arr.<span class="hljs-built_in">removeLast</span>()<br>(lldb) x/<span class="hljs-number">10</span>xg <span class="hljs-number">0x0000600001850730</span><br><span class="hljs-number">0x600001850730</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850740</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600001850750</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600001850760</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001850770</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li><p>查看<code>insert(_:at:)</code>，同样是，插入后，后续数据填充剩余长度</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">arr.insert(<span class="hljs-number">8</span>, at: <span class="hljs-number">1</span>)<br><br>(lldb) x<span class="hljs-operator">/</span>10xg <span class="hljs-number">0x0000600002c7c690</span><br><span class="hljs-number">0x600002c7c690</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600002c7c6a0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600002c7c6b0</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000008</span><br><span class="hljs-number">0x600002c7c6c0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000004</span> <span class="hljs-comment">//覆盖其长度的内容</span><br><span class="hljs-number">0x600002c7c6d0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br><br>arr.insert(<span class="hljs-number">10</span>, at: <span class="hljs-number">1</span>)<br>(lldb) x<span class="hljs-operator">/</span>10xg <span class="hljs-number">0x0000600002c7c690</span><br><span class="hljs-number">0x600002c7c690</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600002c7c6a0</span>: <span class="hljs-number">0x0000000000000005</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600002c7c6b0</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600002c7c6c0</span>: <span class="hljs-number">0x0000000000000008</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600002c7c6d0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li><p>查看<code>remove(at:)</code>,重指定删除位置，开始，往后赋值剩余长度的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">arr.<span class="hljs-built_in">remove</span>(at: <span class="hljs-number">1</span>)<br><br>(lldb) x/<span class="hljs-number">10</span>xg <span class="hljs-number">0x0000600002c7c690</span><br><span class="hljs-number">0x600002c7c690</span>: <span class="hljs-number">0x00007ff84e526fb0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600002c7c6a0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600002c7c6b0</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000008</span><br><span class="hljs-number">0x600002c7c6c0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600002c7c6d0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>swift</code>中可变数组，采用的方式，和<code>OC</code>中<code>NSMutableArray</code>环形缓冲区结构实现的方式不同，是比较朴素的方式，不确定是不是<code>内存的进步，导致苹果放弃了环形缓冲结构</code>.</p>
</li>
</ul>
<h1 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h1><blockquote>
<p>NSMutableArray采用的是环形缓冲区的结构，</p>
</blockquote>
<ul>
<li>通过<code>class-dump</code>查看<code>_NSArrayM</code>中的重要的成员变量有<ul>
<li><code>_used</code>: 计数</li>
<li><code>_list</code>: 缓冲区指针</li>
<li><code>_size</code>: 缓冲区大小</li>
<li><code>_offset</code>: 缓冲区中的数组第一个元素索引</li>
</ul>
</li>
<li>后面通过内存情况来排查下</li>
</ul>
<h2 id="获取容量和存放地址"><a href="#获取容量和存放地址" class="headerlink" title="获取容量和存放地址"></a>获取容量和存放地址</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Printing description of mutArr:<br>&lt;__NSArrayM <span class="hljs-number">0x600000c894a0</span>&gt;(<br><span class="hljs-number">11</span>,<br><span class="hljs-number">55</span>,<br><span class="hljs-number">22</span>,<br><span class="hljs-number">33</span>,<br><span class="hljs-number">44</span><br>)<br><br>x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x600000c894a0</span><br><span class="hljs-number">0x600000c894a0</span>: <span class="hljs-number">0x00007ff8653dd898</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x600000c894b0</span>: <span class="hljs-number">0x00006000021154f0</span> <span class="hljs-number">0x0000000a00000009</span><br></code></pre></td></tr></table></figure>
<ul>
<li>多次尝试发现<code>0x00006000021154f0</code>内存上存放了数组中的大小，<code>0x0000000a</code>显然是容量。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSMutableArray</span>(<span class="hljs-title">address</span>)</span><br>- (<span class="hljs-keyword">void</span> *)elementsAddress &#123;<br>    <span class="hljs-keyword">void</span> *address = (__bridge  <span class="hljs-keyword">void</span> *)<span class="hljs-keyword">self</span>;<br>    <span class="hljs-keyword">return</span> *((<span class="hljs-keyword">void</span> **)address + <span class="hljs-number">2</span>);<br>&#125;<br><br>- (<span class="hljs-keyword">int</span>)capacity &#123;<br>    <span class="hljs-keyword">void</span> *address = (__bridge  <span class="hljs-keyword">void</span> *)<span class="hljs-keyword">self</span>;<br>    <span class="hljs-keyword">return</span> *((<span class="hljs-keyword">int</span> *)address + <span class="hljs-number">7</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h2 id="数据添加"><a href="#数据添加" class="headerlink" title="数据添加"></a>数据添加</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *str1 = <span class="hljs-string">@&quot;11&quot;</span>;<br><span class="hljs-built_in">NSString</span> *str2 = <span class="hljs-string">@&quot;22&quot;</span>;<br><span class="hljs-built_in">NSString</span> *str3 = <span class="hljs-string">@&quot;33&quot;</span>;<br><span class="hljs-built_in">NSString</span> *str4 = <span class="hljs-string">@&quot;44&quot;</span>;<br><span class="hljs-built_in">NSString</span> *str5 = <span class="hljs-string">@&quot;55&quot;</span>;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str1 字符串常量地址 %p&quot;</span>,str1);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str2 字符串常量地址 %p&quot;</span>,str2);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str3 字符串常量地址 %p&quot;</span>,str3);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str4 字符串常量地址 %p&quot;</span>,str4);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str5 字符串常量地址 %p&quot;</span>,str5);<br><br><span class="hljs-built_in">NSMutableArray</span> *mutArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithCapacity:<span class="hljs-number">10</span>];<br>[mutArr addObject:str1];<br>[mutArr addObject:str2];<br>[mutArr addObject:str3];<br>[mutArr addObject:str4];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mutArr.count ; i ++) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;数组 %@ %d,%lx&quot;</span>,mutArr[i],[mutArr capacity],[mutArr elementsAddress]);<br>&#125;<br>[mutArr insertObject:str5 atIndex:<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mutArr.count ; i ++) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;数组 %@ %d,%lx&quot;</span>,mutArr[i],[mutArr capacity],[mutArr elementsAddress]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="打印以及llDB分析"><a href="#打印以及llDB分析" class="headerlink" title="打印以及llDB分析"></a>打印以及llDB分析</h3><ul>
<li>打印输出<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">str1 字符串常量地址 <span class="hljs-number">0x104670f60</span><br>str2 字符串常量地址 <span class="hljs-number">0x104670f80</span><br>str3 字符串常量地址 <span class="hljs-number">0x104670fa0</span><br>str4 字符串常量地址 <span class="hljs-number">0x104670fc0</span><br>str5 字符串常量地址 <span class="hljs-number">0x104670fe0</span><br>数组 <span class="hljs-number">11</span> <span class="hljs-number">10</span>,<span class="hljs-number">6000021154f</span>0<br>数组 <span class="hljs-number">22</span> <span class="hljs-number">10</span>,<span class="hljs-number">6000021154f</span>0<br>数组 <span class="hljs-number">33</span> <span class="hljs-number">10</span>,<span class="hljs-number">6000021154f</span>0<br>数组 <span class="hljs-number">44</span> <span class="hljs-number">10</span>,<span class="hljs-number">6000021154f</span>0<br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>分析,显然在插入<code>str5</code>后，数组内存地址未变，原来的<code>str1</code>跑到了数组末尾<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 未添加前</span><br>x/<span class="hljs-number">8</span>xg <span class="hljs-number">6000021154f</span>0<br><span class="hljs-number">0x6000021154f0</span>: <span class="hljs-number">0x0000000104670f60</span> <span class="hljs-number">0x0000000104670f80</span><br><span class="hljs-number">0x600002115500</span>: <span class="hljs-number">0x0000000104670fa0</span> <span class="hljs-number">0x0000000104670fc0</span><br><span class="hljs-number">0x600002115510</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x600002115520</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><br><span class="hljs-comment">// 插入后,str1，移动到了内存的最后，处，其他未变</span><br>x/<span class="hljs-number">20</span>xg <span class="hljs-number">0x00006000021154f0</span><br><span class="hljs-number">0x6000021154f0</span>: <span class="hljs-number">0x0000000104670fe0</span> <span class="hljs-number">0x0000000104670f80</span><br><span class="hljs-number">0x600002115500</span>: <span class="hljs-number">0x0000000104670fa0</span> <span class="hljs-number">0x0000000104670fc0</span><br><span class="hljs-number">0x600002115510</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x600002115520</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x600002115530</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000104670f60</span> <span class="hljs-comment">// str1</span><br><span class="hljs-number">0x600002115540</span>: <span class="hljs-number">0x00007ff865a1f1a0</span> <span class="hljs-number">0x0000000000000003</span><br>...<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据扩容"><a href="#数据扩容" class="headerlink" title="数据扩容"></a>数据扩容</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSMutableArray</span> *mutArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br><span class="hljs-built_in">NSMutableArray</span> *capacityArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObject:@<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span> ; i ++) &#123;<br>        [mutArr addObject:str1];<br>        <span class="hljs-keyword">if</span> (![capacityArr.lastObject  isEqual: @([mutArr capacity])]) &#123;<br>            [capacityArr addObject:@([mutArr capacity])];<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld号数据 容量：%d，存储地址0x%lx&quot;</span>,i,[mutArr capacity],[mutArr elementsAddress]);<br>        &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="打印以及llDB分析-1"><a href="#打印以及llDB分析-1" class="headerlink" title="打印以及llDB分析"></a>打印以及llDB分析</h3><ul>
<li>打印输出<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0</span>号数据 容量：<span class="hljs-number">2</span>，存储地址<span class="hljs-number">0x600000008140</span><br><span class="hljs-number">2</span>号数据 容量：<span class="hljs-number">4</span>，存储地址<span class="hljs-number">0x600000276500</span><br><span class="hljs-number">4</span>号数据 容量：<span class="hljs-number">6</span>，存储地址<span class="hljs-number">0x600000c8d3e0</span><br><span class="hljs-number">6</span>号数据 容量：<span class="hljs-number">10</span>，存储地址<span class="hljs-number">0x600002140000</span><br><span class="hljs-number">10</span>号数据 容量：<span class="hljs-number">16</span>，存储地址<span class="hljs-number">0x600002c29080</span><br><span class="hljs-number">16</span>号数据 容量：<span class="hljs-number">26</span>，存储地址<span class="hljs-number">0x600003911e10</span><br><span class="hljs-number">26</span>号数据 容量：<span class="hljs-number">42</span>，存储地址<span class="hljs-number">0x104930cd0</span><br><span class="hljs-number">42</span>号数据 容量：<span class="hljs-number">68</span>，存储地址<span class="hljs-number">0x1048173c0</span><br><span class="hljs-number">68</span>号数据 容量：<span class="hljs-number">110</span>，存储地址<span class="hljs-number">0x1048175e0</span><br><span class="hljs-number">110</span>号数据 容量：<span class="hljs-number">192</span>，存储地址<span class="hljs-number">0x10503a800</span><br><span class="hljs-number">192</span>号数据 容量：<span class="hljs-number">320</span>，存储地址<span class="hljs-number">0x10d00a600</span><br><span class="hljs-number">320</span>号数据 容量：<span class="hljs-number">576</span>，存储地址<span class="hljs-number">0x10580f000</span><br><span class="hljs-number">576</span>号数据 容量：<span class="hljs-number">960</span>，存储地址<span class="hljs-number">0x109013200</span><br><span class="hljs-number">960</span>号数据 容量：<span class="hljs-number">1600</span>，存储地址<span class="hljs-number">0x10a8d0800</span><br><span class="hljs-number">1600</span>号数据 容量：<span class="hljs-number">2624</span>，存储地址<span class="hljs-number">0x10a8d8800</span><br></code></pre></td></tr></table></figure></li>
<li>分析，根据其容量可知，并非简单的<code>2</code>倍扩容,大概可以归纳如下：<ul>
<li>小于等于<code>128</code>时，<code>f(0) = 2</code>,<code>f(1) = 4</code>,<code>f(x) = f(x-1) + f(x-2)</code>，的方式</li>
<li>当大于<code>128</code>之后，<code>192 = 128 + 64 * 1</code>、<code>320 = 192 + 2 * 64</code>、<code>576 = 320 + 4 * 64</code>、<code>960 = 576 + 6 * 64</code>、<code>1600 = 960 + 10 * 64</code>、<code>2624 = 1600 * 16 * 64</code>,….。很显然，回到最开始的值与<code>64</code>的乘法之差</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2023/03/12/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个字符串变量占用多少内存"><a href="#一个字符串变量占用多少内存" class="headerlink" title="一个字符串变量占用多少内存"></a>一个字符串变量占用多少内存</h1><blockquote>
<p>显然一个字符串占有<code>16</code>个字节</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789&quot;</span><br><span class="hljs-keyword">var</span> str2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789ABCDEFGHIGK&quot;</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">String</span>&gt;.stride. <span class="hljs-comment">//16</span><br><span class="hljs-type">MemoryLayout</span>.stride(ofValue: str1) <span class="hljs-comment">//16</span><br><span class="hljs-type">MemoryLayout</span>.stride(ofValue: str2) <span class="hljs-comment">//16</span><br></code></pre></td></tr></table></figure>

<h1 id="字符串的底层存储"><a href="#字符串的底层存储" class="headerlink" title="字符串的底层存储"></a>字符串的底层存储</h1><h2 id="小于长度0xF的字符串"><a href="#小于长度0xF的字符串" class="headerlink" title="小于长度0xF的字符串"></a>小于长度<code>0xF</code>的字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>汇编查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100003de8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:   leaq   <span class="hljs-number">0x185</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi         ; <span class="hljs-string">&quot;0123456789&quot;</span><br><span class="hljs-number">0x100003def</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>xa, <span class="hljs-operator">%</span>esi<br><span class="hljs-number">0x100003df4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">20</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edx<br><span class="hljs-number">0x10000dfd9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000e1c2</span>               ; symbol stub <span class="hljs-keyword">for</span>: <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(_builtinStringLiteral: <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, utf8CodeUnitCount: <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, isASCII: <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span><br><span class="hljs-number">0x10000dfde</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">30</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0x71fb</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.str1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span><br><span class="hljs-number">0x10000dfe5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">37</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rdx, <span class="hljs-number">0x71fc</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.str1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li>
<li>分析，这里将<code>rax</code>和<code>rdx</code>的分别赋值给了<code>str1</code>(地址是<code>0x1000151E0</code>)的前<code>8</code>个字节和后<code>8</code>个字节，<code>register read rax</code>查看<ul>
<li><code>x 0x1000151E0</code> -&gt; <code>30 31 32 33 34 35 36 37 38 39 00 00 00 00 00 ea</code>,查看<code>str1</code>地址内存,小端模式（低低高高）</li>
<li><code>rax = 0x3736353433323130</code>，<code>rdx = 0xea00000000003938</code>,根据<a href="https://www.ascii-code.com/">ASCII码表</a>可知<code>30-39</code>是<code>0-9</code>。<strong>显然</strong>,字符串直接存储在<code>str1</code>地址的内存上</li>
<li><code>0xea</code>,存储的实际是字符串的<code>tag</code>和长度，其中<code>e</code>是<code>tag</code>,而<code>a</code>是<code>10</code>即字符串的长度<ul>
<li><code>&quot;0123456789ABCDE&quot;</code>的内存<code>30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 ef</code>,显然最后的长度变成了<code>f</code>即<code>15</code>,<code>e</code>是<code>tag</code></li>
<li><code>&quot;0123456789ABCDEF&quot;</code>上<code>10 00 00 00 00 00 00 d0 f0 f5 00 00 01 00 00 80</code>,<code>0xd000000000000010</code> + <code>0x800000010000f5f0</code>,显然和前面的不同。其存储的方式发生了改变</li>
</ul>
</li>
<li><strong>总结</strong>，如果字符串长度小于<code>0xF</code>，其字符串直接存储在地址的内存上，其第<code>16</code>个字节上，存储者字符串的<code>tag</code>和<code>长度</code>。而字符串长度大于<code>0xF</code>，其存储方式发生了改变</li>
</ul>
</li>
</ul>
<h2 id="大于长度0xF的字符串"><a href="#大于长度0xF的字符串" class="headerlink" title="大于长度0xF的字符串"></a>大于长度<code>0xF</code>的字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>根据其内存，其内存地址是 <code>0xd000000000000010</code> + <code>0x8000000100003f50</code></li>
<li>汇编查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-number">0x10000dfb8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:   leaq   <span class="hljs-number">0x1651</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span><br>    <span class="hljs-number">0x10000dfbf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x10, <span class="hljs-operator">%</span>esi<br>    <span class="hljs-number">0x10000dfc4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">20</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edx<br>-&gt;  <span class="hljs-number">0x10000dfc9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000e1b2</span>               ; symbol stub <span class="hljs-keyword">for</span>: <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(_builtinStringLiteral: <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, utf8CodeUnitCount: <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, isASCII: <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span><br>    <span class="hljs-number">0x10000dfce</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">30</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0x720b</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.str1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span><br>    <span class="hljs-number">0x10000dfd5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">37</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rdx, <span class="hljs-number">0x720c</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.str1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br>    <br><span class="hljs-operator">-------</span><br>libswiftCore.dylib`<span class="hljs-type">Swift</span>.<span class="hljs-type">String</span>.<span class="hljs-keyword">init</span><br>    <span class="hljs-number">0x7ff819e87ae0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">32</span><span class="hljs-operator">&gt;</span>:  cmpq   <span class="hljs-variable">$0</span>xf, <span class="hljs-operator">%</span>rsi<br>    <span class="hljs-number">0x7ff819e87ae4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">36</span><span class="hljs-operator">&gt;</span>:  jle    <span class="hljs-number">0x7ff819e87b26</span>            ; <span class="hljs-operator">&lt;+</span><span class="hljs-number">102</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-number">0x7ff819e87ae6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">38</span><span class="hljs-operator">&gt;</span>:  movabsq $<span class="hljs-operator">-</span><span class="hljs-number">0x4000000000000000</span>, <span class="hljs-operator">%</span>rcx ; imm <span class="hljs-operator">=</span> <span class="hljs-number">0xC000000000000000</span> <br>    <span class="hljs-number">0x7ff819e87af0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">48</span><span class="hljs-operator">&gt;</span>:  orq    <span class="hljs-operator">%</span>rsi, <span class="hljs-operator">%</span>rcx<br>    <span class="hljs-number">0x7ff819e87af3</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">51</span><span class="hljs-operator">&gt;</span>:  testb  <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>al<br>    <span class="hljs-number">0x7ff819e87af5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">53</span><span class="hljs-operator">&gt;</span>:  cmoveq <span class="hljs-operator">%</span>rsi, <span class="hljs-operator">%</span>rcx<br>    <span class="hljs-number">0x7ff819e87af9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">57</span><span class="hljs-operator">&gt;</span>:  movabsq <span class="hljs-variable">$0</span>x1000000000000000, <span class="hljs-operator">%</span>rax ; imm <span class="hljs-operator">=</span> <span class="hljs-number">0x1000000000000000</span> <br>    <span class="hljs-number">0x7ff819e87b03</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">67</span><span class="hljs-operator">&gt;</span>:  orq    <span class="hljs-operator">%</span>rcx, <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x7ff819e87b06</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">70</span><span class="hljs-operator">&gt;</span>:  movabsq <span class="hljs-variable">$0</span>x7fffffffffffffe0, <span class="hljs-operator">%</span>rdx ; imm <span class="hljs-operator">=</span> <span class="hljs-number">0x7FFFFFFFFFFFFFE0</span> <br>    <span class="hljs-number">0x7ff819e87b10</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">80</span><span class="hljs-operator">&gt;</span>:  addq   <span class="hljs-operator">%</span>rdx, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x7ff819e87b13</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">83</span><span class="hljs-operator">&gt;</span>:  addq   <span class="hljs-variable">$0</span>x20, <span class="hljs-operator">%</span>rdx<br>-&gt;  <span class="hljs-number">0x7ff819e87b17</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">87</span><span class="hljs-operator">&gt;</span>:  orq    <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">%</span>rdx<br></code></pre></td></tr></table></figure></li>
<li>分析,这里字符串<code>&quot;0123456789ABCDEF&quot;</code>的地址赋值给了<code>rdi = 0x0000000100003f70  &quot;0123456789ABCDEF&quot;</code>,将字符串的长度<code>0x10</code>传给了<code>esi</code>（即<code>rsi</code>）</li>
<li>在<code>Swift.String.init</code>方法中会<code>cmpq   $0xf, %rsi</code>会对字符串的长度，进行判断然后处理，这里<code>addq   %rdx, %rdi</code>,这里将<code>rdx</code>和<code>rdi</code>中的值相加，然后赋值给<code>rdi</code>(最终复制给了<code>rdx</code>),这里<code>rdi</code>是<code>0x7fffffffffffffe0</code> + <code>0x0000000100003f70</code> = <code>0x8000000100003f50</code>,即字符串<code>后8字节</code>存储的内容,显然字符串后8字节减去<code>0x7fffffffffffffe0</code>存储着字符串的内存地址。</li>
<li>其<code>前8字节</code>存储的实际是字符串的<code>tag</code>和<code>长度</code><ul>
<li><code>&quot;0123456789ABCDEFGH&quot;</code>的内存地址<code>0xd000000000000012</code> + <code>0x8000000100003f50</code></li>
<li>显然，其高位<code>d</code>代表大于<code>oxF</code>的字符串存储方法，低位开始代表字符串的长度</li>
</ul>
</li>
<li>大于<code>oxF</code>的字符串存储的字符串真实地址位置实际在<code>__TEXT.cstring</code>常量区,<code>&quot;0123456789ABCDEF&quot;</code>的真实内存地址是<code>0x0000000100003f70</code><ul>
<li><code>swiftc -o main.o main.swift</code>,编译成<code>.o</code>文件，用<code>machOview</code>查看</li>
<li>显然<code>3f70</code>是在<code>__TEXT.cstring</code>常量区，且小于<code>oxF</code>存在内存上的字符串，在常量区，仍有备份<br><img src="1.png"></li>
</ul>
</li>
</ul>
<h2 id="字符串拼接后的内存放在那里"><a href="#字符串拼接后的内存放在那里" class="headerlink" title="字符串拼接后的内存放在那里"></a>字符串拼接后的内存放在那里</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789ABCD&quot;</span><br>str1.append(<span class="hljs-string">&quot;E&quot;</span>)<br>str1.append(<span class="hljs-string">&quot;G&quot;</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>添加长度小于<code>0xF</code>，直接查看内存<code>str1</code>的地址是<code>0x1000151E0</code>,<ul>
<li><code>x 0x1000151E0</code> -&gt; <code>30 31 32 33 34 35 36 37 38 39 41 42 43 44 00 ee</code></li>
<li><code>str1.append(&quot;E&quot;)</code>后<code>x 0x1000151E0</code> -&gt; <code>30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 ef</code></li>
<li>显然，当添加后长度低于<code>0xF</code>后，其内存仍然存储在地址内存上</li>
</ul>
</li>
<li>当添加后大于<code>0xF</code>，<code>str1.append(&quot;G&quot;)</code> -&gt; <code>0xf000000000000010 0x000060000170c000</code>，此时<code>tag</code>和此前不同为<code>f</code>,其长度为<code>16</code>,查看其存储地址<code>0x000060000170c000</code>,显然其地址+<code>0x20</code>之后开始存储字符串的真实内容。实际上字符串拼接长度大于<code>oxF</code>后，会存储在堆中，其内存存储在地址后<code>0x20</code>（前<code>16</code>个字节，类似对象，<code>metaDat</code>和引用计数）后 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">x<span class="hljs-operator">/</span>50xb <span class="hljs-number">0x000060000170c000</span><br> <span class="hljs-number">0x60000170c000</span>: <span class="hljs-number">0xa8</span> <span class="hljs-number">0xe9</span> <span class="hljs-number">0x3f</span> <span class="hljs-number">0x4f</span> <span class="hljs-number">0xf8</span> <span class="hljs-number">0x7f</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span><br> <span class="hljs-number">0x60000170c008</span>: <span class="hljs-number">0x03</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span><br> <span class="hljs-number">0x60000170c010</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span><br> <span class="hljs-number">0x60000170c018</span>: <span class="hljs-number">0x10</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0xf0</span><br> <span class="hljs-number">0x60000170c020</span>: <span class="hljs-number">0x30</span> <span class="hljs-number">0x31</span> <span class="hljs-number">0x32</span> <span class="hljs-number">0x33</span> <span class="hljs-number">0x34</span> <span class="hljs-number">0x35</span> <span class="hljs-number">0x36</span> <span class="hljs-number">0x37</span><br> <span class="hljs-number">0x60000170c028</span>: <span class="hljs-number">0x38</span> <span class="hljs-number">0x39</span> <span class="hljs-number">0x41</span> <span class="hljs-number">0x42</span> <span class="hljs-number">0x43</span> <span class="hljs-number">0x44</span> <span class="hljs-number">0x45</span> <span class="hljs-number">0x47</span><br> <span class="hljs-number">0x60000170c030</span>: <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span><br></code></pre></td></tr></table></figure>
<ul>
<li>判断为何在堆中，断点查看<code>malloc</code>方法，查看<code>append</code>是否有分配堆空间，显然拦截成功，分配了堆空间<ul>
<li>查看<code>malloc</code>生成的堆空间地址<code>rax = 0x000060000170c000</code>,即最后字符串的后<code>8</code>字节地址<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">  bt<br>  <span class="hljs-operator">*</span> thread #<span class="hljs-number">1</span>, queue <span class="hljs-operator">=</span> &#x27;com.apple.main<span class="hljs-operator">-</span>thread&#x27;, stop reason <span class="hljs-operator">=</span> breakpoint <span class="hljs-number">2.1</span><br><span class="hljs-operator">*</span> frame #<span class="hljs-number">0</span>: <span class="hljs-number">0x00007ff80b89ec19</span> libsystem_malloc.dylib`_malloc_zone_malloc <span class="hljs-operator">+</span> <span class="hljs-number">10</span><br>  frame #<span class="hljs-number">1</span>: <span class="hljs-number">0x00007ff81a1a2b96</span> libswiftCore.dylib`std::__1::pair<span class="hljs-operator">&lt;</span>(anonymous namespace)::<span class="hljs-type">TupleCacheEntry</span><span class="hljs-operator">*</span>, swift::<span class="hljs-type">MetadataResponse</span><span class="hljs-operator">&gt;</span> swift::<span class="hljs-type">LockingConcurrentMap</span>&lt;(anonymous namespace)::<span class="hljs-type">TupleCacheEntry</span>, (anonymous namespace)::<span class="hljs-type">TupleCacheStorage</span>&gt;::getOrInsert<span class="hljs-operator">&lt;</span>(anonymous namespace)::<span class="hljs-type">TupleCacheEntry</span>::<span class="hljs-type">Key</span>, swift::<span class="hljs-type">MetadataRequest</span><span class="hljs-operator">&amp;</span>, swift::<span class="hljs-type">TargetValueWitnessTable</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*&amp;&gt;</span>((anonymous namespace)::TupleCacheEntry::<span class="hljs-type">Key</span>, swift::<span class="hljs-type">MetadataRequest</span><span class="hljs-operator">&amp;</span>, swift::<span class="hljs-type">TargetValueWitnessTable</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*&amp;</span>) <span class="hljs-operator">+</span> <span class="hljs-number">4038</span><br>  frame #<span class="hljs-number">2</span>: <span class="hljs-number">0x00007ff81a1a19b4</span> libswiftCore.dylib`swift_getTupleTypeMetadata <span class="hljs-operator">+</span> <span class="hljs-number">116</span><br>  frame #<span class="hljs-number">3</span>: <span class="hljs-number">0x00007ff81a1c41ce</span> libswiftCore.dylib`swift::<span class="hljs-type">Demangle</span>::__runtime::<span class="hljs-type">TypeDecoder</span>&lt;(anonymous namespace)::<span class="hljs-type">DecodedMetadataBuilder</span>&gt;::decodeMangledType(swift::Demangle::__runtime::<span class="hljs-type">Node</span><span class="hljs-operator">*</span>, unsigned int, bool) <span class="hljs-operator">+</span> <span class="hljs-number">9342</span><br>  frame #<span class="hljs-number">4</span>: <span class="hljs-number">0x00007ff81a1c149d</span> libswiftCore.dylib`swift_getTypeByMangledNodeImpl(swift::<span class="hljs-type">MetadataRequest</span>, swift::Demangle::__runtime::<span class="hljs-type">Demangler</span><span class="hljs-operator">&amp;</span>, swift::Demangle::__runtime::<span class="hljs-type">Node</span><span class="hljs-operator">*</span>, void const<span class="hljs-operator">*</span> const<span class="hljs-operator">*</span>, std::__1::function<span class="hljs-operator">&lt;</span>swift::<span class="hljs-type">TargetMetadata</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span> (unsigned int, unsigned int)<span class="hljs-operator">&gt;</span>, std::__1::function<span class="hljs-operator">&lt;</span>swift::<span class="hljs-type">TargetWitnessTable</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span> (swift::<span class="hljs-type">TargetMetadata</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span>, unsigned int)<span class="hljs-operator">&gt;</span>) <span class="hljs-operator">+</span> <span class="hljs-number">493</span><br>  frame #<span class="hljs-number">5</span>: <span class="hljs-number">0x00007ff81a1c126d</span> libswiftCore.dylib`swift_getTypeByMangledNode <span class="hljs-operator">+</span> <span class="hljs-number">477</span><br>  frame #<span class="hljs-number">6</span>: <span class="hljs-number">0x00007ff81a1c1980</span> libswiftCore.dylib`swift_getTypeByMangledNameImpl(swift::<span class="hljs-type">MetadataRequest</span>, __swift::__runtime::llvm::<span class="hljs-type">StringRef</span>, void const<span class="hljs-operator">*</span> const<span class="hljs-operator">*</span>, std::__1::function<span class="hljs-operator">&lt;</span>swift::<span class="hljs-type">TargetMetadata</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span> (unsigned int, unsigned int)<span class="hljs-operator">&gt;</span>, std::__1::function<span class="hljs-operator">&lt;</span>swift::<span class="hljs-type">TargetWitnessTable</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span> (swift::<span class="hljs-type">TargetMetadata</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span>, unsigned int)<span class="hljs-operator">&gt;</span>) <span class="hljs-operator">+</span> <span class="hljs-number">992</span><br>  frame #<span class="hljs-number">7</span>: <span class="hljs-number">0x00007ff81a1bdc4d</span> libswiftCore.dylib`swift_getTypeByMangledName <span class="hljs-operator">+</span> <span class="hljs-number">477</span><br>  frame #<span class="hljs-number">8</span>: <span class="hljs-number">0x00007ff81a1bde7e</span> libswiftCore.dylib`swift_getTypeByMangledNameInContext <span class="hljs-operator">+</span> <span class="hljs-number">174</span><br>  frame #<span class="hljs-number">9</span>: <span class="hljs-number">0x00007ff81a133c47</span> libswiftCore.dylib`__swift_instantiateConcreteTypeFromMangledName <span class="hljs-operator">+</span> <span class="hljs-number">39</span><br>  frame #<span class="hljs-number">10</span>: <span class="hljs-number">0x00007ff81a01f961</span> libswiftCore.dylib`<span class="hljs-type">Swift</span>._StringGuts.prepareForAppendInPlace(totalCount: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>, otherUTF8Count: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () <span class="hljs-operator">+</span> <span class="hljs-number">385</span><br>  frame #<span class="hljs-number">11</span>: <span class="hljs-number">0x00007ff81a01fc16</span> libswiftCore.dylib`<span class="hljs-type">Swift</span>._StringGuts.append(<span class="hljs-type">Swift</span>._StringGutsSlice) -&gt; () <span class="hljs-operator">+</span> <span class="hljs-number">390</span><br>  frame #<span class="hljs-number">12</span>: <span class="hljs-number">0x000000010000e041</span> <span class="hljs-type">SwiftDText</span>`main at main.swift:<span class="hljs-number">69</span>:<span class="hljs-number">6</span><br>  frame #<span class="hljs-number">13</span>: <span class="hljs-number">0x00007ff80b6fd310</span> dyld`start <span class="hljs-operator">+</span> <span class="hljs-number">2432</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong>，一开始大于<code>oxF</code>的字符串(此前存在<code>常量区</code>)拼接后一样的存储在<code>堆</code>中，因为<code>常量区</code>是无法更改的</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="空字符串的存储"><a href="#空字符串的存储" class="headerlink" title="空字符串的存储"></a><span id="jump">空字符串的存储</span></h2><blockquote>
<p>先分析下，空字符串在内存中是如何保存的</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> empty <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>empty) &#123; <span class="hljs-variable">$0</span>&#125;<br><span class="hljs-built_in">print</span>(ptr) <span class="hljs-comment">// 0x00007ff7bfefead0</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>lldb</code>查看,其前<code>16</code>个字节存储的大小是<code>0x0000000000000000</code> + <code>0xe000000000000000</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">lldb) x<span class="hljs-operator">/</span>4xg <span class="hljs-number">0x00007ff7bfefead0</span><br><span class="hljs-number">0x7ff7bfefead0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0xe000000000000000</span><br><span class="hljs-number">0x7ff7bfefeae0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000100015330</span><br></code></pre></td></tr></table></figure></li>
<li><p>这里并不能看出<code>string</code>的内存结构，下面根据源码进行具体分析</p>
</li>
</ul>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="String-Swift"><a href="#String-Swift" class="headerlink" title="String.Swift"></a><code>String.Swift</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">@frozen<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">String</span> &#123;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-comment">// @SPI(Foundation)</span><br>  var _guts: _StringGuts<br><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-function">internal <span class="hljs-title">init</span><span class="hljs-params">(_ _guts: _StringGuts)</span> </span>&#123;<br>    self._guts = _guts<br>    _invariantCheck()<br>  &#125;<br><br>  <span class="hljs-comment">// This is intentionally a static function and not an initializer, because</span><br>  <span class="hljs-comment">// an initializer would conflict with the Int-parsing initializer, when used</span><br>  <span class="hljs-comment">// as function name, e.g.</span><br>  <span class="hljs-comment">//   [1, 2, 3].map(String.init)</span><br>  @_alwaysEmitIntoClient<br>  @_semantics(<span class="hljs-string">&quot;string.init_empty_with_capacity&quot;</span>)<br>  @_semantics(<span class="hljs-string">&quot;inline_late&quot;</span>)<br>  @inlinable<br>  internal <span class="hljs-keyword">static</span> func _createEmpty(withInitialCapacity: Int) -&gt; String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(_StringGuts(_initialCapacity: withInitialCapacity))<br>  &#125;<br><br>  <span class="hljs-comment">/// Creates an empty string.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// Using this initializer is equivalent to initializing a string with an</span><br>  <span class="hljs-comment">/// empty string literal.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">///     let empty = &quot;&quot;</span><br>  <span class="hljs-comment">///     let alsoEmpty = String()</span><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  @_semantics(<span class="hljs-string">&quot;string.init_empty&quot;</span>)<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">init</span>() &#123; self.<span class="hljs-built_in">init</span>(_StringGuts()) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>最直观地可以看到<code>String</code>是一个结构体，就是我们所说的值类型；它有一个成员变量<code>_StringGuts</code>,其中最后有一个创建空字符串初始化方式<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(_StringGuts())<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="StringGuts"><a href="#StringGuts" class="headerlink" title="_StringGuts"></a><code>_StringGuts</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">/<br><span class="hljs-comment">// StringGuts is a parameterization over String&#x27;s representations. It provides</span><br><span class="hljs-comment">// functionality and guidance for efficiently working with Strings.</span><br><span class="hljs-comment">//</span><br>@frozen<br><span class="hljs-keyword">public</span> <span class="hljs-comment">// SPI(corelibs-foundation)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">StringGuts</span>:</span> @unchecked Sendable &#123;<br>  @usableFromInline<br>  internal var _object: _StringObject<br><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-function">internal <span class="hljs-title">init</span><span class="hljs-params">(_ object: _StringObject)</span> </span>&#123;<br>    self._object = object<br>    _invariantCheck()<br>  &#125;<br><br>  <span class="hljs-comment">// Empty string</span><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-built_in">init</span>() &#123;<br>    self.<span class="hljs-built_in">init</span>(_StringObject(empty: ()))<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Raw</span><br>extension _StringGuts &#123;<br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  internal var rawBits: _StringObject.RawBitPattern &#123;<br>    <span class="hljs-keyword">return</span> _object.rawBits<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>_StringGuts</code>也是一个结构体，它有一个成员变量是<code>_StringObject</code>类型的实例;并且在最后是通过初始化出一个<code>_StringObject</code>类型的实例来初始化<code>_StringGuts</code>的。因此真正<code>swift</code>的实质就是<code>_StringObject</code></li>
</ul>
<h3 id="StringObject"><a href="#StringObject" class="headerlink" title="_StringObject"></a><code>_StringObject</code></h3><ul>
<li><p>创建空字符串的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">@inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-function">internal <span class="hljs-title">init</span><span class="hljs-params">(empty:())</span> </span>&#123;<br>    <span class="hljs-comment">// Canonical empty pattern: small zero-length string</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> arch(i386) || arch(arm) || arch(arm64_32) || arch(wasm32)</span><br>    self.<span class="hljs-built_in">init</span>(<br>      count: <span class="hljs-number">0</span>,<br>      variant: .<span class="hljs-built_in">immortal</span>(<span class="hljs-number">0</span>),<br>      discriminator: Nibbles.emptyString,<br>      flags: <span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    self._countAndFlagsBits = <span class="hljs-number">0</span><br>    self._object = Builtin.<span class="hljs-built_in">valueToBridgeObject</span>(Nibbles.emptyString._value)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    _internalInvariant(self.smallCount == <span class="hljs-number">0</span>)<br>    _invariantCheck()<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>初始化方法,其内有成员变量<code>_count</code>,<code>_variant</code>,<code>_discriminator</code>,<code>_flags</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">@usableFromInline<br>  internal var _count: Int <span class="hljs-comment">// 字符串大小</span><br><br>  @usableFromInline<br>  internal var _variant: Variant <span class="hljs-comment">// 枚举值 默认0</span><br><br>  @usableFromInline<br>  internal var _discriminator: UInt8 <span class="hljs-comment">// 空字符串在初始化的时候传递了一个Nibbles.emptyString</span><br><br>  @usableFromInline<br>  internal var _flags: UInt16<br><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-built_in">init</span>(count: Int, variant: Variant, discriminator: UInt64, flags: UInt16) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> os(Android) &amp;&amp; arch(arm64)</span><br>    _internalInvariant(discriminator &amp; <span class="hljs-number">0x00FF</span>_0000_0000_0000 == discriminator,<br>      <span class="hljs-string">&quot;only the second byte can carry the discriminator and small count on Android AArch64&quot;</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    _internalInvariant(discriminator &amp; <span class="hljs-number">0xFF00</span>_0000_0000_0000 == discriminator,<br>      <span class="hljs-string">&quot;only the top byte can carry the discriminator and small count&quot;</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    self._count = count<br>    self._variant = variant<br>    self._discriminator = <span class="hljs-built_in">UInt8</span>(truncatingIfNeeded: discriminator &amp;&gt;&gt; <span class="hljs-number">56</span>)<br>    self._flags = flags<br>    self._invariantCheck()<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>Variant</code>是一个枚举值，默认是<code>immortal 0</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">internal <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Variant</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">immortal</span><span class="hljs-params">(UInt)</span> <span class="hljs-comment">// 原始字符串</span></span><br><span class="hljs-function">    <span class="hljs-keyword">case</span> <span class="hljs-title">native</span><span class="hljs-params">(AnyObject)</span> <span class="hljs-comment">// AnyObject</span></span><br><span class="hljs-function">    <span class="hljs-keyword">case</span> <span class="hljs-title">bridged</span><span class="hljs-params">(_CocoaString)</span> <span class="hljs-comment">// NSString</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    @inlinable @<span class="hljs-title">inline</span><span class="hljs-params">(__always)</span></span><br><span class="hljs-function">    internal <span class="hljs-keyword">static</span> func <span class="hljs-title">immortal</span><span class="hljs-params">(start: UnsafePointer&lt;UInt8&gt;)</span> -&gt; Variant </span>&#123;<br>      let biased = <span class="hljs-built_in">UInt</span>(bitPattern: start) &amp;- _StringObject.nativeBias<br>      <span class="hljs-keyword">return</span> .<span class="hljs-built_in">immortal</span>(biased)<br>    &#125;<br><br>    @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>    internal var isImmortal: Bool &#123;<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .immortal = self &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>internal var _discriminator: UInt8</code> 在初始化的时候传递了一个<code>Nibbles.emptyString</code>（<code>Nibbles</code>是一个枚举类型）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Encoding is optimized for common fast creation. The canonical empty string,</span><br><span class="hljs-comment"> ASCII small strings, as well as most literals, have all consecutive 1s in their</span><br><span class="hljs-comment"> high nibble mask, and thus can all be encoded as a logical immediate operand</span><br><span class="hljs-comment"> on arm64.</span><br><span class="hljs-comment">*/</span><br>extension _StringObject.Nibbles &#123;<br>  <span class="hljs-comment">// The canonical empty string is an empty small string</span><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  internal <span class="hljs-keyword">static</span> var emptyString: UInt64 &#123;<br>    <span class="hljs-keyword">return</span> _StringObject.Nibbles.<span class="hljs-built_in">small</span>(isASCII: <span class="hljs-literal">true</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Discriminator for small strings</span><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  internal <span class="hljs-keyword">static</span> func <span class="hljs-built_in">small</span>(isASCII: Bool) -&gt; UInt64 &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> os(Android) &amp;&amp; arch(arm64)</span><br>    <span class="hljs-keyword">return</span> isASCII ? <span class="hljs-number">0x00E0</span>_0000_0000_0000 : <span class="hljs-number">0x00A0</span>_0000_0000_0000<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">return</span> isASCII ? <span class="hljs-number">0xE000</span>_0000_0000_0000 : <span class="hljs-number">0xA000</span>_0000_0000_0000<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>0x00E0_0000_0000_0000</code>和<a href="#jump">空字符串的存储</a>中空字符串的内存一致</p>
</li>
</ul>
<h2 id="小于长度0xF的字符串-1"><a href="#小于长度0xF的字符串-1" class="headerlink" title="小于长度0xF的字符串"></a>小于长度<code>0xF</code>的字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789&quot;</span><br><span class="hljs-comment">//内存：0x3736353433323130  0xea00000000003938</span><br><span class="hljs-keyword">var</span> str2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中&quot;</span><br><span class="hljs-comment">//内存：0x0000000000adb8e4 0xa300000000000000</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>small strings</code>的<code>Discriminator</code>,<ul>
<li>中文字符不是<code>ASCII</code>编码，一个中文字符占据<code>3</code>个字节（<code>24</code>位),其<code>Discriminator</code>为<code>0xa000000000000000</code>,这里的长度<code>3</code>并非真实长度，而是其字节数。</li>
<li><code>&quot;0123456789&quot;</code>,是<code>ASCII</code>编码,并且一个字符占<code>1</code>哥字节，其<code>Discriminator</code>为<code>0xe000000000000000</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-comment">// Discriminator for small strings</span><br>  <span class="hljs-keyword">@inlinable</span> <span class="hljs-meta">@inline</span>(__always)<br>  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">small</span>(<span class="hljs-params">isASCII</span>: <span class="hljs-type">Bool</span>)</span> -&gt; <span class="hljs-type">UInt64</span> &#123;<br><span class="hljs-keyword">#if</span> os(<span class="hljs-type">Android</span>) <span class="hljs-operator">&amp;&amp;</span> arch(arm64)<br>    <span class="hljs-keyword">return</span> isASCII <span class="hljs-operator">?</span> <span class="hljs-number">0x00E0_0000_0000_0000</span> : <span class="hljs-number">0x00A0_0000_0000_0000</span><br><span class="hljs-keyword">#else</span><br>    <span class="hljs-keyword">return</span> isASCII <span class="hljs-operator">?</span> <span class="hljs-number">0xE000_0000_0000_0000</span> : <span class="hljs-number">0xA000_0000_0000_0000</span><br><span class="hljs-keyword">#endif</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="大于长度0xF的字符串-1"><a href="#大于长度0xF的字符串-1" class="headerlink" title="大于长度0xF的字符串"></a>大于长度<code>0xF</code>的字符串</h2><blockquote>
<p>对于大字符串(大于<code>15</code>个字符串)来说，原本的小字符串占据的<code>15</code>个字节已经不足以存储字符串了，那就会发生改变</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> `<span class="hljs-string">&quot;0123456789ABCDEFGH&quot;</span><br><span class="hljs-comment">//内存地址:0xd000000000000012.  0x8000000100003f70</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>largeImmortal</code>的<code>Discriminator</code></p>
<ul>
<li>这里<code> 0x0080_0000_0000_0000</code>，是<code>Discriminator</code>，剩下的<code>0x100003f70</code>实际上关联了实际存储的字符串<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Discriminator for large, immortal, swift-native strings</span><br>  <span class="hljs-keyword">@inlinable</span> <span class="hljs-meta">@inline</span>(__always)<br>  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largeImmortal</span>()</span> -&gt; <span class="hljs-type">UInt64</span> &#123;<br><span class="hljs-keyword">#if</span> os(<span class="hljs-type">Android</span>) <span class="hljs-operator">&amp;&amp;</span> arch(arm64)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x0080_0000_0000_0000</span><br><span class="hljs-keyword">#else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x8000_0000_0000_0000</span><br><span class="hljs-keyword">#endif</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>源码意思是实际的字符串需要加上偏移量<code>nativeBias</code>即<code>32</code>，<code>32</code>的<code>16</code>进制是<code>0x20</code>实际字符串存储的位置是<code>0x100003f70 + 20</code> = <code>0x100003f90</code>,</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Large</span> strings can either be <span class="hljs-string">&quot;native&quot;</span>, <span class="hljs-string">&quot;shared&quot;</span>, or <span class="hljs-string">&quot;foreign&quot;</span>.<br><br> <span class="hljs-type">Native</span> strings have tail<span class="hljs-operator">-</span>allocated storage, which begins at an offset of<br> `nativeBias` from the storage object&#x27;s address. <span class="hljs-type">String</span> literals, which reside<br> <span class="hljs-keyword">in</span> the constant section, are encoded <span class="hljs-keyword">as</span> their start address minus `nativeBias`,<br> unifying code paths <span class="hljs-keyword">for</span> both literals (<span class="hljs-string">&quot;immortal native&quot;</span>) and native strings.<br> <span class="hljs-type">Native</span> <span class="hljs-type">Strings</span> are always managed by the <span class="hljs-type">Swift</span> runtime.<br><br> <span class="hljs-type">Shared</span> strings <span class="hljs-keyword">do</span> not have tail<span class="hljs-operator">-</span>allocated storage, but can provide access<br> upon query to contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> code units. <span class="hljs-type">Lazily</span><span class="hljs-operator">-</span>bridged <span class="hljs-type">NSStrings</span> capable of<br> providing access to contiguous <span class="hljs-type">ASCII</span><span class="hljs-operator">/</span><span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> <span class="hljs-keyword">set</span> the <span class="hljs-type">ObjC</span> bit. <span class="hljs-type">Accessing</span> shared<br> string&#x27;s pointer should always be behind a resilience barrier, permitting<br> future evolution.<br><br> <span class="hljs-type">Foreign</span> strings cannot provide access to contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span>. <span class="hljs-type">Currently</span>, this only<br> encompasses lazily<span class="hljs-operator">-</span>bridged <span class="hljs-type">NSStrings</span> that cannot be treated <span class="hljs-keyword">as</span> <span class="hljs-string">&quot;shared&quot;</span>. <span class="hljs-type">Such</span><br> strings may provide access to contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">16</span>, or may be discontiguous <span class="hljs-keyword">in</span><br> storage. <span class="hljs-type">Accessing</span> foreign strings should remain behind a resilience barrier<br> <span class="hljs-keyword">for</span> future evolution. <span class="hljs-type">Other</span> foreign forms are reserved <span class="hljs-keyword">for</span> the future.<br><br> <span class="hljs-type">Shared</span> and foreign strings are always created and accessed behind a resilience<br> barrier, providing flexibility <span class="hljs-keyword">for</span> the future.<br><br> <span class="hljs-operator">┌────────────┐</span><br> <span class="hljs-operator">│</span> nativeBias <span class="hljs-operator">│</span><br> <span class="hljs-operator">├────────────┤</span><br> <span class="hljs-operator">│</span>     <span class="hljs-number">32</span>     <span class="hljs-operator">│</span><br> <span class="hljs-operator">└────────────┘</span><br><br> <span class="hljs-operator">┌───────────────┬────────────┐</span><br> <span class="hljs-operator">│</span>    b63:b60    <span class="hljs-operator">│</span>   b60:b0   <span class="hljs-operator">│</span><br> <span class="hljs-operator">├───────────────┼────────────┤</span><br> <span class="hljs-operator">│</span> discriminator <span class="hljs-operator">│</span> objectAddr <span class="hljs-operator">│</span><br> <span class="hljs-operator">└───────────────┴────────────┘</span><br><br> discriminator: <span class="hljs-type">See</span> comment <span class="hljs-keyword">for</span> _StringObject.<span class="hljs-type">Discriminator</span><br> objectAddr: <span class="hljs-type">The</span> address of the beginning of the potentially<span class="hljs-operator">-</span>managed object.<br><br> <span class="hljs-type">TODO</span>(<span class="hljs-type">Future</span>): <span class="hljs-type">For</span> <span class="hljs-type">Foreign</span> strings, consider allocating a bit <span class="hljs-keyword">for</span> whether they<br> can provide contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">16</span> code units, which would allow us to avoid doing<br> the full call <span class="hljs-keyword">for</span> non<span class="hljs-operator">-</span>contiguous <span class="hljs-type">NSString</span>.<br><br></code></pre></td></tr></table></figure></li>
<li><p>而大字符串前面的标识位<code>0xd000000000000012</code></p>
<ul>
<li><code>0-47</code>位是长度，这里是<code>0x12</code>即长度为18<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">All</span> non<span class="hljs-operator">-</span>small forms share the same structure <span class="hljs-keyword">for</span> the other half of the bits<br> (i.e. non<span class="hljs-operator">-</span>object bits) <span class="hljs-keyword">as</span> a word containing code unit count and various<br> performance flags. <span class="hljs-type">The</span> top <span class="hljs-number">16</span> bits are nonessential flags; these aren&#x27;t<br> critical <span class="hljs-keyword">for</span> correct operation, but they may provide additional guarantees that<br> allow more efficient operation or more reliable detection of runtime errors.<br> <span class="hljs-type">The</span> lower <span class="hljs-number">48</span> bits contain the code unit count (aka endIndex).<br><br><span class="hljs-operator">┌──────┬──────┬──────┬──────┬──────┬──────────┬───────────────────────────────┐</span><br><span class="hljs-operator">│</span> b63  <span class="hljs-operator">│</span> b62  <span class="hljs-operator">│</span> b61  <span class="hljs-operator">│</span> b60  <span class="hljs-operator">│</span> b59  <span class="hljs-operator">│</span>  b58:<span class="hljs-number">48</span>  <span class="hljs-operator">│</span>             b47:<span class="hljs-number">0</span>             <span class="hljs-operator">│</span><br><span class="hljs-operator">├──────┼──────┼──────┼──────┼──────┼──────────┼───────────────────────────────┤</span><br><span class="hljs-operator">│</span> <span class="hljs-type">ASCII</span><span class="hljs-operator">│</span> <span class="hljs-type">NFC</span>  <span class="hljs-operator">│</span>native<span class="hljs-operator">│</span> tail <span class="hljs-operator">│</span> <span class="hljs-type">UTF8</span> <span class="hljs-operator">│</span> reserved <span class="hljs-operator">│</span>             count             <span class="hljs-operator">│</span><br><span class="hljs-operator">└──────┴──────┴──────┴──────┴──────┴──────────┴───────────────────────────────┘</span><br><br> b63: isASCII. <span class="hljs-keyword">set</span> when all code units are known to be <span class="hljs-type">ASCII</span>, enabling:<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Trivial</span> <span class="hljs-type">Unicode</span> scalars, they&#x27;re just the code units<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Trivial</span> <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">16</span> transcoding (just bit<span class="hljs-operator">-</span>extend)<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Also</span>, isASCII always implies isNFC<br><br> b62: isNFC. <span class="hljs-keyword">set</span> when the contents are <span class="hljs-keyword">in</span> normal form <span class="hljs-type">C</span><br>   <span class="hljs-operator">-</span> <span class="hljs-type">Enables</span> trivial lexicographical comparisons: just memcmp<br>   <span class="hljs-operator">-</span> `isASCII` always implies `isNFC`, but not vice versa<br><br> b61: isNativelyStored. <span class="hljs-keyword">set</span> <span class="hljs-keyword">for</span> native stored strings<br>   <span class="hljs-operator">-</span> `largeAddressBits` holds an instance of `_StringStorage`.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">I</span>.e. the start of the code units <span class="hljs-keyword">is</span> at the stored address <span class="hljs-operator">+</span> `nativeBias`<br>   <span class="hljs-operator">-</span> <span class="hljs-type">NOTE</span>: isNativelyStored <span class="hljs-keyword">is</span> <span class="hljs-operator">*</span>specifically<span class="hljs-operator">*</span> allocated to b61 to align with the<br>     bit<span class="hljs-operator">-</span>position of isSmall on the <span class="hljs-type">BridgeObject</span>. <span class="hljs-type">This</span> allows us to check <span class="hljs-keyword">for</span><br>     native storage without an extra branch guarding against smallness. <span class="hljs-type">See</span><br>     `_StringObject.hasNativeStorage` <span class="hljs-keyword">for</span> this usage.<br><br> b60: isTailAllocated. contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> code units starts at address <span class="hljs-operator">+</span> `nativeBias`<br>   <span class="hljs-operator">-</span> `isNativelyStored` always implies `isTailAllocated`, but not vice versa<br>      (e.g. literals)<br>   <span class="hljs-operator">-</span> `isTailAllocated` always implies `isFastUTF8`<br><br> b59: isForeignUTF8. <span class="hljs-type">This</span> bit <span class="hljs-keyword">is</span> to be <span class="hljs-keyword">set</span> on future <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> encoded string<br>      variants, i.e. on strings whose index positions are measured <span class="hljs-keyword">in</span> <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> code<br>      units, even though their storage isn&#x27;t continuous. <span class="hljs-type">As</span> of <span class="hljs-type">Swift</span> <span class="hljs-number">5.7</span>, we<br>      don&#x27;t have any such foreign forms, but inlinable index validation methods<br>      need to prepare <span class="hljs-keyword">for</span> the possibility of their introduction, so we need to<br>      assign this bit <span class="hljs-keyword">in</span> preparation.<br><br>      <span class="hljs-type">If</span> we decide to never introduce such forms, we can stop checking this bit<br>      at any time, but we cannot reuse it <span class="hljs-keyword">for</span> something <span class="hljs-keyword">else</span> <span class="hljs-operator">--</span> we need to<br>      preserve its current meaning to keep inlined index validation code<br>      working.<br><br> b48<span class="hljs-operator">-</span><span class="hljs-number">58</span>: <span class="hljs-type">Reserved</span> <span class="hljs-keyword">for</span> future usage.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Because</span> <span class="hljs-type">Swift</span> <span class="hljs-keyword">is</span> <span class="hljs-type">ABI</span> stable (on <span class="hljs-keyword">some</span> platforms at least), these bits can<br>     only be assigned semantics that don&#x27;t affect interoperability with code<br>     built with previous releases of the <span class="hljs-type">Standard</span> <span class="hljs-type">Library</span>, from <span class="hljs-number">5.0</span> onward.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Older</span> binaries will not look at newly assigned bits, and they will not<br>     <span class="hljs-keyword">set</span> them, either (unless by side effect of calling into newly built code).<br>     <span class="hljs-type">Such</span> code must <span class="hljs-keyword">continue</span> working.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Code</span> <span class="hljs-keyword">in</span> new versions of the stdlib must <span class="hljs-keyword">continue</span> to work correctly even <span class="hljs-keyword">if</span><br>     <span class="hljs-keyword">some</span> of these newly assigned bits are never <span class="hljs-keyword">set</span> <span class="hljs-operator">--</span> <span class="hljs-keyword">as</span> may be the <span class="hljs-keyword">case</span> when<br>     the initialization of a string was emitted entirely into an older client<br>     binary.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">This</span> typically means that these bits can only be used <span class="hljs-keyword">as</span> <span class="hljs-keyword">optional</span><br>     performance shortcuts, e.g. to signal the availability of a potential fast<br>     path. (<span class="hljs-type">However</span>, it <span class="hljs-keyword">is</span> also possible to store information here that allows<br>     more reliable detection <span class="hljs-operator">&amp;</span> handling of runtime errors, like the<br>     `isForeignUTF8` bit above.)<br><br> b0<span class="hljs-operator">-</span><span class="hljs-number">47</span>: count. <span class="hljs-type">Stores</span> the number of code units. <span class="hljs-type">Corresponds</span> to the position of<br>     the `endIndex`.<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>类的初始化</title>
    <url>/2023/03/06/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h1><ul>
<li>类、结构体、枚举都可以定义初始化器</li>
<li>类有<code>2</code>种初始化器：指定初始化器 (<code>designated initializer</code>）、便捷初始化器 (<code>convenience initializer</code>)</li>
<li>每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器</li>
<li>默认初始化器总是类的指定初始化器</li>
<li>类偏向于少量指定初始化器，一个类通常只有一个指定初始化器</li>
<li>初始化器的相互调用规则<ul>
<li>指定初始化器必须从它的直系父类调用指定初始化器</li>
<li>便捷初始化器必须从相同的类里调用另一个初始化器</li>
<li>便捷初始化器最终必须调用一个<strong>指定初始化器</strong></li>
</ul>
</li>
</ul>
<h2 id="两段式初始化"><a href="#两段式初始化" class="headerlink" title="两段式初始化"></a>两段式初始化</h2><ul>
<li><code>swift</code>在编码安全方面是煞费苦心，为了保证初始化过程的安全，设定了两段式初始化、 安全检查</li>
<li>两段式初始化<ul>
<li>第1阶段：初始化所有存储属性<ol>
<li>外层调用指定\便捷初始化器</li>
<li>分配内存给实例，但未初始化</li>
<li>指定初始化器确保当前类定义的存储属性都初始化</li>
<li>指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链</li>
</ol>
</li>
<li>第2阶段：设置新的存储属性值<ol>
<li>从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例</li>
<li>初始化器现在能够使用<code>self</code>（访问、修改它的属性 ，调用它的实例方法等等）</li>
<li>最终，链中任何便捷初始化器都有机会定制实例以及使用<code>self</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h2><ul>
<li>指定初始化器必须保证在调用父类初始化器之前，其所在类定义的所有存储属性都要初始化完成</li>
<li>指定初始化器必须先调用父类初始化器，然后才能为继承的属性设置新值</li>
<li>便捷初始化器必须先调用同类中的其它初始化器(指定初始化器，或者其他调用了指定初始化器的便携初始化)，然后再为任意属性设置新值</li>
<li>初始化器在第1阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用<code>se1f</code></li>
<li>直到第1阶段结束，实例才算完全合法</li>
</ul>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><ul>
<li>当重写父类的指定初始化器时 ，必须加上<code>override</code>（即使子类的实现是便捷初始化器）</li>
<li>如果子类写了一个匹配父类便捷初始化器的初始化器，不用加上<code>override</code><ul>
<li>因为父类的便捷初始化器永远不会通过子类<code>直接调用</code>，因此，严格来说，子类<strong>无法重写</strong>父类的便捷初始化器</li>
</ul>
</li>
</ul>
<h2 id="自动继承"><a href="#自动继承" class="headerlink" title="自动继承"></a>自动继承</h2><ol>
<li>如果子类没有自定义任何<code>指定初始化器</code>，它会自动继承父类所有的指定初始化器<ul>
<li>如果子类有自己的初始化器，且不满足<code>2</code>，则不会继承父类的任何初始化器</li>
</ul>
</li>
<li>如果子类提供了父类所有<code>指定初始化器</code>的实现（要么通过<code>方式1</code>继承，要么重写）<ul>
<li>子类自动继承所有的父类便捷初始化器</li>
</ul>
</li>
<li>就算子类添加了更多的便捷初始化器，这些规则仍然适用</li>
<li>子类以<code>便捷初始化器的形式</code><strong>重写</strong>父类的指定初始化器，也可以作为满足规则<code>2</code>的一部分</li>
</ol>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>方法调用,多态</title>
    <url>/2023/03/05/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>查看<code>swift</code>方法调用、以及多态实现的原理</p>
</blockquote>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul>
<li>例子<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">speak</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sleep</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> animal <span class="hljs-operator">=</span> <span class="hljs-type">Animal</span>()<br>animal.sleep()<br>animal.speak() <br></code></pre></td></tr></table></figure></li>
<li>汇编查看，结构体的方法调用，直接调用<code>函数地址</code>执行方法,结构体没有多态的逻辑<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x10000df71</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>-&gt;  <span class="hljs-number">0x10000df74</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000e130</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span>.<span class="hljs-keyword">init</span>() -&gt; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span> at main.swift:<span class="hljs-number">10</span><br>    <span class="hljs-number">0x10000df79</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">9</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000e060</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span>.sleep() -&gt; () at main.swift:<span class="hljs-number">15</span><br>    <span class="hljs-number">0x10000df7e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">14</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x10000df90</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span>.speak() -&gt; () at main.swift:<span class="hljs-number">11</span><br>    <span class="hljs-number">0x10000df83</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">19</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">speak</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sleep</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:<span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">speak</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sleep</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> animal <span class="hljs-operator">=</span> <span class="hljs-type">Animal</span>()<br>animal.sleep() <span class="hljs-comment">//0x58(%rax)</span><br>animal.speak() <span class="hljs-comment">//0x50(%rax)</span><br>animal <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span>()<br>animal.speak() <span class="hljs-comment">//0x50(%rax)</span><br>animal.sleep()<br></code></pre></td></tr></table></figure>
<ul>
<li>汇编查看<ol>
<li><code>register read r13</code> -&gt; <code>r13 = 0x0000600000014000</code>,和<code>animal</code>的地址一致,<code>movq   (%r13), %rax</code>将<code>aniaml</code>地址上的头<code>8</code>字节存的信息（即<code>metaData</code>-<code>0x0000000100014cd0</code>）赋值给<code>rax</code>。</li>
<li><code>callq  *0x58(%rax)</code>,<code>si</code>查看,其实际为<code>sleep</code>方法调用，现在，在<code>metaData</code>偏移<code>0x58</code>的内存上存有函数的地址</li>
<li><code>speak</code>方法同样在<code>0x50(%rax)</code>位置处，同样存有地址，且，类方法存储的地址相距<code>8</code>字节</li>
<li>将<code>Dog</code>初始化后赋值给<code>animal</code>，其<code>metaData</code>和<code>Animal</code>不同，地址为<code>0x0000000100014d70</code>，和原来的<code>animal</code>没有关系。但其实际上调用的函数地址是仍然是偏移<code>0x50</code>和<code>0x58</code>处的函数地址。</li>
<li>将<code>Dog</code>中重写的方法去掉，发现情况一致，<code>Dog</code>和<code>Animal</code>头<code>8</code>字节的<code>metaData</code>仍然<code>不同</code>，但是方法同样偏移相同的位置<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//调用sleep方法</span><br><span class="hljs-number">0x10000d98d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">93</span><span class="hljs-operator">&gt;</span>:  movq   (<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x10000d991</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">97</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-operator">*</span><span class="hljs-number">0x58</span>(<span class="hljs-operator">%</span>rax)<br>-&gt;  <span class="hljs-number">0x10000d994</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">100</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0xa8</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><br><span class="hljs-comment">// 调用speak方法</span><br><span class="hljs-number">0x10000d9d8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">168</span><span class="hljs-operator">&gt;</span>: movq   (<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br>-&gt;  <span class="hljs-number">0x10000d9dc</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">172</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-operator">*</span><span class="hljs-number">0x50</span>(<span class="hljs-operator">%</span>rax)<br><br><span class="hljs-comment">//将Dog()赋值给animal</span><br> ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Dog</span>.__allocating_init() -&gt; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Dog</span> at main.swift:<span class="hljs-number">20</span><br>    <span class="hljs-number">0x10000d9fc</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">204</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x98</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x10000da03</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">211</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0x7a36</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.animal : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span><br>    <span class="hljs-number">0x10000da0a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">218</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x50</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rsi<br>    <span class="hljs-number">0x10000da0e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">222</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x21, <span class="hljs-operator">%</span>edx<br>    <span class="hljs-number">0x10000da13</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">227</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br>    <span class="hljs-number">0x10000da15</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">229</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>ecx<br>    <span class="hljs-number">0x10000da17</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">231</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x10000e14c</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_beginAccess<br>    <span class="hljs-number">0x10000da1c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">236</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x98</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x10000da23</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">243</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-number">0x7a16</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.animal : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span><br>    <span class="hljs-number">0x10000da2a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">250</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0x7a0f</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.animal : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span><br>    <br><span class="hljs-comment">//调用dog的speak方法</span><br><span class="hljs-number">0x10000da77</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">327</span><span class="hljs-operator">&gt;</span>: movq   (<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br>-&gt;  <span class="hljs-number">0x10000da7b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">331</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-operator">*</span><span class="hljs-number">0x50</span>(<span class="hljs-operator">%</span>rax)<br><span class="hljs-comment">//调用dog的sleep方法</span><br><span class="hljs-number">0x10000dac2</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">402</span><span class="hljs-operator">&gt;</span>: movq   (<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x10000dac6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">406</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-operator">*</span><span class="hljs-number">0x58</span>(<span class="hljs-operator">%</span>rax)<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="总结，"><a href="#总结，" class="headerlink" title="总结，"></a><strong>总结</strong>，</h2><ul>
<li>实际上,<code>swift</code>中方法的确认，是由<code>虚表</code>来决定的。其前<code>8字节</code>存放了类型的信息，其后面<code>0x50</code>之后存放函数地址，如果<code>重写</code>了父类的方法，则会存储重写后的方法地址; 未重写父类的方法，则会保存<code>父类的方法</code>到子类的虚表中，父类方法之后则是本类中新添加的方法。</li>
<li>代码在编译完，由编译器将函数地址放到<code>metaData</code>中，</li>
<li>在赋值时，由于<code>Dog</code>,和<code>Animal</code>的类型信息不同，会寻找到对应的方法实现。</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>下标、重写</title>
    <url>/2023/03/05/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="subscript下标"><a href="#subscript下标" class="headerlink" title="subscript下标"></a><code>subscript</code>下标</h1><ul>
<li>结构体,对结构体设置，必须要有<code>set</code>方法，才能改结构体内的值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>,y <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br>    <span class="hljs-function"><span class="hljs-keyword">subscript</span>(<span class="hljs-params">index</span>:<span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Point</span> &#123;<br>        <span class="hljs-keyword">set</span> &#123; point <span class="hljs-operator">=</span> newValue &#125;<br><br>        <span class="hljs-keyword">get</span> &#123; point &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> p <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br>p[<span class="hljs-string">&quot;0&quot;</span>].x <span class="hljs-operator">=</span> <span class="hljs-number">11</span> <span class="hljs-comment">//本质上是 p[&quot;0&quot;].x = Point(11,p[&quot;0&quot;].y)</span><br>p[<span class="hljs-string">&quot;0&quot;</span>].y <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li>
<li>类，返回的是引用类型，因此不需要<code>set</code>也能设置<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>,y <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br>    <span class="hljs-function"><span class="hljs-keyword">subscript</span>(<span class="hljs-params">index</span>:<span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Point</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; point &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> p <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br>p[<span class="hljs-string">&quot;0&quot;</span>].x <span class="hljs-operator">=</span> <span class="hljs-number">11</span> <br>p[<span class="hljs-string">&quot;0&quot;</span>].y <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><h2 id="重写类型方法、下标"><a href="#重写类型方法、下标" class="headerlink" title="重写类型方法、下标"></a>重写类型方法、下标</h2><ul>
<li>被<code>class</code>修饰的类型方法、下标，允许被子类重写<ul>
<li>父类如果是<code>class</code>修饰方法，则可以重写，并且新的方法写出<code>static</code>可以防止当前类的子类，继续重写</li>
</ul>
</li>
<li>被<code>static</code>修饰的类型方法、下标，不允许被子类重写</li>
</ul>
<h2 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h2><ul>
<li>重写实例属性<ul>
<li>子类可以将父类的属性（存储、计算） 重写为计算属性</li>
<li>子类不可以将父类计算属性写为存储属性</li>
<li>只能重写<code>var</code>属性，不能重写<code>let</code>属性</li>
<li>重写时，属性名、类型要一致</li>
<li>子类重写后的属性权限 不能小于 父类属性的权限<ul>
<li>如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的</li>
<li>如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的</li>
</ul>
</li>
</ul>
</li>
<li>重写类型属性<ul>
<li>被<code>class</code>修饰的计算类型属性，可以被子类重写,<code>存储属性</code>不能用<code>class</code>修饰，只能被<code>static</code></li>
<li>被<code>static</code>修饰的类型属性（存储、计算），不可以被子类重写</li>
</ul>
</li>
</ul>
<h2 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h2><blockquote>
<p>重写属性观察器，实际上并不会覆盖父类的属性观察器，只是再添加了一次观察器。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Animal:willSet&quot;</span>,newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Animal:didSet&quot;</span>,oldValue)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:<span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dog:willSet&quot;</span>,newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dog:didSet&quot;</span>,oldValue)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> dog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span> ()<br>dog.age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-comment">/*打印结果：</span><br><span class="hljs-comment">Dog:willSet 10</span><br><span class="hljs-comment">Animal:willSet 10</span><br><span class="hljs-comment">Animal:didSet 0</span><br><span class="hljs-comment">Dog:didSet 0</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>重写属性观察器，会先是子类的<code>willSet</code>-&gt;父类的<code>willSet</code>方法，最后是在父类中进行实际的设置，然后父类的<code>didSet</code>方法-&gt;子类的<code>didSet</code>方法</li>
</ul>
<h2 id="通过重写为计算属性增加属性观察器"><a href="#通过重写为计算属性增加属性观察器" class="headerlink" title="通过重写为计算属性增加属性观察器"></a>通过重写为计算属性增加属性观察器</h2><blockquote>
<p>在同一个类中计算属性不能同时有<code>set</code>/<code>get</code>和<code>willset</code>/<code>didSet</code>，但是可以通过重写的方式，使其子类中可以拥有属性观察器。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> num:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num get&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">20</span><br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num set&quot;</span>)<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:<span class="hljs-title">Animal</span> </span>&#123; <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> num: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num:willSet&quot;</span>,newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num:didSet&quot;</span>,oldValue)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> dog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span> ()<br>dog.num <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br><span class="hljs-comment">/*打印结果：</span><br><span class="hljs-comment">num get</span><br><span class="hljs-comment">num:willSet 12</span><br><span class="hljs-comment">num set</span><br><span class="hljs-comment">num:didSet 20</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>重写计算属性，可以为其添加属性观察器，会先调用<code>get</code>方法，给<code>oldValue</code>赋值,再调用<code>willSet</code>、<code>set</code>、<code>didSet</code>方法</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>属性</title>
    <url>/2023/03/01/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h3><ul>
<li><code>lazy</code>属性必须是<code>var</code>，不能是<code>let</code><ul>
<li>必须在实例的初始化方法完成之前就拥有值</li>
</ul>
</li>
<li>如果多条线程同时第一次访问<code>lazy</code>属性<ul>
<li>无法保证属性只被初始化<code>1</code>次</li>
</ul>
</li>
<li>当结构体包含一个延迟存储属性时，只有<code>var</code>才能访问延迟存储属性<ul>
<li>因为延迟属性初始化时需要改变结构体的内存</li>
</ul>
</li>
</ul>
<h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><ul>
<li><code>willset</code>会传递新值，默认叫<code>newValue</code></li>
<li><code>didset</code>会传递旧值，默认叫<code>oldValue</code></li>
<li>在初始化器中设置属性值不会触发<code>willSet</code>和<code>didset</code></li>
<li>在属性定义时设置初始值也不会触发<code>willSet</code>和<code>didset</code><ul>
<li>属性定义是设置，和初始化器中设置，其源码实际是一样的</li>
</ul>
</li>
<li>属性观察器，计算属性的功能，同样可以应用在全局变量、局部变量身上</li>
</ul>
<h3 id="inout探究"><a href="#inout探究" class="headerlink" title="inout探究"></a>inout探究</h3><blockquote>
<p>此前对函数inout进行探究，其值传入的是地址。但和属性值关联起来使用，会有所不同</p>
</blockquote>
<ul>
<li>例子,用<code>Int</code>类型，(<code>Int</code>类型的值，能在内存中直观的看到)<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> width:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br>    <span class="hljs-keyword">var</span> side:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;willSet&quot;</span>,newValue)<br>        &#125;<br><br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;didSet&quot;</span>,oldValue,side)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> area:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>           <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;getArea&quot;</span>)<br>           <span class="hljs-keyword">return</span> width <span class="hljs-operator">*</span> side<br>        &#125;<br>        <br>        <span class="hljs-keyword">set</span> &#123;<br>            width <span class="hljs-operator">=</span> newValue <span class="hljs-operator">/</span> side<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;setArea&quot;</span>)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">init</span>()</span> &#123;<br>        <span class="hljs-keyword">self</span>.side  <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;设置Num&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="单纯存储属性调用"><a href="#单纯存储属性调用" class="headerlink" title="单纯存储属性调用"></a>单纯存储属性调用</h4><ul>
<li>纯属性调用,<code>test(&amp;s.width)</code>,很显然是拿到数据地址(<code>0xb745(%rip)</code> = <code>0x1000054cb + 0xb745 = 0x0000000100010c10 </code>)(<code>width</code>是第一个，它的地址，即函数地址，第一个存的<code>8</code>，第二个是<code>2</code>)，作为<code>rdi</code>参数，之后进行函数调用。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-number">0x1000054c4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">52</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-number">0xb745</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span><br>-&gt;  <span class="hljs-number">0x1000054cb</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">59</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008620</span>               ; <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-keyword">inout</span> <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">240</span><br><span class="hljs-comment">//内存情况  rdi的值 0x1000054cb + 0xb745 = 0x0000000100010c10</span><br>x<span class="hljs-operator">/</span>4xg <span class="hljs-number">0x0000000100010c10</span><br><span class="hljs-number">0x100010c10</span>: <span class="hljs-number">0x0000000000000008</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x100010c20</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="计算属性调用"><a href="#计算属性调用" class="headerlink" title="计算属性调用"></a>计算属性调用</h4><ul>
<li>计算属性调用,<code>test(&amp;s.area)</code>，输出<code>getArea</code>、<code>设置Num</code>、<code>setArea</code>。首先计算属性会通过<code>get</code>取值拿到局部变量之后，将局部变量地址传进<code>test</code>函数去设置，设置完毕之后，再调用<code>set</code>方法。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-number">0x100005266</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">54</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0xb9a3</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span><br>    <span class="hljs-number">0x10000526d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">61</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0xb9a4</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rsi        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br>-&gt;  <span class="hljs-number">0x100005274</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">68</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008120</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.area.getter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">226</span><br>    <span class="hljs-number">0x100005279</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">73</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x10000527d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">77</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100005281</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">81</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008550</span>               ; <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-keyword">inout</span> <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">242</span><br>    <span class="hljs-number">0x100005286</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">86</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x10000528a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">90</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-number">0xb97f</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>r13        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span><br>    <span class="hljs-number">0x100005291</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">97</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008290</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.area.setter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">231</span><br></code></pre></td></tr></table></figure></li>
<li>汇编验证<ol>
<li><code>movq   0xb9a3(%rip) , %rdi</code>、<code>movq   0xb9a4(%rip), %rsi</code>,<code>rdi</code>和<code>rsi</code>作为参数，这里将<code>width</code>和<code>side</code>地址上的存<code>8</code>和<code>2</code>分别进行赋值；作为后续调用<code>area.getter</code>的参数</li>
<li><code>rax</code>作为返回值，这里将<code>get</code>返回的结果赋值给，<code>-0x28(%rbp)</code>地址空间上,<code>rbp</code>是栈空间地址，<code>-0x28(%rbp)</code>为局部变量，代码在<code>main</code>函数中，是<code>main</code>函数的局部变量</li>
<li><code>leaq   -0x28(%rbp), %rdi</code>,将<code>局部变量</code>的<code>地址</code>赋予<code>rdi</code>作为函数参数，调用<code>test(inout Swift.Int)</code>方法</li>
<li><code> movq   -0x28(%rbp), %rdi</code>,<code>leaq   0xb97f(%rip), %r13</code>,将<code>3</code>中修改后的局部变量的值赋值<code>rdi</code>作为参数,即<code>s</code>地址也作为参数，调用<code>area.setter</code>进行赋值</li>
</ol>
</li>
</ul>
<h4 id="带属性观察器的存储属性调用"><a href="#带属性观察器的存储属性调用" class="headerlink" title="带属性观察器的存储属性调用"></a>带属性观察器的存储属性调用</h4><ul>
<li>存储属性调用，<code>test(&amp;s.side)</code>，输出<code>设置Num</code>、<code>willSet 20</code>、<code>didSet 2 20</code>。先设置值，方法执行完毕后，才调用<code>willSet</code>和<code>didSet</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100005326</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">54</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0xb8eb</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rax        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br>-&gt;  <span class="hljs-number">0x10000532d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">61</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100005331</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">65</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100005335</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">69</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008610</span>               ; <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-keyword">inout</span> <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">242</span><br>    <span class="hljs-number">0x10000533a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">74</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x10000533e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">78</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-number">0xb8cb</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>r13        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span><br>    <span class="hljs-number">0x100005345</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">85</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100007f30</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.side.setter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">215</span><br>    <span class="hljs-number">0x10000534a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">90</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br></code></pre></td></tr></table></figure></li>
<li>汇编验证<ol>
<li><code>movq 0xb8eb(%rip), %rax</code>,<code>movq   %rax, -0x28(%rbp)</code>,这里取出<code>sid</code>的值，取出来，将他赋值给局部变量<code> -0x28(%rbp)</code></li>
<li><code>leaq   -0x28(%rbp), %rdi</code>,这里将<code>局部变量</code>的<code>地址</code>取出作为参数，传递给<code>test</code>函数</li>
<li><code>movq   -0x28(%rbp), %rdi</code>,<code>leaq   0xb8cb(%rip), %r13</code>,这里将修改后的局部变量，以及<code>s</code>作为参数(类似<code>OC</code>中,<code>settr</code>函数，默认传入<code>self</code>)，调用<code>side.setter</code></li>
<li><code>side.setter</code>方法<ol>
<li>这里<code>r13</code>，<code>rdi</code>的值始终保持不变，一个是<code>s</code>，一个是新值，也作为<code>willSet</code>方法和<code>didiSet</code>方法的参数调用</li>
<li>在<code>movq %rax, 0x8(%r13)</code>,<code>didiSet</code>方法之前，将<code>rax</code>的值。即<code>-0x30(%rbp)</code>内存中的值(最开始<code>rdi</code>赋值的)，进行了新值的替换，<code>r13</code>是<code>s</code>，其后<code>8</code>字节即<code>side</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100007f34</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>r13<br><span class="hljs-number">0x100007f36</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">6</span><span class="hljs-operator">&gt;</span>:  subq   <span class="hljs-variable">$0</span>x38, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100007f3a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x38</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f3e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">14</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x30</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f42</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f4a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">26</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f52</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">34</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f5a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">42</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f5e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">46</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f62</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">50</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-number">0x8</span>(<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br><span class="hljs-number">0x100007f66</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">54</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f6a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">58</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f6e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">62</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100007f90</span>               ;       <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.side.willset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">216</span><br><span class="hljs-number">0x100007f73</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">67</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x38</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>r13<br><span class="hljs-number">0x100007f77</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">71</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x30</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rax<br><span class="hljs-number">0x100007f7b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">75</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100007f7f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">79</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0x8</span>(<span class="hljs-operator">%</span>r13)<br><span class="hljs-number">0x100007f83</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">83</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100008080</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.side.didset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">220</span><br><span class="hljs-number">0x100007f88</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">88</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x38, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100007f8c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">92</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>r13<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>有属性观察器的存储属性，实现和计算属性一样，采用<code>拷入拷出</code>或者<code>值结果调用</code>的方式，目的是为了设置完属性后，可以触发属性观察器。本质上<code>test</code>函数内部，是不会触发属性观察器的。</li>
</ul>
<h4 id="inout总结"><a href="#inout总结" class="headerlink" title="inout总结"></a>inout总结</h4><ul>
<li>如果实参有物理内存地址，且没有设置属性观察器<ul>
<li>直接将实参的内存地址传入函数（实参进行引用传递）</li>
</ul>
</li>
<li>如果实参是计算属性 或者 设置了属性观察器<ul>
<li>采取了<code>Copy In Copy Out</code>(<code>拷入拷出</code>)的做法<ul>
<li>调用该函数时 ，先复制实参的值，产生<code>副本</code>(局部变量),调用<code>get</code>（存储属性是直接取值，计算属性是<code>get</code>）</li>
<li>将<code>副本</code>的内存地址传入函数（<code>副本</code>进行引1用传递），在函数内部可以修改<code>副本</code>的值</li>
<li>函数返回后，再将<code>副本</code>的值覆盖实参的值,调用(<code>set</code>)</li>
</ul>
</li>
</ul>
</li>
<li>总结：<code>inout</code>的本质就是引用传递（地址传递）</li>
</ul>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><ul>
<li>严格来说，属性可以分为<ul>
<li>实例属性 ( Instance Property)：只能通过实例去访问<ul>
<li>存储实例属性 ( Stored Instance Property）：存储在实例的内存中，每个实例都有1份，</li>
<li>计算实例属性 ( Computed Instance Property )</li>
</ul>
</li>
<li>类型属性( Type Property ）：只能通过类型去访问<ul>
<li>存储类型属性 ( Stored Type Property)：整个程序运行过程中，就只有1份内存（类似于<strong>全局变量</strong>)</li>
<li>计算类型属性 ( Computed Type Property )</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="类型属性细节"><a href="#类型属性细节" class="headerlink" title="类型属性细节"></a>类型属性细节</h4><ul>
<li>不同于存储实例属性，你必须给存储类型属性设定初始值<ul>
<li>因为类型没有像实例那样的<code>init</code>初始化器来初始化存储属性</li>
</ul>
</li>
<li>存储类型属性默认就是<code>lazy</code>，会在第一次使用的时候才初始化<ul>
<li>就算被多个线程同时访问，保证只会初始化一次,会使用<code>dispatch_once</code>技术</li>
</ul>
</li>
<li>枚举类型也可以定义<strong>类型属性</strong>（存储类型属性、计算类型属性）<ul>
<li>枚举类型中不可以定义存储实例属性，但是可以定义类型属性</li>
<li>这是因为类型属性，不在实例中，属于全局变量</li>
</ul>
</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ol>
<li><code>private</code>保证外界不会调用初始化方法</li>
<li>使用类型属性，是<code>lazy</code>，会在第一次使用的时候才初始化，并且保证只会初始化一次，线程安全的,和OC中<code>dispatch_once</code>一致<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileManager</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">FileManager</span> ()<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">init</span>( &#123; &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="汇编查看"><a href="#汇编查看" class="headerlink" title="汇编查看"></a>汇编查看</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> count  <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">var</span> num1 <span class="hljs-operator">=</span> <span class="hljs-number">11</span> <br><span class="hljs-type">Car</span>.count <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br><span class="hljs-keyword">var</span> num3 <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<ul>
<li>汇编代码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-comment">//num1的赋值</span><br>    <span class="hljs-number">0x100003c18</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-variable">$0</span>xb, <span class="hljs-number">0x453d</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-keyword">static</span> <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Car</span>.count : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">4</span><br>    <span class="hljs-number">0x100003c23</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">19</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003c90</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Car</span>.count.unsafeMutableAddressor : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift<br>    <span class="hljs-number">0x100003c28</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">24</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">%</span>rdi<br>-&gt;  <span class="hljs-number">0x100003c2b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">27</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c2f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">31</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rsi<br>    <span class="hljs-number">0x100003c33</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">35</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x21, <span class="hljs-operator">%</span>edx<br>    <span class="hljs-number">0x100003c38</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">40</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br>    <span class="hljs-number">0x100003c3a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">42</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>ecx<br>    <span class="hljs-number">0x100003c3c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">44</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003e6e</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_beginAccess<br>    <span class="hljs-number">0x100003c41</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">49</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rax<br>    <span class="hljs-comment">//这里对count赋值</span><br>    <span class="hljs-number">0x100003c45</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">53</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>xc, (<span class="hljs-operator">%</span>rax)<br>    <span class="hljs-number">0x100003c4c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">60</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <br><span class="hljs-comment">//num3的赋值</span><br><span class="hljs-number">0x100003c55</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">69</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x9, <span class="hljs-number">0x4508</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.num1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">4</span><br>    <span class="hljs-number">0x100003c60</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">80</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br></code></pre></td></tr></table></figure></li>
<li>分析汇编<ol>
<li><code>num1</code>的地址<code>0x100008160</code>、count的地址<code>0x0000000100008158</code>,num3的地址<code>0x100008168</code>，显然<code>count</code>和<code>num1</code>以及<code>num3</code>的地址是连续的，而num1和num3是全局变量，显然<code>count</code>和<code>num1</code>和<code>num3</code>一样，均是全局变量</li>
<li>类属性本质就是全局变量，相比一般的全局变量，类属性可以增加访问权限控制。</li>
</ol>
</li>
<li>类属性的加载分析,通过<code>SIL</code>源码编译查看<ol>
<li>指令<code>swiftc -emit-sil main.swift -o main.sil</code>生成<code>SIL</code></li>
<li><code>count</code>加了<code>static</code>是全局变量，其初始化方法调用了<code>global_init_once_fn</code>（类似<code>dispatch_once</code>,保证只会初始化一次）,其内部载第一次加载的时候初始化，并赋值<code>2</code>，<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>  <span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> count: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">deinit</span><br>  <span class="hljs-function"><span class="hljs-keyword">init</span>()</span><br>&#125;<br><br><br><span class="hljs-comment">// one-time initialization function for count</span><br>sil <span class="hljs-keyword">private</span> [global_init_once_fn] @<span class="hljs-variable">$s4main3CarC5count_WZ</span> : $<span class="hljs-keyword">@convention(c)</span> () -&gt; () &#123;<br>bb0:<br>  alloc_global @<span class="hljs-variable">$s4main3CarC5countSivpZ</span>           <span class="hljs-comment">// id: %0</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s4main3CarC5countSivpZ</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// user: %4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int64</span>, <span class="hljs-number">2</span>          <span class="hljs-comment">// user: %3</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int</span> (%2 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int64</span>)          // <span class="hljs-title">user</span>: %4</span><br><span class="hljs-class">  <span class="hljs-title">store</span> %3 <span class="hljs-title">to</span> %1 : <span class="hljs-title">$</span>*<span class="hljs-title">Int</span>                          // <span class="hljs-title">id</span>: %4</span><br><span class="hljs-class">  %5 = <span class="hljs-title">tuple</span> ()                                   // <span class="hljs-title">user</span>: %6</span><br><span class="hljs-class">  <span class="hljs-title">return</span> %5 : <span class="hljs-title">$</span>()                                 // <span class="hljs-title">id</span>: %6</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">$s4main3CarC5count_WZ</span>&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2023/02/27/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote>
<p>一个函数和它所捕获的变量\常量环境组合起来，称为闭包</p>
<ul>
<li>一般指定义在函数内部的函数</li>
<li>一般它捕获的是外层的局部变量\常量</li>
</ul>
</blockquote>
<h2 id="闭包本质查看"><a href="#闭包本质查看" class="headerlink" title="闭包本质查看"></a>闭包本质查看</h2><h3 id="不捕获变量"><a href="#不捕获变量" class="headerlink" title="不捕获变量"></a>不捕获变量</h3><ul>
<li>源码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> i<br>    &#125;<br>    <span class="hljs-keyword">return</span> plus(i:)<br>&#125;<br><span class="hljs-keyword">var</span> fu <span class="hljs-operator">=</span> getFun()<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.stride(ofValue: fu)) <span class="hljs-comment">//16</span><br></code></pre></td></tr></table></figure></li>
<li>汇编查看<ul>
<li><code>rax</code>一般为返回值，很明显将<code>0xe5(%rip)</code>的地址存放在计算器<code>rax</code>中，返回<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">SwiftDText</span>`getFun():<br>-&gt;  <span class="hljs-number">0x100004e10</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004e11</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004e14</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-number">0xe5</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rax          ; plus(i: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">195</span><br>    <span class="hljs-number">0x100004e1b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">11</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>ecx, <span class="hljs-operator">%</span>ecx<br>    <span class="hljs-number">0x100004e1d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">13</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-operator">%</span>ecx, <span class="hljs-operator">%</span>edx<br>    <span class="hljs-number">0x100004e1f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004e20</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">16</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
<li>查看<code>rax</code>地址,很明显存放的是函数地址，显然不捕获变量的闭包，直接返回了函数的地址。并且和<code>fu</code>的指针一致。  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">register read rax<br>rax <span class="hljs-operator">=</span> <span class="hljs-number">0x0000000100004f00</span>  <span class="hljs-type">SwiftDText</span>`plus(i: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">195</span><br>p fu<br>() <span class="hljs-variable">$R0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0000000100004f00</span> <br></code></pre></td></tr></table></figure></li>
<li>此外将<code>xorl   %ecx, %ecx</code>进行异或,其值为<code>0</code>，并将结果赋值给<code>edx</code>（<code>edx</code>与<code>rdx</code>共寄存器，只是一个<code>4</code>字节，一个<code>8</code>字节),也可理解为赋值给了<code>rdx</code></li>
<li><code>fn</code>指针变量是<code>16</code>字节空间，<ul>
<li>其中赋值的地址为<code>0x100002299 + 0xe337 = 0x1000105D0</code>,<code>0x1000022a0 + 0xe338 = 0x1000105D8</code>,并且为<code>movq</code>(占<code>8</code>字节)数据移动赋值</li>
<li>因此，很显然这里将<code>rax</code>中的函数地址地址赋予<code>fu</code>，同时<code>rdx</code>也赋值给了<code>fu</code>，<code>rdx</code>和后续捕获变量有关系<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100002292</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0xe337</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span><br><span class="hljs-number">0x100002299</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rdx, <span class="hljs-number">0xe338</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br><span class="hljs-number">0x1000022a0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">32</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edi<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h3><ul>
<li>源码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span>,num2 <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>    <span class="hljs-keyword">return</span> plus(i:)<br>&#125;<br><span class="hljs-keyword">var</span> fu <span class="hljs-operator">=</span> getFun()<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.stride(ofValue: fu)) <span class="hljs-comment">//16</span><br></code></pre></td></tr></table></figure></li>
<li>汇编查看<ul>
<li>汇编源码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100008870</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x100008871</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x100008874</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  subq   <span class="hljs-variable">$0</span>x10, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100008878</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x8</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100008880</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">16</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100008888</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">24</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x9, <span class="hljs-operator">-</span><span class="hljs-number">0x8</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100008890</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">32</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x3, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100008898</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">40</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0x3b79</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; _swift_FORCE_LOAD_<span class="hljs-variable">$_swiftIOKit_</span><span class="hljs-variable">$_SwiftDText</span> <span class="hljs-operator">+</span> <span class="hljs-number">24</span><br><span class="hljs-number">0x10000889f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">47</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x20, <span class="hljs-operator">%</span>esi<br><span class="hljs-number">0x1000088a4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">52</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x7, <span class="hljs-operator">%</span>edx<br><span class="hljs-number">0x1000088a9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">57</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x10000ab86</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_allocObject<br><span class="hljs-number">0x1000088ae</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">62</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">%</span>rdx <span class="hljs-comment">//堆生成的对象，给了rdx</span><br><span class="hljs-number">0x1000088b1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">65</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x9, <span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rdx)  <span class="hljs-comment">//9赋值给了rdx后16字节</span><br><span class="hljs-number">0x1000088b9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">73</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x3, <span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rdx) <span class="hljs-comment">//3赋值给了rdx后24字节</span><br><span class="hljs-number">0x1000088c1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">81</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0xf8</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rax          ; partial apply forwarder <span class="hljs-keyword">for</span> function signature specialization <span class="hljs-operator">&lt;</span><span class="hljs-type">Arg</span>[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Value</span> <span class="hljs-type">Promoted</span> from <span class="hljs-type">Box</span>, <span class="hljs-type">Arg</span>[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Value</span> <span class="hljs-type">Promoted</span> from <span class="hljs-type">Box</span><span class="hljs-operator">&gt;</span> of plus(i: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at <span class="hljs-operator">&lt;</span>compiler<span class="hljs-operator">-</span>generated<span class="hljs-operator">&gt;</span> <span class="hljs-comment">//注意这里和之前未捕获的不同</span><br><span class="hljs-number">0x1000088c8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">88</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x10, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x1000088cc</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">92</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x1000088cd</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">93</span><span class="hljs-operator">&gt;</span>: retq <br></code></pre></td></tr></table></figure></li>
<li>可以看出调用了<code>swift_allocObject</code>，在堆空间生成了对象。并且该对象的地址返回在<code>rax</code>中,打印出地址，以及存储的<code>num</code>,<code>num2</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">register read rax<br>rax <span class="hljs-operator">=</span> <span class="hljs-number">0x0000600000208000</span><br><span class="hljs-comment">//显示地址的内存，6组，每组8字节，按16进制显示</span><br>x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x0000600000208000</span><br><span class="hljs-number">0x600000208000</span>: <span class="hljs-number">0x000000010000c418</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000208010</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000208020</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li><code>leaq    0xf8(%rip), %rax</code>，<code>movq   $0x9, 0x10(%rdx)、movq   $0x3, 0x18(%rdx)</code>,函数地址传给了<code>rax</code>,生成的包装<code>num</code> 的对象传给了<code>rdx</code>,<code>rdx</code>和<code>rax</code>一般用做函数返回值。实际返回结果后，将<code>rax</code>和<code>rdx</code>上的值，赋值给了<code>fn对象</code>（由于在全局区执行，所以是<code>rip</code>，全局变量）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-number">0x100005f62</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0xaca7</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span><br><span class="hljs-number">0x100005f69</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rdx, <span class="hljs-number">0xaca8</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br><span class="hljs-comment">//此时rip的的地址是0x100010C10，将rax和rdx存在该地址的内存上，一个为函数地址，一个为存储的变量地址</span><br>x<span class="hljs-operator">/</span>2g <span class="hljs-number">0x100010C10</span><br><span class="hljs-number">0x100010c10</span>: <span class="hljs-number">0x00000001000089c0</span> <span class="hljs-number">0x0000600000208000</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，和未捕获的闭包表达式不同，捕获了变量的闭包，其赋值给<code>rdx</code>的函数地址，和实际的不同.(xcode旁边的注解和捕获变量的赋值，是不一样的)，实际上，该函数地址进行了一次包装<ul>
<li>最后用的是<code>jmp</code>跳转，而非<code>call</code>。因为不需要悬停返回在包装函数的内部，需要返回的是<code>-&gt;</code>通过<code>callq  *%rax</code>调用包装函数的地方（这种方式，在使用者看来，是直接调用函数的，并且函数内的<code>ret</code>会返回调用包装函数处）。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//实际调用函数的地方</span><br><span class="hljs-number">0x100005f97</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">71</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0xac7a</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>r13        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span> <span class="hljs-comment">//这里实际将，num包装的堆地址传给了r13</span><br><span class="hljs-number">0x100005f9e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">78</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x80</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100005fa2</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">82</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100005fa5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">85</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000abf2</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_retain<br><span class="hljs-number">0x100005faa</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">90</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100005fae</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">94</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000abb6</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_endAccess<br><span class="hljs-number">0x100005fb3</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">99</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">-</span><span class="hljs-number">0x88</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rax<br><span class="hljs-number">0x100005fba</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">106</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edi<br><span class="hljs-number">0x100005fbf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">111</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-operator">*%</span>rax<br><span class="hljs-comment">//函数内部</span><br><span class="hljs-number">0x1000089c0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp  <span class="hljs-comment">//即上面rax中存放的地址</span><br><span class="hljs-number">0x1000089c1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x1000089c4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rsi <span class="hljs-comment">//将r13中的num包装对象偏移16字节（即num）取出，偏移24字节num2，传给rsi作为函数参数</span><br><span class="hljs-number">0x1000089c8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rdx<br><span class="hljs-number">0x1000089cc</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">12</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x1000089cd</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">13</span><span class="hljs-operator">&gt;</span>: jmp    <span class="hljs-number">0x100008920</span>               ; function signature specialization <span class="hljs-operator">&lt;</span><span class="hljs-type">Arg</span>[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Value</span> <span class="hljs-type">Promoted</span> from <span class="hljs-type">Box</span>, <span class="hljs-type">Arg</span>[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Value</span> <span class="hljs-type">Promoted</span> from <span class="hljs-type">Box</span><span class="hljs-operator">&gt;</span> of plus(i: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">197</span> <span class="hljs-comment">//最终实际地址是0x100008920  </span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="捕获的时机"><a href="#捕获的时机" class="headerlink" title="捕获的时机"></a>捕获的时机</h3><ul>
<li><strong>注意</strong>，捕获只会在使用的时候进行捕获，这里捕获的是<code>20</code>，而非<code>9</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> i<br>    &#125;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> plus(i:)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,如果没有执行，则不会捕获，和此前未捕获变量一致<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> i<br>    &#125;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-variable">$0</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,如果是全局变量，也不会进行捕获</li>
<li><strong>注意</strong>,下面的函数中未对<code>num</code>和<code>num2</code>进行修改，最终这两个数(<code>3</code>个以上也是这样)，会包装成一个堆对象  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>,(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>) &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span>,num2 <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,下面的函数对<code>num</code>和<code>num2</code>进行修改，最终这<code>两</code>个数，会<code>分别</code>包装成一个堆对象，汇编查看会生成两个堆对象<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>,(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>) &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span>,num2 <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        num <span class="hljs-operator">+=</span> i<br>        num2 <span class="hljs-operator">+=</span> i<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,下面会生成两个堆对象，每个堆对象包装了<code>num</code>和<code>num2</code>（由于未修改）。如果<code>num</code>和<code>num2</code>修改了，也只会<code>分别</code>生成一个，不会因为两次闭包捕获，各自生成一次。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>,(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>) &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span>,num2 <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> (plus(i:),minus(i:))<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>可以把闭包想象成是一个类的实例对象<ul>
<li>内存在堆空间</li>
<li>捕获的局部变量\常量就是对象的成员（存储属性）</li>
<li>组成闭包的函数就是类内部定义的方法</li>
</ul>
</li>
</ul>
<h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><blockquote>
<p>自动闭包的参数会延迟执行，甚至不执行</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getfirstPositive</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span>? &#123;<br>    <span class="hljs-keyword">return</span> v1 <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">?</span> v1 : v2 ()<br>&#125;<br>getFirstPositive(<span class="hljs-operator">-</span><span class="hljs-number">4</span>, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>@autoclosure</code> 会自动将<code>20</code> 封装成闭包<code>&#123; 20 &#125;</code></li>
<li><code>@autoclosure</code> 只支持<code>()一＞T</code>格式的参数</li>
<li>空合并运算符<code>??</code>使用了<code>@autoclosure</code> 技术<ul>
<li><code>func ?? &lt;T&gt;(optional:T?,defaultValue:@autoclosure() throws -&gt; T?) rethrows -&gt; T?</code></li>
</ul>
</li>
<li>有<code>@autoclosure</code>、无<code>@autoclosure</code>，构成了函数重载</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>结构体与类</title>
    <url>/2023/02/26/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="结构体是值类型（枚举也是值类型），类是引用类型（指针类型）"><a href="#结构体是值类型（枚举也是值类型），类是引用类型（指针类型）" class="headerlink" title="结构体是值类型（枚举也是值类型），类是引用类型（指针类型）"></a>结构体是值类型（枚举也是值类型），类是引用类型（指针类型）</h1><ul>
<li>例子<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> width <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> height <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-keyword">var</span> y <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> size <span class="hljs-operator">=</span> <span class="hljs-type">Size</span>()<br>    <span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>执行<code>test()</code>方法时的内存地址,(<code>64</code>位)<br><img src="1.png"><ul>
<li>内存地址由<code>高</code>到<code>低</code>在栈中赋值，结构体直接存储在<code>栈</code>上，类在<code>栈</code>上存的是<code>8</code>字节的<code>指针地址</code></li>
<li>堆空间的<code>Size</code>对象占<code>32</code>位，其中<code>16</code>位存<code>width</code>，<code>height</code>数据，<code>8</code>位存<code>引用计数</code>，<code>8</code>位<code>类型信息</code>的地址</li>
</ul>
</li>
<li>注意，类的指针和结构体存的地方不一定在栈，<ul>
<li>如果在全局区生成，则类的指针和结构体在全局区，</li>
<li>如果结构体变量为类的属性，则会和该类一起在堆区生成</li>
<li>如果在函数内生成，则类的指针和结构体在栈区</li>
</ul>
</li>
</ul>
<h1 id="类和结构体的大小"><a href="#类和结构体的大小" class="headerlink" title="类和结构体的大小"></a>类和结构体的大小</h1><ul>
<li>类中用<code>MemoryLayout</code>获取的大小，实际是指针大小始终位<code>8</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Size</span>&gt;.stride) <span class="hljs-comment">// 8,Size指针变量因此是8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Point</span>&gt;.stride) <span class="hljs-comment">// 16，</span><br></code></pre></td></tr></table></figure></li>
<li>获取类内存中的指针数据<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> size <span class="hljs-operator">=</span> <span class="hljs-type">Size</span>()<br><span class="hljs-keyword">let</span> sizePoint <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(bitPattern: <span class="hljs-built_in">unsafeBitCast</span>(size, to: <span class="hljs-type">UInt</span>.<span class="hljs-keyword">self</span>))<span class="hljs-operator">!</span> <span class="hljs-comment">//存放在堆中的引用地址</span><br>malloc_size(sizePoint) <span class="hljs-comment">//32 获取堆中的内存数据大小</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="值类型赋值"><a href="#值类型赋值" class="headerlink" title="值类型赋值"></a>值类型赋值</h1><ul>
<li>值类型赋值给<code>var</code>、<code>let</code>或者给函数传参，是直接将所有内容拷贝一份</li>
<li>类似于对文件进行<code>copy</code>、<code>paste</code>操作，产生了全新的文件副本。属于深拷贝 ( <code>deep copy</code> )</li>
</ul>
<h2 id="结构体的Copy-on-Write"><a href="#结构体的Copy-on-Write" class="headerlink" title="结构体的Copy on Write"></a>结构体的Copy on Write</h2><ul>
<li>在<code>swift</code>标准库中，为了提升性能，<code>String</code>、<code>Array</code>、<code>Dictionary</code>、<code>set</code>采取了<code>Copy On Write</code>的技术<ul>
<li>比如仅当有<code>“写</code>〞操作时 ，才会真正执行拷贝操作</li>
<li>对于标准库值类型的赋值操作 ，<code>Swift</code> 能确保最佳性能，所有没必要为了<code>保证最佳性能来避免赋值</code><ul>
<li>如果是非标准库的结构体，是<strong>不会</strong>有写时拷贝的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="引用类型赋值"><a href="#引用类型赋值" class="headerlink" title="引用类型赋值"></a>引用类型赋值</h2><ul>
<li>引用赋值给<code>var</code>、 <code>let</code>或者给函数传参，是将内存地址拷贝一份</li>
<li>类似于制作一个文件的替身（快捷方式、链接），指向的是同一个文件。属于浅拷贝 (<code>shallow copy</code>)</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>汇编基本认识，x86汇编</title>
    <url>/2023/02/25/iOS%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>软件、程序的执行过程<br><img src="1.png"></li>
<li>通常，cpu会将内存中的数据存储到寄存器中，然后再对寄存器中的数据进行计算</li>
<li>假设内存中有块<code>红色内存空间</code>的值是3，现在想把它的值加1，并将结果存储到<code>蓝色内存空间</code><ul>
<li>CPU首先会将<code>红色内存空间</code>的值放到<code>rax寄存器</code>中: <code>movq</code> <code>红色内存空间</code>, <code>%rax</code></li>
<li>然后让rax寄存器与1相加，送回到rax中：<code>addq</code> <code>$0x1</code>,<code>%rax</code>,</li>
<li>最后将值赋值给内存空间：<code>movq</code> <code>%rax</code>，<code>蓝色内存空间</code></li>
</ul>
</li>
<li>CPU不支持内存之间的改变，因此要通过寄存器，并且寄存器内操作，速度要快些<h3 id="语言发展"><a href="#语言发展" class="headerlink" title="语言发展"></a>语言发展</h3></li>
</ul>
<ol>
<li>机器语言<ul>
<li>由0和1组成</li>
</ul>
</li>
<li>汇编语言( Assembly Language )<ul>
<li>用符号代替了O和1，比机器语言便于阅读和记忆</li>
</ul>
</li>
<li>高级语言<ul>
<li>C\C++\java\javaScript\Python等，更接近人类自然语言</li>
</ul>
</li>
</ol>
<ul>
<li>例如，将寄存器BX的内容送入奇存器AX<ul>
<li>机器语言：1000100111011000</li>
<li>汇编语言：movw %bx, %ax</li>
<li>高级语言：ax = bx;</li>
</ul>
</li>
<li>汇编语言与机器语言一一对应，但是高级语言和汇编语言不是一一对应的</li>
<li>汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言</li>
<li>高级语言可以通过编译得到;汇编语言\机器语言 ，但汇编语言\机器语言几乎不可能还原成高级语言</li>
<li>iOS中，主要的汇编语言是<ul>
<li>AT&amp;T汇编 -＞ ioS模拟器</li>
<li>ARM汇编 -＞ ioS真机设备</li>
</ul>
</li>
</ul>
<h3 id="常见的x86汇编指令"><a href="#常见的x86汇编指令" class="headerlink" title="常见的x86汇编指令"></a>常见的x86汇编指令</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="left">AT&amp;T</th>
<th>Intel</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器命名</td>
<td align="left">%rax</td>
<td>rax</td>
<td align="left"></td>
</tr>
<tr>
<td>操作数顺序</td>
<td align="left">movq %rax, %rdx</td>
<td>mov rdx, rax</td>
<td align="left">将rax的值赋值给rdx</td>
</tr>
<tr>
<td>常数\立即数</td>
<td align="left">movq <code>$3</code>, <code>%rax</code> ;movq <code>$0x10</code>, %rax</td>
<td>mov rax, 3   ;  mov rax, 0x10</td>
<td align="left">将3赋值给rax;  将Ox10赋值给rax,(带$符号的都是立即数，即常数)</td>
</tr>
<tr>
<td>内存赋值</td>
<td align="left">movq $0xa, 0x1ff7(%rip)</td>
<td>mov qword ptr [rip+0x1ff7],     0xa</td>
<td align="left">将0xa赋值给地址为rip +0x1ff7的内存空间（注意执行指令，<code>rip</code>中存放了下一条指令的地址,因此此时相加的是与下一条指令相加的地址）</td>
</tr>
<tr>
<td>取内存地址</td>
<td align="left">leaq -0x18(%rbp), %rax</td>
<td>lea rax, [rbp - 0x181]</td>
<td align="left">将rbp-0x18这个地址值赋值给rax</td>
</tr>
<tr>
<td>jmp指令</td>
<td align="left">jmp *%rdx; jmp 0×4001002; jmp *(%rax)</td>
<td>jmp rdx ;jmp 0×4001002;jmp [rax]</td>
<td align="left">jmp 0×4001002 ，跳到指定内存地址，去执行代码。  jmp *%rdx  间接跳转rdx的地址</td>
</tr>
<tr>
<td>call 指令</td>
<td align="left">call 0x19001632               call *%rdx</td>
<td>callq 0x19001632              call   %rdx</td>
<td align="left">跳转到函数地址进行执行，会和retq(会返回当初callq调用的下一个指令)配和使用，和jmp不同</td>
</tr>
<tr>
<td>操作数长度</td>
<td align="left">movl %eax, %edx; movb $0x10, %al; leaw 0x10(%d×), %ax</td>
<td>mov edx, eax;mov al, 0x10;lea ax, [dx + 0x10]</td>
<td align="left">b = byte (8-bit) ;s = short (16-bit integer or 32-bit floating point) ;W = word (16-bit);I = long (32-bit integer or 64-bit floating point);q = quad (64 bit);t = ten bytes (80-bit floating point)</td>
</tr>
</tbody></table>
<ul>
<li>操作数长度，代表要覆盖的长度，列如<code>movq 0xa, (0x110)</code>,将0xa存放在0x110地址中(考虑大小端存放)，占8字节（q为64位），而<code>movw 0xa, (0x110)</code>,表示占2字节（w为16位）</li>
<li><strong>注意</strong>，带括号的指地址上的内存，<ul>
<li><code>movq $0xa, 0x1ff7(%rip)</code>,将<code>$0xa</code>赋值给<code>0x1ff7(%rip)</code>地址上的内存空间</li>
<li> <code>movq %rax, %rdx</code>，将<code>rax</code>赋值给<code>rdx</code></li>
</ul>
</li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul>
<li>寄存器命名特点<ul>
<li>r开头：64bit,8字节</li>
<li>e开头: 32bit,4字节</li>
<li>ax,bx,cx: 2字节</li>
<li>ah al:8bit 1字节</li>
</ul>
</li>
<li>iOS中为64位寄存器，但是也有其他低位寄存器，会拿出一半来做4字节及一下的寄存器，其内存是共用的</li>
</ul>
<p><img src="2.png"></p>
<ul>
<li>寄存器只能存储8个字节的，像对象都是存在堆中的 </li>
<li>常用有16个常用寄存器<ul>
<li>rax、rbx rex、rdx、rsi、rdi、rbp、 rsp</li>
<li>r8.r9. r10.r11、 r12、r13、rl4、r15</li>
</ul>
</li>
<li>寄存器的具体用途<ol>
<li><code>rax</code>、<code>rdx</code>常作为函数返回值使用</li>
<li><code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>等奇存器常用于存放函数参数，参数过多，寄存器不够，则会放到栈中</li>
<li><code>rsp</code>、<code>rbp</code>用于栈操作,用来存在栈空间的地址值<ul>
<li>函数中，一般<code>rbp</code>和<code>rsp</code>之间用来存局部变量的，其他地方（<code>rbp</code>上方x或<code>rsp</code>下方）存放函数参数(在2中寄存器不够了，就会放到栈中)</li>
</ul>
</li>
<li><code>rip</code>作为指令指针<ul>
<li>存储着<code>CPU</code>下一条要执行的指令的地址</li>
<li>，一旦<code>CPU</code>读取一条指令，<code>rip</code>会自动指向下一条指令（存储下一条指令的地址）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h4><ul>
<li>内存地址格式为：<code>0x4bdc(%rip)</code>，一般是全局变量 ，全局区（数据段）</li>
<li>内存地址格式为：<code>-0x78（%rbp</code>），一般是局部变量，栈空间</li>
<li>内存地址格式为：<code>0x10（%rax)</code>，一般是堆空间</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举内存分析</title>
    <url>/2023/02/25/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="内存查看"><a href="#内存查看" class="headerlink" title="内存查看"></a>内存查看</h2><blockquote>
<p><code>view Memory</code>功能，查看地址中存放的内存</p>
</blockquote>
<ul>
<li><p>查看效果<br><img src="1.png"></p>
</li>
<li><p>地址内存查看方式，<code>iOS</code>是小端模式，高高低低，高地址存高位，低地址存低位</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">上面<span class="hljs-number">8</span>个字节实际上是<br><span class="hljs-number">0x00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span><br></code></pre></td></tr></table></figure></li>
<li><p>获取枚举的地址方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1 <br><span class="hljs-keyword">let</span> nums <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>t) &#123; <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>) &#125; <span class="hljs-comment">//内存地址 0x000000010000c0b0</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="普通枚举"><a href="#普通枚举" class="headerlink" title="普通枚举"></a>普通枚举</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum</span> </span>&#123; <br>    <span class="hljs-keyword">case</span> test1,test2,test3,test4,test5,test6<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.size) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.stride) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.alignment) <span class="hljs-comment">// 1</span><br><br><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1<br>t <span class="hljs-operator">=</span> .test5<br>t <span class="hljs-operator">=</span> .test6<br></code></pre></td></tr></table></figure>
<ul>
<li>内存情况,占用<code>1</code>字节内存,第一个枚举是<code>00</code>,后面依次增加，其内存最大是<code>0xFF</code>预计最大可以有枚举数<code>256</code>个（这么大的数量无需用枚举了）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1 <span class="hljs-comment">// 0x00</span><br>t <span class="hljs-operator">=</span> .test5  <span class="hljs-comment">// 0x04</span><br>t <span class="hljs-operator">=</span> .test6  <span class="hljs-comment">// 0x05</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="带原始值的枚举"><a href="#带原始值的枚举" class="headerlink" title="带原始值的枚举"></a>带原始值的枚举</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum</span>:<span class="hljs-title">Int</span> </span>&#123; <br>    <span class="hljs-keyword">case</span> test1 <span class="hljs-operator">=</span> <span class="hljs-number">10</span>,test2,test3,test4,test5,test6<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.size) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.stride) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.alignment) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<ul>
<li>内存情况,占用<code>1</code>字节内存。其内存情况和普通枚举类型一样的，其原始值不占有内存空间，类似计算属性<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1 <span class="hljs-comment">// 0x00</span><br>t <span class="hljs-operator">=</span> .test5  <span class="hljs-comment">// 0x04</span><br>t <span class="hljs-operator">=</span> .test6  <span class="hljs-comment">// 0x05</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="带关联值的枚举"><a href="#带关联值的枚举" class="headerlink" title="带关联值的枚举"></a>带关联值的枚举</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum</span> </span>&#123; <br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>),test2(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>),test3(<span class="hljs-type">Int</span>),test4(<span class="hljs-type">Bool</span>),test5,test6<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.size) <span class="hljs-comment">// 25</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.stride) <span class="hljs-comment">// 32</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.alignment) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>内存情况,实际占用<code>25</code>个字节，内存对齐是<code>32</code>个字节。对于存储情况，以最大存储<code>3</code>个<code>Int</code>，为<code>24</code>字节，前面的<code>24</code>个字节均用来存储关联值的（不管当前实际关联值大小是<code>1</code>个字节，还是<code>16</code>个字节），最高位用来存储枚举的类型（普通枚举不一样）。</p>
<ul>
<li>内存从右到左，从上到下，内存地址增加</li>
<li>关联值和非关联值，枚举的标志位存放的位置是不一样的，类似共用体<ul>
<li>非关联值排在前面，普通枚举排在后面<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//占用内存情况</span><br><span class="hljs-comment">//10 00 00 00 00 00 00 00  //实际为 0x10</span><br><span class="hljs-comment">//02 00 00 00 00 00 00 00  //实际为 0x02</span><br><span class="hljs-comment">//03 00 00 00 00 00 00 00  //实际为 0x03</span><br><span class="hljs-comment">//00 </span><br><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <br><span class="hljs-comment">//占用内存情况</span><br><span class="hljs-comment">//04 00 00 00 00 00 00 00  //实际为 0x04</span><br><span class="hljs-comment">//05 00 00 00 00 00 00 00  //实际为 0x05</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00  </span><br><span class="hljs-comment">//01                       //实际为 0x01</span><br>t <span class="hljs-operator">=</span> .test2(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <br> <span class="hljs-comment">//占用内存情况</span><br><span class="hljs-comment">//01 00 00 00 00 00 00 00  //实际为 0x01</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00  </span><br><span class="hljs-comment">//03                       //实际为 0x03</span><br>t <span class="hljs-operator">=</span> .test4(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">//占用内存情况</span><br><span class="hljs-comment">//10 00 00 00 00 00 00 00  //第一位标识位是1，表明第二个普通的枚举</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00  </span><br><span class="hljs-comment">//04                      //实际为 0x04而非按顺序的0x05, 这表明总共有4个关联枚举？</span><br>t <span class="hljs-operator">=</span> .test6<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>最后一个值为<code>bool</code>类型，则实际尺寸仍然是<code>25</code>字节，<code>bool</code>和<code>枚举的标识位</code>混用，并且有关联类型的标识符和普通的标识符号顺序不同。但是中间有<code>bool</code>，实际占用是<code>32</code>字节。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//实际占用25字节</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum2</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> test4(<span class="hljs-type">Bool</span>) <br>    <span class="hljs-keyword">case</span> test5 <br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Bool</span>)<br>    <span class="hljs-keyword">case</span> test2(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> test3(<span class="hljs-type">Int</span>)<br>&#125;<br><br><span class="hljs-comment">//实际占用32字节</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum2</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> test4(<span class="hljs-type">Bool</span>) <br>    <span class="hljs-keyword">case</span> test5 <br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Bool</span>,<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> test2(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> test3(<span class="hljs-type">Int</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>注意如果只有一个项的关联值，其内存不会算上枚举自身的<code>1</code>字节<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNUm</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNUm</span>&gt;.size) <span class="hljs-comment">//24</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNUm</span>&gt;.stride) <span class="hljs-comment">//24</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNUm</span>&gt;.alignment) <span class="hljs-comment">//24</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="switch匹配"><a href="#switch匹配" class="headerlink" title="switch匹配"></a>switch匹配</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum</span> </span>&#123; <br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>),test2(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>),test3(<span class="hljs-type">Int</span>),test4(<span class="hljs-type">Bool</span>),test5,test6<br>&#125;<br><br><span class="hljs-comment">//实际大小是25</span><br><span class="hljs-keyword">var</span> e <span class="hljs-operator">=</span> <span class="hljs-type">TestEnum</span>.test1(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)<br><span class="hljs-comment">//取出标识位去判断，这里是第25位</span><br><span class="hljs-keyword">switch</span> e &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .test1(v1,v2,v3): <span class="hljs-comment">//判断25位是0，取出前24个字节进行赋值</span><br>        <span class="hljs-built_in">print</span>(v1,v2,v3)<br>     <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .test2(v1,v2): <span class="hljs-comment">//判断25位是1，取出前16个字节进行赋值</span><br>        <span class="hljs-built_in">print</span>(v1,v2,v3)<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>swift的枚举、可选项</title>
    <url>/2023/02/23/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E6%9E%9A%E4%B8%BE%E3%80%81%E5%8F%AF%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h1><ul>
<li>递归枚举，必须用<code>indirect</code>修饰<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ArithExpr</span></span>&#123;<br>    <span class="hljs-keyword">case</span> number(<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">indirect</span> <span class="hljs-keyword">case</span> sum(<span class="hljs-type">ArithExpr</span>,<span class="hljs-type">ArithExpr</span>)<br>    <span class="hljs-keyword">indirect</span> <span class="hljs-keyword">case</span> difference(<span class="hljs-type">ArithExpr</span>,<span class="hljs-type">ArithExpr</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="关联值和原始值的内存"><a href="#关联值和原始值的内存" class="headerlink" title="关联值和原始值的内存"></a>关联值和原始值的内存</h1><ul>
<li><p>原始值所分配的空间只有<code>1</code>个字节，不管他有无原始值。原始值一开始是决定好的，无法更改，因此没必要存储到内存中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Season1</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> spring,summer,autumn,winter<br>&#125;<br><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season1</span>&gt;.stride <span class="hljs-comment">//1  分配占用的空间大小</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season1</span>&gt;.size   <span class="hljs-comment">// 1 实际用到的空间大小</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season1</span>&gt;.alignment  <span class="hljs-comment">// 1 对齐的参数</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Season</span>:<span class="hljs-title">Int</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> spring <span class="hljs-operator">=</span> <span class="hljs-number">100</span>,summer <span class="hljs-operator">=</span> <span class="hljs-number">200</span>,autumn <span class="hljs-operator">=</span> <span class="hljs-number">300</span>,winter <span class="hljs-operator">=</span> <span class="hljs-number">400</span><br>&#125;<br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season</span>&gt;.stride <span class="hljs-comment">//1  分配占用的空间大小</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season</span>&gt;.size   <span class="hljs-comment">// 1 实际用到的空间大小</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season</span>&gt;.alignment  <span class="hljs-comment">// 1 对齐的参数</span><br></code></pre></td></tr></table></figure></li>
<li><p>关联值中，以所占最大的关联值的内存为准。由于将来需要将关联值存储到枚举的<code>内存</code>内，因此需要分配内存。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Password</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> number(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) <span class="hljs-comment">// Int 4字节，加上枚举1个字节，实际33</span><br>    <span class="hljs-keyword">case</span> other<br>    <span class="hljs-keyword">case</span> bigNumer(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)<br>&#125;<br><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Password</span>&gt;.size <span class="hljs-comment">// 33</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Password</span>&gt;.alignment <span class="hljs-comment">// 8</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Password</span>&gt;.stride <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="多重可选项"><a href="#多重可选项" class="headerlink" title="多重可选项"></a>多重可选项</h1><ul>
<li><span id="jump1">示意图1</span><br><img src="1.png"><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> num2: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> num1<br><span class="hljs-keyword">var</span> num3: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(num2 <span class="hljs-operator">==</span> num3) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">print</span>(num1 <span class="hljs-operator">==</span> num2) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">print</span>(num2 <span class="hljs-operator">==</span> <span class="hljs-number">10</span>) <span class="hljs-comment">//true </span><br><span class="hljs-comment">//双重强制解包</span><br>num3<span class="hljs-operator">!!</span> <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></li>
<li><span id="jump2">示意图2</span><br><img src="2.png"><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span> <br><span class="hljs-keyword">var</span> num2: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> num1<br><span class="hljs-keyword">var</span> num3: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-built_in">print</span>(num2 <span class="hljs-operator">==</span> num3) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">print</span>(num1 <span class="hljs-operator">==</span> num2) <span class="hljs-comment">//true </span><br><span class="hljs-built_in">print</span>(num1 <span class="hljs-operator">==</span> num3) <span class="hljs-comment">//false </span><br>(num2 <span class="hljs-operator">??</span> <span class="hljs-number">1</span>) <span class="hljs-operator">??</span> <span class="hljs-number">2</span> <span class="hljs-comment">//2  num2解出来不为nil，是num1;num1解出来为nil，赋值2</span><br>(num3 <span class="hljs-operator">??</span> <span class="hljs-number">1</span>) <span class="hljs-operator">??</span> <span class="hljs-number">2</span> <span class="hljs-comment">//1  num3解出来为nil，则赋值1</span><br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="可选-的源码，"><a href="#可选-的源码，" class="headerlink" title="可选==的源码，"></a>可选<code>==</code>的源码，</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Optional</span> <span class="hljs-title">where</span> <span class="hljs-title">Wrapped</span>:<span class="hljs-title">Equatable</span> </span>&#123;<br>    <span class="hljs-comment">//这里在求等于时会保证两个类型一致</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">==</span>(<span class="hljs-params">lhs</span>: <span class="hljs-type">Wrapped</span>?, <span class="hljs-params">rhs</span>: <span class="hljs-type">Wrapped</span>?)</span> -&gt; <span class="hljs-type">Bool</span> &#123;<br>      <span class="hljs-keyword">switch</span> (lhs, rhs) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (l<span class="hljs-operator">?</span>, r<span class="hljs-operator">?</span>):<br>        <span class="hljs-keyword">return</span> l <span class="hljs-operator">==</span> r<br>      <span class="hljs-keyword">case</span> (<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在<a href="#jump1">示意1</a>中。<code>num1</code>会再包装一次，变成<code>Int??</code>,类比<code>Optional(Optional(10))</code>,两者的包装程度一致。像非<code>nil</code>参数再比较时，由于都会进行包装时其相等，因此只要满足参数相等，其可选就会相等。   <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> num2: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> num1<br></code></pre></td></tr></table></figure>
</li>
<li>在<a href="#jump2">示意2</a>中。<code>num1</code>会再包装一次，变成<code>Int??</code>，类比<code>Optional(nil)</code>,但是<code>num3</code>的值是<code>nil</code>已经满足了<code>Int??</code>类型的要求，因此是不一样的。而<code>num1</code>的值赋予给<code>num2</code>是，同样包装了一次，因此<code>num2</code>和<code>num3</code>是相等的都为<code>Optional(nil)</code>。</li>
</ul>
<h2 id="可选-的源码，-1"><a href="#可选-的源码，-1" class="headerlink" title="可选??的源码，"></a>可选<code>??</code>的源码，</h2>   <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">??</span> &lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-params">optional</span>: <span class="hljs-type">T</span>?, <span class="hljs-params">defaultValue</span>: <span class="hljs-keyword">@autoclosure</span> () <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">T</span>)</span><br>    <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-type">T</span> &#123;<br>  <span class="hljs-keyword">switch</span> <span class="hljs-keyword">optional</span> &#123;<br>  <span class="hljs-keyword">case</span> .some(<span class="hljs-keyword">let</span> value):<br>    <span class="hljs-keyword">return</span> value<br>  <span class="hljs-keyword">case</span> .none:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> defaultValue()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>下列例子中，同样，在使用<code>??</code>时，会返回传入参数解包一次的值,并且只会解包一次。</p>
<ul>
<li>由于<code>Int?</code> -&gt; <code>Int????</code>,类型是可以直接赋值的，因此可以这么判断</li>
<li>而<code>Int????</code> -&gt; <code>Int?</code>,是没办法赋值的，在编译器中会按<code>Any</code>处理<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num:<span class="hljs-type">Int</span>??? <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-comment">//传入参数是Int???，最后返回是Int??</span><br><span class="hljs-comment">// num1 = num // 无法赋值</span><br><span class="hljs-built_in">print</span>(num <span class="hljs-operator">??</span> num1) <span class="hljs-comment">// Optional(Optional(1))</span><br><br>num <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-comment">//传入参数是Int???，最后返回是Int??，这会对num1进行包装</span><br><span class="hljs-built_in">print</span>(num <span class="hljs-operator">??</span> num1) <span class="hljs-comment">// Optional(Optional(2))</span><br><span class="hljs-comment">// </span><br><br>num <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> num3:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>num3 <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br> <span class="hljs-built_in">print</span>(num3 <span class="hljs-operator">??</span> num) <span class="hljs-comment">//Optional(Optional(Optional(1)))</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可以使用<code>lldb</code>指令<code>frame variable -R</code>或者<code>fr v -R</code>查看结构</p>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>枚举、可选项</tag>
      </tags>
  </entry>
  <entry>
    <title>swift的函数</title>
    <url>/2023/02/22/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="inout"><a href="#inout" class="headerlink" title="inout"></a><code>inout</code></h1><h2 id="inout的函数"><a href="#inout的函数" class="headerlink" title="inout的函数"></a><code>inout</code>的函数</h2><blockquote>
<p>是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）</p>
</blockquote>
<ul>
<li>汇编验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-type">Int</span>)</span> &#123;<br> <br> &#125;<br> <span class="hljs-comment">// movq 值传递 %rbp - 0x20的地址中取值,传给方法</span><br><span class="hljs-number">0x100003f70</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">64</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100003f74</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">68</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003f90</span>               ;  <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">11</span><br><span class="hljs-number">0x100003f79</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">73</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br><span class="hljs-number">0x100003f7b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">75</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x20, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100003f7f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">79</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x100003f80</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">80</span><span class="hljs-operator">&gt;</span>: retq <br> <br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br> <br> &#125;<br> <br> <span class="hljs-comment">// leaq 地址传递 %rbp - 0x20的地址传到 %rdi,且在callq后面，并没有movq赋值操作</span><br><span class="hljs-number">0x100003f6c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">44</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0x408d</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.num : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span><br><span class="hljs-number">0x100003f73</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">51</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003f90</span>               ; <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-keyword">inout</span> <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">11</span><br><span class="hljs-number">0x100003f78</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">56</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100003f7c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">60</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003fa8</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_endAccess<br><span class="hljs-number">0x100003f81</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">65</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br><span class="hljs-number">0x100003f83</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">67</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x20, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100003f87</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">71</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x100003f88</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">72</span><span class="hljs-operator">&gt;</span>: retq  <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="inout-函数存在的独占访问权限"><a href="#inout-函数存在的独占访问权限" class="headerlink" title="inout 函数存在的独占访问权限"></a><code>inout</code> 函数存在的独占访问权限</h2><ul>
<li>下面均会出现<code>imultaneous accesses to 0x100008178, but modification requires exclusive access</code>崩溃异常<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&lt;!--</span>第一种<span class="hljs-operator">--&gt;</span><br><span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-params">nu</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    nu <span class="hljs-operator">+=</span> <span class="hljs-number">3</span><br>    <span class="hljs-built_in">print</span>(num) <span class="hljs-comment">// 读同一个地址的num会崩溃</span><br>    <span class="hljs-comment">//num += 10 // 写同一个地址的num也会崩溃</span><br>&#125;<br>test(nu: <span class="hljs-operator">&amp;</span>num)<br><span class="hljs-operator">&lt;!--</span>第二种<span class="hljs-operator">--&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNum</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> i:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <br>&#125;<br><br><span class="hljs-keyword">let</span> testNum <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-params">i</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123; <br>    i <span class="hljs-operator">+=</span> <span class="hljs-number">3</span><br>    <span class="hljs-built_in">print</span>(testNum.i) <span class="hljs-comment">// 读同一个地址的num会崩溃</span><br>    <span class="hljs-comment">//testNum.i += 10 // 写同一个地址的num也会崩溃</span><br>&#125;<br>test(i: <span class="hljs-operator">&amp;</span>testNum.i)<br></code></pre></td></tr></table></figure></li>
<li>当一个变量访问同一块内存时，会产生独占内存访问权限冲突</li>
</ul>
<h2 id="计算型属性或者一个具有属性观察器的属性调用inout时"><a href="#计算型属性或者一个具有属性观察器的属性调用inout时" class="headerlink" title="计算型属性或者一个具有属性观察器的属性调用inout时"></a>计算型属性或者一个具有属性观察器的属性调用inout时</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNum</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> j:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> i:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;get&quot;</span>)<br>            <span class="hljs-keyword">return</span> j<br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set&quot;</span>)<br>            j <span class="hljs-operator">=</span> newValue<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">let</span> actNum <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-params">i</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始&quot;</span>)<br>    i <span class="hljs-operator">+=</span> <span class="hljs-number">3</span><br>    actNum.i <span class="hljs-operator">+=</span> <span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(actNum.i)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束&quot;</span>)<br>&#125;<br>test(i: <span class="hljs-operator">&amp;</span>actNum.i)<br><span class="hljs-built_in">print</span>(actNum.i)<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">get</span><br><span class="hljs-comment">开始</span><br><span class="hljs-comment">get</span><br><span class="hljs-comment">set</span><br><span class="hljs-comment">get</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">结束</span><br><span class="hljs-comment">set</span><br><span class="hljs-comment">get</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>在<code>test</code>方法内部同时使用<code>&amp;actNum.i</code>和<code>actNum.i</code>并未出现<code>独占内存访问权限冲突</code>,造成这种情况出现的原因实际上和设置了属性观察器有关,并且在方法内部设置的值<code>10</code>，最后输出的时候，仍为<code>3</code>。<ul>
<li>表明方法内部的<code>i</code>,和<code>actNum.i</code>并非同一个，因此没有出现独占内存。并且在方法结束后，会重新赋值给<code>actNum.i</code>这种行为叫做<code>拷入拷出</code>或者<code>值结果调用</code>。具体见<code>属性那章</code></li>
<li><code>拷入拷出</code>遵循如下规则：<ol>
<li>函数调用时，参数的值被拷贝。</li>
<li>函数体内部，拷贝后的值被修改。</li>
<li>函数返回后，拷贝后的值被赋值给原参数。</li>
</ol>
</li>
<li>可以认为在调用函数前，先创建了一个值<code>x</code>，并将调用<code>get</code>方法将<code>actNum.i</code>赋值给<code>x</code>，这是在函数中进行的<code>inout</code>操作是<code>x</code>，在函数结束后，调用<code>set</code>方法，将<code>x</code>的值赋予给<code>actNum.i</code></li>
</ul>
</li>
<li><strong>注意</strong>，<ul>
<li>计算属性，只适用于<code>类</code>，如果是<code>结构体</code>(生成局部变量的内存和值在一块，仍处于同一块内存)，仍然会报错。</li>
<li>有属性观察器的存储属性的<code>类</code>，<ul>
<li>有包含<code>willSet</code>，则不会报错</li>
<li>如果没有<code>willSet</code>,其<code>didSet</code>一定要有<code>oldValue</code>局部变量，否则也会报错。(因为不加的话，编译器不会生成局部变量，来避免内存冲突。经过都是调用完方法后，再进行赋值的)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote>
<ul>
<li>规则<ul>
<li>函数名相同</li>
<li>参数个数不同 或者 参数类型不同 或者 参数标签不同</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>注意</strong>,重载和返回值类型无关。但是如果指定类型，则不会报错<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">40</span><br>    <span class="hljs-keyword">return</span> num<br>&#125;<br><span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> num2:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> test(<span class="hljs-operator">&amp;</span>num) <span class="hljs-comment">//不会报错</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span><span class="hljs-operator">=</span> test(<span class="hljs-operator">&amp;</span>num) <span class="hljs-comment">//会报错,无法分清</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，默认参数和函数重载一起使用产生二义性时，编译器不会报错（在<code>C++</code>中会报错）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>,<span class="hljs-params">type</span>:<span class="hljs-type">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>)</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">40</span><br>&#125;<br><span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-comment">//会调用test(_ num: inout Int)</span><br>test(<span class="hljs-operator">&amp;</span>num) <span class="hljs-comment">// num = 40</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,可变参数、省略参数标签、函数重载一起使用参数二义性时，编译器有可能会报错（避免这种情况）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//第一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-type">Int</span>,<span class="hljs-params">num2</span>:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>)</span> &#123;<br>    <br>&#125;<br><span class="hljs-comment">//第二</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">num2</span>:<span class="hljs-type">Int</span>)</span> &#123;<br>   <br>&#125;<br><span class="hljs-comment">//第三</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>:<span class="hljs-type">Int</span>...)</span> &#123;<br>    <br>&#125;<br><span class="hljs-comment">//编译起报错，但是屏蔽第一个代码，就不会报错了</span><br>test(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul>
<li>如果开启了编译器优化（<code>Release</code>模式默认会开启优化）(<code>buildSetting</code>中的<code>optimization</code>)，编译器会自动将某些函数变成内联函数<ul>
<li>将函数调用展开成函数体</li>
</ul>
</li>
<li>哪些函数不会被自动内联<ul>
<li>函数体比较长</li>
<li>包含递归调用</li>
<li>包含动态派发（无法在编译的时候确定是谁调用的）</li>
</ul>
</li>
<li><code>@inline</code>,内联注解， <code>Apple</code> 的文档中是找不到，不建议使用<ul>
<li><code>@inline(__always) func test(i:Int) &#123;  &#125;</code>,开启编译优化后，即使代码很长也会被内联（递归调用,动态派发除外）</li>
<li><code>@inline(never) func test(i:Int) &#123;  &#125;</code>,永远不会被内联，即使开启了编译器优化（有时不起作用,还是会转为内联）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>swift的基础语法</title>
    <url>/2023/02/20/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>记录下<code>swfit</code>的基础不同的语法</p>
</blockquote>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>只能赋值<code>1</code>次</li>
<li>它的值不要求在编泽时期确定，但使用之前必须赋值<code>1</code>次</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>标识符（比如常量名、变量名、函数名）几乎可以使用任何字符</li>
<li>标识符不能以数字开头，不能包含空白字符、制表符、節头等特殊字符</li>
</ul>
<h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><blockquote>
<p>只有<strong>值类型</strong>和<strong>引用类型</strong>，以前语言中的<code>Int</code>，<code>Bool</code>均为<strong>结构体</strong>，而非<strong>基础数据类型</strong></p>
</blockquote>
<p><img src="1.png"></p>
<ul>
<li>整数类型：<code>Int8</code>、 <code>Int16</code>、 <code>Int32</code>、<code>Int64</code>、<code>UInt8</code>、 <code>UInt16</code>、 <code>UInt32</code>、<code>UInt64</code></li>
<li>在<code>32bit</code>平台，<code>Int</code>等价于<code>Int32</code>；在<code>64bit</code>平台，<code>Int</code>等价于<code>Int64</code></li>
<li>整数的最值：<code>UInt8.max</code>、 <code>Int16. min</code></li>
<li>目一般情况下，都是直接使用<code>Int</code>即可</li>
<li>浮点类型：<code>Float</code> ，<code>32位</code>，精度只有<code>6位</code>；<code>Double</code>，<code>64位</code>，精度至少<code>15位</code></li>
</ul>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ul>
<li>字面量<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//整数</span><br><span class="hljs-keyword">let</span> intDecimal <span class="hljs-operator">=</span> <span class="hljs-number">17</span><span class="hljs-comment">//十进制</span><br><span class="hljs-keyword">let</span> intBinary <span class="hljs-operator">=</span> <span class="hljs-number">0b10001</span> <span class="hljs-comment">// 二进制</span><br><span class="hljs-keyword">let</span> intoctal <span class="hljs-operator">=</span> <span class="hljs-number">0o21</span> <span class="hljs-comment">//八进制</span><br>llet intHexadecimal <span class="hljs-operator">=</span> <span class="hljs-number">0x11</span><span class="hljs-comment">//十六进制</span><br><br><span class="hljs-comment">//浮点数</span><br><span class="hljs-keyword">let</span> doubleDecimal <span class="hljs-operator">=</span> <span class="hljs-number">125.0</span> <span class="hljs-comment">//十进制，等价于1.25e2，日.0125等价于1.25e-2</span><br><span class="hljs-comment">//只有十六进制可以这么写</span><br><span class="hljs-keyword">let</span> doubleHexadecimal1<span class="hljs-operator">=</span> <span class="hljs-number">0xFp2</span> <span class="hljs-comment">//十六进制，意味着15x2^2，相当于十进制的68.0</span><br><span class="hljs-keyword">let</span> doubleHe xadecima12 <span class="hljs-operator">=</span><span class="hljs-number">0xFp-2</span> <span class="hljs-comment">// 十六进制，意味着15x2^-2，相当于十进制的3.75</span><br></code></pre></td></tr></table></figure></li>
<li>类型转换<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//字面量可以直接相加，因为数字字面量本身没有明确的类型</span><br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-operator">+</span> <span class="hljs-number">0.14156</span> <span class="hljs-comment">//不会报错</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul>
<li><code>for</code>遍历值作为变量 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//i默认是let，有需要时可以声明为var，但是该变量只能单个for中变化,下一次又会重新赋值</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">3</span> &#123;<br>    <span class="hljs-built_in">print</span>(i)<br>    i <span class="hljs-operator">+=</span> <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-comment">//输出 1、2、3</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="区间运算"><a href="#区间运算" class="headerlink" title="区间运算"></a>区间运算</h2><ul>
<li>区间运算  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> names <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> names[<span class="hljs-number">2</span><span class="hljs-operator">...</span><span class="hljs-number">3</span>] &#123;<br>    <span class="hljs-built_in">print</span>(n)<br>&#125;<br><span class="hljs-comment">//输出 c d</span><br></code></pre></td></tr></table></figure></li>
<li>单侧区间:让区间朝一个方向尽可能远  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> names[<span class="hljs-number">1</span><span class="hljs-operator">...</span>] &#123;<br>    <span class="hljs-built_in">print</span>(n)<br>&#125;<br><span class="hljs-comment">//输出 b c d</span><br><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> names[<span class="hljs-operator">..&lt;</span><span class="hljs-number">2</span>] &#123;<br>    <span class="hljs-built_in">print</span>(n)<br>&#125;<br><span class="hljs-comment">//输出 a b</span><br><span class="hljs-comment">//3到正无穷，但是...3不能用for</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">3</span><span class="hljs-operator">...</span> &#123;<br>    <span class="hljs-built_in">print</span>(i)<br>&#125;<br><br><span class="hljs-keyword">let</span> rang:<span class="hljs-type">PartialRangeThrough</span>&lt;<span class="hljs-type">Int</span>&gt; <span class="hljs-operator">=</span> <span class="hljs-operator">...</span><span class="hljs-number">3</span> <span class="hljs-comment">//负无穷到3，不能用于for</span><br></code></pre></td></tr></table></figure></li>
<li>字符串、字符也能包含区间，但是不能用于<code>for</code>  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> stringRang <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cc&quot;</span><span class="hljs-operator">...</span><span class="hljs-string">&quot;ff&quot;</span><br>stringRang.contains(<span class="hljs-string">&quot;dz&quot;</span>) <span class="hljs-comment">//true</span><br>str.contains(<span class="hljs-string">&quot;fg&quot;</span>) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li>
<li>带间隔的区间值  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//从4开始，累加2，&lt;=12</span><br><span class="hljs-keyword">for</span> tickMark <span class="hljs-keyword">in</span> <span class="hljs-built_in">stride</span>(from: <span class="hljs-number">4</span>, through: <span class="hljs-number">12</span>, by: <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>,tickMark)<br>&#125;<br><span class="hljs-comment">//输出 4 6 8 10 12</span><br><span class="hljs-comment">//从4开始，累加2，&lt;12</span><br><span class="hljs-keyword">for</span> tickMark <span class="hljs-keyword">in</span> <span class="hljs-built_in">stride</span>(from: <span class="hljs-number">4</span>, to: <span class="hljs-number">12</span>, by: <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>,tickMark)<br>&#125;<br><span class="hljs-comment">//输出 4 6 8 10</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>swift的编译</title>
    <url>/2023/02/20/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="swift的编译"><a href="#swift的编译" class="headerlink" title="swift的编译"></a>swift的编译</h3><p><img src="2.png"><br><img src="1.png"></p>
<ul>
<li>OC前端采用<code>Clang</code>，<code>swift</code>的前端采用的是<code>swiftc</code>,swift编译时会生成swift的中间代码<code>SIL</code>，对代码进行优化之后，在转换成<code>IR</code>,它们的后端均为<code>LLVM</code></li>
</ul>
<h3 id="swift语法"><a href="#swift语法" class="headerlink" title="swift语法"></a>swift语法</h3><ul>
<li>一些操作<ul>
<li>生成语法树：<code>swiftc -dump-ast main.swift</code></li>
<li>生成最简洁的SIL代码：<code>swiftc -emit-sil main.swift</code></li>
<li>生成LLVM IR代码：<code>swiftc -emit-ir main.swift -o main.ll</code></li>
<li>口生成汇编代码：<code>swiftc -emit-assembly main.swift -o main.s</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>安装包瘦身</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>安装包（IPA）主要由可执行文件、资源组成</p>
</blockquote>
<ul>
<li>资源（图片、音频、视频等）<ul>
<li>采取无损压缩</li>
<li>去除没有用到的资源： <a href="https://github.com/tinymind/LSUnusedResources">地址</a></li>
</ul>
</li>
<li>可执行文件瘦身<ul>
<li><code>Strip Linked Product</code>、<code>Make Strings Read-Only</code>、<code>Symbols Hidden by Default</code>设置为<code>YES</code></li>
<li>去掉异常支持，<code>Enable C++ Exceptions</code>、<code>Enable Objective-C Exceptions</code>设置为<code>NO</code>， <code>Other C Flags</code>添加<code>-fno-exceptions</code></li>
</ul>
</li>
<li>利用<a href="https://www.jetbrains.com/objc/">AppCode</a>检测未使用的代码：<code>菜单栏 -&gt; Code -&gt; Inspect Code</code></li>
<li>编写<code>LLVM插件</code>检测出重复代码、未被调用的代码</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>启动优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="APP的启动"><a href="#APP的启动" class="headerlink" title="APP的启动"></a>APP的启动</h2><ul>
<li><code>APP</code>的启动可以分为2种<ul>
<li>冷启动（<code>Cold Launch</code>）：从零开始启动<code>APP</code></li>
<li>热启动（<code>Warm Launch</code>）：<code>APP</code>已经在内存中，在后台存活着，再次点击图标启动<code>APP</code></li>
<li><code>APP</code>启动时间的优化，主要是针对冷启动进行优化</li>
</ul>
</li>
<li><code>APP</code>的冷启动可以概括为<code>3</code>大阶段<ul>
<li><code>dyld</code></li>
<li><code>runtime</code></li>
<li><code>main</code><br><img src="1.png"></li>
</ul>
</li>
</ul>
<h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3><ul>
<li><code>dyld（dynamic link editor）</code>，<code>Apple</code>的动态链接器，可以用来装载<code>Mach-O</code>文件（可执行文件、动态库等）</li>
<li>启动<code>APP</code>时，<code>dyld</code>所做的事情有<ul>
<li>装载<code>APP</code>的可执行文件，同时会递归加载所有依赖的动态库</li>
<li>当<code>dyld</code>把可执行文件、动态库都装载完毕后，会通知<code>Runtime</code>进行下一步的处理</li>
</ul>
</li>
</ul>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><ul>
<li>启动<code>APP</code>时，<code>runtime</code>所做的事情有<ul>
<li>调用<code>map_images</code>进行可执行文件内容的解析和处理<ul>
<li>例如类的解析<code>realizeClassWithoutSwift</code>（重新解析<code>Class</code>，初始化一些<code>flags</code>,初始化<code>class_rw_t</code>(一开始<code>data</code>中存的是<code>class_ro_t</code>,取出存入<code>class_rw_t</code>)并设置<code>data</code>）</li>
</ul>
</li>
<li>在<code>load_images</code>中调用<code>call_load_methods</code>，调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法<ul>
<li>还有<code>attachCategories</code>，将分类中的方法、属性、协议，加到<code>class_rw_t</code>中</li>
</ul>
</li>
<li>进行各种<code>objc</code>结构的初始化（注册<code>Objc</code>类 、初始化类对象等等）</li>
<li>调用<code>C++</code>静态初始化器(结构体的初始化)和<code>__attribute__((constructor))</code>修饰的函数（类似<code>+load</code>，由系统调用）</li>
</ul>
</li>
<li>到此为止，可执行文件和动态库中所有的符号<code>(Class，Protocol，Selector，IMP，…)</code>都已经按格式成功加载到内存中，被<code>runtime</code>所管理</li>
</ul>
<h3 id="APP的启动-main"><a href="#APP的启动-main" class="headerlink" title="APP的启动 - main"></a>APP的启动 - main</h3><ul>
<li>对<code>application:didFinishLaunchingWithOptions:</code>方法耗时优化</li>
<li>总的来说<ul>
<li><code>APP</code>的启动由<code>dyld</code>主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li>
<li>并由<code>runtime</code>负责加载成<code>objc</code>定义的结构</li>
<li>所有初始化工作结束后，<code>dyld</code>就会调用<code>main</code>函数</li>
<li>接下来就是<code>UIApplicationMain</code>函数，<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions:</code>方法</li>
</ul>
</li>
</ul>
<h2 id="APP的启动优化"><a href="#APP的启动优化" class="headerlink" title="APP的启动优化"></a>APP的启动优化</h2><ul>
<li><p>按照不同的阶段</p>
<ul>
<li><p><code>dyld</code></p>
<ol>
<li>减少动态库、合并一些动态库（定期清理不必要的动态库）</li>
<li>减少<code>Objc</code>类、分类的数量、减少<code>Selector</code>数量（定期清理不必要的类、分类）</li>
<li>减少<code>C++虚函数</code>数量</li>
<li><code>Swift</code>尽量使用<code>struct</code></li>
</ol>
</li>
<li><p><code>runtime</code></p>
<ul>
<li>用<code>+initialize</code>方法和<code>dispatch_once</code>取代所有的<code>__attribute__((constructor))</code>、<code>C++静态构造器</code>、<code>ObjC的+load</code></li>
</ul>
</li>
<li><p><code>main</code></p>
<ul>
<li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunching</code>方法中按需加载</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/kangqy/p/15746243.html">二进制重排</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>耗电优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><ul>
<li>尽可能降低<code>CPU</code>、<code>GPU</code>功耗</li>
<li>少用定时器</li>
<li>优化<code>I/O</code>操作<ul>
<li>尽量不要频繁写入小数据，最好批量一次性写入</li>
<li>读写大量重要数据时，考虑用<code>dispatch_io</code>，其提供了基于<code>GCD</code>的异步操作文件<code>I/O</code>的<code>API</code>。用<code>dispatch_io</code>系统会优化磁盘访问</li>
<li>数据量比较大的，建议使用数据库（比如<code>SQLite</code>、<code>CoreData</code>）</li>
</ul>
</li>
<li>网络优化<ul>
<li>减少、压缩网络数据</li>
<li>如果多次请求的结果是相同的，尽量使用缓存</li>
<li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li>
<li><strong>网络不可用</strong>时，不要尝试执行网络请求</li>
<li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li>
<li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载</li>
</ul>
</li>
<li>定位优化<ul>
<li>如果只是需要快速确定用户位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法。定位完成后，会自动让定位硬件断电</li>
<li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li>
<li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li>
<li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为<code>YES</code>，如果用户不太可能移动的时候系统会自动暂停位置更新</li>
<li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion</code></li>
</ul>
</li>
<li>硬件检测优化<ul>
<li>用户移动、摇晃、倾斜设备时，会产生动作(<code>motion</code>)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>卡顿优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a><code>CPU</code>和<code>GPU</code></h2><blockquote>
<p>在屏幕成像的过程中，<code>CPU</code>和<code>GPU</code>起着至关重要的作用</p>
</blockquote>
<ul>
<li><p><code>CPU</code>（<code>Central Processing Unit</code>，中央处理器）</p>
<ul>
<li>对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（<code>Core Graphics</code>）</li>
</ul>
</li>
<li><p><code>GPU</code>（<code>Graphics Processing Unit</code>，图形处理器）</p>
<ul>
<li>纹理的渲染<br><img src="1.png"></li>
</ul>
</li>
<li><p>在<code>iOS</code>中是双缓冲机制，有<code>前帧缓存</code>、<code>后帧缓存</code></p>
</li>
</ul>
<h3 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因"></a>卡顿产生的原因</h3><p><img src="2.png"></p>
<ul>
<li>红色:<code>CPU</code>、蓝色:<code>GPU</code>,</li>
<li>卡顿解决的主要思路<ul>
<li>尽可能减少<code>CPU</code>、<code>GPU</code>资源消耗</li>
<li>按照<code>60FPS</code>的刷帧率，每隔<code>16ms</code>就会有一次<code>VSync</code>信号</li>
</ul>
</li>
</ul>
<h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li><p>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用<code>CALayer</code>取代<code>UIView</code></p>
</li>
<li><p>不要频繁地调用<code>UIView</code>的相关属性，比如<code>frame</code>、<code>bounds</code>、<code>transform</code>等属性，尽量减少不必要的修改</p>
</li>
<li><p>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</p>
</li>
<li><p><code>Autolayout</code>会比直接设置<code>frame</code>消耗更多的CPU资源</p>
</li>
<li><p>图片的<code>size</code>最好刚好跟<code>UIImageView</code>的<code>size</code>保持一致</p>
</li>
<li><p>控制一下线程的最大并发数量</p>
</li>
<li><p>尽量把耗时的操作放到子线程</p>
<ul>
<li>文本处理（尺寸计算、绘制）</li>
<li>图片处理（解码、绘制）</li>
<li><code>iOS10</code>以上支持,解码<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">UIGraphicsImageRendererFormat</span> *uiformat = [[<span class="hljs-built_in">UIGraphicsImageRenderer</span> alloc] init];<br>uiformat.scale = image.scale;<br>uiformat.opaque = !hasAlpha;<br><span class="hljs-built_in">UIGraphicsImageRenderer</span> *uirenderer = [[<span class="hljs-built_in">UIGraphicsImageRenderer</span> alloc] initWithSize:imageSize format:uiformat];<br><span class="hljs-built_in">UIGraphicsImageDrawingActions</span> uiactions = ^(<span class="hljs-built_in">UIGraphicsImageRendererContext</span> *rendererContext) &#123;<br>    [image drawInRect:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, imageSize.width, imageSize.height)];<br>&#125;;<br><span class="hljs-built_in">UIImage</span> *decodedImage = [uirenderer imageWithActions:uiactions];<br></code></pre></td></tr></table></figure></li>
<li><code>iOS10以</code>下支持，解码<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//redraw image using device context</span><br>    <span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span>(imageView.bounds.size, <span class="hljs-literal">YES</span>, <span class="hljs-number">0</span>);<br>    [image drawInRect:imageView.bounds];<br>    image = <span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span>();<br>    <span class="hljs-built_in">UIGraphicsEndImageContext</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><ul>
<li><p>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</p>
</li>
<li><p><code>GPU</code>能处理的最大纹理尺寸是<code>4096x4096</code>，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</p>
</li>
<li><p>尽量减少视图数量和层次</p>
</li>
<li><p>减少透明的视图（<code>alpha&lt;1</code>），不透明的就设置<code>opaque</code>为<code>YES</code></p>
</li>
<li><p>尽量避免出现离屏渲染</p>
</li>
</ul>
<h4 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h4><ul>
<li><p>在<code>OpenGL</code>中，<code>GPU</code>有<code>2</code>种渲染方式</p>
<ol>
<li><code>On-Screen Rendering</code>：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作</li>
<li><code>Off-Screen Rendering</code>：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
</ol>
</li>
<li><p>离屏渲染消耗性能的原因</p>
<ul>
<li>需要创建新的缓冲区</li>
<li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（<code>On-Screen</code>）切换到离屏（<code>Off-Screen</code>）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕</li>
</ul>
</li>
<li><p>哪些操作会触发离屏渲染？</p>
<ul>
<li><p>光栅化，<code>layer.shouldRasterize = YES</code></p>
</li>
<li><p>遮罩，<code>layer.mask</code></p>
</li>
<li><p>圆角，同时设置<code>layer.masksToBounds = YES</code>、<code>layer.cornerRadius大于0</code></p>
<ul>
<li>考虑通过<code>CoreGraphics</code>绘制裁剪圆角，或者提供圆角图片</li>
</ul>
</li>
</ul>
</li>
<li><p>阴影，<code>layer.shadowXXX</code></p>
<ul>
<li>如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染</li>
</ul>
</li>
</ul>
<h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3><ul>
<li><p>平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作</p>
</li>
<li><p>可以添加<code>Observer</code>到主线程<code>RunLoop</code>中，通过监听<code>RunLoop</code>状态切换的耗时，以达到监控卡顿的目的</p>
<ul>
<li>绘制操作基本都在<code>source0</code>和<code>source1</code>中处理,主要监听</li>
<li><code>kCFRunLoopBeforeWaiting</code>,开始休眠之前，处理的事件卡顿</li>
<li><code>kCFRunLoopBeforeSources</code>,处理<code>source0</code>，<code>kCFRunLoopAfterWaiting</code>，被<code>source1</code>唤醒处理的耗时<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)startMonitoring &#123;<br>    <span class="hljs-keyword">if</span> (_isMonitoring) &#123; <span class="hljs-keyword">return</span>; &#125;<br>    _isMonitoring = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<br>        <span class="hljs-number">0</span>,<br>        (__bridge <span class="hljs-keyword">void</span> *)<span class="hljs-keyword">self</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span><br>    &#125;;<br>    _observer = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="hljs-literal">YES</span>, <span class="hljs-number">0</span>, &amp;lxdRunLoopObserverCallback, &amp;context);<br>    <span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(lxd_event_monitor_queue(), ^&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">self</span>.isMonitoring) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.currentActivity == kCFRunLoopBeforeWaiting) &#123;<br>                __block <span class="hljs-built_in">BOOL</span> timeOut = <span class="hljs-literal">YES</span>;<br>                <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                    timeOut = <span class="hljs-literal">NO</span>;<br>                    dispatch_semaphore_signal(<span class="hljs-keyword">self</span>.eventSemphore);<br>                &#125;);<br>                <span class="hljs-comment">//等待1s,看添加到主队列的block是否执行完</span><br>                [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval: <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (timeOut) &#123;<br>                    [LXDBacktraceLogger lxd_logMain];<span class="hljs-comment">//打印堆栈信息</span><br>                &#125;<br>                dispatch_wait(<span class="hljs-keyword">self</span>.eventSemphore, DISPATCH_TIME_FOREVER);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(lxd_fluecy_monitor_queue(), ^&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">self</span>.isMonitoring) &#123;<br>        <span class="hljs-comment">//监听信号量解锁，并进行等待</span><br>            <span class="hljs-keyword">long</span> waitTime = dispatch_semaphore_wait(<span class="hljs-keyword">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">200</span> * <span class="hljs-built_in">NSEC_PER_MSEC</span>));<span class="hljs-comment">//解锁成功返回0</span><br>            <span class="hljs-keyword">if</span> (waitTime != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.observer) &#123;<br>                    <span class="hljs-keyword">self</span>.timeOut = <span class="hljs-number">0</span>;<br>                    [<span class="hljs-keyword">self</span> stopMonitoring];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//是否当前状态一直卡处理source0和休眠唤醒状态，超过5次，就打印</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.currentActivity == kCFRunLoopBeforeSources || <span class="hljs-keyword">self</span>.currentActivity == kCFRunLoopAfterWaiting) &#123;<br>                    <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">self</span>.timeOut &lt; <span class="hljs-number">5</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    [LXDBacktraceLogger lxd_logMain];<br>                    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval: <span class="hljs-number">5</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">self</span>.timeOut = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)stopMonitoring &#123;<br>    <span class="hljs-keyword">if</span> (!_isMonitoring) &#123; <span class="hljs-keyword">return</span>; &#125;<br>    _isMonitoring = <span class="hljs-literal">NO</span>;<br>    <br>    <span class="hljs-built_in">CFRunLoopRemoveObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);<br>    <span class="hljs-built_in">CFRelease</span>(_observer);<br>    _observer = <span class="hljs-literal">nil</span>;<br>&#125;<br><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lxdRunLoopObserverCallback(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity, <span class="hljs-keyword">void</span> * info) &#123;<br>    [LXDAppFluecyMonitor sharedMonitor].currentActivity = activity;<br>    <span class="hljs-comment">//每次变化进行信号量的增加，在监听的队列进行减少</span><br>    dispatch_semaphore_signal([LXDAppFluecyMonitor sharedMonitor].semphore);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>自动释放池</title>
    <url>/2023/02/18/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><ul>
<li><p>编译,<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@autoreleasepool</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>发现实际上是一个<code>__AtAutoreleasePool</code>的结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>    <span class="hljs-comment">//创建的时候调用构造函数，即 objc_autoreleasePoolPush();</span><br>    &#125;<br>    <span class="hljs-comment">//代码块结束的时候析构函数,即 objc_autoreleasePoolPop(atautoreleasepoolobj)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">AtAutoreleasePool</span> &#123;</span><br>    <span class="hljs-comment">//构造函数，在创建结构体的时候调用</span><br>  __AtAutoreleasePool() &#123; <br>  atautoreleasepoolobj = <span class="hljs-built_in">objc_autoreleasePoolPush</span>();<br>  &#125;<br>    <span class="hljs-comment">//析构函数，在结构体销毁的时候调用</span><br>  ~__AtAutoreleasePool() &#123;<br>  <span class="hljs-built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);<br>  &#125;<br>  <span class="hljs-keyword">void</span> * atautoreleasepoolobj;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">objc_autoreleasePoolPush</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::<span class="hljs-built_in">push</span>();<br>&#125;<br><br><span class="hljs-function">NEVER_INLINE</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">objc_autoreleasePoolPop</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ctxt)</span></span><br><span class="hljs-function"></span>&#123;<br>    AutoreleasePoolPage::<span class="hljs-built_in">pop</span>(ctxt);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>自动释放池的主要底层数据结构是：<code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code></li>
<li>用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管理的</li>
</ul>
<h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a><code>AutoreleasePoolPage</code></h3><ul>
<li>主要结构<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoreleasePoolPage</span> :</span> <span class="hljs-keyword">private</span> AutoreleasePoolPageData &#123; .... &#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AutoreleasePoolPageData</span> &#123;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">const</span> SIZE =<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span><br>		PAGE_MAX_SIZE;  <span class="hljs-comment">// must be multiple of vm page size</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>		PAGE_MIN_SIZE;  <span class="hljs-comment">// size and alignment, power of 2</span><br>		<span class="hljs-comment">//(1 &lt;&lt; 12) //4096</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><br>    <span class="hljs-keyword">magic_t</span> <span class="hljs-keyword">const</span> magic;<br>	__unsafe_unretained id *next;<br>	<span class="hljs-keyword">objc_thread_t</span> <span class="hljs-keyword">const</span> thread;<br>	AutoreleasePoolPage * <span class="hljs-keyword">const</span> parent;<br>	AutoreleasePoolPage *child;<br>	<span class="hljs-keyword">uint32_t</span> <span class="hljs-keyword">const</span> depth;<br>	<span class="hljs-keyword">uint32_t</span> hiwat;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>每个<code>AutoreleasePoolPage</code>对象占用<code>4096</code>字节内存，除了用来存放它内部的<code>成员变量</code>(主要成员大概占用<code>56</code>字节)，剩下的空间用来存放<code>autorelease</code>对象的地址<ul>
<li>剩下空间不够了，则会创建一个新的</li>
</ul>
</li>
<li>所有的<code>AutoreleasePoolPage</code>对象通过<code>双向链表</code>的形式连接在一起</li>
</ul>
<h3 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a><code>objc_autoreleasePoolPush</code></h3><ul>
<li>所有的<code>AutoreleasePoolPage</code>对象通过双向链表的形式连接在一起</li>
</ul>
<ol>
<li><code>objc_autoreleasePoolPush</code>调用<code>push</code>方法会将一个<code>POOL_BOUNDARY</code>(实际是个<code>nil</code>)入栈，并且返回其存放的内存地址<ul>
<li>后续调用<code>autorelease</code>加入释放值,也是调用<code>autoreleaseFast</code>方法添加到释放池，<code>page</code>不够，则创建新的，此时新的不用加<code>POOL_BOUNDARY</code>标记<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">push</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ReturnAutoreleaseInfo info = <span class="hljs-built_in">getReturnAutoreleaseInfo</span>();<br>        <span class="hljs-built_in">moveTLSAutoreleaseToPool</span>(info);<br><br>        id *dest;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(DebugPoolAllocation)) &#123;<br>            <span class="hljs-comment">// Each autorelease pool starts on a new pool page.</span><br>            dest = <span class="hljs-built_in">autoreleaseNewPage</span>(POOL_BOUNDARY);<span class="hljs-comment">//新建的页，第一个地址假上一个POOL_BOUNDARY</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dest = <span class="hljs-built_in">autoreleaseFast</span>(POOL_BOUNDARY);<br>        &#125;<br>        <span class="hljs-built_in">ASSERT</span>(dest == (id *)EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);<br>        <span class="hljs-keyword">return</span> dest;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h3><ol>
<li><code>objc_autoreleasePoolPop(atautoreleasepoolobj)</code>,调用<code>pop</code>时，则会对所有添加的值调用<code>release</code>方法，直到遇到<code>POOL_BOUNDARY</code>为止,<code>holdPage</code>为当前页面<br><img src="1.png"></li>
<li>存放的类型是<code>AutoreleasePoolEntry</code>,<code>ptr</code>是对象地址，<code>count</code>则是释放池内，该对象调用<code>autorelease</code>的次数<ul>
<li>当前页面没了，则会调整到父页，并设置父页面为当前页面，继续<code>release</code>，直到碰到<code>POOL_BOUNDARY</code></li>
<li><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域<br><img src="2.png"></li>
</ul>
</li>
</ol>
<h3 id="autoreleaseFast"><a href="#autoreleaseFast" class="headerlink" title="autoreleaseFast"></a>autoreleaseFast</h3><ol>
<li><code>autorelease</code>方法实际内部调用的是<code>autoreleaseFast</code>，其传入的值是对象<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> id *<span class="hljs-title">autoreleaseFast</span><span class="hljs-params">(id obj)</span></span><br><span class="hljs-function">    </span>&#123;<br>        AutoreleasePoolPage *page = <span class="hljs-built_in">hotPage</span>();<br>        <span class="hljs-keyword">if</span> (page &amp;&amp; !page-&gt;<span class="hljs-built_in">full</span>()) &#123;<br>            <span class="hljs-keyword">return</span> page-&gt;<span class="hljs-built_in">add</span>(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">autoreleaseFullPage</span>(obj, page);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">autoreleaseNoPage</span>(obj);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>add</code>添加到释放值，如果已经存在则增加次数，否则增加一个<code>AutoreleasePoolEntry</code><ul>
<li>这里增加次数只会在<code>4</code>个偏移内，如果超过了这个偏移，则当做新的元素</li>
<li>在找到已经存在的，会将其前几个偏移的移动到当前偏移的后面，当前偏移存放在第一个<br><img src="3.png"></li>
</ul>
</li>
</ul>
<h3 id="查看释放值信息"><a href="#查看释放值信息" class="headerlink" title="查看释放值信息"></a>查看释放值信息</h3><ul>
<li><code>_objc_autoreleasePoolPrint</code>,该方法是一个私有方法,<code>MRC</code>环境下</li>
<li><code>p1</code>在距离上一个<code>p1</code>在<code>4</code>的范围内，则数量增加<code>1</code>，并且移动到头部<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> _objc_autoreleasePoolPrint(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">@autoreleasepool</span> &#123;  <br>    CJPerson *p1 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p2 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p3 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p4 = [[[CJPerson alloc] init] autorelease];<br>    [p1 <span class="hljs-keyword">retain</span>];<br>    [p1 autorelease];<br>    CJPerson *p5 = [[[CJPerson alloc] init] autorelease];<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123; <br>            CJPerson *p6 = [[[CJPerson alloc] init] autorelease];<br>             _objc_autoreleasePoolPrint();<br>    &#125;<br>   <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">objc[5867]: ##############</span><br><span class="hljs-comment">objc[5867]: AUTORELEASE POOLS for thread 0x7ff856aee640</span><br><span class="hljs-comment">objc[5867]: 10 releases pending.</span><br><span class="hljs-comment">objc[5867]: [0x10080b000]  ................  PAGE  (hot) (cold)</span><br><span class="hljs-comment">objc[5867]: [0x10080b038]  ################  POOL 0x10080b038</span><br><span class="hljs-comment">//每个AutoreleasePoolEntry`指针占8位</span><br><span class="hljs-comment">objc[5867]: [0x10080b040]    0x600000004060  CJPerson</span><br><span class="hljs-comment">objc[5867]: [0x10080b048]    0x600000004070  CJPerson</span><br><span class="hljs-comment">objc[5867]: [0x10080b050]    0x600000004080  CJPerson</span><br><span class="hljs-comment">//移动到最后，并且会打印数量</span><br><span class="hljs-comment">objc[5867]: [0x10080b058]    0x600000004050  CJPerson  autorelease count 2 </span><br><span class="hljs-comment">objc[5867]: [0x10080b060]    0x600000004090  CJPerson</span><br><span class="hljs-comment">objc[5867]: [0x10080b068]  ################  POOL 0x10080b068</span><br><span class="hljs-comment">objc[5867]: [0x10080b070]    0x6000000040a0  CJPerson</span><br><span class="hljs-comment">objc[5867]: ##############</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
<li><code>p1</code>在距离上一个<code>p1</code>在<code>4</code>的范围之外，则会另新增一个，尽管他们存的内存地址是一样的<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> _objc_autoreleasePoolPrint(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">@autoreleasepool</span> &#123;  <br>    CJPerson *p1 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p2 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p3 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p4 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p5 = [[[CJPerson alloc] init] autorelease];<br>    [p1 <span class="hljs-keyword">retain</span>];<br>    [p1 autorelease];<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123; <br>            CJPerson *p6 = [[[CJPerson alloc] init] autorelease];<br>             _objc_autoreleasePoolPrint();<br>    &#125;<br>   <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">objc[6090]: ##############</span><br><span class="hljs-comment">objc[6090]: AUTORELEASE POOLS for thread 0x7ff856aee640</span><br><span class="hljs-comment">objc[6090]: 11 releases pending.</span><br><span class="hljs-comment">objc[6090]: [0x102009000]  ................  PAGE  (hot) (cold)</span><br><span class="hljs-comment">objc[6090]: [0x102009038]  ################  POOL 0x102009038</span><br><span class="hljs-comment">objc[6090]: [0x102009040]    0x60000000c020  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009048]    0x60000000c030  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009050]    0x60000000c040  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009058]    0x60000000c050  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009060]    0x60000000c060  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009068]    0x60000000c020  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009070]  ################  POOL 0x102009070</span><br><span class="hljs-comment">objc[6090]: [0x102009078]    0x60000000c070  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009080]  ################  POOL 0x102009080</span><br><span class="hljs-comment">objc[6090]: [0x102009088]    0x60000000c080  CJPerson</span><br><span class="hljs-comment">objc[6090]: ##############</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="autorelease时机"><a href="#autorelease时机" class="headerlink" title="autorelease时机"></a>autorelease时机</h3><ul>
<li><code>iOS</code>在主线程的<code>Runloop</code>中注册了<code>2</code>个<code>Observer</code><ul>
<li>第1个<code>Observer</code>监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li>
<li>第2个<code>Observer</code>监听了<code>kCFRunLoopBeforeWaiting</code>事件，会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code></li>
<li>  监听了<code>kCFRunLoopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li>
</ul>
</li>
</ul>
<h1 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h1><ul>
<li><a href="https://www.jianshu.com/p/5eac83471b23">iOS-MRC与ARC区别以及五大内存区</a></li>
</ul>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>dealloc</title>
    <url>/2023/02/18/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dealloc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引用计数存储"><a href="#引用计数存储" class="headerlink" title="引用计数存储"></a>引用计数存储</h2><blockquote>
<ul>
<li>在<code>iOS</code>中，使用引用计数来管理<code>OC</code>对象的内存</li>
<li>一个新创建的<code>OC</code>对象引用计数默认是<code>1</code>，当引用计数减为<code>0</code>，<code>OC</code>对象就会销毁，释放其占用的内存空间</li>
<li>调用<code>retain</code>会让<code>OC</code>对象的引用计数<code>+1</code>，调用<code>release</code>会让<code>OC</code>对象的引用计数<code>-1</code></li>
<li>内存管理的经验总结<ul>
<li>当调用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法返回了一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它</li>
<li>想拥有某个对象，就让它的引用计数<code>+1</code>；不想再拥有某个对象，就让它的引用计数<code>-1</code></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>从<code>arm64</code>架构开始，对<code>isa</code>进行了优化，变成了一个共用体（<code>union</code>）结构，还使用位域来存储更多的信息<ul>
<li>其中<code>has_sidetable_rc</code>为<code>1</code>引用计数器是否过大无法存储在<code>isa</code>中<ul>
<li>如果为<code>1</code>，那么引用计数会存储在一个叫<code>SideTable</code>的类的属性中</li>
</ul>
</li>
<li><code>extra_rc</code>里面存储的值是引用<code>计数器减1</code>,<code>818</code>源码之前是减<code>1</code>，之后则是其本来的值了，见<a href="#jump">retainCount</a></li>
</ul>
</li>
</ul>
<p><img src="1.png"></p>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a><code>SideTable</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SideTable</span> &#123;</span><br>    <span class="hljs-keyword">spinlock_t</span> slock;<br>    RefcountMap refcnts; <span class="hljs-comment">//refcnts是一个存放着对象引用计数的散列表</span><br>    <span class="hljs-keyword">weak_table_t</span> weak_table;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a><span id="jump"><code>retainCount</code></span></h3><ul>
<li><p><code>818</code>源码,<code>extra_rc</code>上存的引用计数，不用做加<code>1</code>的操作，其上存的并非引用计数减一<br> <img src="2.png"></p>
<ul>
<li>并新增了方法，判断<code>isDeallocating</code><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(ISA_BITFIELD)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        ISA_BITFIELD;  <span class="hljs-comment">// defined in isa.h</span><br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeallocating</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> extra_rc == <span class="hljs-number">0</span> &amp;&amp; has_sidetable_rc == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDeallocating</span><span class="hljs-params">()</span> </span>&#123;<br>        extra_rc = <span class="hljs-number">0</span>;<br>        has_sidetable_rc = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>781</code>源码，<code>extra_rc</code>上存的是引用计数啊减<code>1</code>，计算时需要加1<br> <img src="3.png"></p>
</li>
<li><p>根据<code>key</code>从<code>SideTables</code>中获取<code>sidetable</code>，再从<code>refcnts</code>获取迭代器，从中取出引用计数<br>  <img src="4.png"></p>
</li>
</ul>
<h3 id="relese"><a href="#relese" class="headerlink" title="relese"></a>relese</h3><blockquote>
<p><code>relese</code>实际调用<code>rootrelease</code>，核心方法是<code>sidetable_release</code></p>
</blockquote>
<ul>
<li><code>sidetable_release</code><br>  <img src="5.png"><ul>
<li><code>refcnt</code>，在每次引用计数增减，变化一个<code>SIDE_TABLE_RC_ONE</code></li>
<li><code>relese</code>，引用计数释放完了，则会调用<code>delloc</code>方法</li>
</ul>
</li>
</ul>
<h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p><img src="6.png"></p>
<h3 id="SIDE-TABLE-RC-ONE"><a href="#SIDE-TABLE-RC-ONE" class="headerlink" title="SIDE_TABLE_RC_ONE"></a>SIDE_TABLE_RC_ONE</h3><ul>
<li>每次引用计数改变的值<code>0B100</code>，后两位分别判断是否有弱引用，是否正在释放<br>  <img src="7.png"></li>
</ul>
<h2 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h2><ul>
<li>当一个对象要释放时，会自动调用<code>dealloc</code>，接下的调用轨迹是<ol>
<li><code>dealloc</code></li>
<li><code>_objc_rootDealloc</code></li>
<li><code>rootDealloc</code></li>
<li><code>object_dispose</code></li>
<li><code>objc_destructInstance</code>、<code>free</code></li>
</ol>
</li>
</ul>
<ol>
<li>会判断是否是<code>弱引用</code>、<code>关联对象</code>、<code>c++析构函数</code>（当使用<code>Objective-C++</code>编译器（<code>.mm</code>文件)）、<code>引用计数表</code>，都没有的话直接<code>free释放</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">objc_object::<span class="hljs-built_in">rootDealloc</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTaggedPointer</span>()) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// fixme necessary?</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(<span class="hljs-built_in">isa</span>().nonpointer                     &amp;&amp;<br>                 !<span class="hljs-built_in">isa</span>().weakly_referenced             &amp;&amp;<br>                 !<span class="hljs-built_in">isa</span>().has_assoc                     &amp;&amp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ISA_HAS_CXX_DTOR_BIT</span><br>                 !<span class="hljs-built_in">isa</span>().has_cxx_dtor                  &amp;&amp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>                 !<span class="hljs-built_in">isa</span>().<span class="hljs-built_in">getClass</span>(<span class="hljs-literal">false</span>)-&gt;<span class="hljs-built_in">hasCxxDtor</span>() &amp;&amp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>                 !<span class="hljs-built_in">isa</span>().has_sidetable_rc))<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">sidetable_present</span>());<br>        <span class="hljs-built_in">free</span>(<span class="hljs-keyword">this</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">object_dispose</span>((id)<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>按顺序先处理后，再去释放，关联对象也是采用<code>typedef DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt; AssociationsHashMap;</code>和<code>RefcountMap</code>的结构一致，有墓碑机制<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">objc_destructInstance</span><span class="hljs-params">(id obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (obj) &#123;<br>        <span class="hljs-comment">// Read all of the flags at once for performance.</span><br>        <span class="hljs-keyword">bool</span> cxx = obj-&gt;<span class="hljs-built_in">hasCxxDtor</span>();<br>        <span class="hljs-keyword">bool</span> assoc = obj-&gt;<span class="hljs-built_in">hasAssociatedObjects</span>();<br><br>        <span class="hljs-comment">// This order is important.</span><br>        <span class="hljs-keyword">if</span> (cxx) <span class="hljs-built_in">object_cxxDestruct</span>(obj);<span class="hljs-comment">//手动调用c++析构函数</span><br>        <span class="hljs-keyword">if</span> (assoc) _object_remove_associations(obj, <span class="hljs-comment">/*deallocating*/</span><span class="hljs-literal">true</span>);<span class="hljs-comment">//删删除关联对象</span><br>        obj-&gt;<span class="hljs-built_in">clearDeallocating</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-comment">//清除弱引用和sidetable</span><br>objc_object::<span class="hljs-built_in">clearDeallocating</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!<span class="hljs-built_in">isa</span>().nonpointer)) &#123;<br>        <span class="hljs-comment">// Slow path for raw pointer isa.</span><br>        <span class="hljs-built_in">sidetable_clearDeallocating</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">isa</span>().weakly_referenced  ||  <span class="hljs-built_in">isa</span>().has_sidetable_rc)) &#123;<br>        <span class="hljs-comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span><br>        <span class="hljs-built_in">clearDeallocating_slow</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">sidetable_present</span>());<br>&#125;<br><br>objc_object::<span class="hljs-built_in">clearDeallocating_slow</span>()<br>&#123;<br>    <span class="hljs-built_in">ASSERT</span>(<span class="hljs-built_in">isa</span>().nonpointer  &amp;&amp;  (<span class="hljs-built_in">isa</span>().weakly_referenced || <span class="hljs-built_in">isa</span>().has_sidetable_rc));<br><br>    SideTable&amp; table = <span class="hljs-built_in">SideTables</span>()[<span class="hljs-keyword">this</span>];<br>    table.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isa</span>().weakly_referenced) &#123;<br>        <span class="hljs-built_in">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class="hljs-keyword">this</span>); <span class="hljs-comment">//清除弱引用</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isa</span>().has_sidetable_rc) &#123;<br>        table.refcnts.<span class="hljs-built_in">erase</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//清楚sidetable</span><br>    &#125;<br>    table.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="weak指针释放"><a href="#weak指针释放" class="headerlink" title="weak指针释放"></a>weak指针释放</h3><ol>
<li>获取到<code>weak_entry_t</code>，从中获取存放的弱引用指针，将其置为<code>nil</code><br><img src="8.png"><ol start="2">
<li>从<code>weak_table_t</code>，查找的方式，是通过<code>hash</code>表，线性查找的方式<br><img src="9.png"></li>
<li><code>weak_entry_t</code>的结构，会根据数组长度的不同，结构有所不同<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">weak_table_t</span> &#123;</span><br><span class="hljs-keyword">weak_entry_t</span> *weak_entries;<br><span class="hljs-keyword">size_t</span>    num_entries;<br><span class="hljs-keyword">uintptr_t</span> mask;<br><span class="hljs-keyword">uintptr_t</span> max_hash_displacement;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">weak_entry_t</span> &#123;</span><br>    DisguisedPtr&lt;objc_object&gt; referent;<br> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>          <span class="hljs-keyword">weak_referrer_t</span> *referrers;<br>          <span class="hljs-keyword">uintptr_t</span>        out_of_line_ness : <span class="hljs-number">2</span>;<br>          <span class="hljs-keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;<br>          <span class="hljs-keyword">uintptr_t</span>        mask;<br>         <span class="hljs-keyword">uintptr_t</span>        max_hash_displacement;<br>      &#125;;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-comment">// out_of_line_ness field is low bits of inline_referrers[1]</span><br>        <span class="hljs-keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];<br>    &#125;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><ol>
<li><a href="https://blog.csdn.net/u014600626/article/details/51435943">OC关联objc_setAssociatedObject, 如何使用及原理</a></li>
<li><a href="https://blog.csdn.net/weixin_50990189/article/details/126004836">weak底层原理</a></li>
</ol>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>js的基础学习（二）</title>
    <url>/2023/02/18/js%E7%9A%84%E5%AD%A6%E4%B9%A0/js%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a><code>Math</code></h3><blockquote>
<p><code>Math</code>中的方法，都会隐式转换成<code>Number</code></p>
</blockquote>
<h4 id="max"><a href="#max" class="headerlink" title="max"></a><code>max</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numArr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.max(...numArr)); <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;张三&#x27;</span>)); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;张三&#x27;</span>)); <span class="hljs-comment">// -Infinity</span><br></code></pre></td></tr></table></figure>
<h4 id="abs"><a href="#abs" class="headerlink" title="abs"></a><code>abs</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.abs(-<span class="hljs-number">0.13</span>));   <span class="hljs-comment">// 0.13</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.abs(<span class="hljs-string">&#x27;-0.13&#x27;</span>)); <span class="hljs-comment">// -0.13隐式转换</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.abs(<span class="hljs-string">&#x27;数字&#x27;</span>)); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure>
<h4 id="round"><a href="#round" class="headerlink" title="round"></a><code>round</code></h4><blockquote>
<p>四舍五入，其他数字都是四舍五入，但是<code>.5</code>特殊，它是往大了取</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.round(<span class="hljs-number">1.5</span>)); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.round(<span class="hljs-string">&#x27;-1.5&#x27;</span>)); <span class="hljs-comment">// -1 .5特殊，它是往大了取</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.round(-<span class="hljs-number">1.4</span>)); <span class="hljs-comment">// -1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.round(-<span class="hljs-number">1.6</span>)); <span class="hljs-comment">// -2</span><br></code></pre></td></tr></table></figure>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><blockquote>
<p>字符串本身是不可变的，指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span><br>str = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-comment">//当重新给str赋值的时候，常量`abc`不会被修改，依然在内存中</span><br><span class="hljs-comment">//重新给字符串赋予值没回重新在内存中开辟空间，这个特点就是字符串的不可变</span><br><span class="hljs-comment">//由于字符串的不可变，咋子大量拼接字符串的时候会有效率问题</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>js的基础学习（一）</title>
    <url>/2023/02/15/js%E7%9A%84%E5%AD%A6%E4%B9%A0/js%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>只记录<code>js</code>中特殊的写法</p>
</blockquote>
<span id="more"></span>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><table>
<thead>
<tr>
<th>情况</th>
<th align="left">说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>var age</code> ; <code>console.log (age)</code>;</td>
<td align="left">只声明 不赋值</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>console.log(age)</code></td>
<td align="left">不声明 不赋值 直接使用</td>
<td>报错</td>
</tr>
<tr>
<td><code>age = 10</code>; <code>console.log (age)</code>;</td>
<td align="left">不声明 只赋值</td>
<td><code>10</code></td>
</tr>
</tbody></table>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><blockquote>
<p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的 内存中。<code>JavaScript</code> 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会 被自动确定。</p>
</blockquote>
<h3 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h3><ul>
<li>在代码运行时，变量的数据类型是由 <code>JS</code>引擎 根据<code>=</code>右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型。 <code>JavaScript</code> 拥有动态类型，同时也意味着相同的变量可用作不同的类型:<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">6</span>; <span class="hljs-comment">// x 为数字 </span><br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;Bill&quot;</span>; <span class="hljs-comment">// x 为字符串</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ul>
<li>在函数内部，没有声明直接赋值的变量也是全局变量<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>; <span class="hljs-comment">//全局变量</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> num1 = <span class="hljs-number">20</span>; <span class="hljs-comment">//局部变量</span><br>    num2 = <span class="hljs-number">20</span>;<span class="hljs-comment">// 也是全局变量，在函数内部，没有声明直接赋值的变量也是全局变量</span><br>&#125;<br>fun(); <span class="hljs-comment">//必须执行该方法，才可以输出num2</span><br><span class="hljs-built_in">console</span>.log(num2); <span class="hljs-comment">// 2</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><ul>
<li>简单数据类型 (<code>Number</code>,<code>String</code>,<code>Boolean</code>,<code>Undefined</code>,<code>Null</code>)</li>
<li>复杂数据类型 (<code>object</code>)</li>
</ul>
<h4 id="数字型-Number"><a href="#数字型-Number" class="headerlink" title="数字型 Number"></a>数字型 <code>Number</code></h4><ul>
<li>数字型三个特殊值<ul>
<li><code>Infinity</code> ，代表无穷大，大于任何数值</li>
<li><code>-Infinity</code> ，代表无穷小，小于任何数值</li>
<li> <code>NaN</code> ，<code>Not a number</code>，代表一个非数值</li>
</ul>
</li>
<li> 隐式转换是我们在进行算数运算的时候，<code>JS</code>自动转换了数据类型<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-string">&#x27;11&#x27;</span> - <span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">// 10</span><br>alert(<span class="hljs-string">&#x27;11&#x27;</span> - <span class="hljs-string">&#x27;sss&#x27;</span>); <span class="hljs-comment">// NaN</span><br>alert(<span class="hljs-string">&#x27;11&#x27;</span> - <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="字符串型-String"><a href="#字符串型-String" class="headerlink" title="字符串型 String"></a>字符串型 <code>String</code></h4><ul>
<li>字符串拼接<ul>
<li>多个字符串之间可以使用 <code>+</code> 进行拼接，其拼接方式为 字符串 <code>+</code> 任何类型 = 拼接之后的新字符串 </li>
<li>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">alert(<span class="hljs-string">&#x27;hello&#x27;</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-string">&#x27;world&#x27;</span>); <span class="hljs-comment">// hello world </span><br>alert(<span class="hljs-string">&#x27;100&#x27;</span> + <span class="hljs-string">&#x27;100&#x27;</span>); <span class="hljs-comment">// 100100</span><br>alert(<span class="hljs-string">&#x27;11&#x27;</span> + <span class="hljs-number">12</span>); <span class="hljs-comment">// 1112</span><br>alert(<span class="hljs-string">&#x27;11&#x27;</span> + <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// 11undefined</span><br>alert(<span class="hljs-string">&#x27;11&#x27;</span> + <span class="hljs-literal">false</span>); <span class="hljs-comment">// 11false</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型 Boolean"></a>布尔型 Boolean</h4><blockquote>
<ul>
<li>布尔类型有两个值:<code>true</code> 和 <code>false</code> ，其中 <code>true</code> 表示真(对)，而 <code>false</code> 表示假(错)。 </li>
<li>布尔型和数字型相加的时候， <code>true</code> 的值为 1 ，<code>false</code> 的值为 0。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 2 </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<ul>
<li>转换为布尔型<ul>
<li>代表空、否定的值会被转换为 <code>false</code> ，如 <code>&#39;&#39;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code></li>
<li>其余值都会被转换为 <code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>)); <span class="hljs-comment">// false </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// false </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// false </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// false </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// false </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;小白&#x27;</span>)); <span class="hljs-comment">// true </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">12</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a><code>Undefined</code> 和 <code>Null</code></h4><ul>
<li>一个声明后没有被赋值的变量会有一个默认值 <code>undefined</code> ( 如果进行相连或者相加时，注意结果)<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> variable;<br><span class="hljs-built_in">console</span>.log(variable); <span class="hljs-comment">// undefined </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你好&#x27;</span> + variable); <span class="hljs-comment">// 你好undefined </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span> + variable); <span class="hljs-comment">// NaN </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + variable); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure></li>
<li>一个声明变量给 <code>null</code> 值，里面存的值为空<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vari = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你好&#x27;</span> + vari); <span class="hljs-comment">// 你好null </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span> + vari); <span class="hljs-comment">// 11 </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + vari); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="短路运算-逻辑中断-，"><a href="#短路运算-逻辑中断-，" class="headerlink" title="短路运算(逻辑中断)，"></a>短路运算(逻辑中断)，</h3><blockquote>
<p>当有多个表达式值时，左边的表达式值可以确定结果时，就不在继续运算右边的表达式的值;</p>
</blockquote>
<ol>
<li>逻辑与<ul>
<li>表达式1 <code>&amp;&amp;</code> 表达式2</li>
<li>如果第一个表达式的值为真，则返回<code>表达式2</code></li>
<li>如果第一个表达式的值为假，则返回<code>表达式1</code><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span>); <span class="hljs-comment">// 456</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">456</span>);  <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&quot;</span> &amp;&amp; <span class="hljs-number">456</span>);  <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span> &amp;&amp; <span class="hljs-number">5678</span>);  <span class="hljs-comment">// 5678</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>逻辑或<ul>
<li>表达式1 <code>||</code> 表达式2</li>
<li>如果第一个表达式的值为真，则返回<code>表达式1</code></li>
<li>如果第一个表达式的值为假，则返回<code>表达式2</code></li>
</ul>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数和形参匹配"><a href="#函数和形参匹配" class="headerlink" title="函数和形参匹配"></a>函数和形参匹配</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params">num1,num2</span>) </span>&#123;<br>    consloe.log(num1 + num2);<br>&#125;<br>getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-comment">//如果实参的个数多于形参的个数，会取到形参的个数</span><br>getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);  <span class="hljs-comment">// 3</span><br><span class="hljs-comment">//形参可以看做是不用声明的变量，num2是为Undefined</span><br>getSum(<span class="hljs-number">1</span>);  <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params">num1,num2</span>) </span>&#123;<br>    consloe.log(num1 + num2);<br>&#125;<br><span class="hljs-comment">//没有返回值，返回Undefined</span><br>consloe.log(getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)); <span class="hljs-comment">//Undefined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params">num1,num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1，num2;<br>&#125;<br><span class="hljs-comment">//多个返回值，只会返回最后一个</span><br>consloe.log(getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)); <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure>

<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><blockquote>
<p><code>js</code>中<code>arguments</code>是函数的内置对象，存储了传递的所有实参</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[i]);<br>    &#125;<br>&#125;<br><br>fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure>

<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><blockquote>
<p><code>js</code>引擎运行<code>js</code>分为两步: 预解析 代码执行</p>
<ul>
<li>预解析<code>js</code>引擎会把<code>js</code>里面所有的<code>var</code>还有<code>function</code>提升到当前作用域的最前面</li>
<li>代码执行 按照代码书写的顺序从上往下执行</li>
</ul>
</blockquote>
<h3 id="预解析-1"><a href="#预解析-1" class="headerlink" title="预解析"></a>预解析</h3><ul>
<li>变量提升 就是把所有的<code>变量声明</code>提升到当前的作用域最前面 不提升<code>赋值操作</code><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(num); <span class="hljs-comment">//输出Undefined，只会提升作用域，不提升赋值</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>fun(); <span class="hljs-comment">//会报错，因不提升赋值</span><br><span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = b = c = <span class="hljs-number">9</span>; <span class="hljs-comment">//相当于 var a=9; b = 9;c = 9;b和c是全局变量(在函数内部，没有声明</span><br>直接赋值的变量也是全局变量),但是必须执行<br><span class="hljs-comment">//集体赋值是var a=9,b = 9,c = 9;这种都是局部变量</span><br>    <span class="hljs-built_in">console</span>.log(num);<span class="hljs-comment">//输出Undefined,以为当前函数作用域下也有个局部变量num,因此会提升到最前面</span><br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span>;<br>&#125;<br>fun()<br><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 9</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 9</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 报错，没有a的全局变量</span><br></code></pre></td></tr></table></figure></li>
<li>函数提升 就是把所有的函数声明提升到当前作用于的最前面 不调用函数<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fun(); <span class="hljs-comment">//不会报错，函数提升了</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>字面量创建对象<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> objc = &#123;<br>    <span class="hljs-attr">usanme</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<br>    <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//调用属性</span><br><span class="hljs-built_in">console</span>.log(obj.usname); <span class="hljs-comment">//张三</span><br><span class="hljs-built_in">console</span>.log(obj[<span class="hljs-string">&#x27;usname&#x27;</span>]); <span class="hljs-comment">//张三</span><br>obj.sayHi();<br></code></pre></td></tr></table></figure></li>
<li><code>new Objc</code>创建对象<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <span class="hljs-comment">//创建一个空的对象</span><br>obj.uname = <span class="hljs-string">&#x27;张三&#x27;</span>;<br>obj.age = <span class="hljs-number">18</span>;<br>obj.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>构造函数创建一个对象,必须用<code>new</code>构建<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname,age,sex</span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.name = uname;<br>     <span class="hljs-built_in">this</span>.age = age;<br>     <span class="hljs-built_in">this</span>.sex = sex;<br>     <span class="hljs-built_in">this</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sayHi&#x27;</span>)<br>     &#125;<br>&#125;<br><span class="hljs-keyword">var</span> star = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;男&#x27;</span>); <span class="hljs-comment">//必须new，不加则是方法，返回undefined</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="new关键词的执行过程"><a href="#new关键词的执行过程" class="headerlink" title="new关键词的执行过程"></a>new关键词的执行过程</h3><ol>
<li><code>new 构造函数</code>可以在内存中创建一个空的对象</li>
<li><code>this</code>就会指向刚才创建的空对象</li>
<li>执行构造函数里面的代码，<code>this.</code>给这个空对象添加属性和方法</li>
<li>返回这个对象（所以构造函数不需要<code>return</code>）</li>
</ol>
<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><blockquote>
<p>用<code>for in</code>对遍历对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> star) &#123;<br>   <span class="hljs-built_in">console</span>.log(key); <span class="hljs-comment">//属性名</span><br>   <span class="hljs-built_in">console</span>.log(star[key]); <span class="hljs-comment">// 属性内的值</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Tagged Pointer</title>
    <url>/2023/02/15/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/TaggedPointer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a><code>Tagged Pointer</code></h1><blockquote>
<ul>
<li>从<code>64bit</code>开始，<code>iOS</code>引入了<code>Tagged Pointer</code>技术，用于优化<code>NSNumber</code>、<code>NSData</code>、<code>NSString</code>等<code>小对象</code>的存储</li>
<li>在没有使用<code>Tagged Pointer</code>之前， <ul>
<li><code>NSNumber</code>等对象需要动态分配内存、维护引用计数等，<code>NSNumber</code>指针存储的是<code>堆</code>中<code>NSNumber</code>对象的地址值</li>
</ul>
</li>
<li>使用<code>Tagged Pointer</code>之后，<ul>
<li><code>NSNumber</code>指针里面存储的数据变成了：<code>Tag</code> + <code>Data</code>，也就是将数据直接存储在了指针中</li>
<li>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</li>
</ul>
</li>
<li><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从<code>指针</code>提取数据，节省了以前的调用开销(因为没有<code>isa</code>存在，不是<code>OC</code>对象，不会走<code>方法调用流程</code>)</li>
</ul>
</blockquote>
<h2 id="如何判断一个指针是否为Tagged-Pointer？"><a href="#如何判断一个指针是否为Tagged-Pointer？" class="headerlink" title="如何判断一个指针是否为Tagged Pointer？"></a>如何判断一个指针是否为<code>Tagged Pointer</code>？</h2><p><img src="1.png"><br><img src="2.png"></p>
<ul>
<li>iOS平台，最高有效位是<code>1</code>（第<code>64bit</code>）</li>
<li>Mac平台，最低有效位是<code>1</code></li>
</ul>
<h2 id="Tagged-Pointer存储地方思考"><a href="#Tagged-Pointer存储地方思考" class="headerlink" title="Tagged Pointer存储地方思考"></a><code>Tagged Pointer</code>存储地方思考</h2><ul>
<li>解码<code>extern</code>调用私有函数,和一个指针<code>^</code>才能得到真正的<code>taggedPointer</code>指针<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">extern</span> uintptr_t objc_debug_taggedpointer_obfuscator;<br>uintptr_t _objc_decodeTaggedPointer_(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable  ptr) &#123;<br>    <span class="hljs-keyword">return</span> (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;<br>&#125;<br><br><span class="hljs-built_in">NSNumber</span> *number1 = @<span class="hljs-number">4</span>;<br><span class="hljs-built_in">NSNumber</span> *number2 = @<span class="hljs-number">5</span>;<br><span class="hljs-built_in">NSNumber</span> *number3 = @<span class="hljs-number">100</span>;<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p  %p  %p&quot;</span>,number1,number2,number3);<br><span class="hljs-comment">///0xc96fede699842146  0xc96fede699842786  0xc96fede699861216</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;0x%lx   0x%lx   0x%lx&quot;</span>,_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(number1)),_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(number2)),_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(number3)));<br><span class="hljs-comment">///0xb000000000000042   0xb000000000000052   0xb000000000000642</span><br><br><span class="hljs-built_in">NSString</span> *str1 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;sd&quot;</span>];<br><span class="hljs-built_in">NSString</span> *str2 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;sdadad&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p  %p&quot;</span>,str1,str2);<br><span class="hljs-comment">//0xbaf35d65b6463f52  0xbaf51b73f0563f56</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;0x%lx 0x%lx&quot;</span>,_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(str1)),_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(str2)));<br><span class="hljs-comment">//0xa000000000064732   0xa006461646164736</span><br></code></pre></td></tr></table></figure></li>
<li>分析,注意上面的数据是在<code>x86</code>模拟器上的数据<ul>
<li>前面的<code>0xb</code>明显是<code>tag</code>,为<code>0xb</code> -&gt; <code>1011</code>, <code>0xa</code> -&gt; <code>1010</code>,<ul>
<li>在iOS中最高位为<code>1</code>表明是<code>Tagged Pointer</code></li>
<li>后三位代表数据类型，<code>011</code>代表<code>int</code>（如果是带小数点的无法不会转成<code>tag</code>），<code>010</code>代表字符串</li>
</ul>
</li>
<li><code>42</code> -&gt; <code>100 0010</code>(<code>4</code>),<code>52</code> -&gt;<code>101 0010</code>(<code>5</code>)<ul>
<li>前四位代表存储的内容</li>
<li>后<code>4</code>位代表数据长度(一般是<strong>字符串长度</strong>)，后四位<code>&quot;sd&quot;</code> -&gt; <code>0010</code>长度<code>2</code>、<code>&quot;sdadad&quot;</code> -&gt; <code>0110</code>长度<code>6</code></li>
</ul>
</li>
</ul>
</li>
<li>如果是<code>iOS</code>，<strong>arm64</strong>下，数据格式不同,需要注意<ul>
<li><code>@5 -&gt; 0x8000000000000291</code>,<code>@8 -&gt; 0x8000000000000411</code>,最高位<code>1</code>是标识，低<code>7</code>位是<code>标识</code>和<code>数据长度</code></li>
</ul>
</li>
<li>在<code>iOS</code>中，<code>Tagged Pointer</code>中间<code>56</code>位用来存东西，前<code>4</code>位是<code>tag</code>，后<code>4</code>位是数据长度</li>
</ul>
<h2 id="Tagged-Pointer的题目思考"><a href="#Tagged-Pointer的题目思考" class="headerlink" title="Tagged Pointer的题目思考"></a><code>Tagged Pointer</code>的题目思考</h2><h3 id="关于野指针的问题"><a href="#关于野指针的问题" class="headerlink" title="关于野指针的问题"></a>关于野指针的问题</h3><ul>
<li>崩溃地方在<code>objc_release</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>            <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">self</span>.name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;abcdefghijk&quot;</span>];<br>            <span class="hljs-comment">// 解锁</span><br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>            <span class="hljs-keyword">self</span>.name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;abc&quot;</span>];<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>原因：设置<code>name</code>方法本质为如下方法，（<code>ARC</code>下也会有<code>release</code>引用释放,也会存在该问题）,因此在多线程下调用很可能会出现野指针问题<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name<br>&#123;<br>    <span class="hljs-keyword">if</span> (_name != name) &#123;<br>        [name <span class="hljs-keyword">retain</span>];<span class="hljs-comment">// 保留新对象</span><br>        [_name release];<span class="hljs-comment">//原先的引用计数减1</span><br>        _name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>但实际上，将赋值的对象设置仅为<code>[NSString stringWithFormat:@&quot;abc&quot;]</code>，或者为<code>@&quot;abcdefghijk&quot;</code>字面量时，不会出现<strong>野指针</strong>的问题。<ul>
<li>原因在于，<code>[NSString stringWithFormat:@&quot;abc&quot;]</code>类型为<code>NSTaggedPointerString</code>,不是<code>OC</code>对象不会有实际的<code>release</code>方法</li>
<li><code>@&quot;abcdefghijk&quot;</code>字面量为<code>__NSCFConstantString</code>，是字符串常量，<code>release</code>不会使其释放</li>
<li><code>[NSString stringWithFormat:@&quot;abcdefghijk&quot;]</code>,在超过<code>Tagged Pointer</code>,数据限制后，其类型为<code>__NSCFString</code>,字符串的<code>OC</code>对象，存在<code>引用计数</code>，因此会出现<code>野指针</code>问题</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>swift类的动态性</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="swift类的动态性"><a href="#swift类的动态性" class="headerlink" title="swift类的动态性"></a>swift类的动态性</h1><h2 id="动态方法查询"><a href="#动态方法查询" class="headerlink" title="动态方法查询"></a>动态方法查询</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> methodCount: <span class="hljs-type">UInt32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> methodList <span class="hljs-operator">=</span> class_copyMethodList(<span class="hljs-type">JPTeacher</span>.<span class="hljs-keyword">self</span>, <span class="hljs-operator">&amp;</span>methodCount)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-built_in">numericCast</span>(methodCount) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> method <span class="hljs-operator">=</span> methodList<span class="hljs-operator">?</span>[i] &#123;<br>            <span class="hljs-keyword">let</span> methodName <span class="hljs-operator">=</span> method_getName(method)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方法列表:<span class="hljs-subst">\(methodName)</span>&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;not found method&quot;</span>)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> count:<span class="hljs-type">UInt32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> proList <span class="hljs-operator">=</span> class_copyPropertyList(<span class="hljs-type">JPTeacher</span>.<span class="hljs-keyword">self</span>, <span class="hljs-operator">&amp;</span>count)<br>    <span class="hljs-keyword">for</span>  i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-built_in">numericCast</span>(count) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> proerty <span class="hljs-operator">=</span> proList<span class="hljs-operator">?</span>[i] &#123;<br>            <span class="hljs-keyword">let</span> proertyName <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(cString: property_getName(proerty))                      <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成员属性：<span class="hljs-subst">\(proertyName)</span>&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;not found property&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="静态性"><a href="#静态性" class="headerlink" title="静态性"></a>静态性</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JPTeacher</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------teach&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------test1&quot;</span>)<br>    &#125;<br>&#125;<br>test()<br><span class="hljs-comment">//什么都不会输出</span><br></code></pre></td></tr></table></figure>

<ul>
<li>调用<code>test()</code>方法，不会输出任何信息。因为，<code>Swift</code>是静态语言，所以没有动态特性。⽅法和属性不加任何修饰符的情况下，不具备所谓的<code>Runtime</code>特性，它的方法调度方式使用<code>V_table</code>函数表调度</li>
</ul>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JPTeacher</span>:<span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------teach&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------test1&quot;</span>)<br>    &#125;<br>&#125;<br>test()<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法列表:age</span><br><span class="hljs-comment">方法列表:setAge:</span><br><span class="hljs-comment">方法列表:teach</span><br><span class="hljs-comment">方法列表:test1</span><br><span class="hljs-comment">方法列表:init</span><br><span class="hljs-comment">成员属性：age</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>继承⾃<code>NSObject</code>的类，如果想要动态获取当前⽅法和属性，必须在其声明前添加<code>@objc</code>关键字。</li>
</ul>
<h3 id="Runtime-API交换方法"><a href="#Runtime-API交换方法" class="headerlink" title="Runtime API交换方法"></a>Runtime API交换方法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exchangeMethod</span>()</span> &#123;<br>    <span class="hljs-keyword">if</span>  <span class="hljs-keyword">let</span>  method1 <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-type">LGTeacher</span>.<span class="hljs-keyword">self</span>, <span class="hljs-type">NSSelectorFromString</span>(<span class="hljs-string">&quot;test1&quot;</span>)),<br>        <span class="hljs-keyword">let</span>  method2 <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-type">LGTeacher</span>.<span class="hljs-keyword">self</span>, <span class="hljs-type">NSSelectorFromString</span>(<span class="hljs-string">&quot;teach&quot;</span>)) &#123;<br>        method_exchangeImplementations(method1, method2)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>swift</code>调用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">LGTeacher</span>().teach()<br>exchangeMethod()<br><span class="hljs-type">LGTeacher</span>().teach()<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-------teach</span><br><span class="hljs-comment">-------teach</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>oc</code>中调用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">[[<span class="hljs-type">LGTeacher</span> new] teach];<br>[<span class="hljs-keyword">self</span>  exchangeMethod];<br>[[<span class="hljs-type">LGTeacher</span> new] teach];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-------teach</span><br><span class="hljs-comment">------test1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
<li><p>显然<code>OC</code>中桥接的方法，进行了交互，但是<code>swift</code>中调用的并未进行交换。这是因为<code>swift</code>中的方法，仍然是函数调用，加上<code>@objc</code>后,由打印可知，增加了<code>objc</code>的方法。因此两个调用的方法实际上是不一样的</p>
<ul>
<li>但是如果是在<code>extension</code>中，加上的<code>@objc</code>，则<code>swift</code>和<code>oc</code>中调用，都是<code>消息派发</code>，并可以交换</li>
</ul>
</li>
<li><p>如果想在<code>swift</code>中可以交换方法，则需要添加<code>dynamic</code>关键字，让它们具备动态特性，例子</p>
<ul>
<li><code>dynamic</code>针对类中的方法，如果是<code>extension</code>中的，只需<code>@objc</code>，就会是消息派发<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LGTeacher</span>:<span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------teach&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------test1&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-type">LGTeacher</span>().teach()<br>exchangeMethod()<br><span class="hljs-type">LGTeacher</span>().teach()<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-------teach</span><br><span class="hljs-comment">------test1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>注意</strong>,如果在方法中不加<code>@objc</code>，只加<code>dynamic</code>,那么在打印的方法中将没有<code>teach</code>和<code>test1</code>方法，也无法交换。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>定时器通过<code>addTarget</code>添加的时候，会强引用<code>target</code>，如果此时<code>target</code>持有了定时器，则会出现循环引用</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//__weak typeof(self) weakSelf = self;将target的self,换成weakSelf，一样会出现循环引用 </span><br>__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>；<br><span class="hljs-comment">//和block不一样，block内部会根据weak还是strong，去引用对象</span><br><br><span class="hljs-comment">//而NSTimer中，尽管传入的是weakSelf，但其内部，仍然会强引用self</span><br><span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(timerTest) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br><br><span class="hljs-comment">//出现循环引用，无法释放</span><br>- (<span class="hljs-keyword">void</span>)dealloc<br>&#123;<br>    [<span class="hljs-keyword">self</span>.timer invalidate];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="NSObjec的代理转发"><a href="#NSObjec的代理转发" class="headerlink" title="NSObjec的代理转发"></a><code>NSObjec</code>的代理转发</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> <br>                                                target:[JPProxy proxyWithTarget:<span class="hljs-keyword">self</span>] <br>                                              selector:<span class="hljs-keyword">@selector</span>(timerTest) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JPProxy</span> : <span class="hljs-title">NSObject</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span> target;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">JPProxy</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target<br>&#123;<br>    JPProxy *proxy = [[JPProxy alloc] init];<br>    proxy.target = target;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br><br>- (<span class="hljs-keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.target;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<ul>
<li>通过一个代理类<code>proxy</code>，弱引用持有<code>self</code>，而定时器的<code>target</code>为该代理类，则可打破该循环引用，并且，定时器在代理类中查询<code>timerTest</code>方法时,会通过消息转发机制，由<code>self</code>来处理</li>
<li><code>CADisplayLink</code>也可以通过一样的方式，解决循环引用</li>
</ul>
<h4 id="NSProxy的代理转发"><a href="#NSProxy的代理转发" class="headerlink" title="NSProxy的代理转发"></a>NSProxy的代理转发</h4><blockquote>
<p><code>NSProxy</code>和<code>NSObject</code>一样，同样是一种基类,<code>NSProxy</code>没有<code>forwardingTargetForSelector:</code>,因此要走<code>methodSignatureForSelector</code>,<code>forwardInvocation:</code>最后一步方法转发流程</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JPProxy</span> : <span class="hljs-title">NSProxy</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span> target;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">JPProxy</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target<br>&#123;<br>    <span class="hljs-comment">// NSProxy对象不需要调用init，因为它本来就没有init方法</span><br>    JPProxy *proxy = [JPProxy alloc];<br>    proxy.target = target;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br><br><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel<br>&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.target methodSignatureForSelector:sel];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation<br>&#123;<br>    [invocation invokeWithTarget:<span class="hljs-keyword">self</span>.target];<br>&#125;<br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>对于转发来说，<code>NSProxy</code>的效率要比<code>NSObject</code>要快。<ul>
<li>因为继承自<code>NSObject</code>的代理，需要先<code>查询方法</code>-&gt;<code>方法解析</code>-&gt;最后才是<code>方法转发</code>。</li>
<li>而继承自<code>NSProxy</code>，会直接走向<code>方法转发</code>。</li>
</ul>
</li>
</ul>
<h3 id="CGD定时器"><a href="#CGD定时器" class="headerlink" title="CGD定时器"></a>CGD定时器</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dispatch_source_t timer = dispatch_source_create(DISPATCH_TIME_NOW, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dispatch_get_main_queue());<br><span class="hljs-comment">// 设置时间（start是几秒后开始执行，interval是时间间隔）</span><br>dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(start * <span class="hljs-built_in">NSEC_PER_SEC</span>)), (uint64_t)(interval * <span class="hljs-built_in">NSEC_PER_SEC</span>), <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 设置回调</span><br>dispatch_source_set_event_handler(timer, ^&#123;<br>        <br>&#125;);<br><span class="hljs-comment">// 启动定时器</span><br>dispatch_resume(timer);<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>读写锁</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li>读写锁的应用场景<ul>
<li>同一时间，只能有<code>1</code>个线程进行写的操作</li>
<li>同一时间，允许有多个线程进行读的操作</li>
<li>同一时间，不允许既有写的操作，又有读的操作</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="读写锁的方案"><a href="#读写锁的方案" class="headerlink" title="读写锁的方案"></a>读写锁的方案</h3><ul>
<li><code>pthread_rwlock</code>：读写锁</li>
<li><code>dispatch_barrier_async</code>：异步栅栏调用</li>
</ul>
<h3 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote>
<p>读用<code>pthread_rwlock_rdlock</code>，写用<code>pthread_rwlock_wrlock</code>，运行读同时并发进行，写必须按顺序进行</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">pthread_rwlock_t _lock;<br>pthread_rwlock_init(&amp;_lock, <span class="hljs-literal">NULL</span>);<br><br>- (<span class="hljs-keyword">void</span>)read &#123;<br>    pthread_rwlock_rdlock(&amp;_lock);<br>    <span class="hljs-comment">//读加锁    </span><br>    pthread_rwlock_unlock(&amp;_lock);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)write<br>&#123;<br>    pthread_rwlock_wrlock(&amp;_lock);<br>    <br>     <span class="hljs-comment">//写加锁    </span><br>    pthread_rwlock_unlock(&amp;_lock);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)dealloc<br>&#123;<br>    pthread_rwlock_destroy(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.queue = dispatch_queue_create(<span class="hljs-string">&quot;rw_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><span class="hljs-built_in">dispatch_async</span>(<span class="hljs-keyword">self</span>.queue, ^&#123;<br>    <span class="hljs-comment">//读操作</span><br>&#125;);<br><br><span class="hljs-comment">//使用栅栏添加到队列的任务，会等之前的读任务执行完，再执行该任务，</span><br><span class="hljs-comment">//并且之后添加到该队列的读任务，必须等到该任务执行完，才能执行。</span><br>dispatch_barrier_async(<span class="hljs-keyword">self</span>.queue, ^&#123;<br>    <span class="hljs-comment">//写操作</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><strong>注意</strong>，<code>dispatch_barrier_async</code>传入的并发队列必须是<strong>自己</strong>通过<code>dispatch_queue_cretate</code> 创建的如果传入的是一个<code>串行</code>或是一个<code>全局的并发队列</code>，那这个函数便等同于<code>dispatch_async</code>函数的效果，无法保证读写安全</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>多线程和锁</title>
    <url>/2023/02/02/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h2><ul>
<li>资源共享<ul>
<li><code>1</code>块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li>
<li>比如多个线程访问同一个对象、同一个变量、同一个文件</li>
</ul>
</li>
<li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li>
</ul>
<h2 id="OS中的线程同步方案"><a href="#OS中的线程同步方案" class="headerlink" title="OS中的线程同步方案"></a>OS中的线程同步方案</h2><ol>
<li><code>OSSpinLock</code></li>
<li><code>os_unfair_lock</code></li>
<li><code>pthread_mutex</code></li>
<li><code>dispatch_semaphore</code></li>
<li><code>dispatch_queue(DISPATCH_QUEUE_SERIAL)</code></li>
<li><code>NSLock</code></li>
<li><code>NSRecursiveLock</code></li>
<li><code>NSCondition</code></li>
<li><code>NSConditionLock</code></li>
<li><code>@synchronized</code></li>
</ol>
<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><blockquote>
<p><code>OSSpinLock</code>叫做”自旋锁”，等待锁的线程会处于忙等（<code>busy-wait</code>）状态，一直占用着<code>CPU</code>资源</p>
<ul>
<li>目前已经不再安全，可能会出现优先级反转问题<ul>
<li>如果等待锁的线程优先级较高，它会一直占用着<code>CPU</code>资源；获得锁的优先级低的线程，没有<code>CPU</code>资源，分配不到时间片，无法执行完，就无法释放锁</li>
<li>多线程原理是，操作系统通过<code>时间片轮转算法</code>，每次给一个线程一个时间片，让其可以执行,(如果所给的时间片足够短，则看起来是同时执行的</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h4><blockquote>
<p><code>iOS10</code>以上由于优先级反转的问题，导致被废弃，系统建议使用<code>os_unfair_lock</code></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;libkern/OSAtomic.h&gt;</span></span><br><br>OSSpinLock _lock = OS_SPINLOCK_INIT;<span class="hljs-comment">//多个线程持有同一个锁</span><br><br>OSSpinLockLock(&amp;_lock);<br><span class="hljs-comment">//需要同步的代码</span><br>OSSpinLockUnlock(&amp;_lock)<br></code></pre></td></tr></table></figure>

<h4 id="自旋锁逻辑查看"><a href="#自旋锁逻辑查看" class="headerlink" title="自旋锁逻辑查看"></a>自旋锁逻辑查看</h4><ul>
<li>汇编源码查看线程等待锁时，所做的事，通过<code>lldb</code>的<code>s</code>指令(代码级别的),<code>si</code>(stepi)(汇编级别的)，一步步查看汇编执行，<code>ni</code>(<code>next</code>)指令遇到函数级别的调用会跳过<ul>
<li>如果可以获取到锁，则不会走<code>_OSSPinLockLockSlow</code>,直接执行同步代码<br><img src="2.png"></li>
<li>如果没有获取到锁，则会走<code>_OSSPinLockLockSlow</code>方法中，类似<code>while</code>循环调用，线程不会休眠<br><img src="1.png"></li>
</ul>
</li>
</ul>
<h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><blockquote>
<ul>
<li><code>mutex</code>叫做”互斥锁”，等待锁的线程会处于休眠状态</li>
<li><code>pthread_mutex</code>可以在多个平台上使用(<code>window</code>、<code>linux</code>、<code>macos</code>)都可以使用</li>
</ul>
</blockquote>
<h4 id="使用教程-1"><a href="#使用教程-1" class="headerlink" title="使用教程"></a>使用教程</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;pthread/pthread.h&gt;</span></span><br><br>pthread_mutex_t _pthreadMutex;<br><span class="hljs-comment">//初始化属性</span><br>pthread_mutexattr_t attr;<br>pthread_mutexattr_init(&amp;attr);<br>pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);<br><span class="hljs-comment">//初始化锁</span><br>pthread_mutex_init(&amp;_pthreadMutex, &amp;attr);<br><span class="hljs-comment">//pthread_mutex_init(&amp;_pthreadMutex, NULL);传null为DEFALT，即NORMAL</span><br><span class="hljs-comment">//销毁属性</span><br>pthread_mutexattr_destroy(&amp;attr);<br><span class="hljs-comment">//不用锁之后需要销毁</span><br>pthread_mutex_destroy(&amp;_pthreadMutex);<br></code></pre></td></tr></table></figure>

<h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTHREAD_MUTEX_NORMAL		0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTHREAD_MUTEX_ERRORCHECK	1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTHREAD_MUTEX_RECURSIVE	  2</span><br></code></pre></td></tr></table></figure>

<h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><blockquote>
<p>允许<code>**同一个线程**</code>对<code>**一把锁**</code>重复多次加锁，而不会造成死锁,<br>    - 注意，多个线程访问的话，一个线程持有之后，另一个线程访问，同样会被阻塞，休眠，直到递归锁被释放。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);<br><span class="hljs-comment">//初始化递归锁</span><br>pthread_mutex_init(&amp;_pthreadMutex, &amp;attr);<br></code></pre></td></tr></table></figure>

<h4 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 初始化条件</span><br>pthread_cond_t _cond;<br>pthread_cond_init(&amp;_cond, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//销毁</span><br>pthread_cond_destroy(&amp;_cond);<br><br><span class="hljs-comment">//执行</span><br>[[[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(__remove) object:<span class="hljs-literal">nil</span>] start];<br>[[[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(__add) object:<span class="hljs-literal">nil</span>] start];<br><span class="hljs-comment">//删除方法</span><br>- (<span class="hljs-keyword">void</span>)__remove &#123;<br>    pthread_mutex_lock(&amp;_mutex);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.data.count == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 等待，线程进行休眠，并且会释放该锁</span><br>     pthread_cond_wait(&amp;_cond, &amp;_mutex);<br>     <span class="hljs-comment">//当被signal唤醒之后，继续加锁，然后由后面unlock进行解锁</span><br>    &#125;<br>    [<span class="hljs-keyword">self</span>.data removeLastObject];<br>     pthread_mutex_unlock(&amp;_mutex); <br>&#125;<br>- (<span class="hljs-keyword">void</span>)__add &#123;<br>    <span class="hljs-comment">//添加方法</span><br>    pthread_mutex_lock(&amp;_mutex);<br>    [<span class="hljs-keyword">self</span>.data addObject:<span class="hljs-string">@&quot;Test&quot;</span>]; <br>    <span class="hljs-comment">// 信号，会唤醒一个等待的线程，让删除方法的线程继续执行</span><br>    pthread_cond_signal(&amp;_cond);<span class="hljs-comment">//放在unlock前面，则wait会先唤醒，并且再等待锁释放</span><br>    <span class="hljs-comment">// 广播，唤醒所有等待的线程</span><br>    <span class="hljs-comment">//pthread_cond_broadcast(&amp;_cond);</span><br>    pthread_mutex_unlock(&amp;_mutex);<br>    <span class="hljs-comment">//pthread_cond_signal(&amp;_cond);//放在unlock后面，则wait唤醒之后，可以立刻获取锁，但是也可能，被不是自己要唤醒的地方的获取锁，被优先级的地方获取到，建议放在unlock前面</span><br>&#125; <br></code></pre></td></tr></table></figure>
<h4 id="互斥锁逻辑查看"><a href="#互斥锁逻辑查看" class="headerlink" title="互斥锁逻辑查看"></a>互斥锁逻辑查看</h4><blockquote>
<p>互拆锁底层调用了<code>syscall</code>，会使当前线程休眠</p>
</blockquote>
<ul>
<li>汇编源码查看线程等待锁时，所做的事<ol>
<li>在<code>pthread_mutex_lock</code>方法中,如果可以获取到锁，则会直接<code>retq</code>返回，没有则会执行<code>_pthread_mutex_firstfit_lock_slow</code>方法<br> <img src="6.png"></li>
<li>在这个方法中最终会执行到<code>_pthread_mutex_firstfit_lock_wait</code>方法中<br> <img src="3.png"></li>
<li>调用<code>__psynch_mutexwait</code>方法<br><img src="4.png"></li>
<li>在该方法中，最后会走到<code>syscall</code>方法，系统调用方法，<code>si</code>执行终止，由系统调用让线程进入了休眠的状态。<br><img src="5.png"></li>
</ol>
</li>
</ul>
<h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><blockquote>
<ul>
<li><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code> ，从<code>iOS10</code>开始才支持</li>
<li>从底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等</li>
<li>系统方法底层调用的是<code>syscall</code>方法，和互斥锁一致</li>
</ul>
</blockquote>
<ul>
<li>使用教程<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;os/lock.h&gt;</span></span><br><br>os_unfair_lock _lock = OS_UNFAIR_LOCK_INIT;<br><br>os_unfair_lock_lock(&amp;_lock);<br> <span class="hljs-comment">//需要同步的代码</span><br> os_unfair_lock_unlock(&amp;_lock);<br></code></pre></td></tr></table></figure></li>
<li>汇编发现是一种互斥锁,和<code>pthread_mutex</code>一样，等待锁会走到<code>**syscall**</code>方法,系统调用使得线程进入休眠状态<br><img src="7.png"></li>
</ul>
<h3 id="NSLOCK、NSRecursiveLock"><a href="#NSLOCK、NSRecursiveLock" class="headerlink" title="NSLOCK、NSRecursiveLock"></a>NSLOCK、NSRecursiveLock</h3><blockquote>
<p><code>NSLock</code>是对<code>mutex</code>普通锁的封装<br><code>NSRecursiveLock</code>也是对<code>mutex</code>递归锁的封装，<code>API</code>跟<code>NSLock</code>基本一致</p>
</blockquote>
<ul>
<li>使用教程<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLock</span> *_lock = [[<span class="hljs-built_in">NSLock</span> alloc] init];<br><span class="hljs-comment">//NSRecursiveLock *_lock = [[NSRecursiveLock alloc] init];</span><br><span class="hljs-comment">//均实现了&lt;NSLocking&gt;协议</span><br>[_lock lock]<br><span class="hljs-comment">//[_lock tryLock]</span><br>[_lock unlock]<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><blockquote>
<p><code>NSCondition</code>是对<code>mutex</code>和<code>cond</code>的封装</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSCondition</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSLocking</span>&gt;</span><br>- (<span class="hljs-keyword">void</span>)wait<br>- (<span class="hljs-built_in">BOOL</span>)waitUntilDate:(<span class="hljs-built_in">NSDate</span> *)limit N<br>- (<span class="hljs-keyword">void</span>)signal <br>- (<span class="hljs-keyword">void</span>)broadcast;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><blockquote>
<p><code>NSConditionLock</code>是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值.</p>
<ul>
<li><code>lockWhenCondition:</code>只有满足具体条件值的才能获取到锁，<code>unlockWithCondition:</code>解锁可以重新设定(如果不传值，初始化，默认是<code>0</code>)</li>
<li><code>lock</code>和之前一样直接加锁，不会根据条件值来判断</li>
</ul>
</blockquote>
<p><img src="8.png"></p>
<h3 id="dispatch-queue-DISPATCH-QUEUE-SERIAL"><a href="#dispatch-queue-DISPATCH-QUEUE-SERIAL" class="headerlink" title="dispatch_queue(DISPATCH_QUEUE_SERIAL)"></a>dispatch_queue(DISPATCH_QUEUE_SERIAL)</h3><blockquote>
<p>直接使用<code>GCD</code>的串行队列，也是可以实现线程同步的</p>
</blockquote>
<p><img src="9.png"></p>
<h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><blockquote>
<ul>
<li><code>semaphore</code>叫做”信号量”</li>
<li>信号量的初始值，可以用来控制线程并发访问的最大数量</li>
<li>信号量的初始值为<code>1</code>，代表同时只允许<code>1</code>条线程访问资源，保证线程同步</li>
</ul>
</blockquote>
<p><img src="10.png"></p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><blockquote>
<p><code>@synchronized</code>是对<code>mutex</code>递归锁的封装,在最新版本中，锁已经改为<code>os_unfair_lock</code>了，但仍可实现递归，（<code>os_unfair_lock</code>是不支持递归的，代码做了优化，未开源）<br>源码查看：<code>objc4</code>中的<code>objc-sync.mm</code>文件<br><code>@synchronized(obj)</code>内部会生成<code>obj</code>对应的递归锁，然后进行加锁、解锁操作</p>
</blockquote>
<ul>
<li>使用<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>       <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>重要数据结构<br><img src="11.png"></li>
<li><code>723</code>以及之前的版本，用的是<code>pthread_mutex_t</code><br><img src="14.png"></li>
<li><code>723</code>之后的版本，用的是<code>os_recursive_unfair_lock</code><br><img src="12.png"></li>
<li><code>os_recursive_unfair_lock</code>结构本质上是<code>os_unfair_lock</code><br><img src="13.png"></li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>多线程的问题</title>
    <url>/2023/01/31/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li>多线程原理是，操作系统通过<code>时间片轮转算法</code>，每次给一个线程一个时间片，让其可以执行,(如果所给的时间片足够短，则看起来是同时执行的)。(单个<code>CPU</code>是如此，共享同一个进程。如果是多核CPU则，每个<code>CPU</code>中的线程，是并行的)</li>
<li><code>GCD</code>中,调度库对并行对立和串行队列能够创建的线程总数进行了限制，这个限制在不同的运行环境下会有所不同。以<code>(iphone14)iOS16</code>为例，单个并行队列最多可以创建<code>64</code>个线程，而串行队列可以创建<code>512</code>个线程</li>
<li>在<code>iOS</code>中,主线程的栈空间为<code>1MB</code>,其他次级线程的内存空间为<code>512KB</code>,</li>
</ul>
</blockquote>
<h2 id="常见多线程方案"><a href="#常见多线程方案" class="headerlink" title="常见多线程方案"></a>常见多线程方案</h2><table>
<thead>
<tr>
<th align="center">技术方案</th>
<th align="left">简介</th>
<th align="center">语言</th>
<th align="center">线程生命周期</th>
<th align="center">使用频率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pthread</td>
<td align="left">一套通用的多线程API、适用于Unix\Linux\Windows等系统、跨平台\可移植、使用难度大</td>
<td align="center">c</td>
<td align="center">手动管理</td>
<td align="center">几乎不用</td>
</tr>
<tr>
<td align="center">NSThread</td>
<td align="left">使用更加面向对象、简单易用，可直接操作线程对象</td>
<td align="center">OC</td>
<td align="center">手动管理</td>
<td align="center">偶尔使用</td>
</tr>
<tr>
<td align="center">GCD</td>
<td align="left">旨在替代NSThread等线程技术、充分利用设备的多核</td>
<td align="center">c</td>
<td align="center">自动管理</td>
<td align="center">经常使用</td>
</tr>
<tr>
<td align="center">NSOperation</td>
<td align="left">基于GCD（底层是GCD）、比GCD多了一些更简单实用的功能、使用更加面向对象</td>
<td align="center">OC</td>
<td align="center">自动管理</td>
<td align="center">经常使用</td>
</tr>
</tbody></table>
<h2 id="常见的死锁问题"><a href="#常见的死锁问题" class="headerlink" title="常见的死锁问题"></a>常见的死锁问题</h2><ol>
<li>主队列中，用<code>dispatch_sync</code>同步在主队列中执行任务会有死锁，<ul>
<li>原因是<code>sync</code>同步执行会立刻执行<code>任务二</code>，但是在主队列中，已经添加了<code>任务三</code>，必须等<code>任务3</code>(<code>viewDidLoad</code>方法)执行完之后，才能执行<code>任务二</code>,因此造成死锁</li>
<li>改为<code>dispatch_async</code>,则不会出现死锁，会先执行<code>任务三</code>，再执行<code>任务二</code>,按主队列任务添加顺序执行<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务一&quot;</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();<br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务二&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务三&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>串行队列,和<code>1</code>相同，任务三的执行要求任务四执行完成，而<code>sync</code>要求立刻执行任务三，因此出现死锁<ul>
<li>将任务三放到另一个队列，或者采用<code>async</code>则可以避免<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务一&quot;</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;queue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务二&quot;</span>);<br>        <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务三&quot;</span>);<br>        &#125;);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务四&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务五&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果是并发队列，则不会产生死锁<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务一&quot;</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务二&quot;</span>);<br>        <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务三&quot;</span>);<br>        &#125;);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务四&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务五&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p>
</blockquote>
<h2 id="多线程的其他问题"><a href="#多线程的其他问题" class="headerlink" title="多线程的其他问题"></a>多线程的其他问题</h2><ol>
<li>下面打印结果实际为，<code>1-&gt;3</code>,其中<code>2</code>并<strong>未打印</strong><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>  [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0.0</span>];<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>&#125;);<br><br>- (<span class="hljs-keyword">void</span>)test<br>&#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>直接用<code>[self performSelector:@selector(test) withObject:nil];</code>会打印<code>1-&gt;2-&gt;3</code>,因为其源码本质是通过<code>objc_msgSend</code>调用的<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)performSelector:(SEL)sel withObject:(<span class="hljs-keyword">id</span>)obj &#123;<br>         <span class="hljs-keyword">if</span> (!sel) [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:sel];<br>      <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-keyword">id</span>))objc_msgSend)(<span class="hljs-keyword">self</span>, sel, obj);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果在主线程中调用,会打印出<code>1-&gt;3-&gt;2</code></li>
<li><strong>原因</strong>:<code>[self performSelector:@selector(test) withObject:nil afterDelay:0.0];</code>的源码是在<code>Runloop</code>相关源码中定义的，其本质是添加了一个<code>Timer</code>到<code>Runloop</code>中的。而在<code>1</code>中通过<code>dispatch_async</code>开了一个<strong>子线程</strong>(用一次就扔掉)，但是实际上，<strong>子线程</strong>是没有启动<code>runloop</code>的，因此添加到的任务是<strong>无效的</strong>，因此不会打印<ul>
<li>解决方法,增加<code>runloop</code>，再启动<code>runloop</code>后，则会打印出<code>1-&gt;3-&gt;2</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0.0</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>[[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];<br>&#125;);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>源码，<code>NSRunloop</code>不开源，但是可以通过<a href="http://www.gnustep.org/resources/downloads.php%0D">GNU</a>大致了解下源码,虽然<code>GNUstep</code>不是苹果官方源码，但还是具有一定的参考价值</li>
</ul>
<ol start="2">
<li>与<code>1</code>类似的问题,<code>waitUntilDone</code>为<code>YES</code>会崩溃，因为在当执行输出<code>1</code>后，线程已经退出了，不能在线程中执行，如果<code>waitUntilDone</code>为<code>NO</code>，则不会崩溃，但是不会执行<code>test</code>方法<ul>
<li>和<code>1</code>类似，要在里面启动<code>Runloop</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithBlock:^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-comment">//解决问题</span><br>    <span class="hljs-comment">//[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br>    <span class="hljs-comment">//[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br>&#125;];<br>[thread start];<br>[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="常驻线程的实现"><a href="#常驻线程的实现" class="headerlink" title="常驻线程的实现"></a>常驻线程的实现</h2><blockquote>
<p>线程保活，必须在当前线程下要有<code>runloop</code>的运行</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs Objc">    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (^KeepAliveThreadTask)(<span class="hljs-keyword">void</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">KeepAliveThread</span> : <span class="hljs-title">NSObject</span></span><br>    <br>    - (<span class="hljs-keyword">void</span>)executeTask:(KeepAliveThreadTask)task;<br>    <br>    - (<span class="hljs-keyword">void</span>)stop;<br>    <span class="hljs-keyword">@end</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">KeepAliveThread</span>()</span><br>    <span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSThread</span> *innerThread;<br>    <span class="hljs-keyword">@end</span><br>    <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">KeepAliveThread</span></span><br>    - (<span class="hljs-keyword">instancetype</span>)init &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>            _innerThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithBlock:^&#123;<br>                <span class="hljs-built_in">CFRunLoopSourceContext</span> context = &#123;<span class="hljs-number">0</span>&#125;;<br>                <span class="hljs-built_in">CFRunLoopSourceRef</span> source = <span class="hljs-built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="hljs-number">0</span>, &amp;context);<br>                <span class="hljs-built_in">CFRunLoopAddSource</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopDefaultMode);<br>                <span class="hljs-built_in">CFRelease</span>(source);<br>                <span class="hljs-comment">// 添加了一个sources，保证runloop不会退出</span><br>                <span class="hljs-built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="hljs-number">1.0e10</span>, <span class="hljs-literal">false</span>);<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;MatterKeepAliveThread end&quot;</span>);<br>            &#125;];<br>            [_innerThread start];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>    &#125;<br>    - (<span class="hljs-keyword">void</span>)stop &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.innerThread) <span class="hljs-keyword">return</span>;<br>        <br>        [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(__stop) onThread:<span class="hljs-keyword">self</span>.innerThread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br>    &#125;<br>    <span class="hljs-comment">// 线程执行的任务</span><br>    - (<span class="hljs-keyword">void</span>)executeTask:(KeepAliveThreadTask)task &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.innerThread || !task) <span class="hljs-keyword">return</span>;<br>        [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(__executeTask:) onThread:<span class="hljs-keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="hljs-literal">NO</span>];<br>    &#125;<br>    <br>    - (<span class="hljs-keyword">void</span>)dealloc &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>        <span class="hljs-comment">// 当前实例销毁，会主动停止线程</span><br>        [<span class="hljs-keyword">self</span> stop];<br>    &#125;<br>    <br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - private methods</span><br>    - (<span class="hljs-keyword">void</span>)__stop &#123;<br>        <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>        <span class="hljs-keyword">self</span>.innerThread = <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <br>    - (<span class="hljs-keyword">void</span>)__executeTask:(MatterKeepAliveThreadTask)task &#123;<br>        task();<br>    &#125;<br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>runloop的运行逻辑</title>
    <url>/2023/01/20/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop%E7%9A%84%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="运行流程分析"><a href="#运行流程分析" class="headerlink" title="运行流程分析"></a>运行流程分析</h2><p><img src="1.png"></p>
<ol>
<li>通知<code>Observers</code>：进入<code>Loop</code></li>
<li>通知<code>Observers</code>：即将处理<code>Timers</code></li>
<li>通知<code>Observers</code>：即将处理<code>Sources</code><ul>
<li><code>Observers</code>内，实际调用，<code>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</code></li>
</ul>
</li>
<li>处理<code>Blocks</code><ul>
<li>处理通过<code>CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void))</code>添加到<code>runloop</code>的<code>block</code></li>
<li>实际调用：<code>_CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</code></li>
</ul>
</li>
<li>处理<code>Source0</code>（如果返回结果是<code>true</code>，可能会再次处理<code>Blocks</code>）<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code></li>
<li>只有被<code>Signal</code>的<code>source0</code>才会去处理</li>
</ul>
</li>
<li>如果存在<code>Source1</code>，就跳转到第8步<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code></li>
</ul>
</li>
<li>通知<code>Observers</code>：开始休眠（等待消息唤醒）<ul>
<li><code>__CFRunLoopServiceMachPort</code>内，用户态会下发<code>mach_msg</code>给内核态（只有内核可以<code>真正的休眠线程</code>（而<code>非阻塞线程</code>,<code>忙等</code>），节省<code>CPU</code>），切换到内核态，当内核收到消息后，再唤醒线程，节省<code>CPU</code>资源<br><img src="2.png"></li>
</ul>
</li>
<li>通知<code>Observers</code>：结束休眠（被下面某个消息唤醒）<ol>
<li>处理<code>Timer</code><ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</code></li>
</ul>
</li>
<li>处理<code>GCD Async To Main Queue</code>,<code>GCD</code>异步回到主队列的任务<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>，注意只有通过<code>dispatch_async(dispatch_get_main_queue(),block);</code>，<code>GCD</code>异步回到主队列，才会有<code>runloop</code>的协助</li>
</ul>
</li>
<li>处理<code>Source1</code><ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code></li>
</ul>
</li>
</ol>
</li>
<li>处理<code>Blocks</code></li>
<li>根据前面的执行结果，决定如何操作<ol>
<li>回到第<code>02</code>步</li>
<li>退出<code>Loop</code></li>
</ol>
</li>
<li>通知<code>Observers：</code>退出<code>Loop</code></li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="CFRunLoopRunSpecific"><a href="#CFRunLoopRunSpecific" class="headerlink" title="CFRunLoopRunSpecific"></a><code>CFRunLoopRunSpecific</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SInt32 <span class="hljs-title">CFRunLoopRunSpecific</span><span class="hljs-params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="hljs-comment">/* DOES CALLOUT */</span><br>    <span class="hljs-built_in">CHECK_FOR_FORK</span>();<br>    <span class="hljs-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="hljs-keyword">return</span> kCFRunLoopRunFinished;<br>    __CFRunLoopLock(rl);<br>    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;<br>	Boolean did = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);<br>	__CFRunLoopUnlock(rl);<br>	<span class="hljs-keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;<br>    &#125;<br>    <span class="hljs-comment">// 1.这里会记录下当前mode的状态运行状态</span><br>    <span class="hljs-keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);<br>    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;<br>    rl-&gt;_currentMode = currentMode;<br>    <span class="hljs-keyword">int32_t</span> result = kCFRunLoopRunFinished;<br>    <span class="hljs-comment">// 2. CFRunLoopRunSpecific会保持前一次mode的状态属性（stopped和currentMode）然后发出即将要进入新的mode通知</span><br>	<span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);<br>	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);<br>	<span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);<br>    <span class="hljs-comment">// 3 . __CFRunLoopRun(__CFRunLoopRun会创建一个循环)，然后这个mode运行结束后再发已退出mode通知。再恢复前一次的stopped和currentMode</span><br>        __CFRunLoopModeUnlock(currentMode);<br>    <span class="hljs-comment">// 4 .这里会恢复之前记录mode的状态</span><br>        __CFRunLoopPopPerRunData(rl, previousPerRun);<br>	rl-&gt;_currentMode = previousMode;<br>    __CFRunLoopUnlock(rl);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>分析<ol>
<li>首先<code>Runloop</code>进入的是<code>kCFRunLoopDefaultMode</code> 会无限执行</li>
<li><code>CFRunLoopRunSpecific</code>会保持前一次<code>mode</code>的状态属性,并且会记录下当前<code>mode</code>的运行状态 </li>
<li>然后发出即将要进入新的<code>mode</code>通知，然后进入<code>__CFRunLoopRun</code>(<code>__CFRunLoopRun</code>会创建一个循环)</li>
<li>这个<code>mode</code>运行结束后再发已退出<code>mode</code>通知,再恢复前一次的<code>currentmode</code>,和2中记录的运行状态</li>
</ol>
</li>
<li>如果<code>CFRunLoopRunSpecific</code>被调用多次会怎么样？ <ul>
<li>因为函数调用时栈，前一次<code>mode</code>信息都是被记录在栈<code>stack</code>中，新的<code>Mode</code>开启新的<code>__CFRunLoopRun</code>(<code>do-while</code>)事件处理循环。但是所有<code>Runloop</code>的第一个<code>mode</code>，都是<code>kCFRunLoopDefaultMode</code></li>
</ul>
</li>
</ul>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="CFRunLoopRun"></a><code>CFRunLoopRun</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;<br>    <span class="hljs-comment">//获取系统启动后的CPU运行时间，用于控制超时时间</span><br>    <span class="hljs-keyword">uint64_t</span> startTSR = <span class="hljs-built_in">mach_absolute_time</span>();<br><br>    <span class="hljs-comment">//1. 判断runloop和runloopmode是否是已经结束，如果已经结束就直接返回</span><br>    <span class="hljs-keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;<br>        __CFRunLoopUnsetStopped(rl);<br>	<span class="hljs-keyword">return</span> kCFRunLoopRunStopped;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rlm-&gt;_stopped) &#123;<br>	rlm-&gt;_stopped = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">return</span> kCFRunLoopRunStopped;<br>    &#125;<br>    <br>    <span class="hljs-comment">//2. 如果当前runloop是主线程runloop就获取dispatchPort ，dispatchPort 用来接收主队列的任务和事件</span><br>    <span class="hljs-keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;<br>    Boolean libdispatchQSafe = <span class="hljs-built_in">pthread_main_np</span>() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="hljs-literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="hljs-number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));<br>    <span class="hljs-comment">////如果在主线程 &amp;&amp; runloop是主线程的runloop &amp;&amp; 该mode是commonMode，则给mach端口赋值为主线程收发消息的端口</span><br>    <span class="hljs-keyword">if</span> (libdispatchQSafe &amp;&amp; (<span class="hljs-built_in">CFRunLoopGetMain</span>() == rl) &amp;&amp; <span class="hljs-built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();<br>    <br>    <span class="hljs-keyword">mach_port_name_t</span> modeQueuePort = MACH_PORT_NULL;<br>    <span class="hljs-keyword">if</span> (rlm-&gt;_queue) &#123;<br>        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);<br>        <span class="hljs-keyword">if</span> (!modeQueuePort) &#123;<br>            <span class="hljs-built_in">CRASH</span>(<span class="hljs-string">&quot;Unable to get port for run loop mode queue (%d)&quot;</span>, <span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//3. 根据seconds参数，设置一个GCD定时器</span><br>    <span class="hljs-keyword">dispatch_source_t</span> timeout_timer = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">timeout_context</span> *<span class="hljs-title">timeout_context</span> =</span> (struct __timeout_context *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*timeout_context));<br>    <span class="hljs-comment">//立即超时</span><br>    <span class="hljs-keyword">if</span> (seconds &lt;= <span class="hljs-number">0.0</span>) &#123; <span class="hljs-comment">// instant timeout</span><br>        seconds = <span class="hljs-number">0.0</span>;<br>        timeout_context-&gt;termTSR = <span class="hljs-number">0ULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;<br>        <span class="hljs-comment">//seconds为超时时间，超时时执行__CFRunLoopTimeout函数</span><br>	<span class="hljs-keyword">dispatch_queue_t</span> queue = <span class="hljs-built_in">pthread_main_np</span>() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();<br>	timeout_timer = <span class="hljs-built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, queue);<br>        <span class="hljs-built_in">dispatch_retain</span>(timeout_timer);<br>	timeout_context-&gt;ds = timeout_timer;<br>	timeout_context-&gt;rl = (CFRunLoopRef)<span class="hljs-built_in">CFRetain</span>(rl);<br>	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);<br>	<span class="hljs-built_in">dispatch_set_context</span>(timeout_timer, timeout_context); <span class="hljs-comment">// source gets ownership of context</span><br>    <span class="hljs-comment">// 4. 超时后执行__CFRunLoopTimeout</span><br>	<span class="hljs-built_in">dispatch_source_set_event_handler_f</span>(timeout_timer, __CFRunLoopTimeout);<br>    <span class="hljs-comment">// 5. __CFRunLoopTimeoutCancel释放runloop内存和定时器相关的环境内存</span><br>    <span class="hljs-built_in">dispatch_source_set_cancel_handler_f</span>(timeout_timer, __CFRunLoopTimeoutCancel);<br>    <span class="hljs-keyword">uint64_t</span> ns_at = (<span class="hljs-keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="hljs-number">1000000000ULL</span>);<br>    <span class="hljs-built_in">dispatch_source_set_timer</span>(timeout_timer, <span class="hljs-built_in">dispatch_time</span>(<span class="hljs-number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="hljs-number">1000ULL</span>);<br>    <span class="hljs-built_in">dispatch_resume</span>(timeout_timer);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// infinite timeout</span><br>        <span class="hljs-comment">//永不超时</span><br>        seconds = <span class="hljs-number">9999999999.0</span>;<br>        timeout_context-&gt;termTSR = UINT64_MAX;<br>    &#125;<br>    <span class="hljs-comment">//上一次是否是dispatch，默认为true</span><br>    Boolean didDispatchPortLastTime = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//记录最后runloop的状态</span><br>    <span class="hljs-keyword">int32_t</span> retVal = <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">// 6.进入do-while循环</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;<br>        <span class="hljs-keyword">voucher_t</span> voucherCopy = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">//初始化一个存放内核消息的缓冲池</span><br>        <span class="hljs-keyword">uint8_t</span> msg_buffer[<span class="hljs-number">3</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">mach_msg_header_t</span> *msg = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">mach_port_t</span> livePort = MACH_PORT_NULL;<br><br>        <span class="hljs-comment">//取所有需要监听的port</span><br>	__CFPortSet waitSet = rlm-&gt;_portSet;<br>        <span class="hljs-comment">// 设置Runloop为可以被唤醒状态</span><br>        __CFRunLoopUnsetIgnoreWakeUps(rl);<br><br>         <span class="hljs-comment">// 7.条件判断是否有定时器和source的相关观察，发出定时器执行之前相关的观察者事件和发出source执行之前相关的观察者事件</span><br>        <span class="hljs-keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);<br>        <span class="hljs-keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);<br>         <span class="hljs-comment">// 8, 执行Runloop的Block任务</span><br>	__CFRunLoopDoBlocks(rl, rlm);<br>         <span class="hljs-comment">//9. 处理suoce0，并且返回sourceHandledThisLoop</span><br>        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);<br>         <span class="hljs-comment">// 10, 再次执行Runloop的Block任务</span><br>        <span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>            __CFRunLoopDoBlocks(rl, rlm);<br>	     &#125;<br>         <br>         <span class="hljs-comment">// 11. 是否处理了source0，或者没有设置超时</span><br>        Boolean poll = sourceHandledThisLoop || (<span class="hljs-number">0ULL</span> == timeout_context-&gt;termTSR);<br><br>         <span class="hljs-comment">// 12. 如果当前是主线程，并且didDispatchPortLastTime为false，则会去看</span><br>         <span class="hljs-comment">//是否存在端口间的通信，source1，结束后就会标记didDispatchPortLastTime=false,</span><br>         <span class="hljs-comment">//默认是true，如果上次循环是处理GCD会设置为true</span><br>        <span class="hljs-keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;<br>            msg = (<span class="hljs-keyword">mach_msg_header_t</span> *)msg_buffer;<br>            <span class="hljs-comment">// 12 。如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br>            <span class="hljs-comment">//超时时间是0.因此实际不会休眠线程，是直接从缓冲区读取消息的，因为是主线程端口，一般是source1</span><br>            <span class="hljs-keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg_buffer), &amp;livePort, <span class="hljs-number">0</span>, &amp;voucherState, <span class="hljs-literal">NULL</span>)) &#123;<br>                <br>               <span class="hljs-comment">// 如果有触发消息直接去处理消息</span><br>                <span class="hljs-keyword">goto</span> handle_msg;<br>            &#125;<br>        &#125;<br><br>        didDispatchPortLastTime = <span class="hljs-literal">false</span>;<br><br>         <span class="hljs-comment">// 13. 没有处理事件或者超时，则会通知线程即将进入休眠</span><br>	<span class="hljs-keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);<br>         <span class="hljs-comment">// 14. 标记runloop的属性为睡眠标记，设置runloop为可以唤醒</span><br>	__CFRunLoopSetSleeping(rl);<br>	<span class="hljs-comment">// do not do any user callouts after this point (after notifying of sleeping)</span><br><br>        <span class="hljs-comment">// Must push the local-to-this-activation ports in on every loop</span><br>        <span class="hljs-comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span><br>        <span class="hljs-comment">// want these ports to get serviced.</span><br>         <span class="hljs-comment">//15. 把dispatchPort添加到waitPort，解锁runloop和runloop mode</span><br>        __CFPortSetInsert(dispatchPort, waitSet);<br>        <br>	__CFRunLoopModeUnlock(rlm);<br>	__CFRunLoopUnlock(rl);<br>        <span class="hljs-comment">//睡眠开始的时间</span><br>        CFAbsoluteTime sleepStart = poll ? <span class="hljs-number">0.0</span> : <span class="hljs-built_in">CFAbsoluteTimeGetCurrent</span>();<br>         <span class="hljs-comment">// 16. 进入_CFRunLoopServiceMachPort，会进入内核的等待mach_msg，并且while循环等待正确的唤醒，反正操作系统可能存在的假唤醒</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (kCFUseCollectableAllocator) &#123;<br>                <span class="hljs-comment">// objc_clear_stack(0);</span><br>                <span class="hljs-comment">// &lt;rdar://problem/16393959&gt;</span><br>                <span class="hljs-built_in">memset</span>(msg_buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg_buffer));<br>            &#125;<br>            msg = (<span class="hljs-keyword">mach_msg_header_t</span> *)msg_buffer;<br>            <br>            <span class="hljs-comment">//等待唤醒,livePort接收是哪个端口唤醒的,之前处理了事件，等待时间为0，也就是基本上不睡眠，</span><br>            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg_buffer), &amp;livePort, poll ? <span class="hljs-number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);<br>            <br>            <span class="hljs-keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;<br>                <span class="hljs-comment">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span><br>                <span class="hljs-keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));<br>                <span class="hljs-keyword">if</span> (rlm-&gt;_timerFired) &#123;<br>                    <span class="hljs-comment">// Leave livePort as the queue port, and service timers below</span><br>                    rlm-&gt;_timerFired = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (msg &amp;&amp; msg != (<span class="hljs-keyword">mach_msg_header_t</span> *)msg_buffer) <span class="hljs-built_in">free</span>(msg);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Go ahead and leave the inner loop.</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>        <br>        <br>         <span class="hljs-comment">// 18. 对Runloop和runloop mode进行加锁，抢夺Runloop的资源运行，保证唯一操作</span><br>        __CFRunLoopLock(rl);<br>        __CFRunLoopModeLock(rlm);<br><br>        rl-&gt;_sleepTime += (poll ? <span class="hljs-number">0.0</span> : (<span class="hljs-built_in">CFAbsoluteTimeGetCurrent</span>() - sleepStart));<br><br>        <span class="hljs-comment">// Must remove the local-to-this-activation ports in on every loop</span><br>        <span class="hljs-comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span><br>        <span class="hljs-comment">// want these ports to get serviced. Also, we don&#x27;t want them left</span><br>        <span class="hljs-comment">// in there if this function returns.</span><br>    <br>         <span class="hljs-comment">// 19. 把dispatchPort从waitPort移除，这里dispatchPort（主线的dispatchPort不在原有mode中的，是临时添加的）</span><br>        __CFPortSetRemove(dispatchPort, waitSet);<br>        <br>        __CFRunLoopSetIgnoreWakeUps(rl);<br><br>        <span class="hljs-comment">// user callouts now OK again</span><br>	__CFRunLoopUnsetSleeping(rl);<br>        <span class="hljs-comment">// 20, 如果没有处理事件或者超时，则会通知结束休眠</span><br>	<span class="hljs-keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);<br><br>        handle_msg:;<br>        __CFRunLoopSetIgnoreWakeUps(rl);<br><br>        <span class="hljs-comment">// 21. 获取livePort，消息事件来源</span><br>        <span class="hljs-keyword">if</span> (MACH_PORT_NULL == livePort) &#123;<br>            <span class="hljs-built_in">CFRUNLOOP_WAKEUP_FOR_NOTHING</span>();<br>            <span class="hljs-comment">// handle nothing</span><br>            <span class="hljs-comment">// 22.唤醒操作，什么也不做</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;<br>            <span class="hljs-built_in">CFRUNLOOP_WAKEUP_FOR_WAKEUP</span>();<br>            <span class="hljs-comment">// do nothing on Mac OS</span><br>            <span class="hljs-comment">// 22.唤醒操作，什么也不做</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;<br>            <span class="hljs-built_in">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();<br>            <span class="hljs-comment">//23. 处理定时任务，启动下一个定时器任务</span><br>            <span class="hljs-keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, <span class="hljs-built_in">mach_absolute_time</span>())) &#123;<br>                <span class="hljs-comment">// Re-arm the next timer, because we apparently fired early</span><br>                __CFArmNextTimerInMode(rlm, rl);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (livePort == dispatchPort) &#123;<br>            <span class="hljs-built_in">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();<br>            <span class="hljs-comment">// 24. 处理GCD的时间，并设置didDispatchPortLastTime = true;也就是下一个循环的时候，</span><br>            <span class="hljs-comment">//下次不会去判断source1（也就是端口的GCD），为了保证，runloop的睡眠效率</span><br>            __CFRunLoopModeUnlock(rlm);<br>            __CFRunLoopUnlock(rl);<br>            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="hljs-keyword">void</span> *)<span class="hljs-number">6</span>, <span class="hljs-literal">NULL</span>);<br>            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);<br>            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="hljs-keyword">void</span> *)<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>            __CFRunLoopLock(rl);<br>            __CFRunLoopModeLock(rlm);<br>            sourceHandledThisLoop = <span class="hljs-literal">true</span>;<br>            didDispatchPortLastTime = <span class="hljs-literal">true</span>;<br>            <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();<br>            <span class="hljs-comment">// If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. </span><br>            <span class="hljs-comment">//CFMachPortBoost will look in the TSD for the voucher. </span><br>            <span class="hljs-comment">//By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance </span><br>            <span class="hljs-comment">//for anything in between the two pieces of code to set the voucher again.</span><br>            <span class="hljs-keyword">voucher_t</span> previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (<span class="hljs-keyword">void</span> *)voucherCopy, os_release);<br><br>            <span class="hljs-comment">// Despite the name, this works for windows handles as well</span><br>            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);<br>            <span class="hljs-keyword">if</span> (rls) &#123;<br>                <span class="hljs-comment">// 25处理Source1：如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br>		<span class="hljs-keyword">mach_msg_header_t</span> *reply = <span class="hljs-literal">NULL</span>;<br>		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != reply) &#123;<br>		    (<span class="hljs-keyword">void</span>)<span class="hljs-built_in">mach_msg</span>(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="hljs-number">0</span>, MACH_PORT_NULL, <span class="hljs-number">0</span>, MACH_PORT_NULL);<br>		    <span class="hljs-built_in">CFAllocatorDeallocate</span>(kCFAllocatorSystemDefault, reply);<br>		&#125;<br>	    &#125;<br>            <br>            <span class="hljs-comment">// Restore the previous voucher</span><br>            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span> (msg &amp;&amp; msg != (<span class="hljs-keyword">mach_msg_header_t</span> *)msg_buffer) <span class="hljs-built_in">free</span>(msg);<br>        <br>        <span class="hljs-comment">//26. 最后处理一次blocks</span><br>	__CFRunLoopDoBlocks(rl, rlm);<br>        <br>        <span class="hljs-comment">//27. 根据前面的处理结果，决定流程</span><br>    <span class="hljs-keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;<br>        <span class="hljs-comment">//stopAfterHandle为true，并且当前runloop处理了事件sourceHandledThisLoop，处理了source0或者GCD</span><br>	    retVal = kCFRunLoopRunHandledSource;<br>	 &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout_context-&gt;termTSR &lt; <span class="hljs-built_in">mach_absolute_time</span>()) &#123;<br>        <span class="hljs-comment">//超出传入参数标记的超时时间了</span><br>        retVal = kCFRunLoopRunTimedOut;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;<br>            __CFRunLoopUnsetStopped(rl);<br>        <span class="hljs-comment">// 当前RunLoop已经被外部调用者强制停止了</span><br>	    retVal = kCFRunLoopRunStopped;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rlm-&gt;_stopped) &#123;<br>        <span class="hljs-comment">//  当前运行模式已经被停止</span><br>	    rlm-&gt;_stopped = <span class="hljs-literal">false</span>;<br>	    retVal = kCFRunLoopRunStopped;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;<br>        <span class="hljs-comment">// source/timer/observer一个都没有了</span><br>	    retVal = kCFRunLoopRunFinished;<br>	&#125;<br>        <br>    <span class="hljs-built_in">voucher_mach_msg_revert</span>(voucherState);<br>    <span class="hljs-built_in">os_release</span>(voucherCopy);<br>        <span class="hljs-comment">// 如果没超时，mode里不为空也没停止，loop也没被停止，那继续loop。</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> == retVal);<br><br>    <span class="hljs-keyword">if</span> (timeout_timer) &#123;<br>        <span class="hljs-built_in">dispatch_source_cancel</span>(timeout_timer);<br>        <span class="hljs-built_in">dispatch_release</span>(timeout_timer);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">free</span>(timeout_context);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<ol>
<li>判断<code>runloop</code>和<code>runloopmode</code>是否是已经结束，如果已经结束就直接返回<ul>
<li>这是线程安全的设计，<code>CFRunLoopRef</code>中存在各种加锁解锁的操作，它提供了纯 C 函数的 <code>API</code>，这些 <code>API</code> 都是<strong>线程安全</strong>的。</li>
<li>而<code>NSRunLoop</code>是基于 <code>CFRunLoopRef</code> 的封装，提供了面向对象的 <code>API</code>，这些 <code>API</code> 不是<strong>线程安全</strong>的</li>
</ul>
</li>
<li>如果当前<code>runloop</code>是主线程<code>runloop</code>就获取<code>dispatchPort</code> ，<code>dispatchPort</code> 用来接收主队列的任务和事件</li>
<li>根据<code>seconds</code>参数，设置一个<code>GCD</code>定时器<ol>
<li>定时器超时后执行<code>__CFRunLoopTimeout</code>,执行<code>__CFRunLoopTimeout</code>设置超时<code>context-&gt;termTSR = 0LL</code>，并且唤醒<code>Runloop</code>。 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __CFRunLoopTimeout(<span class="hljs-keyword">void</span> *arg) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">timeout_context</span> *<span class="hljs-title">context</span> =</span> (struct __timeout_context *)arg;<br>    context-&gt;termTSR = <span class="hljs-number">0ULL</span>;<br>    <span class="hljs-built_in">CFRUNLOOP_WAKEUP_FOR_TIMEOUT</span>();<br>    <span class="hljs-built_in">CFRunLoopWakeUp</span>(context-&gt;rl);<br>    <span class="hljs-comment">// The interval is DISPATCH_TIME_FOREVER, so this won&#x27;t fire again</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>__CFRunLoopTimeoutCancel</code>释放<code>runloop</code>内存和定时器相关的环境内存 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __CFRunLoopTimeoutCancel(<span class="hljs-keyword">void</span> *arg) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">timeout_context</span> *<span class="hljs-title">context</span> =</span> (struct __timeout_context *)arg;<br>    <span class="hljs-built_in">CFRelease</span>(context-&gt;rl);<br>    <span class="hljs-built_in">dispatch_release</span>(context-&gt;ds);<br>    <span class="hljs-built_in">free</span>(context);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>进入<code>do-while</code>的<code>Runloop</code>循环</li>
<li>条件判断是否有<code>定时器</code>和<code>source</code>的相关观察，发出定时器执行之前相关的观察者事件和发出<code>source</code>执行之前</li>
<li>执行<code>Runloop</code>的<code>Block</code>任务</li>
<li>处理<code>suoce0</code>，并且返回<code>sourceHandledThisLoop</code><ol>
<li>在每一次<code>Do-while</code>结束后，会判断是否是处理<code>stopAfterHandle</code>(处理了<code>source0</code>,<code>source1</code>,<code>GCD</code>)是否为<code>true</code>，然后结合<code>sourceHandledThisLoop</code>来退出<code>Runloop</code>，目的是为了处理单次的事件后就退出.<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">    <span class="hljs-keyword">static</span> Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) &#123;<br>        ....<br>        CFRunLoopSourceRef rls = (CFRunLoopSourceRef)sources;<br> __CFRunLoopSourceLock(rls);<br>        <span class="hljs-keyword">if</span> (__CFRunLoopSourceIsSignaled(rls)) &#123;<br>     __CFRunLoopSourceUnsetSignaled(rls);<br>     <span class="hljs-keyword">if</span> (__CFIsValid(rls)) &#123;<br>         __CFRunLoopSourceUnlock(rls);<br>                __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);<br>         <span class="hljs-built_in">CHECK_FOR_FORK</span>();<br>         sourceHandled = <span class="hljs-literal">true</span>;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         __CFRunLoopSourceUnlock(rls);<br>     &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            __CFRunLoopSourceUnlock(rls);<br>        &#125;<br>        ....<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>source0</code>被<code>Signale</code>，并且<strong>有效</strong>才会去处理。在<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>函数中去处理<code>source0</code>，实际去执行<code>rls-&gt;_context.version0.perform</code>中的方法。并执行完后将<code>sourceHandled</code>设置为<code>true</code></li>
</ol>
</li>
<li>再次执行<code>Runloop</code>的<code>Block</code>任务,可能会有新的<code>block</code>在执行<code>source0</code>的时候被添加了</li>
<li><code>poll</code>表明是否处理了<code>source0</code>，或者没有设置超时</li>
<li>如果当前是主线程，并且<code>didDispatchPortLastTime</code>为<code>false</code>，则会去看是否存在端口间的通信<code>source1</code>，结束后就会标记<code>didDispatchPortLastTime=false</code>,默认是<code>true</code>，如果上次循环是处理<code>GCD</code>会设置为<code>true</code><ul>
<li>如果有 <code>Source1</code> (基于<code>port</code>)(类似<code>GCD</code>也是基于端口的) 处于 <code>ready</code> 状态，直接处理这个 <code>Source1</code> 然后跳转去处理消息。（主线程基于端口的通信，一般是<code>source1</code>）</li>
<li><code>__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL))</code>,超时时间是<code>0</code>，而非<code>INFINITY</code>永远，因此认为是从缓存中取，已经<code>ready</code> 状态的</li>
<li><strong>注意</strong>上次循环是处理<code>GCD</code>会<code>didDispatchPortLastTime</code>设置为<code>true</code>,这是为了提高更新和休眠提升效率(和<code>poll</code>的作用基本一致)。因此下次循环，先不查询<code>source1</code></li>
</ul>
</li>
<li><strong>没有处理事件<code>source0</code>或者设置了超时</strong>，则会通知线程即将进入休眠，即上面<code>9</code>的<code>poll</code>为<code>false</code></li>
<li>标记<code>runloop</code>为睡眠标记，设置<code>runloop</code>为可以唤醒。把<code>dispatchPort</code>添加到<code>waitPort</code>，解锁<code>runloop</code>和<code>runloop mode</code></li>
<li>进入<code>_CFRunLoopServiceMachPort</code>，会进入内核的等待<code>mach_msg</code>，并且<code>while</code>循环等待正确的唤醒。<code>livePort</code>接收是哪个端口唤醒的<ul>
<li>注意如果<code>poll</code>为<code>true</code>,表明之前处理了<code>source0</code>，或者没有设置超时。则超时时间是<code>0</code>,只会快速从缓存中查询后，进入下一次循环。（这是提高更新和休眠提升效率）</li>
<li>如果<code>poll</code>为<code>false</code>,则超时时间为<code>INFINITY</code>，等待唤醒</li>
</ul>
</li>
<li>对<code>Runloop</code>和<code>runloop mode</code>进行加锁，抢夺<code>Runloop</code>的资源运行，保证唯一操作</li>
<li>把<code>dispatchPort</code>从<code>waitPort</code>移除，这里<code>dispatchPort</code>（主线的<code>dispatchPort</code>不在原有<code>mode</code>中的，是临时添加的）</li>
<li><strong>没有处理事件<code>source0</code>或者设置超时</strong>，则会通知线程结束休眠，即上面<code>9</code>的<code>poll</code>为<code>false</code></li>
<li>获取<code>livePort</code>，判断消息事件来源<ol>
<li><code>liveport</code>是空或者是<code>rl-&gt;wakeUpPort</code>，那么就什么都不做，这是<strong>唤醒操作</strong>。跳过<code>livePort</code>的判断逻辑</li>
<li><code>livePort</code>是<code>rlm-&gt;timerPort</code>,那么就执行<code>Timer</code>的事件处理，<code>modeQueuePort</code>定时器相关的端口，并启动下一个定时器任务</li>
<li><code>livePort</code>是<code>dispatchPort</code>，那么就解锁<code>Runloop</code>和<code>RunloopMode</code>，然后处理<code>dispatch_main_queue_callback_4CF</code>(会遍历添加到主线程的<code>GCD</code>执行)的<code>GCD</code>调度任务，完成后加锁<code>Runloop</code>和<code>RunloopMode</code>。<ul>
<li>处理<code>GCD</code>的时，并设置<code>didDispatchPortLastTime = true</code>;也就是下一个循环的时候，不会去判断<code>source1</code>,这是为了提高更新和休眠提升效率。<code>didDispatchPortLastTime</code>的作用<ul>
<li>这个变量为<code>true</code>，<code>handle_msg</code>上次执行了<code>main queue</code>,这样在下次<code>RunLoop</code>不会去判断，<code>source1</code>(添加到主线程的<code>GCD</code>也是基于端口的)去直接跳转执行<code>handle_msg</code>。</li>
<li>然后<code>handle_msg</code>执行了其他分支(比如<code>timer</code>),那么本次<code>RunLoop</code>就不再执行<code>main queue</code>(<code>source1</code>,即使有)，下一次，才会执行。</li>
<li>因为有<code>source1</code>跳转就不会休眠了,这样做，是为了提高更新和休眠提升效率</li>
</ul>
</li>
</ul>
</li>
<li>其他情况，处理<code>Source1</code>：如果一个 <code>Source1</code> (基于<code>port</code>) 发出事件了，处理这个事件</li>
</ol>
</li>
<li>最后再直接处理<code>_CFRunLoopDoBlocks</code>，再重新进入<code>do-while</code>循环处理<code>Timer</code>和<code>source0</code>的观察者逻辑等</li>
<li>最后根据前面的处理结果，决定下一次的流程<ol>
<li><code>stopAfterHandle</code>为<code>true</code>，并且当前<code>runloop</code>处理了事件<code>sourceHandledThisLoop</code>，处理了<code>source0</code>或者<code>GCD</code></li>
<li>超出传入参数标记的超时时间了</li>
<li>当前<code>RunLoop</code>已经被外部调用者强制停止了</li>
<li>当前运行模式已经被停止</li>
<li><code>source</code>/<code>timer</code>/<code>observer</code>一个都没有了</li>
</ol>
</li>
<li>如果没超时，<code>mode</code>里不为空也没停止，<code>loop</code>也没被停止，那继续<code>loop</code>。</li>
</ol>
</li>
<li><p><strong>注意</strong>，上述<code>poll</code>为<code>true</code>(<strong>处理了事件<code>source0</code>或者没有设置超时</strong>)。<code>runloop</code>为了提高更新和休眠提升效率，超时时间为<code>0</code>，不会休眠，<code>_CFRunLoopServiceMachPort</code>直接从缓存中获取。</p>
<ul>
<li>同样<code>didDispatchPortLastTime</code>字段也是如此，如果上一次处理了<code>GCD</code>,则下一次不会去看<code>source1</code>了，尽管他有，这也是为了不阻塞<code>runloop</code>，提高更新和休眠提升效率</li>
</ul>
</li>
</ul>
<h2 id="runloop执行方法需要注意的地方"><a href="#runloop执行方法需要注意的地方" class="headerlink" title="runloop执行方法需要注意的地方"></a>runloop执行方法需要注意的地方</h2><ol>
<li><code>- (void)run</code><ul>
<li><code>[[NSRunloop currentRunloop] run]</code>实际上是在一个<code>while(1)</code>中重复调用<code>-(BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate</code>方法,因此通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>只能取消一次<code>runMode:(NSRunLoopMode)mode beforeDate:</code>的调用，</li>
<li>但是在<code>run</code>方法中，还是会循环调用，是无法取消<code>run</code>方法的循环调用的</li>
</ul>
</li>
<li><code>-(BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate</code><ul>
<li> 注意，该方法，在执行完一次runloop的循环之后，则会退出，例如执行一次<code>performSelector:</code>方法便会释放</li>
</ul>
</li>
<li><strong>注意</strong>,在启动<code>runloop</code>后，要注意<code>_strong typeof(weakSelf) strongSelf = weakSelf</code>的写法。<ul>
<li>例如通过<code>initWithBlock:</code>设置线程,在回调中启动<code>runloop</code>。如果再回调中存在这种写法，则在<code>runloop</code>运行期间，一直会有一个局部强引用持有<code>self</code>，除非将当前的<code>runloop</code>结束</li>
</ul>
</li>
<li><strong>注意</strong>,通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>停止<code>runloop</code>之后。<ul>
<li>不要再使用，<code>performSelector:onThread:withObject:waitUntilDone:</code>在线程中执行。因为线程和<code>runloop</code>的生命周期是一一对应的。</li>
<li>在<code>waitUntilDone</code>为<code>true</code>,不异步执行时，会出现野指针的错误，为<code>false</code>时，异步时可能内部做了处理，不会出现野指针的问题</li>
</ul>
</li>
<li><code>CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</code>,<code>returnAfterSourceHandled</code>为<code>true</code>代表执行完<code>source</code>之后，就退出<code>runloop</code>，类似<code>2</code>中的用法,设置为<code>false</code>则，执行一次<code>source</code>后，是不会退出的。<ul>
<li>和<code>1</code>中不同可以通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>取消当前循环的<code>runloop</code></li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>runloop</code>是怎么响应用户操作的，具体流程是什么样的？<ul>
<li>由<code>source1</code>将系统事件捕获，（例如点击屏幕的事件），<code>source1</code>将事件包装成<code>EventQueue</code>，放到<code>source0</code>中处理</li>
</ul>
</li>
<li><code>NSDefaultRunLoopMode</code>、<code>UITrackingRunLoopMode</code>才是真正存在的模式<code>NSRunLoopCommonModes</code>并不是一个真的模式，它只是一个标记</li>
</ol>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>runloop相关的类</title>
    <url>/2023/01/12/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="runloop的结构"><a href="#runloop的结构" class="headerlink" title="runloop的结构"></a>runloop的结构</h2><blockquote>
<ul>
<li><code>Core Foundation</code>中关于<code>RunLoop</code>的5个类<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="CFRunLoop"><a href="#CFRunLoop" class="headerlink" title="__CFRunLoop"></a>__CFRunLoop</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> __CFRunLoop &#123;<br>    <span class="hljs-built_in">CFRuntimeBase</span> _base;<br>    pthread_mutex_t _lock;			<span class="hljs-comment">/* locked for accessing mode list */</span><br>    __CFPort _wakeUpPort;			<span class="hljs-comment">// 通过该函数CFRunLoopWakeUp内核向该端口发送消息可以唤醒runloop</span><br>    Boolean _unused;<br>    <span class="hljs-keyword">volatile</span> _per_run_data *_perRunData;              <span class="hljs-comment">// reset for runs of the run loop</span><br>    pthread_t _pthread; <span class="hljs-comment">//RunLoop相对应地线程</span><br>    uint32_t _winthread;<br>    <span class="hljs-built_in">CFMutableSetRef</span> _commonModes; <span class="hljs-comment">// 存储的是字符串，记录所有标记为common的mode</span><br>    <span class="hljs-built_in">CFMutableSetRef</span> _commonModeItems; <span class="hljs-comment">// 存储所有commonMode的item(source、timer、observer)</span><br>    <span class="hljs-built_in">CFRunLoopModeRef</span> _currentMode; <span class="hljs-comment">//当前运行的mode</span><br>    <span class="hljs-built_in">CFMutableSetRef</span> _modes; <span class="hljs-comment">// 存储的是CFRunLoopModeRef</span><br>    <span class="hljs-keyword">struct</span> _block_item *_blocks_head; <span class="hljs-comment">// do blocks的时候用到</span><br>    <span class="hljs-keyword">struct</span> _block_item *_blocks_tail;<br>    <span class="hljs-built_in">CFAbsoluteTime</span> _runTime;<br>    <span class="hljs-built_in">CFAbsoluteTime</span> _sleepTime;<br>    <span class="hljs-built_in">CFTypeRef</span> _counterpart;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>简化版<br><img src="1.png"></li>
</ul>
<h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> __CFRunLoopMode *<span class="hljs-built_in">CFRunLoopModeRef</span>;<br><br><span class="hljs-keyword">struct</span> __CFRunLoopMode &#123;<br>    <span class="hljs-built_in">CFRuntimeBase</span> _base;<br>    pthread_mutex_t _lock;	<span class="hljs-comment">/* must have the run loop locked before locking this */</span><br>    <span class="hljs-built_in">CFStringRef</span> _name; <span class="hljs-comment">// mode名称，运行模式是通过名称来识别的</span><br>    Boolean _stopped; <span class="hljs-comment">// mode是否被终止</span><br>    <span class="hljs-keyword">char</span> _padding[<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">CFMutableSetRef</span> _sources0; <br>    <span class="hljs-built_in">CFMutableSetRef</span> _sources1;<br>    <span class="hljs-built_in">CFMutableArrayRef</span> _observers;<br>    <span class="hljs-built_in">CFMutableArrayRef</span> _timers;<br>    <span class="hljs-built_in">CFMutableDictionaryRef</span> _portToV1SourceMap;<br>    __CFPortSet _portSet; <span class="hljs-comment">// 保存所有需要监听的port，比如_wakeUpPort，_timerPort都保存在这个数组中</span><br>    <span class="hljs-built_in">CFIndex</span> _observerMask;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span><br>    dispatch_source_t _timerSource;<br>    <span class="hljs-built_in">dispatch_queue_t</span> _queue;<br>    Boolean _timerFired; <span class="hljs-comment">// set to true by the source when a timer has fired</span><br>    Boolean _dispatchTimerArmed;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_MK_TIMER_TOO</span><br>    mach_port_t _timerPort;<br>    Boolean _mkTimerArmed;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span><br>    DWORD _msgQMask;<br>    <span class="hljs-keyword">void</span> (*_msgPump)(<span class="hljs-keyword">void</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    uint64_t _timerSoftDeadline; <span class="hljs-comment">/* TSR */</span><br>    uint64_t _timerHardDeadline; <span class="hljs-comment">/* TSR */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>简化版<br><img src="2.png"></li>
</ul>
<h4 id="一些常见的Mode"><a href="#一些常见的Mode" class="headerlink" title="一些常见的Mode"></a>一些常见的Mode</h4><ol>
<li><code>kCFRunLoopDefaultMode</code>: <code>App</code>的默认 <code>Mode</code>，通常主线程是在这个 <code>Mode</code> 下运行的。</li>
<li><code>UITrackingRunLoopMode</code>: 界面跟踪 <code>Mode</code>，用于 <code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他 <code>Mode</code> 影响。</li>
<li><code>UIInitializationRunLoopMode</code>: 在刚启动 <code>App</code> 时进入的第一个 <code>Mode</code>，启动完成后就不再使用。</li>
<li><code>GSEventReceiveRunLoopMode</code>: 接受系统事件的内部 <code>Mode</code>，通常用不到。</li>
<li><code>kCFRunLoopCommonModes</code>: 这是一个占位的 <code>Mode</code>，没有实际作用</li>
</ol>
<h4 id="切换mode逻辑"><a href="#切换mode逻辑" class="headerlink" title="切换mode逻辑"></a>切换mode逻辑</h4><ul>
<li><code>CFRunLoopRunSpecific</code>是启动<code>Runloop</code>和指定<code>Runloop</code>在那个<code>mode</code>下执行的。 </li>
<li>这个函数一般是操作系统进行<code>mode</code>的切换。比如滑动的时候，<code>Runloop</code>会进入<code>UITrackingRunLoopMode</code>,而<code>app</code>启动的时候<code>UIInitializationRunLoopMode</code>。</li>
<li>每一个<code>mode</code>处理完成后，如果<code>runloop</code>没有退出，就会返回之前的<code>mode</code>，初始<code>mode</code>是<code>default</code>。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>一个<code>runLoop</code>中有很多模式，存在<code>modes</code>中，但是每次只会选择一种模式,作为当前模式<br><img src="3.png"></li>
<li><code>CFRunLoopModeRef</code>代表<code>RunLoop</code>的运行模式<ul>
<li>一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code></li>
<li><code>RunLoop</code>启动时只能选择其中一个<code>Mode</code>，作为<code>currentMode</code></li>
<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li>
<li>不同组的<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code>能分隔开来，互不影响</li>
<li>如果<code>Mode</code>里没有任何<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code>，<code>RunLoop</code>会立马退出</li>
</ul>
</li>
</ul>
<h2 id="CFRunLoopModeRef-1"><a href="#CFRunLoopModeRef-1" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h2><h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopSource</span> * <span class="hljs-title">CFRunLoopSourceRef</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopSource</span> &#123;</span><br>    CFRuntimeBase _base;<br>    <span class="hljs-keyword">uint32_t</span> _bits;<br>    <span class="hljs-keyword">pthread_mutex_t</span> _lock;<br>    CFIndex _order;<span class="hljs-comment">//执行顺序</span><br>    CFMutableBagRef _runLoops;<span class="hljs-comment">//包含多个RunLoop</span><br>  	<span class="hljs-comment">//版本</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        CFRunLoopSourceContext version0;	<span class="hljs-comment">/* immutable, except invalidation */</span><br>        CFRunLoopSourceContext1 version1;	<span class="hljs-comment">/* immutable, except invalidation */</span><br>    &#125; _context;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>存在两个版本<ul>
<li><code>Source0</code> 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal (source)</code>，将这个 <code>Source</code> 标记为待处理(其标记数据存储在<code>_bits</code>中)，然后手动调用 <code>CFRunLoopWakeUp (runloop)</code> 来唤醒 <code>RunLoop</code>，让其处理这个事件。  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    CFIndex	version;<br>    <span class="hljs-keyword">void</span> *	info;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *(*retain)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">void</span>	(*release)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    CFStringRef	(*copyDescription)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    Boolean	(*equal)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info2);<br>    CFHashCode	(*hash)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">void</span>	(*schedule)(<span class="hljs-keyword">void</span> *info, CFRunLoopRef rl, CFRunLoopMode mode);<br>    <span class="hljs-keyword">void</span>	(*cancel)(<span class="hljs-keyword">void</span> *info, CFRunLoopRef rl, CFRunLoopMode mode);<br>    <span class="hljs-keyword">void</span>	(*perform)(<span class="hljs-keyword">void</span> *info);<br>&#125; CFRunLoopSourceContext;<br></code></pre></td></tr></table></figure></li>
<li><code>Source1</code>包含了一个 <code>mach_port</code> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种<code>Source</code> 能主动唤醒<code> RunLoop</code> 的线程  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    CFIndex	version;<br>    <span class="hljs-keyword">void</span> *	info;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *(*retain)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">void</span>	(*release)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    CFStringRef	(*copyDescription)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    Boolean	(*equal)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info2);<br>    CFHashCode	(*hash)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">mach_port_t</span>	(*getPort)(<span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">void</span> *	(*perform)(<span class="hljs-keyword">void</span> *msg, CFIndex size, CFAllocatorRef allocator, <span class="hljs-keyword">void</span> *info);<br> &#125; CFRunLoopSourceContext1;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a><code>Timers</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopTimer</span> &#123;</span><br>    CFRuntimeBase _base;<br>    <span class="hljs-keyword">uint16_t</span> _bits;<br>    <span class="hljs-keyword">pthread_mutex_t</span> _lock;<br>    CFRunLoopRef _runLoop;<br>    CFMutableSetRef _rlModes;<br>    CFAbsoluteTime _nextFireDate;<br>    CFTimeInterval _interval;		<span class="hljs-comment">/* immutable */</span><br>    CFTimeInterval _tolerance;          <span class="hljs-comment">/* mutable */</span><br>    <span class="hljs-keyword">uint64_t</span> _fireTSR;			<span class="hljs-comment">/* TSR units */</span><br>    CFIndex _order;			<span class="hljs-comment">/* immutable */</span><br>    CFRunLoopTimerCallBack _callout;	<span class="hljs-comment">/* immutable */</span><br>    CFRunLoopTimerContext _context;	<span class="hljs-comment">/* immutable, except invalidation */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>CFRunLoopTimerRef</code> 是基于时间的触发器，它和 <code>NSTimer</code> 是 <code>toll-free bridged</code> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 <code>RunLoop</code> 时，<code>RunLoop</code> 会注册对应的时间点，当时间点到时，<code>RunLoop</code> 会被唤醒以执行那个回调。</li>
<li><code>NSTimer</code>,新建定时器，需要添加到<code>runloop</code>才会执行</li>
<li><code>performSelector:withObject:afterDelay:</code>,<strong>本质</strong>会加到<code>runloop</code>的<code>timer</code></li>
</ul>
<h3 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a><code>Observers</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopObserver</span> &#123;</span><br>    CFRuntimeBase _base;<br>    <span class="hljs-keyword">pthread_mutex_t</span> _lock;<br>    CFRunLoopRef _runLoop; <span class="hljs-comment">//监听的RunLoop</span><br>    CFIndex _rlCount; <span class="hljs-comment">// 添加该Observer的RunLoop对象个数</span><br>    CFOptionFlags _activities;		<span class="hljs-comment">/* immutable */</span><br>    CFIndex _order;			<span class="hljs-comment">//同时间最多只能监听一个</span><br>    CFRunLoopObserverCallBack _callout; <span class="hljs-comment">// 监听的回调	/* immutable */</span><br>    CFRunLoopObserverContext _context; <span class="hljs-comment">// 上下文用于内存管理	/* immutable, except invalidation */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>用于监听<code>RunLoop</code>的状态</li>
<li><code>UI</code>刷新（<code>BeforeWaiting</code>）,在<strong>线程休眠之前</strong>，设置<code>UI</code></li>
<li><code>Autorelease pool</code>（<code>BeforeWaiting</code>）,在<strong>休眠之前</strong>释放自动释放池对象，<strong>唤醒后</strong>新建新的自动释放池</li>
</ul>
<h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><ul>
<li><code>RunLoop</code>的状态改变流程<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Run Loop Observer Activities */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">CF_OPTIONS</span>(<span class="hljs-built_in">CFOptionFlags</span>, <span class="hljs-built_in">CFRunLoopActivity</span>) &#123;<br>    kCFRunLoopEntry = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">0</span>),<br>    kCFRunLoopBeforeTimers = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">1</span>),<br>    kCFRunLoopBeforeSources = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">2</span>),<br>    kCFRunLoopBeforeWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">5</span>),<br>    kCFRunLoopAfterWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">6</span>),<br>    kCFRunLoopExit = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">7</span>),<br>    kCFRunLoopAllActivities = <span class="hljs-number">0x0FFFFFFF</span>U<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>监听<code>RunLoop的</code>状态<ul>
<li>切换<code>mode</code>之后，会先<code>kCFRunLoopExit - kCFRunLoopDefaultMode</code>，之后再<code>kCFRunLoopEntry - UITrackingRunLoopMode</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">CFRunLoopObserverRef</span> observer = <span class="hljs-built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="hljs-literal">YES</span>, <span class="hljs-number">0</span>, ^(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity) &#123;<br>    <span class="hljs-keyword">switch</span> (activity) &#123;<br>       <span class="hljs-keyword">case</span> kCFRunLoopEntry:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopEntry&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopBeforeTimers:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopBeforeSources:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeSources&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopBeforeWaiting:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopAfterWaiting:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopExit:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopExit&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 添加Observer到RunLoop中</span><br><span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);<br>    <span class="hljs-comment">// 释放</span><br><span class="hljs-built_in">CFRelease</span>(observer);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="RunLoop的内部逻辑"><a href="#RunLoop的内部逻辑" class="headerlink" title="RunLoop的内部逻辑"></a>RunLoop的内部逻辑</h3><ul>
<li>运行逻辑<br><img src="5.png"></li>
</ul>
<h4 id="来源按同步异步分类"><a href="#来源按同步异步分类" class="headerlink" title="来源按同步异步分类"></a>来源按同步异步分类</h4><ul>
<li><code>Input sources</code>,输入源传递异步事件，通常消息来自于其他线程或程序，按照是否来源于内核也分为下面几种：<ul>
<li><code>Port-Based Sources</code>，基于<code>Port</code> 的 事件，系统底层的，一般由内核自动发出信号。例如 <code>CFSocketRef</code> ，在应用层基本用不到。</li>
<li><code>Custom Input Sources</code>，非基于 <code>Port</code> 事件，用户手动创建的 <code>Source</code>，则必须从其他线程手动发送信号。</li>
<li><code>Cocoa Perform Selector Sources</code>， <code>Cocoa</code> 提供的 <code>performSelector</code> 系列方法，也是一种事件源。和基于端口的源一样，执行 <code>selector</code> 请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题。不像基于端口的源，一个 <code>selector</code> 执行完后会自动从 <code>Run Loop</code> 里面<strong>移除</strong>。</li>
</ul>
</li>
<li><code>Timer sources</code>,定时源则传递同步事件，发生在特定时间或者重复的时间间隔。<ul>
<li>定时器可以产生基于时间的通知，但它并不是<code>实时机制</code>。和输入源一样，定时器也和你的 <code>Run Loop</code> 的特定模式相关。如果定时器所在的模式当前未被 <code>Run Loop</code> 监视，那么定时器将不会开始直到 <code>Run Loop</code> 运行在相应的模式下。</li>
<li>主要有<code>NSTimer</code>和<code>performSelector:withObject:afterDelay:</code></li>
</ul>
</li>
</ul>
<h4 id="来源按对象分类"><a href="#来源按对象分类" class="headerlink" title="来源按对象分类"></a>来源按对象分类</h4><ul>
<li><p><code>Source1</code>,对应于 <code>Port-Based Sources</code>，即基于 <code>Port</code> 的，通过内核和其他线程通信。</p>
<ul>
<li>常用于接收、分发系统事件，大部分屏幕交互事件都是由 <code>Source1</code> 接收，包装成 <code>Event</code>，然后分发下去，最后由 <code>Source0</code> 去处理。</li>
<li>包括:<ul>
<li>基于<code>Port</code>的线程间通信,</li>
<li>系统事件捕捉，例如，屏幕点击，最开始是<code>source1</code>,传给具体的应用，后面会分发包装成<code>source0</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Source0</code>,是非 <code>Port</code> 事件。在应用中，触摸事件的最终处理，以及 <code>perforSelector:onThread</code> 都是包装成该类型对象，最后由开发者指定回调函数，手动处理该事件。</p>
<ul>
<li><p>需要注意的是 <code>perforSelector:onThread</code> 是否有 <code>delay</code>，即是否延迟函数或者定时函数等类型。</p>
<ul>
<li><p><code>perforSelector:onThread</code> 不是 <code>delay</code> 函数时， 是 <code>Source0</code> 事件。</p>
</li>
<li><p><code>performSelector:withObject:afterDelay</code> 有 <code>delay</code> 时，则属于 <code>Timers </code>事件。</p>
</li>
</ul>
</li>
<li><p>包括:</p>
<ul>
<li>触摸事件处理<br><img src="4.png"></li>
</ul>
</li>
<li><p><code>performSelector:onThread:</code>,线程之间的通信</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>runloop</title>
    <url>/2023/01/10/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h2><ul>
<li>顾名思义<ul>
<li>运行循环</li>
<li>在程序运行过程中循环做一些事情</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理<code>App</code>中的各种事件（比如触摸事件、定时器事件等）</li>
<li>节省<code>CPU</code>资源，提高程序性能：该做事时做事，该休息时休息</li>
</ul>
</li>
<li>应用范畴<ul>
<li>定时器（<code>Timer</code>）、<code>PerformSelector</code></li>
<li><code>GCD Async Main Queue</code></li>
<li>事件响应、手势识别、界面刷新</li>
<li>网络请求</li>
<li><code>AutoreleasePool</code></li>
</ul>
</li>
<li><code>RunLoop</code>与线程<ul>
<li>每条线程都有唯一的一个与之对应的<code>RunLoop</code>对象<ul>
<li><code>CFRunLoopGetCurrent()</code>和<code>[NSRunLoop currentRunLoop]</code>,在当前线程中获取<code>runloop</code></li>
<li>从字典中获取，如果没有的话，则会创建，并存放在字典中，<code>key</code>是线程的指针地址<br><img src="1.png"></li>
</ul>
</li>
<li><code>RunLoop</code>保存在一个全局的<code>Dictionary</code>里，线程作为<code>key</code>，<code>RunLoop</code>作为<code>value</code></li>
<li>线程刚创建时并没有<code>RunLoop</code>对象，<code>RunLoop</code>会在<strong>第一次</strong>获取它时创建</li>
<li><code>RunLoop</code>会在线程结束时销毁</li>
<li>主线程的<code>RunLoop</code>已经自动获取（创建），子线程默认没有开启<code>RunLoop</code>,需要手动开启</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>中间代码（IR）</title>
    <url>/2023/01/09/iOS%E5%AD%A6%E4%B9%A0/Runtime/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><code>Objective-C</code>在变为机器代码之前，会被<code>LLVM</code>编译器转换为中间代码（<code>Intermediate Representation</code>）,<code>ir</code>中间代码代码相比于转成<code>C++</code>更接近底层（但是肯定无法和汇编相比）</p>
</blockquote>
<ul>
<li>可以使用以下命令行指令生成中间代码<ul>
<li><code>clang -emit-llvm -S main.m</code></li>
</ul>
</li>
<li>语法简介<ul>
<li><code>@</code> - 全局变量</li>
<li><code>%</code> - 局部变量</li>
<li><code>alloca</code> - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存</li>
<li><code>i32</code> - <code>32</code>位<code>4</code>字节的整数</li>
<li><code>align</code> - 对齐</li>
<li><code>load</code> - 读出，<code>store</code> 写入</li>
<li><code>icmp</code> - 两个整数值比较，返回布尔值</li>
<li><code>br</code> - 选择分支，根据条件来转向<code>label</code>，不根据条件跳转的话类似 <code>goto</code></li>
<li><code>label</code> - 代码标签</li>
<li><code>call</code> - 调用函数</li>
</ul>
</li>
<li>示例<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">main.m<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> c = a + b;<br>test(c);<br><span class="hljs-comment">//转成main.ll</span><br>  store i32 <span class="hljs-number">10</span>, i32* %<span class="hljs-number">8</span>, align <span class="hljs-number">4</span>  <span class="hljs-comment">//将10存储到局部变量 %8</span><br>  store i32 <span class="hljs-number">20</span>, i32* %<span class="hljs-number">9</span>, align <span class="hljs-number">4</span>  <span class="hljs-comment">//将20存储到局部变量 %9</span><br>  %<span class="hljs-number">19</span> = load i32, i32* %<span class="hljs-number">8</span>, align <span class="hljs-number">4</span> <span class="hljs-comment">//将%8加载到%19</span><br>  %<span class="hljs-number">20</span> = load i32, i32* %<span class="hljs-number">9</span>, align <span class="hljs-number">4</span> <span class="hljs-comment">//将%9加载到%20</span><br>  %<span class="hljs-number">21</span> = add nsw i32 %<span class="hljs-number">19</span>, %<span class="hljs-number">20</span>    <span class="hljs-comment">// %19和%20的值相加</span><br>  store i32 %<span class="hljs-number">21</span>, i32* %<span class="hljs-number">10</span>, align <span class="hljs-number">4</span> <span class="hljs-comment">//将%21的值存储到%10</span><br>  %<span class="hljs-number">22</span> = load i32, i32* %<span class="hljs-number">10</span>, align <span class="hljs-number">4</span>  <span class="hljs-comment">//将 %10的值加载到%22</span><br>  call <span class="hljs-keyword">void</span> @test(i32 %<span class="hljs-number">22</span>) <span class="hljs-comment">//调用函数，参数是 %22</span><br></code></pre></td></tr></table></figure></li>
<li><a href="https://llvm.org/docs/LangRef.html">具体文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>runtime特殊问题</title>
    <url>/2023/01/08/iOS%E5%AD%A6%E4%B9%A0/Runtime/runtime%E7%89%B9%E6%AE%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span>:<span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSString</span> *name;<br>- (<span class="hljs-keyword">void</span>)print;<br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br>- (<span class="hljs-keyword">void</span>)print<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;my name is %@&quot;</span>, <span class="hljs-keyword">self</span>-&gt;_name);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//ViewController中</span><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-comment">// 栈空间由高到低分配空间</span><br>    <span class="hljs-comment">// Person内存中，isa处于最低位(也是对象开始地址)，其成员变量为高位</span><br>    <span class="hljs-comment">//NSString *test = @&quot;123&quot;;如果，前面有这个text对象，则实际会输出my name is 123</span><br>    <span class="hljs-keyword">id</span> cls = [Person <span class="hljs-keyword">class</span>];<br><br>    <span class="hljs-keyword">void</span> *obj = &amp;cls;<br><br>    [(__bridge <span class="hljs-keyword">id</span>)obj print];<br>    <span class="hljs-comment">//实际输出my name is &lt;ViewController: 0x104b08020&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="print为什么能够调用成功？"><a href="#print为什么能够调用成功？" class="headerlink" title="print为什么能够调用成功？"></a><code>print</code>为什么能够调用成功？</h3><ul>
<li>示意图<br><img src="1.jpg"></li>
<li>将<code>[Person class]</code>的类对象<code>cls</code>的地址赋值给<code>obj</code>之后，在<code>obj</code>地址上的<code>前8个字节</code>的东西是<code>cls</code>的类对象的地址。这和正常实例化后的对象<code>person</code>一样，<code>person</code>所指向的地址在内存上前<code>8</code>个字节的地址是<code>isa</code>(类对象的地址)</li>
<li>在调用<code>print</code>方法的时候，就会去<code>obj</code>内存的前<code>8</code>个字节，取出该内存上的对象（正常结构体，则是其内存上前<code>8</code>个字节的<code>isa</code>指针），刚好是类对象，因此最终和调用实例对象方法一样可以调用成功。</li>
<li>在<code>(__bridge id)</code>的时候，实际上将<code>objc</code>指针，转换成了<code>objc_object</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_object &#123;<br>    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_object *<span class="hljs-keyword">id</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="为什么self-name变成了ViewController等其他内容"><a href="#为什么self-name变成了ViewController等其他内容" class="headerlink" title="为什么self.name变成了ViewController等其他内容"></a>为什么<code>self.name</code>变成了<code>ViewController</code>等其他内容</h3><ul>
<li>栈上分配的临时对象的地址，是由<code>高</code>向<code>低</code>进行分配的,下面字符串的指针均指向常量区，其指针均相同，但是，栈给对象分配的指针地址，是不同的  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 0x0000000100998070 @&quot;123&quot;</span><br><span class="hljs-built_in">NSString</span> *test = <span class="hljs-string">@&quot;123&quot;</span>; <span class="hljs-comment">//&amp;test 0x000000016f46cc20</span><br><span class="hljs-built_in">NSString</span> *test1 = <span class="hljs-string">@&quot;123&quot;</span>; <span class="hljs-comment">// &amp;test1 0x000000016f46cc18</span><br><span class="hljs-built_in">NSString</span> *test2 = <span class="hljs-string">@&quot;123&quot;</span>; <span class="hljs-comment">// &amp;test2 0x000000016f46cc10</span><br></code></pre></td></tr></table></figure></li>
<li>实际分配的示意图<br><img src="2.jpg"></li>
<li><code>Person</code>结构体的类型<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> MJPerson_IMPL<br> &#123;<br>    Class isa;<br>     <span class="hljs-built_in">NSString</span> *_name;<br> &#125;;<br></code></pre></td></tr></table></figure></li>
<li><code>NSLog(@&quot;my name is %@&quot;, self-&gt;_name);</code>调用该方法的本质，实际<code>person</code>的前<code>8</code>个字节是<code>cls</code>,而在<code>isa上加8个字节</code>后去取<code>_name</code>变量(结构体越往后面的<strong>地址会越高</strong>)，则根据分配的原则，会取到<code>test</code>,因此加<code>test</code>后，则会输出<code>my name is 123</code></li>
<li>不加局部对象，则会输出<code>my name is &lt;ViewController: 0x104b08020&gt;</code>,是由于<code>[super viewDidLoad]</code>造成的，因此在没有<code>test</code>局部变量后，实际上<code>isa上加8个字节</code>后，取到的是<code>self</code>的地址。最终则会输出<code>my name is &lt;ViewController: 0x104b08020&gt;</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> <span class="hljs-comment">//[super viewDidLoad] ,源码实际</span><br> <span class="hljs-keyword">struct</span> abc = &#123;<br>       <span class="hljs-keyword">self</span>,<br>       [ViewController <span class="hljs-keyword">class</span>]<br>   &#125;;<br><span class="hljs-comment">//注意这里调用的是objc_msgSendSuper2，并非objc_msgSendSuper(这个要传入父类对象)</span><br>objc_msgSendSuper2(abc, sel_registerName(<span class="hljs-string">&quot;viewDidLoad&quot;</span>));<br><span class="hljs-comment">//因此会隐式的生成abc结构体变量，其低地址是self，高地址是[ViewController class]</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，如果将<code>[super viewDidLoad]</code>屏蔽，则由于<code>isa地址加8字节后</code>，找不到任何东西，则会出现<strong>野指针的错误</strong></li>
<li><code>objc_msgSendSuper2</code>可以通过调试发现,<code>(x/4g</code>,打出$1地址上每8个字节存的东西，打印4个),通过调试发现，后续的内存中,第一个是<code>self</code>，第二个是<code>[ViewController class]</code>，而<strong>非父类</strong>。<ul>
<li>但实际在源码中，<code>objc_msgSendSuper2</code>最终还是会去父类去调用</li>
<li><code>lldb</code>调试<br><img src="3.png"></li>
<li>源码中，还是会去父类去调用<br><img src="4.png"></li>
<li>实际调试代码，确定是用<code>objc_msgSendSuper2</code><br><img src="5.png"></li>
</ul>
</li>
</ul>
<h2 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h2><blockquote>
<p><code>&lt;objc/runtime.h&gt;</code>的<code>APi</code></p>
</blockquote>
<h3 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h3><ul>
<li><code>Class object_getClass(id obj)</code><ul>
<li>获取<code>isa</code>指向的<code>Class</code></li>
</ul>
</li>
<li><code>Class object_setClass(id obj, Class cls)</code><ul>
<li>设置<code>isa</code>指向的<code>Class</code>,<strong>可以更改当前对象指向的<code>isa</code></strong></li>
</ul>
</li>
<li><code>BOOL object_isClass(id obj)</code><ul>
<li>判断一个<code>OC</code>对象是否为<code>Class</code></li>
</ul>
</li>
<li><code>BOOL class_isMetaClass(Class cls)</code><ul>
<li>判断一个<code>Class</code>是否为元类</li>
</ul>
</li>
<li><code>Class class_getSuperclass(Class cls)</code><ul>
<li>获取父类</li>
</ul>
</li>
</ul>
<h3 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h3><ul>
<li><code>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</code><ul>
<li>动态创建一个类（参数：父类，类名，额外的内存空间）</li>
</ul>
</li>
<li><code>void objc_registerClassPair(Class cls)</code><ul>
<li>注册一个类（要在类注册之前添加成员变量），在你需要动态创建的类中，加入方法，协议，成员变量后，再去注册</li>
<li>注意，类注册完之后，类的成员变量会在<code>class_ro_t</code>中是不可变的，而方法，协议是在<code>class_rw_t</code>中，任何时候都是可以添加的</li>
</ul>
</li>
</ul>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li><code>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</code><ul>
<li>动态添加成员变量（<strong>已经注册的类是不能动态添加成员变量的</strong>）</li>
<li>例如<code>class_addIvar(newCls, &quot;_age&quot;, sizeof(int), log2(sizeof(int)), @encode(int));</code>添加一个<code>age</code>的成员变量,设置和取值，可以通过<code>kvc</code>实现<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[dog setValue:@<span class="hljs-number">10</span> forKey:<span class="hljs-string">@&quot;_age&quot;</span>];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code><ul>
<li>动态添加属性</li>
</ul>
</li>
<li><code>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code><ul>
<li>动态替换属性</li>
</ul>
</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code><ul>
<li>动态添加方法，只会在当前<code>cls类</code>中添加</li>
</ul>
</li>
<li><code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code><ul>
<li>动态替换方法</li>
</ul>
</li>
</ul>
<h3 id="成员变量相关"><a href="#成员变量相关" class="headerlink" title="成员变量相关"></a>成员变量相关</h3><ul>
<li><p><code>Ivar class_getInstanceVariable(Class cls, const char *name)</code></p>
<ul>
<li>获取一个实例变量信息</li>
<li>获取成员变量的相关信息<ul>
<li><code>const char *ivar_getName(Ivar v)</code></li>
<li><code>const char *ivar_getTypeEncoding(Ivar v)</code></li>
</ul>
</li>
<li>设置和获取成员变量的值<ul>
<li><code>void object_setIvar(id obj, Ivar ivar, id value)</code><ul>
<li>如果设置基本变量,<code>object_setIvar(person, weightVar, (__bridge id)(void *)20)</code>将基本类型转成对象</li>
</ul>
</li>
<li><code>id object_getIvar(id obj, Ivar ivar)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code></p>
<ul>
<li>拷贝实例变量列表（最后需要调用<code>free</code>释放）</li>
</ul>
</li>
</ul>
<h3 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h3><ul>
<li><code>objc_property_t class_getProperty(Class cls, const char *name)</code><ul>
<li>获取一个属性</li>
<li>获取属性的一些信息<ul>
<li><code>const char *property_getName(objc_property_t property)</code></li>
<li><code>const char *property_getAttributes(objc_property_t property)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code><ul>
<li>拷贝属性列表（最后需要调用<code>free</code>释放）</li>
</ul>
</li>
</ul>
<h3 id="方法相关"><a href="#方法相关" class="headerlink" title="方法相关"></a>方法相关</h3><ul>
<li>获得一个实例方法、类方法<ul>
<li><code>Method class_getInstanceMethod(Class cls, SEL name)</code></li>
<li><code>Method class_getClassMethod(Class cls, SEL name)</code></li>
<li>获取方法的相关信息（带有<code>copy</code>的需要调用<code>free</code>去释放）<ul>
<li><code>SEL method_getName(Method m)</code></li>
<li><code>IMP method_getImplementation(Method m)</code></li>
<li><code>const char *method_getTypeEncoding(Method m)</code></li>
<li><code>unsigned int method_getNumberOfArguments(Method m)</code></li>
<li><code>char *method_copyReturnType(Method m)</code></li>
<li><code>char *method_copyArgumentType(Method m, unsigned int index)</code></li>
</ul>
</li>
</ul>
</li>
<li>方法实现相关操作<ul>
<li><code>IMP class_getMethodImplementation(Class cls, SEL name) </code></li>
<li><code>IMP method_setImplementation(Method m, IMP imp)</code></li>
<li><code>void method_exchangeImplementations(Method m1, Method m2) </code><ul>
<li>源码<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> method_exchangeImplementations(Method m1Signed, Method m2Signed)<br>&#123;<br> <span class="hljs-keyword">if</span> (!m1Signed  ||  !m2Signed) <span class="hljs-keyword">return</span>;<br><br>method_t *m1 = _method_auth(m1Signed);<br>method_t *m2 = _method_auth(m2Signed);<br><br>mutex_locker_t lock(runtimeLock);<br><br><span class="hljs-comment">//进行imp的交换</span><br>IMP imp1 = m1-&gt;imp(<span class="hljs-literal">false</span>);<br>IMP imp2 = m2-&gt;imp(<span class="hljs-literal">false</span>);<br>SEL sel1 = m1-&gt;name();<br>SEL sel2 = m2-&gt;name();<br><br>m1-&gt;setImp(imp2);<br>m2-&gt;setImp(imp1);<br><br><br><span class="hljs-comment">// RR/AWZ updates are slow because class is unknown</span><br><span class="hljs-comment">// Cache updates are slow because class is unknown</span><br><span class="hljs-comment">// fixme build list of classes whose Methods are known externally?</span><br><span class="hljs-comment">//这里会清除方法内的所有缓存</span><br>flushCaches(<span class="hljs-literal">nil</span>, __func__, [sel1, sel2, imp1, imp2](Class c)&#123;<br>  <span class="hljs-keyword">return</span> c-&gt;cache.shouldFlush(sel1, imp1) || c-         &gt;cache.shouldFlush(sel2, imp2);<br>&#125;);<br><br>adjustCustomFlagsForMethodChange(<span class="hljs-literal">nil</span>, m1);<br>adjustCustomFlagsForMethodChange(<span class="hljs-literal">nil</span>, m2);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>拷贝方法列表（最后需要调用<code>free</code>释放）</li>
<li><code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code></li>
<li>选择器相关<ul>
<li><code>const char *sel_getName(SEL sel)</code></li>
<li><code>SEL sel_registerName(const char *str)</code></li>
</ul>
</li>
<li>用<code>block</code>作为方法实现<ul>
<li><code>IMP imp_implementationWithBlock(id block)</code></li>
<li><code>id imp_getBlock(IMP anImp)</code></li>
<li><code>BOOL imp_removeBlock(IMP anImp)</code></li>
</ul>
</li>
</ul>
<h4 id="一些获取方法特殊的地方"><a href="#一些获取方法特殊的地方" class="headerlink" title="一些获取方法特殊的地方"></a>一些获取方法特殊的地方</h4><ul>
<li><code>class_getInstanceMethod</code>,去类对象中查找方法列表，会查找父类的</li>
<li><code>class_getClassMethod</code>,注意，其底层还是调用<code>class_getInstanceMethod</code>,（<code>class_ro_t</code>只有方法列表，没有类方法和实例方法的区别，区别在于是存在类对象，还是元类中）<ul>
<li>如果当前调用的是元类，则元类去调用<code>class_getInstanceMethod</code></li>
<li>如果当前调用的是类对象，则从类对象获取元类后，去调用<code>class_getInstanceMethod</code></li>
</ul>
</li>
<li><code>class_getMethodImplementation</code>,该方法永远会返回<code>IMP</code>,和前两个会返回<code>nil</code>不同，如果当前接收者，没有实现该方法，则会返回<code>_objc_msgForward</code>,即消息转发的<code>IMP</code>,因此永远有值</li>
</ul>
<h4 id="方法交换需要注意的地方"><a href="#方法交换需要注意的地方" class="headerlink" title="方法交换需要注意的地方"></a>方法交换需要注意的地方</h4><blockquote>
<p>交换方法，一般认为交换的方法<code>toMethod</code>，是一定存在的</p>
</blockquote>
<ol>
<li>一般交换方法,交换两个方法的<code>Imp</code></li>
<li>交换自己没有实现的方法:<ul>
<li>给自己添加要交换的方法；</li>
<li>然后再将父类的<code>Imp</code>给要交换的方法</li>
</ul>
</li>
<li>交换父类和子类均未实现的方法<ul>
<li>给自己添加要交换的方法；</li>
<li>给交换的方法增加一个空的实现<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Method fromMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, fromSelector);<br>Method toMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, toSelector);<br><span class="hljs-comment">//3. 交换父类和子类均未实现的方法</span><br><span class="hljs-comment">// fromMethod没有实现</span><br><span class="hljs-keyword">if</span> (!fromMethod) &#123;<br>        class_addMethod(<span class="hljs-keyword">class</span>, <br>        fromSelector, <br>        method_getImplementation(toMethod), <br>        method_getTypeEncoding(toMethod));<br>        <span class="hljs-comment">// fromMethod不在，将原来的toMethod加上一个空的实现</span><br>        method_setImplementation(toMethod, <br>        imp_implementationWithBlock(^(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>,SEL _cmd) &#123; &#125;));<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(class_addMethod(<span class="hljs-keyword">class</span>, <br>fromSelector, <br>method_getImplementation(toMethod), <br>method_getTypeEncoding(toMethod))) &#123;<span class="hljs-comment">//将toMethod中的方法加到fromSelector中</span><br><br><span class="hljs-comment">//2. 交换自己没有实现的方法 </span><br>class_replaceMethod(<span class="hljs-keyword">class</span>, <br>toSelector, <br>method_getImplementation(fromMethod), <br>method_getTypeEncoding(fromMethod));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//1. 一般交换方法</span><br>    method_exchangeImplementations(fromMethod, toMethod);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="runtime面试题"><a href="#runtime面试题" class="headerlink" title="runtime面试题"></a>runtime面试题</h3><ol>
<li>什么是<code>Runtime</code><ul>
<li><code>OC</code>是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行<code>OC</code>的动态性就是由<code>Runtime</code>来支撑和实现的，<code>Runtime</code>是一套<code>C语言的API</code>，封装了很多动态性相关的函数平时编写的<code>OC</code>代码，底层都是转换成了<code>Runtime API</code>进行调用</li>
</ul>
</li>
<li>具体应用<ol>
<li>利用关联对象(<code>AssociatedObject</code>)给分类添加属性</li>
<li>遍历类的所有成员变量（利用<code>kvc</code>修改私有属性，字典转模型，自动归档接档）</li>
<li>交换方法实现（交换系统的方法）</li>
<li>利用消息转发机制解决方法找不到的异常问题，(重写<code>forwardInvocation:</code>实现)</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>isKindofClass和isMemberofClass</title>
    <url>/2023/01/08/iOS%E5%AD%A6%E4%B9%A0/Runtime/isKindofclass%E5%92%8CisMemberofClass/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li><code>isKindofClass</code>是判断是否是当前类,或者其子类</li>
<li><code>isMemberOfClass</code>是否是当前类</li>
</ul>
</blockquote>
<span id="more"></span>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (Class)<span class="hljs-keyword">class</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (Class)<span class="hljs-keyword">class</span> &#123;<br>    <span class="hljs-keyword">return</span> object_getClass(<span class="hljs-keyword">self</span>);<br>&#125;<br><span class="hljs-comment">//判断是否是元类成员</span><br>+ (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br>    <span class="hljs-comment">//取出元类</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>-&gt;ISA() == cls;<br>&#125;<br><br>- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] == cls;<br>&#125;<br><br><span class="hljs-comment">//判断元类</span><br><span class="hljs-comment">// [LGPerson isKindOfClass:object_getClass([LGPerson class])] 返回true</span><br>+ (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br>    <span class="hljs-comment">//取出元类，取出元类</span><br>    <span class="hljs-keyword">for</span> (Class tcls = <span class="hljs-keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;getSuperclass()) &#123;<br>        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><br><span class="hljs-comment">// [[LGPerson new] isKindOfClass:[LGPerson class]] 返回true</span><br>- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">for</span> (Class tcls = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;<br>        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span>:<span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student</span>:<span class="hljs-title">Person</span></span><br><span class="hljs-keyword">@end</span><br>[Student isKindofClass:[Person <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//false,类对象是元类的类型（isa指向），并不是类的类型</span><br>[Student isKindofClass:object_class([Person <span class="hljs-keyword">class</span>])] <span class="hljs-comment">// true,类对象是元类(类的类)的类型</span><br>[[Student new] isKindofClass:[Person <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//true，实例对象的父类是，Person</span><br><span class="hljs-comment">//不管方法调用者，不管是实例对象还是类对象，都是返回true，（只要是NSObject体系下的）</span><br>[Student isKindofClass:[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//true，基元类的父类是NSObject，所以是成立的</span><br><br>[Person isMemberOfClass:[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//false，是直接判断isa指针的</span><br>[Person isMemberOfClass:object_class([Sturdent <span class="hljs-keyword">class</span>])] <span class="hljs-comment">//false</span><br>[Person isMemberOfClass:object_class([Person <span class="hljs-keyword">class</span>])] <span class="hljs-comment">//true</span><br>[[Person new] isMemberOfClass:[Person <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>super容易混淆的问题</title>
    <url>/2023/01/06/iOS%E5%AD%A6%E4%B9%A0/Runtime/super/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>关于super的,一些容易混淆问题的记录</p>
</blockquote>
<hr>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><ul>
<li>方法中子类调用<code>[super class]</code>实际输出还是子类的对象，这和一般语言中的有所不同<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student</span>:<span class="hljs-title">Person</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Student</span></span><br>- (<span class="hljs-keyword">instancetype</span>)init<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[self class] = %@&quot;</span>, [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]); <span class="hljs-comment">// Student</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[self superclass] = %@&quot;</span>, [<span class="hljs-keyword">self</span> superclass]); <span class="hljs-comment">// Person</span><br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[super class] = %@&quot;</span>, [<span class="hljs-keyword">super</span> <span class="hljs-keyword">class</span>]); <span class="hljs-comment">// 实际输出 Student</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[super superclass] = %@&quot;</span>, [<span class="hljs-keyword">super</span> superclass]); <span class="hljs-comment">// MJPerson</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="原因解答"><a href="#原因解答" class="headerlink" title="原因解答"></a>原因解答</h3><h4 id="实际调用super的方法"><a href="#实际调用super的方法" class="headerlink" title="实际调用super的方法"></a>实际调用<code>super</code>的方法</h4><pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param super A pointer to an \c objc_super data structure. Pass values identifying the</span><br><span class="hljs-comment"> *  context the message was sent to, including the instance of the class that is to receive the</span><br><span class="hljs-comment"> *  message and the superclass at which to start searching for the method implementation.</span><br><span class="hljs-comment"> * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.</span><br><span class="hljs-comment"> * @param ...</span><br><span class="hljs-comment"> *   A variable argument list containing the arguments to the method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return The return value of the method identified by \e op.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @see objc_msgSend</span><br><span class="hljs-comment"> */</span><br>objc_msgSendSuper(<span class="hljs-keyword">struct</span> objc_super * _Nonnull <span class="hljs-keyword">super</span>, SEL _Nonnull op, ...)<br></code></pre></td></tr></table></figure>
</code></pre>
<h4 id="objc-super的结构体"><a href="#objc-super的结构体" class="headerlink" title="objc_super的结构体"></a><code>objc_super</code>的结构体</h4><pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_super &#123;<br><span class="hljs-comment">/// Specifies an instance of a class.</span><br>__<span class="hljs-keyword">unsafe_unretained</span> _Nonnull <span class="hljs-keyword">id</span> receiver;<br><br><span class="hljs-comment">/// Specifies the particular superclass of the instance to message. </span><br>__<span class="hljs-keyword">unsafe_unretained</span> _Nonnull Class super_class;<br><br><span class="hljs-comment">/* super_class is the first class to search */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</code></pre>
<h4 id="编译后的代码"><a href="#编译后的代码" class="headerlink" title="编译后的代码"></a>编译后的代码</h4><pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">objc_msgSendSuper(<br>(__rw_objc_super)&#123;(<span class="hljs-keyword">id</span>)<span class="hljs-keyword">self</span>, <br>(<span class="hljs-keyword">id</span>)class_getSuperclass(objc_getClass(<span class="hljs-string">&quot;Student&quot;</span>))&#125;,<br> sel_registerName(<span class="hljs-string">&quot;class&quot;</span>)));<br></code></pre></td></tr></table></figure>
</code></pre>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>由编译后的代码可知<code>objc_super</code>结构中的<code>receiver</code>,仍然是<code>self</code>。表明消息接收者仍然是<code>self</code></p>
</li>
<li><p>对<code>super</code>发消息的本质有</p>
<ol>
<li><strong>消息接收者仍然是<code>super</code>的子类对象</strong></li>
<li>其消息的查找是从<strong>父类开始查找方法的实现</strong></li>
</ol>
</li>
<li><p>本问题中,<code>- (Class)class</code>方法是在<code>NSObject</code>上实现的，因此不管是<code>[self class]</code>从当前类开始查找,还是<code>[super class]</code>从父类开始查找方法，实际上都是在<code>NSObject</code>上实现的，因此最终和<code>[self class]</code>一样，还是会返回<code>Student</code></p>
</li>
</ul>
<h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><ul>
<li>注意在查看汇编时，实际调用的是<code>objc_msgSendSuper2</code>,其第二个参数是当前类对象，而非父类对象，但是在实际源码中<code>objc_msgSendSuper2</code>内，最终还是会取父类去调用。因此最终和编译后的<code>objc_msgSendSuper</code>实现实际是一样的</li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>objc_msgSend</title>
    <url>/2023/01/02/iOS%E5%AD%A6%E4%B9%A0/Runtime/objc-msgSend/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h1><blockquote>
<ul>
<li><code>OC</code>中的方法调用，其实都是转换为<code>objc_msgSend</code>函数的调用</li>
<li><code>objc_msgSend</code>的执行流程可以分为<code>3</code>大阶段<ul>
<li><code>消息发送</code></li>
<li><code>动态方法解析</code></li>
<li><code>消息转发</code></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="objc-msgSend源码-866-执行流程"><a href="#objc-msgSend源码-866-执行流程" class="headerlink" title="objc_msgSend源码(866)执行流程"></a>objc_msgSend源码(866)执行流程</h2><h3 id="objc-msg-arm64-s"><a href="#objc-msg-arm64-s" class="headerlink" title="objc-msg-arm64.s"></a>objc-msg-arm64.s</h3><ul>
<li><code>objc-msg-arm64.s</code><ol>
<li><code>MSG_ENTRY _objc_msgSend </code><ul>
<li>到 <code>END_ENTRY _objc_msgSend，objc_msgSend</code>之间定义的。</li>
</ul>
</li>
<li><code>b.le    LNilOrTagged</code><ul>
<li>首先会判断是否时<code>nil</code>，为<code>nil</code>，则会跳转到<code>LReturnZero</code>直接返回，</li>
</ul>
</li>
<li><code>CacheLookup NORMAL</code><ul>
<li>不是<code>nil</code>,去查找缓存</li>
</ul>
</li>
<li><code>.macro CacheLookup</code><ul>
<li>缓存命中<code>CacheHit</code>，直接返回<code>IMP</code></li>
</ul>
</li>
<li>缓存未命中，<code>__objc_msgLookup_uncached</code><ul>
<li>没找到方法，则会调用<code>MethodTableLookup</code>去查找，<code>MethodTableLookup</code></li>
<li>最终调用的是C函数的方法是<code>lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</code>（注意汇编中的比C函数方法多一个<code>_</code>）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="第一阶段，消息发送"><a href="#第一阶段，消息发送" class="headerlink" title="第一阶段，消息发送"></a>第一阶段，消息发送</h3><ul>
<li>在<code>objc-runtime-new.mm</code>文件中，<code>第一个阶段</code>，查找方法<ol>
<li><code>lookUpImpOrForward</code>,为从缓存中查找的逻辑</li>
<li><code>realizeAndInitializeIfNeeded_locked</code><ul>
<li>确保类已经<code>realize</code>了,初始化了</li>
</ul>
</li>
<li><code>for</code>循环进行遍历查找类<code>cls</code>中方法，有个最大的数进行记录，防止陷入死循环<ol>
<li>先去<code>cache_getImp</code>从缓存中获取<ul>
<li>在查找中间的方法过程中，可能会有新方法在中间添加进来，也都会先加到缓存中</li>
</ul>
</li>
<li><code>getMethodNoSuper_nolock</code>、<code>search_method_list_inline</code>、<code>log_and_fill_cache</code><ol>
<li>从<code>class_rw_t</code>的<code>methods</code>中找到所有类和分类的方法，遍历<code>method_list_t</code>查找，因此需要类先<code>realize</code></li>
<li>如果是排好序列的(排序的实现，是在类的<code>realize</code>方法中的<code>methodizeClass</code>进行解析的)，<code>findMethodInSortedMethodList</code>中去查找方法,根据方法名查找，已经排序，<code>二分查找</code>的方式<ul>
<li>如果有相同的有很多，会倒序查找，找到排序的第一个方法</li>
<li>排序，会在<code>prepareMethodLists</code>中调用<code>fixupMethodList</code>方法<ul>
<li><code>method_t</code>中方法类型有<code>big</code>、<code>small</code>、<code>bigSigned</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">    <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> Kind &#123;<br>        <span class="hljs-comment">// Note: method_invoke detects small methods by detecting 1 in the low</span><br>        <span class="hljs-comment">// bit. Any change to that will require a corresponding change to</span><br>        <span class="hljs-comment">// method_invoke.</span><br>        big = <span class="hljs-number">0</span>,<br><br>        <span class="hljs-comment">// `small` encompasses both small and small direct methods. We</span><br>        <span class="hljs-comment">// distinguish those cases by doing a range check against the shared</span><br>        <span class="hljs-comment">// cache.</span><br>        small = <span class="hljs-number">1</span>,<br>        bigSigned = <span class="hljs-number">2</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>big</code>是默认的，大方法，其值为指针  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> big &#123;<br>    SEL name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types;<br>    MethodListIMP imp;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><code>small</code>，小方法，其值表示为相对每个字段的额外地址，其结构是  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> small &#123;<br>    <span class="hljs-comment">// The name field either refers to a selector (in the shared</span><br>    <span class="hljs-comment">// cache) or a selref (everywhere else).</span><br>    RelativePointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *&gt; name;<br>    RelativePointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *&gt; types;<br>    RelativePointer&lt;IMP, <span class="hljs-comment">/*isNullable*/</span><span class="hljs-literal">false</span>&gt; imp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>其引用的选择器在(共享缓存)或者是在磁盘上，考虑<code>相关动态库的系统方法</code>,该方法是只读内存，因此<code>small</code>的是无法修改的。其是否是<code>smal</code>l方法，是由编译器决定，进行设置的</li>
</ul>
</li>
<li><code>bigSigned</code>,和<code>big</code>相同，但是其<code>name</code>已经签名，该方法是由运行时添加的，类似<code>class_addMethod</code>方法添加的</li>
</ul>
</li>
<li>对方法排序，只会对非<code>small</code>的方法进行排序,排序是根据方法名<code>SEL</code>的地址由低到高排序的<br><img src="4.png"></li>
<li>排序的方式采用的是<code>**归并排序**</code><br><img src="5.png"></li>
</ul>
</li>
</ul>
</li>
<li>不是排好序的方法，调用<code>findMethodInUnsortedMethodList</code>，<code>线性遍历查找</code>，找到第一个方法名相同的，后，返回 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">template&lt;<span class="hljs-keyword">class</span> getNameFunc&gt;<br>ALWAYS_INLINE <span class="hljs-keyword">static</span> method_t *<br>findMethodInUnsortedMethodList(SEL sel, <span class="hljs-keyword">const</span> method_list_t *list, <span class="hljs-keyword">const</span> getNameFunc &amp;getName)<br>&#123;<br>    <span class="hljs-keyword">for</span> (auto&amp; meth : *list) &#123;<br>        <span class="hljs-keyword">if</span> (getName(meth) == sel) <span class="hljs-keyword">return</span> &amp;meth;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>log_and_fill_cache(cls, imp, sel, inst, curClass)</code>,查找到方法后，调用<code>void cache_t::insert</code>,去插入到缓存中,保存的类是最开始查找的类方法<code>cls</code>中,而并非当前的类(即如果查找到了父类的<code>IMP</code>,最后会将这个<code>IMP</code>保存到子类的<code>cache</code>)。</li>
<li>当前<code>curClass</code>中没有找到，则会去父类遍历查找<code>curClass = curClass-&gt;getSuperclass()) == nil</code><ul>
<li>如果找到最后的父类，都没有找到方法，则会设置当前<code>imp = _objc_msgForward_impcache</code></li>
<li>或者从缓存中取到的方法，等于<code>_objc_msgForward_impcache</code>,则会跳出循环</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>消息发送流程<br><img src="1.png"></li>
</ul>
<h3 id="第二阶段，动态方法解析"><a href="#第二阶段，动态方法解析" class="headerlink" title="第二阶段，动态方法解析"></a>第二阶段，动态方法解析</h3><ul>
<li><code>log_and_fill_cache</code>，<code>第二个阶段</code>，动态方法解析<ul>
<li><code>(behavior &amp; LOOKUP_RESOLVER) == 0</code>由最开始汇编中，传入，需要进行方法解析，则进入方法解析流程<ol>
<li> <code>behavior ^= LOOKUP_RESOLVER</code>,解析之后，就不需要了</li>
<li> <code>resolveMethod_locked(inst, sel, cls, behavior)</code>,进入方法解析流程</li>
<li>不是元类，则走<code>resolveInstanceMethod</code>方法 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> resolveInstanceMethod(<span class="hljs-keyword">id</span> inst, SEL sel, Class cls)<br>&#123;<br>    lockdebug::assert_unlocked(&amp;runtimeLock);<br>    ASSERT(cls-&gt;isRealized());<br>    SEL resolve_sel = <span class="hljs-keyword">@selector</span>(resolveInstanceMethod:);<br><br>    <span class="hljs-keyword">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(<span class="hljs-comment">/*authenticated*/</span><span class="hljs-literal">true</span>))) &#123;<br>        <span class="hljs-comment">// Resolver not implemented.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="hljs-keyword">typeof</span>(msg))objc_msgSend;<br>    <span class="hljs-keyword">bool</span> resolved = msg(cls, resolve_sel, sel);<br><br>    <span class="hljs-comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span><br>    <span class="hljs-comment">// +resolveInstanceMethod adds to self a.k.a. cls</span><br>    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>会先去找<code>resolveInstanceMethod</code>,<code>_lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(true))</code>先去,其<code>isa</code>，也就是其元类对象，缓存中找，找不到，则走<code>阶段一</code>的方法查找，这次的<code>behavior</code>不包含<code>LOOKUP_RESOLVER</code>,这次是不会去走动态方法解析<ul>
<li> 其中<code>NSObject</code>中<code>+(BOOL)resolveInstanceMethod</code>会有基础实现</li>
<li>因为后续会同步再次去查询方法，因此是否返回<code>true</code>还是<code>false</code>，不影响实际的结果，但是按规范，返回<code>true</code></li>
</ul>
</li>
<li>会用<code>objc_msgSend</code>调用方法</li>
<li>会再调用<code>lookUpImpOrNilTryCache(inst, sel, cls)</code>,去查找，一开始寻找的方法</li>
<li>方法的返回，最后通过调用<code>lookUpImpOrForwardTryCache</code>去查找<ul>
<li><strong>注意</strong>，用<code>lookUpImpOrNilTryCache</code>传入的<code>behavior</code>包括<code>LOOKUP_NIL</code>，即没有搜索到，会返回<code>nil</code>,不会出现<strong>找不到方法的异常</strong></li>
</ul>
</li>
</ol>
</li>
<li>是元类，则会查找<code>resolveClassMethod</code>，同时，如果调用<code>lookUpImpOrNilTryCache</code>,没有找到，也会去走<code>resolveInstanceMethod</code>方法，即上面的流程(注意，此时他会去元类的<code>isa</code>指针中找方法，而元类的<code>isa</code>指针，也就是基元类，也就是<code>NSObjec</code>类方法中)，解析类的方法和实例方法流程一样 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// try [nonMetaClass resolveClassMethod:sel]</span><br><span class="hljs-comment">// and [cls resolveInstanceMethod:sel]</span><br>resolveClassMethod(inst, sel, cls);<br><span class="hljs-keyword">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;<br>    resolveInstanceMethod(inst, sel, cls);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>同样会先去找方法<code>resolveClassMethod</code>，其在<code>NSObject</code>中也已实现</li>
<li>会用<code>objc_msgSend</code>的方式调用</li>
<li>最终用<code>lookUpImpOrForwardTryCache</code>去查找方法</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>示例代码<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> c_other(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL _cmd)<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;c_other - %@ - %@&quot;</span>, <span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>&#125;<br>- (<span class="hljs-keyword">void</span>)other &#123;<br> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;other - %@ - %s&quot;</span>, <span class="hljs-keyword">self</span>, __func__);<br>&#125;<br>+ (<span class="hljs-built_in">BOOL</span>)resolveClassMethod:(SEL)sel<br>&#123;<br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(test)) &#123;<br>        <span class="hljs-comment">// 第一个参数是object_getClass(self)</span><br>       <span class="hljs-comment">// c函数 class_addMethod(object_getClass(self), sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br>       Method method = class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(other));<br>        class_addMethod(<br>        object_getClass(<span class="hljs-keyword">self</span>), <br>        sel,<br>        method_getImplementation(method), <br>        method_getTypeEncoding(method));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveClassMethod:sel];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>动态解析流程<br><img src="2.png"></li>
</ul>
<h3 id="第三阶段，消息转发"><a href="#第三阶段，消息转发" class="headerlink" title="第三阶段，消息转发"></a>第三阶段，消息转发</h3><ul>
<li>在<code>第二阶段</code>中，最终会用<code>lookUpImpOrForwardTryCache</code>,再次去查找一次方法，这次，如果动态解析方法添加到了，则会查找到方法，并直接返回；否则会将<code>imp</code>仍人为<code>_objc_msgForward_impcache</code>，返回。</li>
<li>最终方法调用者会去执行<code>_objc_msgForward_impcache</code>,会跳转到该方法的实现上，该方法在<code>objc-msg-arm64.s</code>文件内，属于汇编，<code>objc_msgSend</code> 函数就是使用汇编语言编写的，其结构分为序言准备（<code>Prologue</code>）、函数体（<code>Body</code>）、结束收尾（<code>Epilogue</code>）三部分。<ul>
<li><code>ENTRY __objc_msgForward</code></li>
<li><code>Core Foundation</code></li>
<li><code>__forwarding__</code>（不开源)</li>
</ul>
</li>
<li>汇编实现的原因<ol>
<li>速度快</li>
<li>函数在调用的时候，需要约定好参数的传递顺序、传递方式、栈维护的方式、名字修饰。这种函数调用这个和被调用者对函数如何调用的约定，就叫做调用惯例。高级语言编译时，会生成遵循调用惯例的代码。<ul>
<li>编译时需要安装调用惯例针对不同CPU架构编译，生成会变代码，确定好栈和寄存器，如果少了编译过程，直接在运行时去动态地调用函数，就需要先生成动态调用相应寄存器和栈状态的汇编指令</li>
<li>要带到事先生成相应寄存器和栈的目的，就不能使用遵循调用惯例的高级编程语言，而要使用汇编语言<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// __forwarding__伪代码</span><br><span class="hljs-keyword">int</span> __forwarding__(<span class="hljs-keyword">void</span> *frameStackPointer, <span class="hljs-keyword">int</span> isStret) &#123;<br>    <span class="hljs-keyword">id</span> receiver = *(<span class="hljs-keyword">id</span> *)frameStackPointer;<br>    SEL sel = *(SEL *)(frameStackPointer + <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *selName = sel_getName(sel);<br>    Class receiverClass = object_getClass(receiver);<br><br>    <span class="hljs-comment">// 调用 forwardingTargetForSelector:</span><br>    <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(forwardingTargetForSelector:))) &#123;<br>        <span class="hljs-keyword">id</span> forwardingTarget = [receiver forwardingTargetForSelector:sel];<br>        <span class="hljs-keyword">if</span> (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;<br>            <span class="hljs-keyword">if</span> (isStret == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">int</span> ret;<br>                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);<br>                <span class="hljs-keyword">return</span> ret;<br>            &#125;<br>            <span class="hljs-keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 僵尸对象</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *className = class_getName(receiverClass);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zombiePrefix = <span class="hljs-string">&quot;_NSZombie_&quot;</span>;<br>    size_t prefixLen = strlen(zombiePrefix); <span class="hljs-comment">// 0xa</span><br>    <span class="hljs-keyword">if</span> (strncmp(className, zombiePrefix, prefixLen) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelError,<br>              <span class="hljs-string">@&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;</span>,<br>              className + prefixLen,<br>              selName,<br>              receiver);<br>        &lt;breakpoint-interrupt&gt;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span><br>    <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(methodSignatureForSelector:))) &#123;<br>        <span class="hljs-built_in">NSMethodSignature</span> *methodSignature = [receiver methodSignatureForSelector:sel];<br>        <span class="hljs-keyword">if</span> (methodSignature) &#123;<br>            <span class="hljs-built_in">BOOL</span> signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;<br>            <span class="hljs-keyword">if</span> (signatureIsStret != isStret) &#123;<br>                <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>                      <span class="hljs-string">@&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#x27;%s&#x27;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;</span>,<br>                      selName,<br>                      signatureIsStret ? <span class="hljs-string">&quot;&quot;</span> : not,<br>                      isStret ? <span class="hljs-string">&quot;&quot;</span> : not);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(forwardInvocation:))) &#123;<br>                <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> _invocationWithMethodSignature:methodSignature frame:frameStackPointer];<br><br>                [receiver forwardInvocation:invocation];<br><br>                <span class="hljs-keyword">void</span> *returnValue = <span class="hljs-literal">NULL</span>;<br>                [invocation getReturnValue:&amp;value];<br>                <span class="hljs-keyword">return</span> returnValue;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>                      <span class="hljs-string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement forwardInvocation: -- dropping message&quot;</span>,<br>                      receiver,<br>                      className);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    SEL *registeredSel = sel_getUid(selName);<br><br>    <span class="hljs-comment">// selector 是否已经在 Runtime 注册过</span><br>    <span class="hljs-keyword">if</span> (sel != registeredSel) &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>              <span class="hljs-string">@&quot;*** NSForwarding: warning: selector (%p) for message &#x27;%s&#x27; does not match selector known to Objective C runtime (%p)-- abort&quot;</span>,<br>              sel,<br>              selName,<br>              registeredSel);<br>    &#125; <span class="hljs-comment">// doesNotRecognizeSelector</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass,<span class="hljs-keyword">@selector</span>(doesNotRecognizeSelector:))) &#123;<br>        [receiver doesNotRecognizeSelector:sel];<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>              <span class="hljs-string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement doesNotRecognizeSelector: -- abort&quot;</span>,<br>              receiver,<br>              className);<br>    &#125;<br><br>    <span class="hljs-comment">// The point of no return.</span><br>    kill(getpid(), <span class="hljs-number">9</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li>实际实现,类方法中也有消息转发处理<ol>
<li><code>-(id)forwardingTargetForSelector:</code>返回可以转发该方法的对象，如果是类方法则是<code>+</code><ul>
<li><strong>注意</strong>，也可以在该实例方法中返回可以响应的类对象（如果类方法支持的话）</li>
</ul>
</li>
<li>如果<code>1</code>中返回的是该对象本身，则会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>,先获取方法签名<ul>
<li>注意方法签名，会决定<code>NSInvocation</code>中的参数和返回值</li>
</ul>
</li>
<li><code>2</code>中获取了方法签名之后，再会调用<code>forwardInvocation:(NSInvocation *)anInvocation</code>方法</li>
<li>如果最后还是没有实现方法<code>3</code>，则会走<code>doesNotRecognizeSelector </code>方法，发出未找到方法的错误<ul>
<li>注意，只要方法<code>3</code>实现了，就算没有任何实现，那么也不会走到<code>doesNotRecognizeSelector</code>的流程，要<strong>注意</strong><code>NSObjec</code>中<code>forwardInvocation:</code>的默认实现,如果没实际实现转发的方法，还是会触发<code>doesNotRecognizeSelector </code></li>
</ul>
</li>
</ol>
</li>
<li><strong>注意</strong>，消息转发成功之后，在当前<strong>调用的类</strong>中是不会缓存方法的，但是在<strong>转发的类</strong>中会缓存;因此,后续调用该方法，仍然无法从缓存中获取，每次调用该方法，都会<strong>重新走消息转发流程</strong>。<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//如果是类方法则是+</span><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">if</span> (aSelector == <span class="hljs-keyword">@selector</span>(text)) &#123;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;v16@0:8i20&quot;</span>];<br>        <span class="hljs-comment">//不带数字位置也是可以的，v-&gt;void、@-&gt;self、:-&gt;SEL、i-&gt;int</span><br>        <span class="hljs-comment">// return [NSMethodSignature signatureWithObjCTypes:&quot;v@:i&quot;]</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>  [<span class="hljs-keyword">super</span> methodSignatureForSelector: aSelector];<br>&#125;<br><span class="hljs-comment">//如果是类方法则是+</span><br>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation &#123;<br>    [anInvocation invokeWithTarget:[[LGPersonText alloc] init]];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>NSObject</code>中的内部实现<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>+ (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation &#123;<br>    [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="hljs-number">0</span>)];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation &#123;<br>    [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="hljs-number">0</span>)];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>方法转发流程<br><img src="3.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
<li><code>OC</code>的消息机制<ul>
<li><code>OC</code>中的方法调用其实都是转成了<code>objc_msgSend</code>函数的调用，给<code>receiver</code>发送一条消息（<code>selector</code>方法）</li>
<li><code>objc_msgSend</code>底层有3大阶段<ol>
<li>消息发送（当前类、父类中查找）</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>objc_class</title>
    <url>/2023/01/01/iOS%E5%AD%A6%E4%B9%A0/Runtime/objc-class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h1><p><img src="1.png"></p>
<h1 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h1><blockquote>
<p><code>class_rw_t</code>里面的<code>methods</code>、<code>properties</code>、<code>protocols</code>是二维数组，是可读可写的，包含了类的初始内容、分类的内容。</p>
</blockquote>
<p><img src="2.png"></p>
<h2 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h2><blockquote>
<p><code>class_ro_t</code>里面的<code>baseMethodList</code>、<code>baseProtocols</code>、<code>ivars</code>、<code>baseProperties</code>是一维数组，是只读的，包含了类的初始内容。</p>
</blockquote>
<p><img src="3.png"></p>
<h2 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h2><blockquote>
<p><code>method_t</code>是对方法\函数的封装</p>
</blockquote>
<p><img src="4.png"></p>
<ul>
<li><code>IMP</code>代表函数的具体实现<ul>
<li><code>typedef id _Nullable (*IMP)(id _Nonnull,SEL _Nonnull,...)</code></li>
</ul>
</li>
<li><code>SEL</code>代表方法\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似 <ul>
<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>
<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是<strong>相同</strong>的 </li>
</ul>
</li>
<li><code>types</code>包含了函数返回值、参数编码的字符串  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">types -&gt;  i24@<span class="hljs-number">0</span>:<span class="hljs-number">8</span>i16f20<br> i <span class="hljs-number">24</span> @ <span class="hljs-number">0</span> : <span class="hljs-number">8</span> i <span class="hljs-number">16</span> f <span class="hljs-number">20</span><br>- (<span class="hljs-keyword">int</span>)test:(<span class="hljs-keyword">int</span>)age height:(<span class="hljs-keyword">float</span>)height;<br></code></pre></td></tr></table></figure>
<ul>
<li>方法为<code>objc_msgSend(id self,SEL,...)</code></li>
<li><code>i-&gt;int</code>,<code>@-&gt;id</code>,<code>:-&gt;SEL</code>,<code>f-&gt;float</code></li>
<li><code>24</code>参数总字节，<code>0</code>从<code>0</code>字节开始，<code>8</code>从第<code>8</code>字节开始</li>
</ul>
</li>
</ul>
<h2 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h2><blockquote>
<p><code>Class</code>内部结构中有个方法缓存（<code>cache_t</code>），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p>
</blockquote>
<ul>
<li><code>mask</code>存储的是散列表的长度减1<br><img src="5.png"></li>
<li>缓存查找<ul>
<li><code>objc-cache.mm</code></li>
<li><code>void cache_t::insert(SEL sel, IMP imp, id receiver)</code></li>
</ul>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol>
<li>插入之前，会先判断是否需要扩容，扩容的条件为，大于之前的倍数（不同平台会不一样）,会扩容为<code>2</code>倍扩容，不超过最大缓存尺寸(最大为<code>MAX_CACHE_SIZE</code> = <code>1&lt;&lt;16</code>,最小为<code>INIT_CACHE_SIZE</code> = <code>1&lt;&lt;2</code>)<ul>
<li><code>arm64</code>,当前缓存大于等于的<code>7/8</code>倍时，扩容<code>2</code>倍<ul>
<li><code>CACHE_END_MARKER</code>是<code>0</code></li>
<li><code>cache_fill_ratio</code>是之前的<code>7/8</code>倍</li>
<li><code>INIT_CACHE_SIZE</code>最小是<code>2</code></li>
</ul>
</li>
<li><code>x86</code>,当前缓存<code>+1</code>大于等于的<code>3/4</code>倍时，扩容<code>2</code>倍<ul>
<li><code>CACHE_END_MARKER</code>是<code>1</code></li>
<li><code>cache_fill_ratio</code>是之前的<code>3/4</code>倍</li>
<li><code>INIT_CACHE_SIZE</code>最小是<code>4</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="8.png"><br>2. 当扩容时，生成的新的<code>buckets</code>会直接替换旧的，会清除之前缓存的方法，也就是说，之前缓存的方法，不会传给新扩容的缓存，缓存会全部释放。新缓存又要重新开始计数。<br><img src="9.png"><br>3. 向缓存中插入方法<br><img src="6.png"><br>4. <code>hash</code>的方式是直接用<code>SEL &amp; mask</code>得到<code>key</code>的方式。存在冲突时，会根据取到的<code>sel</code>判断是不是同一方法<br><img src="10.png"><br>    <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">bucket_t *buckets = cache._buckets;<br>bucket_t bucket = buckets[(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-keyword">@selector</span>(studentTest) &amp; cache._mask];<br><span class="hljs-comment">//即可拿到缓存中的选择器，和实现，可能会有hash冲突，源码中会根据拿到的sel看是不是一致的</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %p&quot;</span>, bucket._key, bucket._imp);<br></code></pre></td></tr></table></figure><br>    - 解决<code>hash</code>冲突的方式，<strong>开放地址法-线性探测</strong></p>
<p><img src="7.png"></p>
<h3 id="扩容时，为什么要释放旧的缓存"><a href="#扩容时，为什么要释放旧的缓存" class="headerlink" title="扩容时，为什么要释放旧的缓存"></a>扩容时，为什么要释放旧的缓存</h3><ol>
<li>提高<code>msgSend</code>效率，扩容发生在<code>msgSend</code>中，如果再做<code>copy</code>操作，会影响消息 发送的效率</li>
<li><code>缓存命中概率</code>，每个方法调用的概率在底层设计的时候，都视为是一样的。所以之前缓存的方法，在后面调用的概率和其他方法的概率是一样的。即清除之前的缓存，不会影响命中概率。</li>
<li><code>减少扩容次数</code>，从而提高效率。还是2的衍生，如果及时清除，可以缓存更多的方法，这样，扩容的概率跟放入新缓存相比更小。</li>
</ol>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>OC类结构</tag>
      </tags>
  </entry>
  <entry>
    <title>isa</title>
    <url>/2023/01/01/iOS%E5%AD%A6%E4%B9%A0/Runtime/isa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><blockquote>
<ul>
<li><code>objective-C</code>的动态性是由<code>runtime API</code>来支撑的</li>
<li><code>runtime API</code>提供的接口基本都是<code>C</code>语言的，源码由<code>C\C++\</code>汇编语言编写</li>
</ul>
</blockquote>
<h2 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h2><blockquote>
<ul>
<li>在<code>arm64</code>架构之前，<code>isa</code>就是一个普通的指针，存储着<code>Class</code>、<code>Meta-Class</code>对象的内存地址</li>
<li>从<code>arm64</code>架构开始，对<code>isa</code>进行了优化，变成了一个共用体（<code>union</code>）(结构体和数据共用的一个内存地址，实际共用体中的结构体，只做展示作用)结构，使用位域来存储更多信息</li>
</ul>
</blockquote>
<h3 id="isa结构"><a href="#isa结构" class="headerlink" title="isa结构"></a>isa结构</h3><ol>
<li>共用体（<code>union</code>）结构(结构体和数据共用的一个内存地址，实际数据存储在<code>bits</code>中，共用体中的结构体，只做展示作用)<br><img src="1.png"><img src="2.png"></li>
</ol>
<h3 id="isa指针每位的含义"><a href="#isa指针每位的含义" class="headerlink" title="isa指针每位的含义"></a>isa指针每位的含义</h3><blockquote>
<p>从内存地址，从上往下，即地址从右边，往左</p>
</blockquote>
<ul>
<li><code>nonpointer</code><ul>
<li><code>0</code>,代表普通的指针，存储着<code>Class</code>、<code>Meta—Class</code>对象的内存地址</li>
<li><code>1</code>,代表优化过，使用位域存储更多的信息</li>
</ul>
</li>
<li><code>has_assoc</code><ul>
<li>是否有设置过关联对象，如果没有，释放会更快</li>
</ul>
</li>
<li><code>has_cxx_dtor</code><ul>
<li>是否有<code>C++</code>的析构函数（<code>.cxx_destruct</code>),如果没有，释放会更快</li>
</ul>
</li>
<li><code>shiftcls</code><ul>
<li>存储着<code>Class</code>、<code>Meta-Class</code>对象的内存地址信息</li>
<li><code>ios</code>中<code>mask</code>为<code>0x0000000ffffffff8</code>,因此，很多类以及元类的地址是以8和0结尾的，因为最后三位均是<code>000</code>.</li>
</ul>
</li>
<li><code>magic</code><ul>
<li>用于在调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li><code>weakly_referenced</code><ul>
<li>是否有被弱引用指向过，如果没有,释放时会更快</li>
</ul>
</li>
<li><code>deallocating</code>/<code>unused</code>(818版本之后)<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li><code>extra_rc</code><ul>
<li>里面存储的值是引用计数器减<code>1</code></li>
</ul>
</li>
<li><code>has_sidetable_rc</code><ul>
<li>引用计数器是否过大无法存储在<code>isa</code>中，如果为<code>1</code>，那么引用计数会存储在一个叫<code>SideTable</code>的类的属性中</li>
</ul>
</li>
</ul>
<p>注意，这里的都是<strong>是否有设置过</strong>，就像关联对象，就算最后将所有的关联对象删除，仍是<code>1</code>，如果有这些，在销毁的时候，会做额外工作.<br><img src="3.png"></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>OC类结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Block</title>
    <url>/2022/12/29/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Block%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="block的本质"><a href="#block的本质" class="headerlink" title="block的本质"></a>block的本质</h1><ul>
<li><p><code>block</code>本质上也是一个<code>OC</code>对象，它内部也有个<code>isa</code>指针</p>
</li>
<li><p><code>block</code>是封装了函数调用以及函数调用环境的<code>OC</code>对象</p>
</li>
<li><p><code>block</code>的底层结构如右图所示<br><img src="1.png"></p>
<h2 id="block编译成C"><a href="#block编译成C" class="headerlink" title="block编译成C++"></a>block编译成C++</h2><blockquote>
<p>通过将<code>block</code>编译成<code>C++</code>来分析<code>block</code>的本质</p>
</blockquote>
</li>
<li><p>执行命令<code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件</code></p>
</li>
<li><p>捕获了<code>auto</code>变量<code>JPPerson</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  JPPerson *__<span class="hljs-keyword">strong</span> person;<br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, JPPerson *__<span class="hljs-keyword">strong</span> _person, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : person(_person) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>  <span class="hljs-keyword">void</span> (*<span class="hljs-keyword">copy</span>)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>  <span class="hljs-keyword">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>与<code>block</code>相关的<code>__block</code>变量,编译器会将<code>__block</code>变量包装成一个对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> __Block_byref_p_1 &#123;<br>  <span class="hljs-keyword">void</span> *__isa;<br>__Block_byref_p_1 *__forwarding;<br> <span class="hljs-keyword">int</span> __flags;<br> <span class="hljs-keyword">int</span> __size;<br> <span class="hljs-keyword">void</span> (*__Block_byref_id_object_copy)(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*);<br> <span class="hljs-keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="hljs-keyword">void</span>*);<br> <span class="hljs-built_in">NSObject</span> *__<span class="hljs-keyword">weak</span> p;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>再将有<code>_weak</code>的方法，使用<code>clang</code>转换OC为<code>C++</code>代码时，注意支持<code>ARC</code>、以及指定运行时系统版本</p>
<ul>
<li><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-16.0.0 main.m -o main.cpp</code></li>
</ul>
</li>
</ul>
<h2 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h2><table>
<thead>
<tr>
<th>block类型</th>
<th>环境</th>
</tr>
</thead>
<tbody><tr>
<td><em>NSGlobalBlock</em></td>
<td>没有访问auto变量</td>
</tr>
<tr>
<td><em>NSStackBlock</em></td>
<td>访问了auto变量</td>
</tr>
<tr>
<td><em>NSMallocBlock</em></td>
<td>_NSStackBlock_调用了copy</td>
</tr>
</tbody></table>
<ul>
<li>注意在非<code>ARC</code>环境下是准确的，如果在<code>ARC</code>环境下,编译器会根据情况，将栈上的<code>block</code>,变成<code>NSMalloCBlock</code></li>
</ul>
<h3 id="block的copy"><a href="#block的copy" class="headerlink" title="block的copy"></a><code>block</code>的<code>copy</code></h3><ul>
<li>每一种<code>block</code>调用<code>copy</code>后的结果如图所示</li>
</ul>
<table>
<thead>
<tr>
<th>block的类</th>
<th>副本源的配置存储域</th>
<th>赋值效果</th>
</tr>
</thead>
<tbody><tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody></table>
<ul>
<li>在<code>ARC</code>环境下，编译器会根据情况，将栈上的<code>block</code>,拷贝到堆上,有以下情况<ol>
<li><code>block</code>作为函数的返回值时</li>
<li>将<code>block</code>赋值给<code>__strong</code>指针</li>
<li><code>block</code>作为<code>Cocoa api</code>名含有<code>usingBlock</code>的方法参数输入时</li>
<li><code>block</code>作为<code>GCD API</code>的方法参数时</li>
</ol>
</li>
</ul>
<h3 id="当block内部访问了对象类型的auto变量时"><a href="#当block内部访问了对象类型的auto变量时" class="headerlink" title="当block内部访问了对象类型的auto变量时"></a>当block内部访问了对象类型的auto变量时</h3><ul>
<li>如果<code>block</code>是在栈上，将不会对<code>auto</code>变量产生强引用</li>
<li>如果<code>block</code>是在堆上<ul>
<li>会调用<code>block</code>内部的<code>copy</code>函数</li>
<li><code>copy</code>函数内部会调用<code>_Block_objc_assign</code>函数</li>
<li><code>_Block_objc_assign</code>函数会根据<code>auto</code>变量的修饰符（<code>_strong</code>、<code>_weak</code>、<code>_unsafe_unretained</code>）做出相应的操作，类似于<code>retain</code>（形成强引用、弱引用）</li>
</ul>
</li>
</ul>
<h2 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="block的内存管理"></a>block的内存管理</h2><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><ul>
<li><code>block</code>的内存管理代码  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;person, (<span class="hljs-keyword">void</span>*)src-&gt;person, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;person, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>当<code>block</code>在栈上</strong>时，并不会对<code>__block</code>变量，以及<code>auto</code>的对象产生强引用</li>
<li>当<code>block</code>被<code>copy</code>到堆时<ul>
<li>会调用<code>block</code>内部的<code>copy</code>函数</li>
<li><code>copy</code>函数内部会调用<code>_Block_object_assign</code>函数</li>
<li><code>_Block_object_assign</code>函数会对<code>_block</code>变量形成强引用,会区分是<code>auto</code>对象（会区分是<code>_weak</code>还是<code>_strong</code>），还是<code>_block</code>对象（强引用）</li>
</ul>
</li>
<li>当<code>block</code>从堆移除<ul>
<li>会调用<code>block</code>内部的<code>dispose</code>函数</li>
<li><code>dispose</code>函数内部会调用<code>_Block_object_dispose</code>函数</li>
<li><code>_Block_object_dispose</code>函数会自动释放引用的<code>_block</code>变量</li>
</ul>
</li>
</ul>
<h3 id="block-1"><a href="#block-1" class="headerlink" title="__block"></a>__block</h3><ul>
<li><p><code>__block</code>一个对象的内存管理代码,<code>copy</code>方法中加的<code>40</code>,是对象p相对结构体的偏移</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">_attribute__((__blocks__(<span class="hljs-keyword">byref</span>))) __attribute__((objc_ownership(<span class="hljs-keyword">weak</span>))) __Block_byref_p_1 p = &#123;<br>(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>,<br>(__Block_byref_p_1 *)&amp;p, <br><span class="hljs-number">33554432</span>, <br><span class="hljs-keyword">sizeof</span>(__Block_byref_p_1), <br>__Block_byref_id_object_copy_131, <br>__Block_byref_id_object_dispose_131, <br>((<span class="hljs-built_in">NSObject</span> *(*)(<span class="hljs-keyword">id</span>, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((<span class="hljs-keyword">id</span>)objc_getClass(<span class="hljs-string">&quot;NSObject&quot;</span>), sel_registerName(<span class="hljs-string">&quot;new&quot;</span>))&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __Block_byref_id_object_copy_131(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">void</span> *src) &#123;<br>    _Block_object_assign((<span class="hljs-keyword">char</span>*)dst + <span class="hljs-number">40</span>, *(<span class="hljs-keyword">void</span> * *) ((<span class="hljs-keyword">char</span>*)src + <span class="hljs-number">40</span>), <span class="hljs-number">131</span>);<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __Block_byref_id_object_dispose_131(<span class="hljs-keyword">void</span> *src) &#123;<br>     _Block_object_dispose(*(<span class="hljs-keyword">void</span> * *) ((<span class="hljs-keyword">char</span>*)src + <span class="hljs-number">40</span>), <span class="hljs-number">131</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>当<code>__block</code>修饰对象时，其构建的_<code>block</code>变量内，也会有<code>copy</code>方法和<code>dispose</code>方法</p>
<ul>
<li>其内<code>copy</code>方法，同样也有<code>_Block_object_assign</code>,以及<code>_Block_object_dispose</code>,对其内修饰的对象进行内存管理（跟外围是<code>_strong</code>还是<code>_weak</code>有一定关系）<ul>
<li> <strong>但是注意，该内存管理只会在<code>ARC</code>下生效，如果在<code>MRC</code>下，在<code>__block</code>不会增加其内对象的引用，属于<code>unowned</code>关系</strong></li>
<li> <strong>如果不是<code>__block</code>,而是直接引用了<code>auto</code>对象，则和此前一样，<code>block</code>直接引用对象(<code>mrc</code>下，<code>copy</code>时，内部也会对<code>auto</code>增加引用)，而非通过<code>__block</code>间接引用</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><code>_block</code>的生成的对象，通过<code>fowarding</code>去指向的原因</p>
<ul>
<li>在栈上的时候，指针指向自己</li>
<li>而赋值到堆上时，栈上的指向堆上复制的，栈上赋值时，其值是保存堆上的值，从而保证了，无论是在栈上还是堆上修改，最后值都会保存的堆上。最终使用的是堆上的<code>block</code></li>
</ul>
</li>
</ul>
<h1 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h1><ul>
<li><a href="https://blog.csdn.net/LVXIANGAN/article/details/43228845?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">iOS之Block代码块的定义及使用</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>在main函数之前应用启动做了什么</title>
    <url>/2022/12/28/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%9C%A8main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="App编译流程及启动流程dyld"><a href="#App编译流程及启动流程dyld" class="headerlink" title="App编译流程及启动流程dyld"></a>App编译流程及启动流程dyld</h2><p><img src="1.png"></p>
<ul>
<li>注意：只有静态库会在编译阶段会打包进入可执行文件，动态库是在程序运行时才会被加入可执行文件。</li>
</ul>
<h2 id="从App启动角度深入了解dyld"><a href="#从App启动角度深入了解dyld" class="headerlink" title="从App启动角度深入了解dyld"></a>从App启动角度深入了解dyld</h2><blockquote>
<p>点击<code>app icon</code> 后，系统调用<code>exec()</code>函数，系统将对应的<code>Mach-O</code>文件加载进内存，同时再将<code>dyld</code>加载进内存。<code>dyld</code>就会进行动态链接。其中<code>dyld</code>的主要工作有一下几点：</p>
<ul>
<li>递归加载可执行文件所依赖所有动态库</li>
<li>进行<code>rebase</code>和<code>bingding</code>操作</li>
<li>调用<code>main</code>函数</li>
</ul>
</blockquote>
<h3 id="dyld加载流程"><a href="#dyld加载流程" class="headerlink" title="dyld加载流程"></a>dyld加载流程</h3><ul>
<li><code>dyld</code>操作流程如下图：<br><img src="2.webp"></li>
</ul>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><ul>
<li><p><code>mach-o</code>文件中的符号地址都是虚拟地址，在程序启动的时候，系统会生成一个随机数(<code>ASLR</code>),使用虚拟地址加上<code>ASLR</code>才是物理地址,也就是程序正真调用的地址。我们把从虚拟地址换算成物理地址的过程称之为<code>rebase</code>。</p>
</li>
<li><p>可以看到<code>start</code>中生成了<code>slide</code>这个相当于<code>ASLR</code><br><img src="5.webp"></p>
</li>
<li><p>这里也是<code>rebase</code><br><img src="6.webp"></p>
</li>
</ul>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><ul>
<li>当引用动态库其他的函数或者变量时，当前 <code>mach-o</code> 文件会指向其他 <code>dylib</code>。这时候就需要 <code>Binding</code> 操作，<code>dyld</code> 会根据符号表去找到相应函数 和变量地址，<code>Binding</code> 解决了修正外部指针指向的问题。</li>
<li>例如程序中调用<code>NSLog</code>方法，在编译时期生成的 <code>mach-o</code> 文件中，会创建一个符号 <code>NSLog</code>(目前指向一个随机的地址)，然后在运行时(从磁盘加载到 内存中，是一个镜像文件)，会将真正的地址给符号(即在内存中将地址与符号进行绑定，是 <code>dyld</code> 做的，也称为动态库符号绑定)</li>
</ul>
<h3 id="调用main函数"><a href="#调用main函数" class="headerlink" title="调用main函数"></a>调用main函数</h3><ul>
<li>通过之前的<code>prepare</code>(<code>prepare</code>中主要调用<code>runAllInitializersForMain</code>)就能获取到<code>main</code>函数，之后直接调用。截止目前，我们的程序就进入我们的源代码中了<br><img src="7.webp"></li>
</ul>
<h4 id="runAllInitializersForMain"><a href="#runAllInitializersForMain" class="headerlink" title="runAllInitializersForMain"></a><code>runAllInitializersForMain</code></h4><ol>
<li><p><code>runAllInitializersForMain</code>方法，先初始化<code>libSystem</code>再初始化其他动态库</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// This is factored out of dyldMain.cpp to support old macOS apps that use crt1.o </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">APIs::runAllInitializersForMain</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !TARGET_OS_EXCLAVEKIT</span><br>    <span class="hljs-comment">// disable page-in linking, not used for dlopen() loaded images</span><br>    <span class="hljs-keyword">if</span> ( !config.security.internalInstall || (config.process.pageInLinkingMode != <span class="hljs-number">3</span>) )<br>        config.syscall.<span class="hljs-built_in">disablePageInLinking</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <br>    <span class="hljs-comment">// run libSystem&#x27;s initializer first</span><br>    <span class="hljs-comment">// 先初始化libSystem</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">libSystemInitialized</span>()) &#123;<br>        <span class="hljs-keyword">const_cast</span>&lt;Loader*&gt;(<span class="hljs-keyword">this</span>-&gt;libSystemLoader)-&gt;<span class="hljs-built_in">beginInitializers</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">this</span>-&gt;libSystemLoader-&gt;<span class="hljs-built_in">runInitializers</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HAS_EXTERNAL_STATE</span><br>    <span class="hljs-keyword">this</span>-&gt;externallyViewable.<span class="hljs-built_in">setLibSystemInitialized</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// after running libSystem&#x27;s initializer, tell objc to run any +load methods on libSystem sub-dylibs</span><br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">notifyObjCInit</span>(<span class="hljs-keyword">this</span>-&gt;libSystemLoader);<br>    <span class="hljs-comment">// &lt;rdar://problem/32209809&gt; call &#x27;init&#x27; function on all images already init&#x27;ed (below libSystem)</span><br>    <span class="hljs-comment">// Iterate using indices so that the array doesn&#x27;t grow underneath us if a +load dloopen&#x27;s</span><br>    <span class="hljs-comment">// 再初始化其他的</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-keyword">this</span>-&gt;loaded.<span class="hljs-built_in">size</span>(); ++i ) &#123;<br>        <span class="hljs-keyword">const</span> Loader* ldr = <span class="hljs-keyword">this</span>-&gt;loaded[i];<br>        <span class="hljs-keyword">if</span> ( (ldr-&gt;dylibInDyldCache || ldr-&gt;<span class="hljs-built_in">analyzer</span>(*<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">isDylib</span>()) &amp;&amp; (<span class="hljs-built_in">strncmp</span>(ldr-&gt;<span class="hljs-built_in">analyzer</span>(*<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">installName</span>(), <span class="hljs-string">&quot;/usr/lib/system/lib&quot;</span>, <span class="hljs-number">19</span>) == <span class="hljs-number">0</span>) ) &#123;<br>            <span class="hljs-comment">// check install name instead of path, to handle DYLD_LIBRARY_PATH overrides of libsystem sub-dylibs</span><br>            <span class="hljs-keyword">const_cast</span>&lt;Loader*&gt;(ldr)-&gt;<span class="hljs-built_in">beginInitializers</span>(*<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">notifyObjCInit</span>(ldr);<br>            <span class="hljs-keyword">const_cast</span>&lt;Loader*&gt;(ldr)-&gt;<span class="hljs-built_in">runInitializers</span>(*<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过查阅<code>libSystem</code>源码和<code>libDispatch</code>源码确认调用关系<br><img src="3.webp"></p>
</li>
<li><p>调用<code>_dyld_objc_notify_register</code>来注册<code>3</code>个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _objc_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> initialized = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (initialized) <span class="hljs-keyword">return</span>;<br>    initialized = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// fixme defer initialization until an objc-using image is found?</span><br>    <span class="hljs-built_in">environ_init</span>();<br>    <span class="hljs-built_in">tls_init</span>();<br>    <span class="hljs-built_in">static_init</span>();<br>    <span class="hljs-built_in">runtime_init</span>();<br>    <span class="hljs-built_in">exception_init</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __OBJC2__</span><br>    <span class="hljs-keyword">cache_t</span>::<span class="hljs-built_in">init</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    _imp_implementationWithBlock_init();<br><br>    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __OBJC2__</span><br>    didCallDyldNotifyRegister = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="Map-image的调用"><a href="#Map-image的调用" class="headerlink" title="Map_image的调用"></a>Map_image的调用</h5><ol>
<li>来到<code>dyld</code>源码中搜索<code>_dyld_objc_notify_register</code>方法并定位。实际调用<code>setObjCNotifiers</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> APIs::_dyld_objc_notify_register(_dyld_objc_notify_mapped   mapped,<br>                                      _dyld_objc_notify_init     init,<br>                                      _dyld_objc_notify_unmapped unmapped)<br>&#123;<br>    <span class="hljs-keyword">if</span> ( config.log.apis )<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;_dyld_objc_notify_register(%p, %p, %p)\n&quot;</span>, mapped, init, unmapped);<br>    <span class="hljs-built_in">setObjCNotifiers</span>(mapped, init, unmapped, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_CREATING_PREBUILTLOADERS</span><br>    <span class="hljs-comment">// If we have prebuilt loaders, then the objc optimisations may hide duplicate classes from libobjc.</span><br>    <span class="hljs-comment">// We need to print the same warnings libobjc would have.</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">const</span> PrebuiltLoaderSet* mainSet = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">processPrebuiltLoaderSet</span>() )<br>        mainSet-&gt;<span class="hljs-built_in">logDuplicateObjCClasses</span>(*<span class="hljs-keyword">this</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>可以看到里面对全局变量赋值其实就是保存<code>3</code>个方法，之后调用了<code>withLoadersReadLock</code>并且传入了<code>block</code>，<code>block</code>内部执行了<code>_notifyObjCMapped</code>。那么<code>block</code>的执行就会调用<code>map_images</code>方法<ul>
<li>可以看到在<code>withLoadersReadLock</code>是直接调用的。也就是说，<code>map_images</code>是在<code>objc_init</code>的时候就会调用<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RuntimeState::setObjCNotifiers</span><span class="hljs-params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    _dyld_objc_notify_unmapped unmapped, _dyld_objc_notify_patch_class patchClass,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    _dyld_objc_notify_mapped2 mapped2, _dyld_objc_notify_init2 init2)</span></span><br><span class="hljs-function"></span>&#123;<br>    memoryManager.<span class="hljs-built_in">withWritableMemory</span>([&amp;]&#123;<br>        <span class="hljs-comment">// map_images</span><br>        _notifyObjCMapped       = mapped;<br>        <span class="hljs-comment">// load_images</span><br>        _notifyObjCInit         = init;<br>        <span class="hljs-comment">// ummap_images</span><br>        _notifyObjCUnmapped     = unmapped;<br>        _notifyObjCPatchClass   = patchClass;<br>        _notifyObjCMapped2      = mapped2;<br>        _notifyObjCInit2        = init2;<br>        locks.<span class="hljs-built_in">withLoadersReadLock</span>(^&#123;<br>            <span class="hljs-keyword">if</span> ( (_notifyObjCPatchClass != <span class="hljs-literal">nullptr</span>) &amp;&amp; !<span class="hljs-keyword">this</span>-&gt;objcReplacementClasses.<span class="hljs-built_in">empty</span>() ) &#123;<br>                <span class="hljs-comment">// Tell Symbolication that we are patching classes</span><br>                <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setDyldPatchedObjCClasses</span>();<br><br>                <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> ObjCClassReplacement&amp; classReplacement : <span class="hljs-keyword">this</span>-&gt;objcReplacementClasses )<br>                    (*_notifyObjCPatchClass)(classReplacement.cacheMH, (<span class="hljs-keyword">void</span>*)classReplacement.cacheImpl,<br>                                             classReplacement.rootMH, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*)classReplacement.rootImpl);<br>                <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;config.log.notifications ) &#123;<br>                    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;objc-patch-class-notifier called with %ld patches:\n&quot;</span>, <span class="hljs-keyword">this</span>-&gt;objcReplacementClasses.<span class="hljs-built_in">size</span>());<br>                &#125;<br><br>                <span class="hljs-comment">// Clear the replacement classes.  We don&#x27;t want to notify about them again if a dlopen happens</span><br>                <span class="hljs-keyword">this</span>-&gt;objcReplacementClasses.<span class="hljs-built_in">clear</span>();<br>            &#125;<br><br>            <span class="hljs-comment">// callback about already loaded images</span><br>            <span class="hljs-keyword">size_t</span> maxCount = <span class="hljs-keyword">this</span>-&gt;loaded.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-built_in">STACK_ALLOC_ARRAY</span>(<span class="hljs-keyword">const</span> mach_header*, mhs, maxCount);<br>            <span class="hljs-built_in">STACK_ALLOC_ARRAY</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, paths, maxCount);<br>            <span class="hljs-built_in">STACK_ALLOC_ARRAY</span>(_dyld_objc_notify_mapped_info, infos, maxCount);<br>            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> Loader* ldr : loaded ) &#123;<br>                <span class="hljs-comment">// don&#x27;t need _mutex here because this is called when process is still single threaded</span><br>                <span class="hljs-keyword">const</span> MachOLoaded* ml = ldr-&gt;<span class="hljs-built_in">loadAddress</span>(*<span class="hljs-keyword">this</span>);<br>                <span class="hljs-keyword">if</span> ( ldr-&gt;hasObjC ) &#123;<br>                    paths.<span class="hljs-built_in">push_back</span>(ldr-&gt;<span class="hljs-built_in">path</span>());<br>                    mhs.<span class="hljs-built_in">push_back</span>(ml);<br>                    infos.<span class="hljs-built_in">push_back</span>(&#123;ml, ldr-&gt;<span class="hljs-built_in">path</span>(), (<span class="hljs-keyword">_dyld_section_location_info_t</span>)ldr, ldr-&gt;<span class="hljs-built_in">dyldDoesObjCFixups</span>(), <span class="hljs-number">0</span>&#125;);<br><br>                    <span class="hljs-comment">// Make the memory read-write while map_images runs</span><br>                    <span class="hljs-keyword">if</span> ( ldr-&gt;<span class="hljs-built_in">hasConstantSegmentsToProtect</span>() &amp;&amp; ldr-&gt;hasReadOnlyObjC )<br>                        ldr-&gt;<span class="hljs-built_in">makeSegmentsReadWrite</span>(*<span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ( !mhs.<span class="hljs-built_in">empty</span>() ) &#123;<br>                <span class="hljs-comment">// 这里map_images调用</span><br>                <span class="hljs-keyword">if</span> ( _notifyObjCMapped != <span class="hljs-literal">nullptr</span> )<br>                    (*_notifyObjCMapped)((<span class="hljs-keyword">uint32_t</span>)mhs.<span class="hljs-built_in">count</span>(), &amp;paths[<span class="hljs-number">0</span>], &amp;mhs[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">if</span> ( _notifyObjCMapped2 != <span class="hljs-literal">nullptr</span> )<br>                    (*_notifyObjCMapped2)((<span class="hljs-keyword">uint32_t</span>)mhs.<span class="hljs-built_in">count</span>(), &amp;infos[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;config.log.notifications ) &#123;<br>                    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;objc-mapped-notifier called with %ld images:\n&quot;</span>, mhs.<span class="hljs-built_in">count</span>());<br>                    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">uintptr_t</span> i = <span class="hljs-number">0</span>; i &lt; mhs.<span class="hljs-built_in">count</span>(); ++i ) &#123;<br>                        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot; objc-mapped: %p %s\n&quot;</span>, mhs[i], paths[i]);<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// Make the memory read-only after map_images runs</span><br>                <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> Loader* ldr : loaded ) &#123;<br>                    <span class="hljs-keyword">if</span> ( ldr-&gt;hasObjC &amp;&amp; ldr-&gt;<span class="hljs-built_in">hasConstantSegmentsToProtect</span>() &amp;&amp; ldr-&gt;hasReadOnlyObjC )<br>                        ldr-&gt;<span class="hljs-built_in">makeSegmentsReadOnly</span>(*<span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 这里直接执行block</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RuntimeLocks::withLoadersReadLock</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (^work)())</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> BUILDING_DYLD</span><br>    <span class="hljs-keyword">if</span> ( _libSystemHelpers != <span class="hljs-literal">nullptr</span> ) &#123;<br>        _libSystemHelpers-&gt;<span class="hljs-built_in">os_unfair_recursive_lock_lock_with_options</span>(&amp;_loadersLock, OS_UNFAIR_LOCK_NONE);<br>        <span class="hljs-built_in">work</span>();<br>        _libSystemHelpers-&gt;<span class="hljs-built_in">os_unfair_recursive_lock_unlock</span>(&amp;_loadersLock);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// BUILDING_DYLD</span></span><br>    &#123;<br>        <span class="hljs-built_in">work</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="load-image的调用"><a href="#load-image的调用" class="headerlink" title="load_image的调用"></a>load_image的调用</h5><ul>
<li><p>就是在<code>runAllInitializersForMain</code>中,在加载完<code>libSystem</code>后，就会加载其镜像，其他动态库，也是如此<br><img src="4.webp"></p>
</li>
<li><p>主要的目的就是调用<code>_notifyObjCInit</code>,也就是之前赋值的<code>load_image</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RuntimeState::notifyObjCInit</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Loader* ldr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//this-&gt;log(&quot;objc-init-notifier checking mh=%p, path=%s, +load=%d, objcInit=%p\n&quot;, ldr-&gt;loadAddress(), ldr-&gt;path(), ldr-&gt;mayHavePlusLoad, _notifyObjCInit);</span><br>    <span class="hljs-keyword">if</span> ( !ldr-&gt;mayHavePlusLoad )<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> ( _notifyObjCInit != <span class="hljs-literal">nullptr</span> ) &#123;<br>        <span class="hljs-keyword">const</span> MachOLoaded* ml  = ldr-&gt;<span class="hljs-built_in">loadAddress</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*        pth = ldr-&gt;<span class="hljs-built_in">path</span>();<br>        <span class="hljs-function">dyld3::ScopedTimer <span class="hljs-title">timer</span><span class="hljs-params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="hljs-keyword">uint64_t</span>)ml, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;config.log.notifications )<br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;objc-init-notifier called with mh=%p, path=%s\n&quot;</span>, ml, pth);<br>        <span class="hljs-comment">// load_image</span><br>        _notifyObjCInit(pth, ml);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( _notifyObjCInit2 != <span class="hljs-literal">nullptr</span> ) &#123;<br>        <span class="hljs-keyword">const</span> MachOLoaded* ml  = ldr-&gt;<span class="hljs-built_in">loadAddress</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*        pth = ldr-&gt;<span class="hljs-built_in">path</span>();<br>        <span class="hljs-function">dyld3::ScopedTimer <span class="hljs-title">timer</span><span class="hljs-params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="hljs-keyword">uint64_t</span>)ml, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;config.log.notifications )<br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;objc-init-notifier called with mh=%p, path=%s\n&quot;</span>, ml, pth);<br>        _dyld_objc_notify_mapped_info info = &#123;<br>            ml, pth, (<span class="hljs-keyword">_dyld_section_location_info_t</span>)ldr, ldr-&gt;<span class="hljs-built_in">dyldDoesObjCFixups</span>(), <span class="hljs-number">0</span><br>        &#125;;<br>        _notifyObjCInit2(&amp;info);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ol>
<li>程序启动时，系统<code>XNU</code>执行程序的可执行二进制文件，从内核态切换到用户态，</li>
<li>根据路径找到并运行动态链接器<code>dyld</code>，并把控制权交给<code>dyld</code>，</li>
<li>然后启动<code>dyld</code>进行程序环境初始化，然后读取可执行文件<code>Mach-O</code>，开始根据头文件内容读取动态库并初始化主程序，</li>
<li>初始化主程序后，就开始链接读取完成的动态库到主程序可执行文件中，然后初始化动态库。</li>
<li>在初始化其他动态库之前，会最先初始化系统库<code>libsystem</code>(依赖<code>libdispatch</code>库和<code>objc</code>库)，运行<code>Runtime</code>。系统库<code>libsystem</code>初始化完成后，就会初始化其他动态库，</li>
<li>然后由<code>Runtime</code>调用<code>map_images</code>来读取类、方法、协议以及分类并存储到对应的表中(注意：分类并不是直接存，而是通过<code>attachLists</code>方法把分类的数据添加到类里面)，</li>
<li>然后<code>Runtime</code>会继续调用<code>load_images</code>调用所有类的<code>load</code>方法以及分类的<code>load</code>方法，</li>
<li>这些都做完之后，通过<code>dyld</code>提供的回调<code>_dyld_objc_notify_register</code>，告诉<code>dyld</code>加载完毕，然后<code>dyld</code>就开始找主程序的入口<code>main</code>函数，最后进入程序的<code>main</code>函数</li>
</ol>
</blockquote>
<h1 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h1><ul>
<li><a href="https://www.jianshu.com/p/ea680941e084">iOS进阶专项分析(八)、深入App启动之dyld、map_images、load_images</a></li>
<li><a href="https://juejin.cn/post/7097113759251955749">dyld4源码解析</a></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>应用启动</tag>
      </tags>
  </entry>
  <entry>
    <title>load、initialize方法的区别</title>
    <url>/2022/12/28/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/load%E3%80%81initialize%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="load、initialize方法的区别"><a href="#load、initialize方法的区别" class="headerlink" title="load、initialize方法的区别"></a>load、initialize方法的区别</h4><ol>
<li><p>调用方式</p>
<ul>
<li> <code>load</code>是根据函数地址直接调用</li>
<li> <code>initialize</code>是通过<code>objc_msgSend</code>调用</li>
</ul>
</li>
<li><p>调用时刻</p>
<ul>
<li><code>load</code>是<code>runtime</code>加载类、分类的时候调用（只会调用1次）</li>
<li><code>initialize</code>是类第一次发送到消息的时候调用，每个类只会<code>initialize</code>一次（父类的<code>initialize</code>方法可能会被调用多次）</li>
</ul>
</li>
<li><p><code>load</code>、<code>initialize</code>的调用顺序</p>
<ol>
<li><code>load</code><ul>
<li>先调用类的<code>load</code><ul>
<li>先编译的类，优先调用<code>load</code></li>
<li>调用子类的<code>load</code>之前，会先调用父类的<code>load</code></li>
</ul>
</li>
<li>再调用分类的<code>load</code><ul>
<li>先编译的分类，优先调用<code>load</code></li>
</ul>
</li>
</ul>
</li>
<li><code>initialize</code><ul>
<li>在，第一次使用的时候调用，先初始化父类，</li>
<li>再初始化子类（可能最终调用的是父类的(子类中没有实现的话)）</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>initialize</title>
    <url>/2022/12/27/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/initialize/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><span id="more"></span>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ol>
<li>在查找方法前，进行<code>initialize</code>的调用<br><img src="16721352310424.png"><img src="16721353684859.png"></li>
</ol>
<ul>
<li>类没有初始化，则去调用初始化<br><img src="16721354586849.png"></li>
<li>先查看有没有父类，有父类，且没有初始化，则先初始化父类的<code>initialize</code><br><img src="16721355384202.png"></li>
<li>采用的是<code>objc_msSend</code>去调用<code>initialize</code>方法<br><img src="16721356497584.png"></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>runtime</code>中会通过<code>RW_INITIALIZED</code>标志位，保证当前类已经初始化了。（此前<code>realizeClassWithoutSwift</code>类的加载，是通过<code>RW_REALIZED</code>来标识的）</li>
<li><code>initialize</code>和<code>load</code>的最大区别是，<code>initialize</code>是通过<code>objc_msgSend</code>进行调用的。而<code>load</code>是拿到函数地址后直接调用的<ul>
<li>如果子类没有实现<code>initialize</code>，会调用父类的<code>initialize</code>（所以父类的<code>initialize</code>可能会调用多次）。（不会像<code>load</code>方法一样，先调用父类的，再调用<code>子类</code>的）</li>
<li>如果分类实现了<code>initialize</code>，就会覆盖本身的<code>initialize</code>调用</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>Load</title>
    <url>/2022/12/26/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Load/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Load方法"><a href="#Load方法" class="headerlink" title="Load方法"></a>Load方法</h3><ul>
<li><code>+load</code>方法会在<code>runtime</code>加载类、分类时调用</li>
<li>每个类、分类的<code>+load</code>，在程序运行过程中只调用一次<ul>
<li><code>flags</code>标识位保证类只会加载一次</li>
<li>首先会先将父类添加到数组，后将自己加进去数组，因此，先父类，再执行子类，最后分类中的<code>load</code>方法</li>
<li>同一级的关系时按照编译的顺序来</li>
</ul>
</li>
<li>尽管<code>load</code>中方法在源码中只会调用一次，但实际上主动<code>[Class load]</code>也会触发<code>load</code>,因此在调用<code>method_exchangeImplementations</code>做hook时，会加上<code>dispatch_once</code>，保证只会执行一次。</li>
</ul>
<span id="more"></span>

<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ol>
<li><p>如果此前没有将分类加载到类中，则这里会调用<code>loadAllCategories</code>方法</p>
</li>
<li><p>在<code>load_images</code>中加载,首先会在<code>prepare_load_methods</code>方法中，找到类和分类的所有<code>load</code>方法<br><img src="16720646359112.png"></p>
</li>
<li><p>构建有类<code>load</code>方法的数组，以及有分类<code>load</code>方法的数组，整个添加顺序是</p>
<ol>
<li>类先按编译的顺序进行添加，递归调用,其中父类会比子类先添加到数组中<ul>
<li>这里有递归，首选会先将父类添加到数组，后将自己加进去数组，因此最后，先父类，再添加子类的<code>load</code>方法（获取类<code>class_ro_t</code>中<code>baseMethod</code>的<code>load</code>方法）<br><img src="16720649726860.png"></li>
</ul>
</li>
<li>分类按编译的顺序进行添加的，这里获取<code>category_t</code>中的<code>classMethods</code>中的load方法<br><img src="16720651219179.png"></li>
</ol>
</li>
<li><p>先调用类中的<code>load</code>方法，再调用分类中的<code>load</code>方法<br><img src="16720639325952.png"></p>
</li>
<li><p>再找到类中的<code>load</code>方法（<code>prepare_load_methods</code>方法事前找到），用函数调用的方式直接执行，分类也是这样的，不是<code>objc_msg</code>的方式<br><img src="16720641861246.png"></p>
</li>
</ol>
<h4 id="load-images流程"><a href="#load-images流程" class="headerlink" title="load_images流程"></a><code>load_images</code>流程</h4><ol>
<li><code>loadAllCategories</code>,加载所有的分类，这里如果类已经<code>Realized</code>,则将分类中的方法、属性、协议加到类的<code>class_rw_t</code>中,否则将分类中类和分类映射加到<code>objc::unattachedCategories</code>(在<code>runtime_init</code>中初始化)存储，会在类<code>Realized</code>的时候，在添加</li>
<li>准备<code>load</code>方法:<code>prepare_load_methods</code><ul>
<li>先处理类，后处理分类 以及 先处理父类，后处理子类的顺序存储到待调度的表中。<ul>
<li>类的处理逻辑：把类对象<code>Class</code>和类对应的<code>load</code>方法的<code>IMP</code>整合成一个<code>loadable_class</code>类型的结构体对象存储在表<code>loadable_classes</code>中。</li>
<li>分类的处理逻辑：把分类对象<code>Category</code>和对应的<code>load</code>方法<code>IMP</code>整合成一个<code>loadable_category</code>类型的结构体对象存储在表<code>loadable_categories</code>中。</li>
</ul>
</li>
</ul>
</li>
<li>调用<code>load</code>方法:<code>call_load_methods</code><ul>
<li>先调用类<code>Class</code>的<code>load</code>，后处理分类<code>Category</code>，通过分类找到对应的类，然后由类调用<code>load</code>方法的顺序进行处理</li>
<li>这个调用处理的顺序是根据准备方法<code>prepare_load_methods</code>中准备好的两张表<code>loadable_classes</code>和<code>loadable_categories</code>的顺序而来的。调用完就从表中移除，全部调用完结束循环。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>调用顺序</li>
</ul>
<ol>
<li><p>先调用类的<code>+load</code></p>
<ol>
<li>按照编译先后的顺序调用，先编译，先调用</li>
<li>调用子类的<code>+load</code>之前会先调用父类的<code>+load</code></li>
</ol>
</li>
<li><p>再调用分类的<code>+load</code></p>
<ol>
<li>按照编译先后顺序调用，先编译，先调用</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>map-images</title>
    <url>/2022/12/26/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/map-images/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><code>runtime</code>初始化<code>objc_init</code>,会注册三个函数<code>map_images</code>、<code>load_images</code>、<code>unmap_image</code>,这里对<code>map_images</code>所做的工作进行探索,</p>
</blockquote>
<h2 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a><code>_objc_init</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">void</span> _objc_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> initialized = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (initialized) <span class="hljs-keyword">return</span>;<br>    initialized = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// fixme defer initialization until an objc-using image is found?</span><br>    <span class="hljs-comment">// 环境变量</span><br>    <span class="hljs-built_in">environ_init</span>();<br>    <span class="hljs-comment">// 静态构造函数</span><br>    <span class="hljs-built_in">static_init</span>();<br>    <span class="hljs-comment">// runtime准备，创建两张表</span><br>    <span class="hljs-built_in">runtime_init</span>();<br>    <span class="hljs-comment">// 异常初始化</span><br>    <span class="hljs-built_in">exception_init</span>();<br>    <span class="hljs-comment">// 缓存</span><br>    <span class="hljs-keyword">cache_t</span>::<span class="hljs-built_in">init</span>();<br><br>    _imp_implementationWithBlock_init();<br><br>    _dyld_objc_callbacks_v1 callbacks = &#123;<br>        <span class="hljs-number">1</span>, <span class="hljs-comment">// version</span><br>        &amp;map_images,<br>        load_images,<br>        unmap_image,<br>        _objc_patch_root_of_class<br>    &#125;;<br>    _dyld_objc_register_callbacks((_dyld_objc_callbacks*)&amp;callbacks);<br><br>    didCallDyldNotifyRegister = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="environ-init"><a href="#environ-init" class="headerlink" title="environ_init"></a><code>environ_init</code></h3><blockquote>
<p><code>environ_init</code>是读取<code>environment variables</code>的一些配置信息，<code>environment variables</code>在<code>Edit Scheme -&gt; Run -&gt; Argments -&gt; Environment Variables</code> 中配置</p>
</blockquote>
<ul>
<li>可以设置<code>OBJC_HELP</code>，启动程序后会打印所有可以设置的信息已经含义解释。<br><img src="1.png"></li>
</ul>
<h3 id="static-init"><a href="#static-init" class="headerlink" title="static_init"></a><code>static_init</code></h3><blockquote>
<p>接下来是<code>static_init</code>：找到<code>objc</code>库中的所有初始化方法，遍历调用，注意：<code>objc</code>库中的静态<code>构造</code>函数早于<code>load</code>方法，<code>load</code>方法早于我们自己的静态<code>构造</code>函数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">static_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> count1;<br>    <span class="hljs-comment">//获取objc库里面所有的静态构造函数</span><br>    <span class="hljs-keyword">auto</span> inits = <span class="hljs-built_in">getLibobjcInitializers</span>(&amp;_mh_dylib_header, &amp;count1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count1; i++) &#123;<br>        inits[i]();<br>    &#125;<br>    <span class="hljs-keyword">size_t</span> count2;<br>    <span class="hljs-keyword">auto</span> offsets = <span class="hljs-built_in">getLibobjcInitializerOffsets</span>(&amp;_mh_dylib_header, &amp;count2);<br>    <span class="hljs-comment">//遍历调用他们</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count2; i++) &#123;<br>        <span class="hljs-function">UnsignedInitializer <span class="hljs-title">init</span><span class="hljs-params">(offsets[i])</span></span>;<br>        <span class="hljs-built_in">init</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="runtime-init"><a href="#runtime-init" class="headerlink" title="runtime_init"></a><span id="jump"><code>runtime_init</code></span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runtime_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    objc::disableEnforceClassRXPtrAuth = DisableClassRXSigningEnforcement;<br>    <span class="hljs-comment">//分类加载表</span><br>    objc::unattachedCategories.<span class="hljs-built_in">init</span>(<span class="hljs-number">32</span>);<br>    <span class="hljs-comment">//类的加载表</span><br>    objc::allocatedClasses.<span class="hljs-built_in">init</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h2><blockquote>
<ul>
<li>整个流程是<code>map_images</code> -&gt; <code>map_images_nolock</code> -&gt; <code>_read_images</code>。这里对<code>map_images_nolock</code>和<code>_read_images</code>进行介绍</li>
</ul>
</blockquote>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> <br>map_images_nolock(<span class="hljs-keyword">unsigned</span> mhCount, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> mhPaths[],<br>                  <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> mach_header * <span class="hljs-keyword">const</span> mhdrs[],<br>                  <span class="hljs-keyword">bool</span> *disabledClassROEnforcement)<br>&#123;<br>    <span class="hljs-comment">//定义一系列变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> firstTime = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> executableHasClassROSigning = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> executableIsARM64e = <span class="hljs-literal">false</span>;<br><br>    header_info *hList[mhCount];<br>    uint32_t hCount;<br>    size_t selrefCount = <span class="hljs-number">0</span>;<br><br>    *disabledClassROEnforcement = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//如果是第一次，就准备初始化环境</span><br>    <span class="hljs-keyword">if</span> (firstTime) &#123;<br>        preopt_init();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (PrintImages) &#123;<br>        _objc_inform(<span class="hljs-string">&quot;IMAGES: processing %u newly-mapped images...\n&quot;</span>, mhCount);<br>    &#125;<br><br><br>    <span class="hljs-comment">// Find all images with Objective-C metadata.</span><br>    hCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//计算class数量，根据总数调整各种表的大小。</span><br>    <span class="hljs-keyword">int</span> totalClasses = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> unoptimizedTotalClasses = <span class="hljs-number">0</span>;<br>    &#123;<br>        uint32_t i = mhCount;<br>        <span class="hljs-keyword">while</span> (i--) &#123;<br>            <span class="hljs-keyword">const</span> headerType *mhdr = (<span class="hljs-keyword">const</span> headerType *)mhdrs[i];<br><br>            auto hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);<br>            <span class="hljs-keyword">if</span> (!hi) &#123;<br>                <span class="hljs-comment">// no objc data in this entry</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;<br>                <span class="hljs-comment">// Size some data structures based on main executable&#x27;s size</span><br><br>                <span class="hljs-comment">// If dyld3 optimized the main executable, then there shouldn&#x27;t</span><br>                <span class="hljs-comment">// be any selrefs needed in the dynamic map so we can just init</span><br>                <span class="hljs-comment">// to a 0 sized map</span><br>                <span class="hljs-keyword">if</span> ( !hi-&gt;hasPreoptimizedSelectors() ) &#123;<br>                  size_t count;<br>                  _getObjc2SelectorRefs(hi, &amp;count);<br>                  selrefCount += count;<br>                  _getObjc2MessageRefs(hi, &amp;count);<br>                  selrefCount += count;<br>                &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_GC_COMPAT</span><br>                <span class="hljs-comment">// 兼容旧版本OC的GCC功能</span><br>                <span class="hljs-comment">// Halt if this is a GC app.</span><br>                <span class="hljs-keyword">if</span> (shouldRejectGCApp(hi)) &#123;<br>                    _objc_fatal_with_reason<br>                        (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, <br>                         OS_REASON_FLAG_CONSISTENT_FAILURE, <br>                         <span class="hljs-string">&quot;Objective-C garbage collection &quot;</span> <br>                         <span class="hljs-string">&quot;is no longer supported.&quot;</span>);<br>                &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>                <span class="hljs-keyword">if</span> (hasSignedClassROPointers(hi)) &#123;<br>                    executableHasClassROSigning = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>            hList[hCount++] = hi;<br><br>            <span class="hljs-keyword">if</span> (PrintImages) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;IMAGES: loading image for %s%s%s%s%s\n&quot;</span>, <br>                             hi-&gt;fname(),<br>                             mhdr-&gt;filetype == MH_BUNDLE ? <span class="hljs-string">&quot; (bundle)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                             hi-&gt;info()-&gt;isReplacement() ? <span class="hljs-string">&quot; (replacement)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                             hi-&gt;info()-&gt;hasCategoryClassProperties() ? <span class="hljs-string">&quot; (has class properties)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                             hi-&gt;info()-&gt;optimizedByDyld()?<span class="hljs-string">&quot; (preoptimized)&quot;</span>:<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//执行一次运行时初始化，必须将其推迟到找到可执行文件本身为止。 </span><br><span class="hljs-comment">//这需要在进一步初始化之前完成。（如果可执行文件不包含Objective-C代码，</span><br><span class="hljs-comment">//但稍后会动态加载Objective-C，则该可执行文件可能不会出现在此infoList中.</span><br>    <span class="hljs-keyword">if</span> (firstTime) &#123;<br>        sel_init(selrefCount); <span class="hljs-comment">//这里会初始化方法列表，并注册系统内部专门的方法。</span><br>        arr_init();<span class="hljs-comment">//这里会初始化`SideTablesMap`表，`associations`关联表</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_GC_COMPAT</span><br>        <span class="hljs-comment">// Reject any GC images linked to the main executable.</span><br>        <span class="hljs-comment">// We already rejected the app itself above.</span><br>        <span class="hljs-comment">// Images loaded after launch will be rejected by dyld.</span><br><br>        <span class="hljs-keyword">for</span> (uint32_t i = <span class="hljs-number">0</span>; i &lt; hCount; i++) &#123;<br>            auto hi = hList[i];<br>            auto mh = hi-&gt;mhdr();<br>            <span class="hljs-keyword">if</span> (mh-&gt;filetype != MH_EXECUTE  &amp;&amp;  shouldRejectGCImage(mh)) &#123;<br>                _objc_fatal_with_reason<br>                    (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, <br>                     OS_REASON_FLAG_CONSISTENT_FAILURE, <br>                     <span class="hljs-string">&quot;%s requires Objective-C garbage collection &quot;</span><br>                     <span class="hljs-string">&quot;which is no longer supported.&quot;</span>, hi-&gt;fname());<br>            &#125;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TARGET_OS_OSX</span><br>        <span class="hljs-keyword">for</span> (uint32_t i = <span class="hljs-number">0</span>; i &lt; hCount; i++) &#123;<br>            auto hi = hList[i];<br>            auto mh = hi-&gt;mhdr();<br>            <span class="hljs-keyword">if</span> (mh-&gt;filetype != MH_EXECUTE) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;<br>            <span class="hljs-keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;__objc_fork_ok&quot;</span>, &amp;size)) &#123;<br>                DisableInitializeForkSafety = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (PrintInitializing) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;INITIALIZE: disabling +initialize fork &quot;</span><br>                                 <span class="hljs-string">&quot;safety enforcement because the app has &quot;</span><br>                                 <span class="hljs-string">&quot;a __DATA,__objc_fork_ok section&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// assume only one MH_EXECUTE image</span><br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// TARGET_OS_OSX</span></span><br><br>    <span class="hljs-comment">// If the main executable is ARM64e, make sure every image that is loaded</span><br>    <span class="hljs-comment">// has pointer signing turned on.</span><br>    <span class="hljs-keyword">if</span> (executableIsARM64e) &#123;<br>        <span class="hljs-keyword">bool</span> shouldWarn = (executableHasClassROSigning<br>                           &amp;&amp; DebugClassRXSigning);<br>        <span class="hljs-keyword">for</span> (uint32_t i = <span class="hljs-number">0</span>; i &lt; hCount; ++i) &#123;<br>            auto hi = hList[i];<br>            <span class="hljs-keyword">if</span> (!hasSignedClassROPointers(hi)) &#123;<br>                <span class="hljs-keyword">if</span> (!objc::disableEnforceClassRXPtrAuth) &#123;<br>                    *disabledClassROEnforcement = <span class="hljs-literal">true</span>;<br>                    objc::disableEnforceClassRXPtrAuth = <span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (shouldWarn) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;%s has un-signed class_ro_t pointers, but the &quot;</span><br>                                 <span class="hljs-string">&quot;main executable was compiled with class_ro_t &quot;</span><br>                                 <span class="hljs-string">&quot;pointer signing enabled&quot;</span>, hi-&gt;fname());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//直接开始镜像读取</span><br>    <span class="hljs-keyword">if</span> (hCount &gt; <span class="hljs-number">0</span>) &#123;<br>        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);<br>    &#125;<br><br>    firstTime = <span class="hljs-literal">NO</span>;<br><br>    <span class="hljs-comment">// Call image load funcs after everything is set up.</span><br>    <span class="hljs-keyword">for</span> (auto func : loadImageFuncs) &#123;<br>        <span class="hljs-keyword">for</span> (uint32_t i = <span class="hljs-number">0</span>; i &lt; mhCount; i++) &#123;<br>            func(mhdrs[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><ol>
<li>判断<code>firstTime</code>，<code>firstTime</code>为<code>YES</code>，则执行环境初始化的准备，为<code>NO</code>就不执行</li>
<li>计算<code>class</code>数量，根据总数调整各种表的大小并做了<code>GC</code>相关逻辑处理(不支持<code>GC</code>则打印提示信息)</li>
<li>判断<code>firstTime</code>，<code>firstTime</code>为<code>YES</code>，执行各种表(<code>SideTablesMap</code>表，<code>associations</code>关联表,<code>sel</code>方法表)初始化操作，为<code>NO</code>则不执行</li>
<li>执行<code>_read_images</code>进行读取，然后将<code>firstTime</code>置为<code>NO</code>，就不再进入上面的逻辑了，下次进入<code>map_images_nolock</code>就开始直接<code>_read_images</code></li>
</ol>
<h2 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h2><h3 id="read-images源码"><a href="#read-images源码" class="headerlink" title="_read_images源码"></a>_read_images源码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> _read_images(header_info **hList, uint32_t hCount, <span class="hljs-keyword">int</span> totalClasses, <span class="hljs-keyword">int</span> unoptimizedTotalClasses)<br>&#123;<br>    header_info *hi;<br>    uint32_t hIndex;<br>    size_t count;<br>    size_t i;<br>    Class *resolvedFutureClasses = <span class="hljs-literal">nil</span>;<br>    size_t resolvedFutureClassCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> doneOnce;<br>    <span class="hljs-keyword">bool</span> launchTime = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-comment">//环境变量设置  OBJC_PRINT_IMAGE_TIMES = YES 会打印ts.log的内容</span><br>    TimeLogger ts(PrintImageTimes);<br>    <span class="hljs-comment">// 加锁</span><br>    lockdebug::assert_locked(&amp;runtimeLock);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EACH_HEADER \</span><br><span class="hljs-meta">    hIndex = 0;         \</span><br><span class="hljs-meta">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="hljs-meta">    hIndex++</span><br><br>    <span class="hljs-keyword">if</span> (!doneOnce) &#123;<br>        doneOnce = <span class="hljs-literal">YES</span>;<br>        launchTime = <span class="hljs-literal">YES</span>;<br>        <span class="hljs-comment">// 1.重新初始化TaggePointer环境</span><br>        <span class="hljs-keyword">if</span> (DisableTaggedPointers) &#123;<br>            disableTaggedPointers();<br>        &#125;<br><br>        initializeTaggedPointerObfuscator();<br><br>        <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);<br>        &#125;<br><br>        <span class="hljs-comment">// 创建gdb_objc_realized_classes表</span><br>        <span class="hljs-keyword">int</span> namedClassesSize =<br>            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="hljs-number">4</span> / <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 实际上它存放的是除了 dyld shared cache 中的 class，无论该 class 是否 realized。</span><br>        gdb_objc_realized_classes =<br>            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);<br><br>        ts.log(<span class="hljs-string">&quot;IMAGE TIMES: first time tasks&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//2. 修复预编译阶段的`@selector`的混乱问题</span><br>    <span class="hljs-keyword">static</span> size_t UnfixedSelectors;<br>    &#123;<br>        mutex_locker_t lock(selLock);<br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            <span class="hljs-keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">bool</span> isBundle = hi-&gt;isBundle();<br>            <span class="hljs-comment">// 取出_objc_selrefs函数</span><br>            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);<br>            UnfixedSelectors += count;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = sel_cname(sels[i]);<br>                <span class="hljs-comment">//这里注册实际是将方法名存储到namedSelectors中保存</span><br>                SEL sel = sel_registerNameNoLock(name, isBundle);<br>                <span class="hljs-comment">//方法列表和注册时不同的，重新赋值</span><br>                <span class="hljs-keyword">if</span> (sels[i] != sel) &#123;<br>                    sels[i] = sel;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);<br><br>    <span class="hljs-keyword">bool</span> hasDyldRoots = dyld_shared_cache_some_image_overridden();<br>    <span class="hljs-number">3.</span> 开始遍历头文件，进行类与元类的读取操作并标记(旧类改动后会生成新的类，并重映射到新的类上)<br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-keyword">if</span> (! mustReadClasses(hi, hasDyldRoots)) &#123;<br>            <span class="hljs-comment">// Image is sufficiently optimized that we need not call readClass()</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        classref_t <span class="hljs-keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);<br><br>        <span class="hljs-keyword">bool</span> headerIsBundle = hi-&gt;isBundle();<br>        <span class="hljs-keyword">bool</span> headerIsPreoptimized = hi-&gt;hasPreoptimizedClasses();<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            Class cls = (Class)classlist[i];<br>            <span class="hljs-comment">//readClass读取类的信息及类的更新</span><br>            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);<br>            <span class="hljs-comment">//旧类和新类不同，则会加到resolvedFutureClasses中</span><br>            <span class="hljs-keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;<br>                <span class="hljs-comment">// Class was moved but not deleted. Currently this occurs</span><br>                <span class="hljs-comment">// only when the new class resolved a future class.</span><br>                <span class="hljs-comment">// Non-lazily realize the class below.</span><br>                resolvedFutureClasses = (Class *)<br>                    realloc(resolvedFutureClasses,<br>                            (resolvedFutureClassCount+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(Class));<br>                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover classes&quot;</span>);<br><br>    <span class="hljs-comment">// Fix up remapped classes</span><br>    <span class="hljs-comment">// Class list and nonlazy class list remain unremapped.</span><br>    <span class="hljs-comment">// Class refs and super refs are remapped for message dispatching.</span><br><br>    <span class="hljs-keyword">if</span> (!noClassesRemapped()) &#123;<br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                remapClassRef(&amp;classrefs[i]);<br>            &#125;<br>            <span class="hljs-comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span><br>            classrefs = _getObjc2SuperRefs(hi, &amp;count);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                remapClassRef(&amp;classrefs[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: remap classes&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_FIXUP</span><br>    <span class="hljs-comment">// Fix up old objc_msgSend_fixup call sites</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (PrintVtables) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot;</span><br>                         <span class="hljs-string">&quot;call sites in %s&quot;</span>, count, hi-&gt;fname());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            fixupMessageRef(refs+i);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up objc_msgSend_fixup&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><br>    <span class="hljs-comment">// Discover protocols. Fix up protocol refs.</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;<br>        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;<br>        ASSERT(cls);<br>        NXMapTable *protocol_map = protocols();<br>        <span class="hljs-keyword">bool</span> isPreoptimized = hi-&gt;hasPreoptimizedProtocols();<br><br>        <span class="hljs-comment">// Skip reading protocols if this is an image from the shared cache</span><br>        <span class="hljs-comment">// and we support roots</span><br>        <span class="hljs-comment">// Note, after launch we do need to walk the protocol as the protocol</span><br>        <span class="hljs-comment">// in the shared cache is marked with isCanonical() and that may not</span><br>        <span class="hljs-comment">// be true if some non-shared cache binary was chosen as the canonical</span><br>        <span class="hljs-comment">// definition</span><br>        <span class="hljs-keyword">if</span> (launchTime &amp;&amp; isPreoptimized) &#123;<br>            <span class="hljs-keyword">if</span> (PrintProtocols) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;PROTOCOLS: Skipping reading protocols in image: %s&quot;</span>,<br>                             hi-&gt;fname());<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">bool</span> isBundle = hi-&gt;isBundle();<br><br>        protocol_t * <span class="hljs-keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            readProtocol(protolist[i], cls, protocol_map,<br>                         isPreoptimized, isBundle);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover protocols&quot;</span>);<br><br>    <span class="hljs-comment">// Fix up @protocol references</span><br>    <span class="hljs-comment">// Preoptimized images may have the right</span><br>    <span class="hljs-comment">// answer already but we don&#x27;t know for sure.</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-comment">// At launch time, we know preoptimized image refs are pointing at the</span><br>        <span class="hljs-comment">// shared cache definition of a protocol.  We can skip the check on</span><br>        <span class="hljs-comment">// launch, but have to visit @protocol refs for shared cache images</span><br>        <span class="hljs-comment">// loaded later.</span><br>        <span class="hljs-keyword">if</span> (launchTime &amp;&amp; hi-&gt;isPreoptimized())<br>            <span class="hljs-keyword">continue</span>;<br>        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            remapProtocolRef(&amp;protolist[i]);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);<br><br>    <span class="hljs-comment">// Discover categories. Only do this after the initial category</span><br>    <span class="hljs-comment">// attachment has been done. For categories present at startup,</span><br>    <span class="hljs-comment">// discovery is deferred until the first load_images call after</span><br>    <span class="hljs-comment">// the call to _dyld_objc_notify_register completes. rdar://problem/53119145</span><br>    <span class="hljs-keyword">if</span> (didInitialAttachCategories) &#123;<br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            load_categories_nolock(hi);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover categories&quot;</span>);<br><br>    <span class="hljs-comment">// Category discovery MUST BE Late to avoid potential races</span><br>    <span class="hljs-comment">// when other threads call the new category code before</span><br>    <span class="hljs-comment">// this thread finishes its fixups.</span><br><br>    <span class="hljs-comment">// +load handled by prepare_load_methods()</span><br><br>    <span class="hljs-comment">// Realize non-lazy classes (for +load methods and static instances)</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        classref_t <span class="hljs-keyword">const</span> *classlist = hi-&gt;nlclslist(&amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            Class cls = remapClass(classlist[i]);<br>            <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">continue</span>;<br><br>            addClassTableEntry(cls);<br><br>            <span class="hljs-keyword">if</span> (cls-&gt;isSwiftStable()) &#123;<br>                <span class="hljs-keyword">if</span> (cls-&gt;swiftMetadataInitializer()) &#123;<br>                    _objc_fatal(<span class="hljs-string">&quot;Swift class %s with a metadata initializer &quot;</span><br>                                <span class="hljs-string">&quot;is not allowed to be non-lazy&quot;</span>,<br>                                cls-&gt;nameForLogging());<br>                &#125;<br>                <span class="hljs-comment">// fixme also disallow relocatable classes</span><br>                <span class="hljs-comment">// We can&#x27;t disallow all Swift classes because of</span><br>                <span class="hljs-comment">// classes like Swift.__EmptyArrayStorage</span><br>            &#125;<br>            realizeClassWithoutSwift(cls, <span class="hljs-literal">nil</span>);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);<br><br>    <span class="hljs-comment">// Realize newly-resolved future classes, in case CF manipulates them</span><br>    <span class="hljs-keyword">if</span> (resolvedFutureClasses) &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;<br>            Class cls = resolvedFutureClasses[i];<br>            <span class="hljs-keyword">if</span> (cls-&gt;isSwiftStable()) &#123;<br>                _objc_fatal(<span class="hljs-string">&quot;Swift class is not allowed to be future&quot;</span>);<br>            &#125;<br>            realizeClassWithoutSwift(cls, <span class="hljs-literal">nil</span>);<br>            cls-&gt;setInstancesRequireRawIsaRecursively(<span class="hljs-literal">false</span><span class="hljs-comment">/*inherited*/</span>);<br>        &#125;<br>        free(resolvedFutureClasses);<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: realize future classes&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (DebugNonFragileIvars) &#123;<br>        realizeAllClasses();<br>    &#125;<br><br><br>    <span class="hljs-comment">// Print preoptimization statistics</span><br>    <span class="hljs-keyword">if</span> (PrintPreopt) &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PreoptTotalMethodLists;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PreoptOptimizedMethodLists;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PreoptTotalClasses;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PreoptOptimizedClasses;<br><br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            <span class="hljs-keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: honoring preoptimized selectors &quot;</span><br>                             <span class="hljs-string">&quot;in %s&quot;</span>, hi-&gt;fname());<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hi-&gt;info()-&gt;optimizedByDyld()) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: IGNORING preoptimized selectors &quot;</span><br>                             <span class="hljs-string">&quot;in %s&quot;</span>, hi-&gt;fname());<br>            &#125;<br><br>            classref_t <span class="hljs-keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                Class cls = remapClass(classlist[i]);<br>                <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">continue</span>;<br><br>                PreoptTotalClasses++;<br>                <span class="hljs-keyword">if</span> (hi-&gt;hasPreoptimizedClasses()) &#123;<br>                    PreoptOptimizedClasses++;<br>                &#125;<br><br>                <span class="hljs-keyword">const</span> method_list_t *mlist;<br>                <span class="hljs-keyword">if</span> ((mlist = cls-&gt;bits.safe_ro()-&gt;baseMethods)) &#123;<br>                    PreoptTotalMethodLists++;<br>                    <span class="hljs-keyword">if</span> (mlist-&gt;isFixedUp()) &#123;<br>                        PreoptOptimizedMethodLists++;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((mlist = cls-&gt;ISA()-&gt;bits.safe_ro()-&gt;baseMethods)) &#123;<br>                    PreoptTotalMethodLists++;<br>                    <span class="hljs-keyword">if</span> (mlist-&gt;isFixedUp()) &#123;<br>                        PreoptOptimizedMethodLists++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: %zu selector references not &quot;</span><br>                     <span class="hljs-string">&quot;pre-optimized&quot;</span>, UnfixedSelectors);<br>        _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted&quot;</span>,<br>                     PreoptOptimizedMethodLists, PreoptTotalMethodLists,<br>                     PreoptTotalMethodLists<br>                     ? <span class="hljs-number">100.0</span>*PreoptOptimizedMethodLists/PreoptTotalMethodLists<br>                     : <span class="hljs-number">0.0</span>);<br>        _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered&quot;</span>,<br>                     PreoptOptimizedClasses, PreoptTotalClasses,<br>                     PreoptTotalClasses<br>                     ? <span class="hljs-number">100.0</span>*PreoptOptimizedClasses/PreoptTotalClasses<br>                     : <span class="hljs-number">0.0</span>);<br>        _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: %zu protocol references not &quot;</span><br>                     <span class="hljs-string">&quot;pre-optimized&quot;</span>, UnfixedProtocolReferences);<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> EACH_HEADER</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>主要流程如下：</p>
<ol>
<li>静态变量<code>doneOnce</code>,控制只加载一次，这里主要的工作时初始化<strong>类映射表</strong><code>gdb_objc_realized_classes</code>以及重新初始化<code>TaggePointer</code>环境<ul>
<li>其中创建的<code>gdb_objc_realized_classes</code>这个表，后期会在<code>addNamedClass</code>静态方法内部对表进行赋值</li>
</ul>
</li>
<li>修复预编译阶段的<code>@selector</code>的混乱问题,方法列表和注册时不同的，重新修复。</li>
<li>开始遍历头文件，进行类与元类的读取操作并标记(旧类改动后会生成新的类，并重映射到新的类上),主要的方法是<code>readClass</code>,其内部<ul>
<li>找不到该类的父类，可能是弱绑定，直接返回<code>nil</code></li>
<li>找到类了，判断这个类是否是一个<code>future</code>的类(可以理解为需要实现的一个类，也可以理解为这个类是否有变化)，如果有变化则创建新类，并把旧类的数据拷贝一份然后赋值给新类<code>newCls</code>，然后调用<code>addRemappedClass</code>进行重映射，用新的类替换掉旧的类，并返回新类<code>newCls</code>的地址</li>
<li>找到类了，如果类没有任何变化，则不进行任何操作，直接返回<code>class</code></li>
<li>期间会将类的信息加入<code>NXMapTable</code>(类映射表)和<code>objc::allocatedClasses</code>(所有类的表,这个表在<code>runtime_init</code>时初始化的)<ul>
<li><code>addNamedClass</code>,<code>key</code>是<code>类名</code>，<code>value</code>是<code>Class</code>,哈希表结构</li>
<li><code>addClassTableEntry</code>,直接将<code>Class</code>和其元类加入<code>objc::allocatedClasses</code>（这个表是在<a href="#jump">runtime_init</a>）类似<code>set</code>中，会通过这个来判断是否是<code>isKnownClass</code></li>
</ul>
</li>
<li><code>readClass</code>会返回一个类，这里会判断，类表中的类和<code>readClass</code>生成的新类是否相等，如果不等，且认为新类，该类认为是<code>Future</code>类（在镜像加载之前就存在的类，需要重新映射，这个类有变化）</li>
</ul>
</li>
<li>修复重映射⼀些没有被镜像⽂件加载进来的类,主要方法<code>remapClassRef</code></li>
<li>修复⼀些旧的<code>objc</code>方法,在方法<code>fixupMessageRef</code>，类似<code>alloc</code>、<code>allocWithZone:</code>、<code>retain</code>、<code>release</code>、<code>autorelease</code>、<code>objc_msgSendSuper2_fixup</code>等一些方法，会重写赋值新的<code>imp</code>。在调试发现，并未触发，显然是对旧版本方法的修复</li>
<li>找到所有的协议<code>protocols</code>，和2,3类似(<code>remap</code>)，主要方法是<code>readProtocol</code>,会将协议加载到一个<code>NXMapTable</code>的映射表中，这里如果声明的协议没有使用，是不会加入的.</li>
<li>和4类似，重映射没有从镜像中加载的协议，主要方法<code>remapProtocolRef</code></li>
<li>分类处理，将分类合并到类中。<strong>注意</strong>,这里的合并操作，是在真正的分类合并操作完成之后（也就是在<code>load_images</code>之后），才能进行合并，一般情况下，并不会执行</li>
<li>对类中有<code>+load</code>存在的,即非懒加载类（有<code>+load</code>的类）,加入到所有类的表中，并进行加载<code>realizeClassWithoutSwift</code>。的作用是，<code>对类 cls 进行首次初始化，包括分配其读写数据。不执行任何 Swift 端初始化。返回该类的真实类结构</code>。</li>
<li>对3中得到的<code>FutureClasses</code>重新映射</li>
</ol>
</li>
<li><p><code>map_images</code>中的各种<code>remap</code>重映射的目的</p>
<ol>
<li><code>加载镜像文件</code>：<code>map_image</code>函数用于加载可执行文件和动态库的镜像文件(加载时，会调用<code>dyld</code>的方式，进行<code>rebase</code>)。它会根据传入的镜像路径，读取相应的二进制文件并将其映射到内存中。</li>
<li><code>符号解析</code>：加载镜像文件后，<code>map_image</code>函数会对其中的符号进行解析。符号可以是函数、全局变量、类、协议等。解析符号是为了建立符号与相应的内存地址之间的关联，以便在后续的代码执行中能够正确地访问和调用这些符号</li>
<li><code>修复链接关系</code>：镜像文件中的符号可能会引用其他的库或框架，需要进行链接才能正确地访问这些外部符号。<code>map_image</code>函数会处理这些链接关系，确保所有的符号都能够正确地链接到相应的库和框架中</li>
<li><code>内存保护和权限设置</code>：<code>map_image</code>函数会为加载的镜像文件设置适当的内存保护和权限设置。这样可以防止对内存的非法访问和修改，提高应用程序的安全性。</li>
</ol>
</li>
</ul>
<h3 id="realizeClassWithoutSwift-源码"><a href="#realizeClassWithoutSwift-源码" class="headerlink" title="realizeClassWithoutSwift 源码"></a>realizeClassWithoutSwift 源码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)<br>&#123;<br>    lockdebug::assert_locked(&amp;runtimeLock);<br><br>      class_rw_t *rw;<br>      Class supercls;<br>      Class metacls;<br><br>        <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        <span class="hljs-keyword">if</span> (cls-&gt;isRealized()) &#123;<br>            validateAlreadyRealizedClass(cls);<br>            <span class="hljs-keyword">return</span> cls;<br>    &#125;<br>     ASSERT(cls == remapClass(cls));<br><br>     <span class="hljs-comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span><br><br>     auto ro = cls-&gt;safe_ro(); <span class="hljs-comment">// 读取类的数据</span><br>     auto isMeta = ro-&gt;flags &amp; RO_META;<br>     <span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;  <span class="hljs-comment">// rw已经有值的话走这里</span><br>    <span class="hljs-comment">// This was a future class. rw data is already allocated.</span><br>      rw = cls-&gt;data();<br>      ro = cls-&gt;data()-&gt;ro();<br>      ASSERT(!isMeta);<br>       cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 正常的类走这里</span><br>      <span class="hljs-comment">// Normal class. Allocate writeable class data.</span><br>       rw = objc::zalloc&lt;class_rw_t&gt;();<br>       rw-&gt;set_ro(ro);<br>       rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;<br>       cls-&gt;setData(rw);<br>  &#125;<br><br>  cls-&gt;cache.initializeToEmptyOrPreoptimizedInDisguise();<br><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> FAST_CACHE_META</span><br>  <span class="hljs-keyword">if</span> (isMeta) cls-&gt;cache.setBit(FAST_CACHE_META);<br> <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-comment">// Choose an index for this class.</span><br> <span class="hljs-comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are         available</span><br> cls-&gt;chooseClassArrayIndex();<br>    <br> <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>      _objc_inform(<span class="hljs-string">&quot;CLASS: realizing class &#x27;%s&#x27;%s %p %p #%u %s%s&quot;</span>,<br>             cls-&gt;nameForLogging(), isMeta ? <span class="hljs-string">&quot; (meta)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>             (<span class="hljs-keyword">void</span>*)cls, ro, cls-&gt;classArrayIndex(),<br>             cls-&gt;isSwiftStable() ? <span class="hljs-string">&quot;(swift)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>             cls-&gt;isSwiftLegacy() ? <span class="hljs-string">&quot;(pre-stable swift)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br> &#125;<br><br> <span class="hljs-comment">// Realize superclass and metaclass, if they aren&#x27;t already.</span><br>  <span class="hljs-comment">//实现超类和元类（如果尚未实现）。</span><br>  <span class="hljs-comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span><br>  <span class="hljs-comment">//对于根类，需要在上面设置了RW_REALIZED之后执行此操作。</span><br> <span class="hljs-comment">// This needs to be done after class index is chosen, for root metaclasses.</span><br> <span class="hljs-comment">//对于根元类，需要在选择类索引之后执行此操作。</span><br>  <span class="hljs-comment">// This assumes that none of those classes have Swift contents,</span><br>  <span class="hljs-comment">//   or that Swift&#x27;s initializers have already been called.</span><br>  <span class="hljs-comment">//   fixme that assumption will be wrong if we add support</span><br>  <span class="hljs-comment">//   for ObjC subclasses of Swift classes.</span><br>  <span class="hljs-comment">// 递归调用 realizeClassWithoutSwift ，实现父类和元类</span><br>  supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), <span class="hljs-literal">nil</span>);<br> metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), <span class="hljs-literal">nil</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span><br>  <span class="hljs-keyword">if</span> (isMeta) &#123; <span class="hljs-comment">// 如果是元类，对isa处理</span><br>        <span class="hljs-comment">// Metaclasses do not need any features from non pointer ISA</span><br>     <span class="hljs-comment">// This allows for a faspath for classes in objc_retain/           objc_release.</span><br>        cls-&gt;setInstancesRequireRawIsa();<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 不是元类，也是对isa处理</span><br>      <span class="hljs-comment">// Disable non-pointer isa for some classes and/or platforms.</span><br>       <span class="hljs-comment">// Set instancesRequireRawIsa.</span><br>       <span class="hljs-keyword">bool</span> instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();<br>       <span class="hljs-keyword">bool</span> rawIsaIsInherited = <span class="hljs-literal">false</span>;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> hackedDispatch = <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-keyword">if</span> (DisableNonpointerIsa) &#123;<br>            <span class="hljs-comment">// Non-pointer isa disabled by environment or app SDK version</span><br>         instancesRequireRawIsa = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="hljs-number">0</span> == strcmp(ro-&gt;getName(),  <span class="hljs-string">&quot;OS_object&quot;</span>))<br>       &#123;<br>         <span class="hljs-comment">// hack for libdispatch et al - isa also acts as vtable pointer</span><br>         hackedDispatch = <span class="hljs-literal">true</span>;<br>            instancesRequireRawIsa = <span class="hljs-literal">true</span>;<br>     &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;getSuperclass()  &amp;&amp;<br>                 supercls-&gt;instancesRequireRawIsa())<br>     &#123;<br>            <span class="hljs-comment">// This is also propagated by addSubclass()</span><br>           <span class="hljs-comment">// but nonpointer isa setup needs it earlier.</span><br>           <span class="hljs-comment">// Special case: instancesRequireRawIsa does not propagate</span><br>            <span class="hljs-comment">// from root class to root metaclass</span><br>            instancesRequireRawIsa = <span class="hljs-literal">true</span>;<br>            rawIsaIsInherited = <span class="hljs-literal">true</span>;<br>      &#125;<br><br>        <span class="hljs-keyword">if</span> (instancesRequireRawIsa) &#123;<br>            cls-&gt;setInstancesRequireRawIsaRecursively(rawIsaIsInherited);<br>       &#125;<br> &#125;<br><span class="hljs-comment">// SUPPORT_NONPOINTER_ISA</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br> <span class="hljs-comment">// Update superclass and metaclass in case of remapping</span><br> <span class="hljs-comment">// 确定继承链，赋值父类和元类</span><br>    cls-&gt;setSuperclass(supercls);<br>    cls-&gt;initClassIsa(metacls);<br>    <span class="hljs-comment">// 协调实例变量的偏移量/布局。</span><br>    <span class="hljs-comment">// Reconcile instance variable offsets / layout.</span><br>    <span class="hljs-comment">// This may reallocate class_ro_t, updating our ro variable.</span><br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);<br>    <span class="hljs-comment">// 经过上一步，再次协调属性对齐后，设置实例大小</span><br>    <span class="hljs-comment">// Set fastInstanceSize if it wasn&#x27;t set already.</span><br>    cls-&gt;setInstanceSize(ro-&gt;instanceSize);<br>    <span class="hljs-comment">// 赋值一些 ro 中的 flags标识位 到 rw</span><br>    <span class="hljs-comment">// Copy some flags from ro to rw</span><br>    <span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;<br>        cls-&gt;setHasCxxDtor();<br>        <span class="hljs-keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;<br>            cls-&gt;setHasCxxCtor();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Propagate the associated objects forbidden flag from ro or from</span><br>    <span class="hljs-comment">// the superclass.</span><br>    <span class="hljs-comment">// 从ro或父类传播关联的对象禁止标志。</span><br>    <span class="hljs-keyword">if</span> ((ro-&gt;flags &amp; RO_FORBIDS_ASSOCIATED_OBJECTS) ||<br>        (supercls &amp;&amp; supercls-&gt;forbidsAssociatedObjects()))<br>    &#123;<br>        rw-&gt;flags |= RW_FORBIDS_ASSOCIATED_OBJECTS;<br>    &#125;<br><br>    <span class="hljs-comment">// Connect this class to its superclass&#x27;s subclass lists</span><br>    <span class="hljs-comment">// 添加当前类到父类的子类列表中，如果没有父类，设置自己就是根类</span><br>    <span class="hljs-keyword">if</span> (supercls) &#123;<br>        addSubclass(supercls, cls);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addRootClass(cls);<br>    &#125;<br><br>    <span class="hljs-comment">// Attach categories</span><br>    methodizeClass(cls, previously);<br><br>    <span class="hljs-keyword">return</span> cls;<br>    &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>非懒加载的类的<code>realizeClassWithoutSwift</code>是在<code>map_images</code>是实现的，而懒加载类则是在,第一次使用该类时，调用相关<code>objc_msgSend</code>方法时调用。（代码中不使用的类，则不会加载解析）</li>
<li><code>methodizeClass</code>方法，修复<code>cls</code> 的方法列表，协议列表和属性列表，将类<code>class_ro_t</code>中的方法添加到<code>class_rw_t</code>中来  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> methodizeClass(Class cls, Class previously)<br>    &#123;<br>        runtimeLock.assertLocked();<br>    <br>        <span class="hljs-keyword">bool</span> isMeta = cls-&gt;isMetaClass();<br>        auto rw = cls-&gt;data();<br>        auto ro = rw-&gt;ro(); <span class="hljs-comment">// 读取ro数据</span><br>        auto rwe = rw-&gt;ext(); <span class="hljs-comment">// 读取ext，赋值给rwe</span><br>    <br>        <span class="hljs-comment">// Methodizing for the first time</span><br>        <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;CLASS: methodizing class &#x27;%s&#x27; %s&quot;</span>, <br>                         cls-&gt;nameForLogging(), isMeta ? <span class="hljs-string">&quot;(meta)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    <br>        <span class="hljs-comment">// Install methods and properties that the class implements itself.</span><br>        method_list_t *list = ro-&gt;baseMethods(); <span class="hljs-comment">// 获取ro中的方法列表</span><br>        <span class="hljs-keyword">if</span> (list) &#123;<br>            <span class="hljs-comment">// 对方法列表list重新排序</span><br>            prepareMethodLists(cls, &amp;list, <span class="hljs-number">1</span>, <span class="hljs-literal">YES</span>,  isBundleClass(cls));<br>            <span class="hljs-keyword">if</span> (rwe) rwe-&gt;methods.attachLists(&amp;list, <span class="hljs-number">1</span>); <span class="hljs-comment">// 如果有rwe，添加方法列表list到rwe的methodsList</span><br>        &#125;<br>    <br>        property_list_t *proplist = ro-&gt;baseProperties;<br>        <span class="hljs-keyword">if</span> (rwe &amp;&amp; proplist) &#123;<br>            rwe-&gt;properties.attachLists(&amp;proplist, <span class="hljs-number">1</span>);<br>        &#125;<br>    <br>        protocol_list_t *protolist = ro-&gt;baseProtocols;<br>        <span class="hljs-keyword">if</span> (rwe &amp;&amp; protolist) &#123;<br>            rwe-&gt;protocols.attachLists(&amp;protolist, <span class="hljs-number">1</span>);<br>        &#125;<br>    <br>        <span class="hljs-comment">// Root classes get bonus method implementations if they don&#x27;t have </span><br>        <span class="hljs-comment">// them already. These apply before category replacements.</span><br>        <span class="hljs-keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;<br>            <span class="hljs-comment">// root metaclass 根元类添加initialize方法</span><br>            addMethod(cls, <span class="hljs-keyword">@selector</span>(initialize), (IMP)&amp;objc_noop_imp, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">NO</span>);<br>        &#125;<br>    <br>        <span class="hljs-comment">// Attach categories. 附加分类</span><br>        <span class="hljs-keyword">if</span> (previously) &#123;<br>            <span class="hljs-keyword">if</span> (isMeta) &#123;<br>                objc::unattachedCategories.attachToClass(cls, previously,<br>                                                         ATTACH_METACLASS);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// When a class relocates, categories with class methods</span><br>                <span class="hljs-comment">// may be registered on the class itself rather than on</span><br>                <span class="hljs-comment">// the metaclass. Tell attachToClass to look for those.</span><br>                objc::unattachedCategories.attachToClass(cls, previously,<br>                                                         ATTACH_CLASS_AND_METACLASS);<br>            &#125;<br>        &#125;<br>        objc::unattachedCategories.attachToClass(cls, cls,<br>                                                 isMeta ? ATTACH_METACLASS : ATTACH_CLASS);<br>    <br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG</span><br>        <span class="hljs-comment">// Debug: sanity-check all SELs; log method list contents</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> auto&amp; meth : rw-&gt;methods()) &#123;<br>            <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;METHOD %c[%s %s]&quot;</span>, isMeta ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                             cls-&gt;nameForLogging(), sel_getName(meth.name));<br>            &#125;<br>            ASSERT(sel_registerName(sel_getName(meth.name)) == meth.name); <br>&#125;<br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>     &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>懒加载类以及分类的加载</title>
    <url>/2022/12/26/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E4%BB%A5%E5%8F%8A%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li>官方在对类进行处理的时候, 为了提高对类处理的效率以及性能, 就对类进行了识别, 当类需要使用的时候, 系统才会对类进行实现. 如果没有使用就不会实现. 当需要使用时才进行加载的类就被称为懒加载类. 反之无论是否使用到这个类, 都会对这个类进行加载的类就被称为非懒加载类</li>
<li>懒加载类和非懒加载类的区别在于是否实现了<code>+(void)load</code>方法</li>
<li>所有的类在使用前都会调用<code>realizeClassMaybeSwiftAndLeaveLocked</code>对类进行加载,通过这个来判断类和分类加载的时机</li>
</ul>
</blockquote>
<span id="more"></span>
<h3 id="验证的方式"><a href="#验证的方式" class="headerlink" title="验证的方式"></a>验证的方式</h3><blockquote>
<p>定义两个类<code>LGPerson</code>和<code>LGPerson(Text)</code>,在<code>load_categories_nolock</code><br>和<code>realizeClassWithoutSwift</code>源码中加入以下代码:</p>
</blockquote>
<ul>
<li>分类<code>load_categories_nolock</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//加载分类的地方</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load_categories_nolock</span><span class="hljs-params">(header_info *hi)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> hasClassProperties = hi-&gt;<span class="hljs-built_in">info</span>()-&gt;<span class="hljs-built_in">hasCategoryClassProperties</span>();<br><br>    <span class="hljs-keyword">size_t</span> count;<br>    <span class="hljs-keyword">auto</span> processCatlist = [&amp;](<span class="hljs-keyword">category_t</span> * <span class="hljs-keyword">const</span> *catlist) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-keyword">category_t</span> *cat = catlist[i];<br>            Class cls = <span class="hljs-built_in">remapClass</span>(cat-&gt;cls);<br>            <span class="hljs-keyword">locstamped_category_t</span> lc&#123;cat, hi&#125;;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * sd = <span class="hljs-string">&quot;LGPerson&quot;</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sd, cls-&gt;<span class="hljs-built_in">mangledName</span>()) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定位到了&quot;</span>);<br>            &#125;<br>        ....<br></code></pre></td></tr></table></figure></li>
<li>类加载<code>realizeClassWithoutSwift</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> Class <span class="hljs-title">realizeClassWithoutSwift</span><span class="hljs-params">(Class cls, Class previously)</span></span><br><span class="hljs-function"></span>&#123;<br>    lockdebug::<span class="hljs-built_in">assert_locked</span>(&amp;runtimeLock);<br><br>    <span class="hljs-keyword">class_rw_t</span> *rw;<br>    Class supercls;<br>    Class metacls;<br>      <br>    <br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> nil;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * sd = <span class="hljs-string">&quot;LGPerson&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sd, cls-&gt;<span class="hljs-built_in">mangledName</span>()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定位到了&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cls-&gt;<span class="hljs-built_in">isRealized</span>()) &#123;<br>        <span class="hljs-built_in">validateAlreadyRealizedClass</span>(cls);<br>        <span class="hljs-keyword">return</span> cls;<br>    &#125;<br>    .....<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="懒加载类和分类"><a href="#懒加载类和分类" class="headerlink" title="懒加载类和分类"></a>懒加载类和分类</h3><blockquote>
<p>查看懒加载类和分类的加载时机</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[[LGPerson alloc] init]<br></code></pre></td></tr></table></figure>
<h4 id="加载的时机"><a href="#加载的时机" class="headerlink" title="加载的时机"></a>加载的时机</h4><h5 id="第一次断点"><a href="#第一次断点" class="headerlink" title="第一次断点"></a>第一次断点</h5><ul>
<li>通过断点查看,显然懒加载类是在第一次调用类相关方法的时候，才会去加载类,首先会调用类方法<br>  <img src="1.png"></li>
<li><code>lldb</code>查看<code>class_ro_t</code>中的代码,首先调用的是<code>[LGPerson alloc]</code>，会先加载元类，并且从方法可知，<code>class_ro_t</code>中存放有分类的方法，<code>class_ro_t</code>从一开始是不能变的，显然分类中的方法，在编译期间，就加载到原始类的方法中了。  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb) p ro.baseMethods<br>(<span class="hljs-keyword">const</span> WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt;) $<span class="hljs-number">2</span> = &#123;<br>  ptr = <span class="hljs-number">0x00000001000083f0</span><br>&#125;<br>  <br>(lldb) p $<span class="hljs-number">2</span>[<span class="hljs-number">0</span>]<br>(method_list_t) $<span class="hljs-number">3</span> = &#123;<br>  entsize_list_tt&lt;method_t, method_list_t, <span class="hljs-number">4294901763</span>, method_t::pointer_modifier&gt; = (entsizeAndFlags = <span class="hljs-number">24</span>, count = <span class="hljs-number">1</span>)<br>&#125;<br>(lldb) p $<span class="hljs-number">3.</span>get(<span class="hljs-number">0</span>).big<br>(method_t::big) $<span class="hljs-number">4</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f3e</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000037f0</span> (KCObjcBuild`+[LGPerson(Text) textCategory])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="第二次断点"><a href="#第二次断点" class="headerlink" title="第二次断点"></a>第二次断点</h5><ul>
<li><p>通过断点查看<br>   <img src="2.png"></p>
</li>
<li><p><code>lldb</code>查看<code>class_ro_t</code>中的代码，这里会调用<code>init</code>,是当前的实例方法，指向<code>LGPerson</code>。同样从其内存中也可发现分类中的方法一开始就在<code>class_ro_t</code>中</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">p ro.baseMethods<br>(<span class="hljs-keyword">const</span> WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt;) $<span class="hljs-number">6</span> = &#123;<br>  ptr = <span class="hljs-number">0x0000000100008410</span><br>&#125;<br>  <br>(lldb) p $<span class="hljs-number">6</span>[<span class="hljs-number">0</span>]<br>(method_list_t) $<span class="hljs-number">7</span> = &#123;<br>  entsize_list_tt&lt;method_t, method_list_t, <span class="hljs-number">4294901763</span>, method_t::pointer_modifier&gt; = (entsizeAndFlags = <span class="hljs-number">24</span>, count = <span class="hljs-number">17</span>)<br>&#125;<br>(lldb) p $<span class="hljs-number">6</span>[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big<br>(method_t::big) $<span class="hljs-number">8</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f3e</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003820</span> (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br> <br>(lldb) p $<span class="hljs-number">6</span>[<span class="hljs-number">0</span>].get(<span class="hljs-number">1</span>).big<br>(method_t::big) $<span class="hljs-number">9</span> = &#123;<br>  name = <span class="hljs-string">&quot;text1&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f3e</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003880</span> (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="第三次断点"><a href="#第三次断点" class="headerlink" title="第三次断点"></a>第三次断点</h5><ul>
<li><p>第三次断点，会去查找元类，由于元类已经初始化，会直接返回。且，整个过程中不会触发在<code>load_categories_nolock</code>断点。</p>
</li>
<li><p>查看加载完成类中的<code>class_rw_t</code>方法，分类方法和类方法，均在<code>class_rw_t</code>的第一张表内，而非分开存放，显然是一开始均在<code>class_ro_t</code>,因此均在二维表<code>class_rw_t</code>的第一张内</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb) p (objc_class *)cls<br>(objc_class *) $<span class="hljs-number">0</span> = <span class="hljs-number">0x0000000100008600</span><br>(lldb) p $<span class="hljs-number">0</span>-&gt;data()<br>(class_rw_t *) $<span class="hljs-number">1</span> = <span class="hljs-number">0x00006000002349a0</span><br>(lldb) p $<span class="hljs-number">1</span>-&gt;methods()<br>(<span class="hljs-keyword">const</span> method_array_t) $<span class="hljs-number">2</span> = &#123;<br>    list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; = &#123;<br>         = &#123;<br>          list = &#123;<br>            ptr = <span class="hljs-number">0x0000000100008410</span><br>          &#125;<br>          arrayAndFlag = <span class="hljs-number">4295001104</span><br>        &#125;<br>      &#125;<br>    &#125;<br>(lldb) p $<span class="hljs-number">2.</span>list[<span class="hljs-number">0</span>]<br>(method_list_t) $<span class="hljs-number">3</span> = &#123;<br>entsize_list_tt&lt;method_t, method_list_t, <span class="hljs-number">4294901763</span>, method_t::pointer_modifier&gt; = (entsizeAndFlags = <span class="hljs-number">27</span>, count = <span class="hljs-number">17</span>)<br>&#125;<br>(lldb) p $<span class="hljs-number">2.</span>list[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big<br>(method_t::big) $<span class="hljs-number">4</span> = &#123;<br>    name = <span class="hljs-string">&quot;textCategory&quot;</span><br>    types = <span class="hljs-number">0x0000000100003f44</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>    imp = <span class="hljs-number">0x0000000100003820</span> (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br>(lldb) p $<span class="hljs-number">2.</span>list[<span class="hljs-number">0</span>].get(<span class="hljs-number">1</span>).big<br>(method_t::big) $<span class="hljs-number">5</span> = &#123;<br>    name = <span class="hljs-string">&quot;text1&quot;</span><br>    types = <span class="hljs-number">0x0000000100003f44</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>    imp = <span class="hljs-number">0x0000000100003880</span> (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>(lldb) p $<span class="hljs-number">2.</span>list[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>).big<br>(method_t::big) $<span class="hljs-number">6</span> = &#123;<br>    name = <span class="hljs-string">&quot;v16@0:8&quot;</span><br>    types = <span class="hljs-number">0x0000000100003820</span> <span class="hljs-string">&quot;UH\x89\xe5H\x83\xec\U00000010H\x89&#125;\xf0H\x89u\xf8H\x8d=\x89\b&quot;</span><br>    imp = <span class="hljs-number">0x0000000100003e33</span> (<span class="hljs-string">&quot;text1&quot;</span>)<br>&#125;<br>(lldb) p $<span class="hljs-number">2.</span>list[<span class="hljs-number">2</span>].get(<span class="hljs-number">0</span>).big<br>(method_t::big) $<span class="hljs-number">7</span> = &#123;<br>name = <span class="hljs-string">&quot;UH\x89\xe5H\x83\xec\U00000010H\x89&#125;\xf0H\x89u\xf8H\x8d=\x89\b&quot;</span><br>types = <span class="hljs-number">0x0000000100003e33</span> <span class="hljs-string">&quot;text1&quot;</span><br>    imp = <span class="hljs-number">0x0000000100003f44</span> (<span class="hljs-string">&quot;v16@0:8&quot;</span>)<br>&#125;<br>(lldb)<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>懒加载中的类和分类，在方法初始化的时候才会去,调用<code>realizeClassWithoutSwift</code>,加载类;<br>懒加载类中的分类方法，一开始就在类的<code>class_ro_t</code>中类，即类加载之前。表明在编译的时候就加到类中了。整个过程中不会去调用<code>load_categories_nolock</code>(将分类方法加到类中)。</p>
</blockquote>
<h3 id="非懒加载类和懒加载分类"><a href="#非懒加载类和懒加载分类" class="headerlink" title="非懒加载类和懒加载分类"></a><span id="jump">非懒加载类和懒加载分类</span></h3><blockquote>
<p>类中实现load方法，分类中不实现。上述一样的排查方式</p>
</blockquote>
<h4 id="加载的时机-1"><a href="#加载的时机-1" class="headerlink" title="加载的时机"></a>加载的时机</h4><h5 id="第一次断点-1"><a href="#第一次断点-1" class="headerlink" title="第一次断点"></a>第一次断点</h5><ul>
<li>通过断点查看,显然在<code>runtime</code>启动的时候，在<code>read_images</code>时，对所有<code>懒加载类</code>进行了加载，并且先加载的是类，而非元类<br>  <img src="3.png"></li>
<li><code>lldb</code>查看此时类中<code>class_ro_t</code>中的方法可知,懒加载分类中的方法，一开始就在类中，并在编译的时候就确定了  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb) p ro.baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>   (method_t::big) $<span class="hljs-number">4</span> = &#123;<br>     name = <span class="hljs-string">&quot;textCategory2&quot;</span><br>     types = <span class="hljs-number">0x0000000100003f47</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>     imp = <span class="hljs-number">0x0000000100003770</span> (KCObjcBuild`-[LGPerson(Text2) textCategory2])<br>   &#125;<br>     <br>   (lldb) p ro.baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">1</span>).big()<br>   (method_t::big) $<span class="hljs-number">5</span> = &#123;<br>     name = <span class="hljs-string">&quot;textCategory&quot;</span><br>     types = <span class="hljs-number">0x0000000100003f47</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>     imp = <span class="hljs-number">0x00000001000037d0</span> (KCObjcBuild`-[LGPerson(Text) textCategory])<br>   &#125;<br>    <br>   (lldb) p ro.baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">2</span>).big()<br>   (method_t::big) $<span class="hljs-number">6</span> = &#123;<br>     name = <span class="hljs-string">&quot;text1&quot;</span><br>     types = <span class="hljs-number">0x0000000100003f47</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>     imp = <span class="hljs-number">0x0000000100003830</span> (KCObjcBuild`-[LGPerson text1])<br>   &#125;<br>     <br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="第二次断点-1"><a href="#第二次断点-1" class="headerlink" title="第二次断点"></a>第二次断点</h5><ul>
<li>会去加载元类，且从<code>lldb</code>查看，元类中的<code>class_ro_t</code>中，同样一开始就有分类中的方法，表明在编译的时候，分类方法就加载到类中了</li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>非懒加载中的类和懒加载分类，在<code>runtime</code>初始化的时候,在<code>read_images</code>时,调用<code>realizeClassWithoutSwift</code>加载类;<br>懒加载分类中的方法，一开始就在非懒加类的<code>class_ro_t</code>中类，即类加载之前。表明在编译的时候就加到类中了。整个过程中不会去调用<code>load_categories_nolock</code>(将分类方法加到类中)。</p>
</blockquote>
<h3 id="懒加载类和非懒加载分类"><a href="#懒加载类和非懒加载分类" class="headerlink" title="懒加载类和非懒加载分类"></a>懒加载类和非懒加载分类</h3><blockquote>
<p>分类中实现<code>load</code>方法，类中不实现。上述一样的排查方式</p>
</blockquote>
<h4 id="一个懒加载分类"><a href="#一个懒加载分类" class="headerlink" title="一个懒加载分类"></a>一个懒加载分类</h4><blockquote>
<p><code>LGPerson(Text)</code>分类中实现<code>load</code>方法,<code>LGPerson (Text2)</code>中不实现</p>
</blockquote>
<h5 id="第一次断点-2"><a href="#第一次断点-2" class="headerlink" title="第一次断点"></a>第一次断点</h5><ul>
<li>通过断点查看,和上一节一样,<code>runtime</code>启动的时候，在<code>read_images</code>时，对所有<code>懒加载类</code>进行了加载。这里显然,懒加载的类由于非懒加载的分类，而变成了非懒加载类。一样先加载的是类，而非元类<br>  <img src="3.png"></li>
<li><code>lldb</code>查看<code>class_ro_t</code>中的方法，发现非懒加载分类<code>LGPerson(Text2)</code>和懒加载分类<code>LGPerson(Text)</code>中的方法，一开始就在懒加载类中，显然也是由编译的时候就加到类中了。  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> (lldb) p ro.baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">8</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory2&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f41</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003750</span> (KCObjcBuild`-[LGPerson(Text2) textCategory2])<br>&#125;<br>  <br>(lldb) p ro.baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">1</span>).big()<br>(method_t::big) $<span class="hljs-number">9</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f41</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000037e0</span> (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br><br>(lldb) p ro.baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">2</span>).big()<br>(method_t::big) $<span class="hljs-number">10</span> = &#123;<br>  name = <span class="hljs-string">&quot;text1&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f41</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003840</span> (KCObjcBuild`-[LGPerson text1])<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="第二次断点-2"><a href="#第二次断点-2" class="headerlink" title="第二次断点"></a>第二次断点</h5><ul>
<li>会去加载元类，且从<code>lldb</code>查看，元类中的<code>class_ro_t</code>中，同样一开始就有分类中的方法，是在编译的时候，分类方法就加载到类中了</li>
</ul>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>懒加载中的类和一个非懒加载分类，和<a href="#jump">非懒加载类和懒加载分类</a>中的表现一致。</p>
</blockquote>
<h4 id="一个以上懒加载分类"><a href="#一个以上懒加载分类" class="headerlink" title="一个以上懒加载分类"></a><span id="jump1">一个以上懒加载分类</span></h4><blockquote>
<p><code>LGPerson(Text)</code>和<code>LGPerson (Text2)</code>分类中均实现<code>load</code>方法，<code>LGPerson (Text3)</code>分类中不实现</p>
</blockquote>
<h5 id="第一次断点-3"><a href="#第一次断点-3" class="headerlink" title="第一次断点"></a>第一次断点</h5><ul>
<li>在<code>load_images</code>时，<code>load_categories_nolock</code>加载所有分类时。其中<code>load_images</code>在<code>read_images</code>之后，并且之前并未有断点，显然，当前类不是<code>非懒加载类</code>(只有一个<code>非懒加载分类</code>时，会变成<code>非懒加载类</code>)，因此在<code>read_images</code>中加载，而是延后了。<br>  <img src="4.png"></li>
<li><code>lldb</code>查看根据分类<code>remapClass</code>出的类，查看其中<code>class_ro_t</code>的方法,显然，最开始的类中不包含分类<code>LGPerson(Text)</code>、<code>LGPerson (Text2)</code>和<code>LGPerson (Text3)</code>的方法  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb)  p (objc_class *)cls<br>    (objc_class *) $<span class="hljs-number">0</span> = <span class="hljs-number">0x0000000100008778</span><br>(lldb) p $<span class="hljs-number">0.</span>safe_ro()<br>    (<span class="hljs-keyword">const</span> class_ro_t *) $<span class="hljs-number">1</span> = <span class="hljs-number">0x0000000100008500</span><br>(lldb) p $<span class="hljs-number">1.</span>baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>    (method_t::big) $<span class="hljs-number">2</span> = &#123;<br>      name = <span class="hljs-string">&quot;text1&quot;</span><br>      types = <span class="hljs-number">0x0000000100003f39</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>      imp = <span class="hljs-number">0x0000000100003820</span> (KCObjcBuild`-[LGPerson text1])<br>    &#125;<br>(lldb) p $<span class="hljs-number">1.</span>baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">1</span>).big()<br>    (method_t::big) $<span class="hljs-number">3</span> = &#123;<br>      name = <span class="hljs-string">&quot;text2&quot;</span><br>      types = <span class="hljs-number">0x0000000100003f39</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>      imp = <span class="hljs-number">0x0000000100003850</span> (KCObjcBuild`-[LGPerson text2])<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看<code>category_t</code>中的方法，很显然是<code>LGPerson(Text)</code>,  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb) p cat.instanceMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">4</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f43</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000037d0</span> (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br>  <br>(lldb) p cat.classMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">5</span> = &#123;<br>  name = <span class="hljs-string">&quot;load&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f43</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003770</span> (KCObjcBuild`+[LGPerson(Text) load])<br>&#125;<br>  <br>(lldb) p cat.classMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">1</span>).big()<br>(method_t::big) $<span class="hljs-number">6</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f43</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000037a0</span> (KCObjcBuild`+[LGPerson(Text) textCategory])<br>&#125;<br> <br>(lldb) <br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="第二-三次断点"><a href="#第二-三次断点" class="headerlink" title="第二,三次断点"></a>第二,三次断点</h5><ul>
<li>仍然在分类加载的循环中，一共有<code>3</code>个分类会加载<code>3</code>次。</li>
<li><code>lldb</code>查看类的<code>class_ro_t</code>的方法,类<code>class_ro_t</code>并未发生任何改变,并且由于类未加载，<code>class_rw_t</code>还未生成。显然分类中的方法并未加载到类中。  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> (lldb) p (objc_class *)cls<br>        (objc_class *) $<span class="hljs-number">10</span> = <span class="hljs-number">0x0000000100008778</span><br> (lldb) p $<span class="hljs-number">10.</span>safe_ro().baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>        (method_t::big) $<span class="hljs-number">11</span> = &#123;<br>          name = <span class="hljs-string">&quot;text1&quot;</span><br>          types = <span class="hljs-number">0x0000000100003f39</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>          imp = <span class="hljs-number">0x0000000100003820</span> (KCObjcBuild`-[LGPerson text1])<br>        &#125;<br>          <br>(lldb) p $<span class="hljs-number">10.</span>safe_ro().baseMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">1</span>).big()<br>        (method_t::big) $<span class="hljs-number">12</span> = &#123;<br>          name = <span class="hljs-string">&quot;text2&quot;</span><br>          types = <span class="hljs-number">0x0000000100003f39</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>          imp = <span class="hljs-number">0x0000000100003850</span> (KCObjcBuild`-[LGPerson text2])<br>        &#125;<br>         <br>(lldb) <br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看<code>category_t</code>中的方法，第二次是<code>LGPerson(Text2)</code>,第三次是<code>LGPerson(Text3)</code></li>
<li>此外，由于不是<code>已经加载的类</code>，无法<code>attach分类方法</code>，会调用方法<code>objc::unattachedCategories.addForClass</code>方法。里面也有个<code>attachToClass</code>方法，在里面增加断点。<code>locstamped_category_t lc&#123;cat, hi&#125;;</code>,<code>lc</code>中包含类和分类的映射关系<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (cls-&gt;<span class="hljs-built_in">ISA</span>()-&gt;<span class="hljs-built_in">isRealized</span>()) &#123;<br>    <span class="hljs-built_in">attachCategories</span>(cls-&gt;<span class="hljs-built_in">ISA</span>(), &amp;lc, <span class="hljs-number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    objc::unattachedCategories.<span class="hljs-built_in">addForClass</span>(lc, cls-&gt;<span class="hljs-built_in">ISA</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="realizeClassWithoutSwift中的断点"><a href="#realizeClassWithoutSwift中的断点" class="headerlink" title="realizeClassWithoutSwift中的断点"></a><code>realizeClassWithoutSwift</code>中的断点</h5><ul>
<li><p>在后续调用<code>prepare_load_methods</code>,加载所有分类中的<code>load</code>方法时，会调用<code>realizeClassWithoutSwift</code>开始加载类。和此前一样，先类，后元类。<br>  <img src="5.png"></p>
</li>
<li><p>这里是对元类方法对，分类方法进行添加.此时<code>unattachedCategories</code>种存储了之前在分类加载时，添加的分类方法<br><img src="6.png"></p>
</li>
<li><p><code>lldb</code>查看添加完后的<code>class_rw_t</code>,显然，元类中的分类的方法已经添加完毕</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb)  p rw.methods.beginLists()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>(method_list_t) $<span class="hljs-number">3</span> = &#123;<br>  entsize_list_tt&lt;method_t, method_list_t, <span class="hljs-number">4294901763</span>, method_t::pointer_modifier&gt; = (entsizeAndFlags = <span class="hljs-number">27</span>, count = <span class="hljs-number">1</span>)<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">4</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory3&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003670</span> (KCObjcBuild`+[LGPerson(Text3) textCategory3])<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">5</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory2&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003700</span> (KCObjcBuild`+[LGPerson(Text2) textCategory2])<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">6</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003790</span> (KCObjcBuild`+[LGPerson(Text) textCategory])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
<li><p>接下来是类中的分类方法添加，<code>lldb</code>查看添加完后的<code>class_rw_t</code>,显然也添加完成了</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">    (lldb) p rw.methods.beginLists()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">11</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory3&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000036a0</span> (KCObjcBuild`-[LGPerson(Text3) textCategory3])<br>&#125;<br><br>(lldb) p rw.methods.beginLists()[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">12</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory2&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003730</span> (KCObjcBuild`-[LGPerson(Text2) textCategory2])<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">13</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000037c0</span> (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">14</span> = &#123;<br>  name = <span class="hljs-string">&quot;text1&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003820</span> (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><blockquote>
<ul>
<li>懒加载中的类和一个以上非懒加载分类，也就是分类中<code>+load</code>方法超过<code>1</code>个,类不是<code>非懒加载类</code>(如果只有一个<code>非懒加载分类</code>时，会变成<code>非懒加载类</code>)，不会在<code>read_image</code>中加载，而是会在<code>load_image</code>中。在加载所有分类的时候，在<code>load_categories_nolock</code>,<code>remapClass</code>中进行加载。</li>
<li><code>remapClass</code>映射出类后，并未进行加载，因此，此时不会将分类中的方法加载到类中，但会将分类加载到<code>objc::unattachedCategories</code>中，构建类和分类的<code>映射表</code></li>
<li>在获取所有分类中的<code>load</code>方法<code>prepare_load_methods</code>时，会去加载分类对应的类方法，并且在加载时，会调用<code>objc::unattachedCategories:attachToClass</code>方法，在这里，将分类中的方法，加载到类中。</li>
</ul>
</blockquote>
<h3 id="非懒加载类和非懒加载分类"><a href="#非懒加载类和非懒加载分类" class="headerlink" title="非懒加载类和非懒加载分类"></a>非懒加载类和非懒加载分类</h3><blockquote>
<p>分类中实现<code>load</code>方法，类中实现<code>load</code></p>
</blockquote>
<h4 id="read-images断点"><a href="#read-images断点" class="headerlink" title="read_images断点"></a><code>read_images</code>断点</h4><ul>
<li>非懒加载类，在<code>read_images</code>中，就进行<code>realize</code>，并且是，先<code>元类</code>，后<code>类</code><br>   <img src="3.png"></li>
</ul>
<h4 id="load-images断点"><a href="#load-images断点" class="headerlink" title="load_images断点"></a><code>load_images</code>断点</h4><ul>
<li><code>load_categories_nolock</code>,加载所有的分类，此时，类已经加载完成了，并且此时就会通过<code>attachCategories(cls, &amp;lc, 1, ATTACH_EXISTING);</code>方法，直接将<code>分类方法</code>添加到<code>类</code>中<br>  <img src="4.png"></li>
<li><code>lldb</code>查看方法加载<ol>
<li>最开始加载的是<code>LGPerson(Text)</code>的方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb) p cat.instanceMethods[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>    (method_t::big) $<span class="hljs-number">0</span> = &#123;<br>     name = <span class="hljs-string">&quot;textCategory&quot;</span><br>     types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>     imp = <span class="hljs-number">0x0000000100003780</span> (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><code>LGPerson(Text)</code>分类方法，加载到类中 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb) p $<span class="hljs-number">2</span>-&gt;data()-&gt;methods().beginLists[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">6</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003780</span> (KCObjcBuild`-[LGPerson(Text)        textCategory])<br>&#125;<br>  <br>(lldb) p $<span class="hljs-number">2</span>-&gt;data()-&gt;methods().beginLists[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">7</span> = &#123;<br>  name = <span class="hljs-string">&quot;text1&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000037e0</span> (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>  <br></code></pre></td></tr></table></figure>
</li>
<li>然后是<code>LGPerson(Text2)</code>分类方法，加载到类中 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">(lldb) p $<span class="hljs-number">2</span>-&gt;data()-&gt;methods().beginLists[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">8</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory2&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000036f0</span> (KCObjcBuild`-[LGPerson(Text2) textCategory2])<br>&#125;<br>  <br>(lldb) p $<span class="hljs-number">2</span>-&gt;data()-&gt;methods().beginLists[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">9</span> = &#123;<br>  name = <span class="hljs-string">&quot;textCategory&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x0000000100003780</span> (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br>  <br>(lldb) p $<span class="hljs-number">2</span>-&gt;data()-&gt;methods().beginLists[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>).big()<br>(method_t::big) $<span class="hljs-number">10</span> = &#123;<br>  name = <span class="hljs-string">&quot;text1&quot;</span><br>  types = <span class="hljs-number">0x0000000100003f46</span> <span class="hljs-string">&quot;v16@0:8&quot;</span><br>  imp = <span class="hljs-number">0x00000001000037e0</span> (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
<li>最后是<code>LGPerson(Text3)</code>分类方法，加载到类中，到此，分类中的方法加载完毕。</li>
</ol>
</li>
</ul>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>和<a href="#jump1">一个以上懒加载分类</a>不同，<code>非懒加载类</code>和<code>分类</code>，会先在<code>read_images</code>，加载类,此时类已经<code>realize</code>解析完毕，并不需要在加载全部<code>load</code>方法时，在进行初始化</li>
<li>在<code>load_images</code>的<code>load_categories_nolock</code>中，在解析完一个<code>分类</code>后，就将一个<code>分类</code>加载到<code>类</code>中。和<a href="#jump1">一个以上懒加载分类</a>不同，不需要将所有<code>分类方法</code>收集到映射表<code>objc::unattachedCategories</code>中，再在类的<code>realize</code>方法中添加到类中</li>
</ul>
</blockquote>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li><code>懒加载类</code>和<code>懒加载分类</code>，分类中的方法在<code>编译</code>的时候就加载到类中，其方法在<code>class_ro_t</code>中；在使用类的时候才会去加载类，一般是触发<code>objc_msgsend</code>，发送消息时</li>
<li><code>非懒加载类</code>和<code>懒加载分类</code>,分类中的方法在编译的时候就加载到类中，其方法在<code>class_ro_t</code>中;类的加载，在<code>runtime</code>启动时，即<code>read_image</code>中，进行加载</li>
<li>懒加载类和非懒加载分类,分两种<ul>
<li>一个<code>非懒加载分类</code>，分类中的方法在<code>编译</code>的时候就加载到类中(显然编译器将其合成到<code>类</code>中，因此本质上<code>类</code>拥有了<code>load</code>方法，变成了<code>非懒加载类</code>)，其方法在<code>class_ro_t</code>中;类的加载，在<code>runtime</code>启动时，即<code>read_image</code>中，进行加载。此时的类受<code>分类影响</code>，变成了<code>非懒加载类</code>。</li>
<li>一个以上<code>非懒加载分类</code>(这类不会受影响，变成<code>非懒加载类</code>),分类的方法在<code>runtime</code>启动，<code>load_images</code>时，在<code>load_categories_nolock</code>时，由于<code>类未加载</code>，会将分类和类的映射在<code>objc::unattachedCategories.addForClass</code>中构建。并在<code>prepare_load_methods</code>会去加载类，在类加载时，会调用<code>objc::unattachedCategories:attachToClass</code>，这里会将分类中的方法加载到类中。</li>
</ul>
</li>
<li><code>非懒加载类</code>和<code>非懒加载分类</code>，<code>runtime</code>启动时，<code>类的加载</code>会在<code>read_image</code>中，进行加载。分类中的方法，会在<code>load_images</code>的<code>load_categories_nolock</code>时，解析完一个分类，就把该分类的方法加载到类中。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>分类</title>
    <url>/2022/12/25/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ol>
<li>通过<code>runtime</code>动态将分类的方法合并到类对象、元类对象中，注意如果是懒加载类，则会在编译的时候，合并，如果是非懒加载类，则会在运行时合并</li>
<li>一个分类文件的编译后的结构体实际为<span id="more"></span>
<img src="16719733229400.png"><ul>
<li>由runtime在运行，或者在编译时（懒加载和非懒加载，有优化），将分类的方法合并到类对象、元类对象中,</li>
<li>编译成<code>.cpp文件</code>，<code>MJPerson(Eat)</code>生成的 <code>_category_t</code>的静态结构体变量，其是单独的静态变量，其在编译的时后,并未合入到类对象中<br><img src="16719737845768.png"></li>
</ul>
</li>
</ol>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul>
<li><p><code>objc4</code>源码解读过程：<code>objc-os.mm</code></p>
<ol>
<li><p><code>_objc_init</code></p>
</li>
<li><p><code>map_images</code></p>
<ul>
<li><code>_read_images</code></li>
</ul>
</li>
<li><p><code>load_images</code></p>
</li>
<li><p><code>prepare_load_methods</code></p>
<ul>
<li><code>schedule_class_load</code></li>
<li><code>add_class_to_loadable_list</code></li>
<li><code>add_category_to_loadable_list</code></li>
</ul>
</li>
<li><p><code>call_load_methods</code></p>
<ul>
<li><code>call_class_loads</code></li>
<li><code>call_category_loads</code></li>
<li><code>(*load_method)(cls, SEL_load)</code></li>
</ul>
</li>
</ol>
</li>
<li><p><code>load</code>方法是根据方法地址直接调用，并不是经过<code>objc_msgSend</code>函数调用</p>
</li>
</ul>
<h3 id="method-array-t的构建"><a href="#method-array-t的构建" class="headerlink" title="method_array_t的构建"></a>method_array_t的构建</h3><blockquote>
<p>在<code>runtime</code>运行后，添加到<code>class_rw_t</code>的<code>method_array_t</code>二维方法数组中</p>
</blockquote>
<ul>
<li><p>类的加载<code>realize</code>方法，可以看到<code>class_rw_t</code>实际上是在运行时创建的，此前类中的<code>bits</code>中保存的是<code>class_ro_t</code>相关数据，在运行时<code>realize</code>，创建<code>class_rw_t</code>数据，并将其赋给<code>bits</code>中<br><img src="2.png" alt="截屏2023-01-01 23.10.16"></p>
</li>
<li><p>加载分类的方法，保证类<code>realize</code>完成后，再去加载分类<br><img src="1.png" alt="截屏2023-01-01 23.10.16"></p>
</li>
<li><p>核心添加方法 <code>attachLists</code></p>
</li>
<li><p><code>objc_838</code>版本，在构建分类大数组是，最后编译的分类，放到最前面，将所有的分类方法、属性、协议数据合并到一个大数组中</p>
<ul>
<li><code>prepareMethodLists</code>会对方法进行处理</li>
<li>这里有做一个判断，防止添加的数据越界，在等于最大<code>64</code>时，会先处理下，在进行大数组的合并。并且方法时从后往前添加的<br><img src="5.png"></li>
</ul>
</li>
<li><p>构建一个新数组，由后往前添加,新加的方法，放到最前面<br><img src="16720258260842.png"></p>
</li>
<li><p><code>objc_750</code>方法，最后编译的分类，放到最前面，最终所有的分类方法、属性、协议数据合并到一个大数组中</p>
<ul>
<li>方法时从前往后添加的<br><img src="4.png"> </li>
</ul>
</li>
<li><p>会通过<code>memmove</code>（内存挪动）(会根据方向挪动位置，保证数据完整性)将原来的方法列表，往后移动相应增加分类容量的位置。前面空出来的位置，用<code>memcpy</code>（内存拷贝）（只会从小地址，开始拷贝），添加在方法列表前面。也就是分类的方法，会在原方法的前面<br><img src="3.png"></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Category</code>的实现原理<ul>
<li><code>Category</code>编译之后的底层结构是<code>struct category_t</code>,里面吗存储着分类的对象方法、类方法、属性、协议信息</li>
<li>在程序运行的时候，<code>runtime</code>会将<code>Category</code>的数据，合并到类信息中（类对象、元类对象中）(并不是所有的分类均会，详情见<a href="%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E4%BB%A5%E5%8F%8A%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD.md">懒加载类以及分类的加载</a>)</li>
</ul>
</li>
<li><code>Category</code>和<code>Class EXtension</code>的区别是什么<ul>
<li><code>Class Extension</code>在<strong>编译</strong>的时候，他的数据已经包含在类信息中</li>
<li><code>Category</code>是在运行时，才会将数据合并到类信息中（并不是所有的分类均会）</li>
</ul>
</li>
</ul>
<h1 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h1><ul>
<li><a href="https://juejin.cn/post/6844903602524274696">iOS底层原理总结 - Category的本质</a></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC</title>
    <url>/2022/12/23/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/KVC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><ol>
<li>通过<code>KVC</code>修改属性会触发<code>KVO</code>，例如<code>age</code>属性,<ul>
<li>注意，就算<code>age</code>属性没有实现<code>set</code>的方法，只有<code>成员变量</code>，通过<code>KVC</code>设置，同样会触发<code>KVO</code></li>
<li>表明<code>KVC</code>内部实际上有调用<code>willchangForkey</code>、以及<code>didChangeForKey:</code>方法</li>
</ul>
</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="16719622557599.png"></p>
<ol>
<li>根据<code>setAge:</code>,<code>_setAge:</code>的顺序找到，找到则调用,设置值</li>
<li>如果<code>1</code>没找到，查看<code>accessInstanceVariablesDirectly</code>（是否可直接查找成员变量）是否返回<code>true</code>，为<code>No</code>，直接报没找到<code>key</code>的异常</li>
<li>如果为<code>true</code>，则按照<code>_age</code>,<code>_isAge</code>,<code>age</code>,<code>isAge</code>的顺序查找成员变量，找到直接赋值<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><img src="%E6%88%AA%E5%B1%8F2022-12-25%2020.15.39.png" alt="截屏2022-12-25 20.15.39"></li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO</title>
    <url>/2022/12/22/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/KVO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><h3 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h3><ul>
<li><p>未使用<code>KVO</code>监听，其<code>isa</code>指针指向的是其<code>class</code>对象。</p>
<ul>
<li><code>class对象</code>包含：（<code>isa</code>指针、<code>superclass</code>指针、实例方法、协议列表、属性列表、成员变量）</li>
</ul>
</li>
<li><p>使用<code>KVO</code>监听，其<code>isa</code>指向为<code>NSKVONotifying_class</code>，一个全新的<code>class对</code>象,</p>
<ul>
<li>由<code>runtime</code>运行时，动态创建的类,</li>
<li>该类实现为其<code>class对象</code>的子类，其内部实现了<code>class</code>、<code>delloc</code>、<code>_isKVOA</code>，以及重写了相关的<code>set</code>方法</li>
<li>通过<code>runtime</code>输出方法，示例代码如下</li>
</ul>
  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span>.person1 addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;height&quot;</span> options:options    context:<span class="hljs-string">@&quot;456&quot;</span>];<br> <span class="hljs-keyword">int</span> num;<br> <span class="hljs-comment">//=注意，这里如果用[self.person1 class]拿不到，被重写了，不会拿到实际的类</span><br>   Method * list = class_copyMethodList(object_getClass(<span class="hljs-keyword">self</span>.person1),     &amp;num);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; num;i++) &#123;<br>      Method method = list[i];<br>       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method)));<br>&#125;<br> free(list);<br> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 输出setHeight:、setAge:、class、dealloc、_isKVOA</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li>
<li><p>在调用<code>set</code>方法后实际调用了<code>_NSSetIntValueAndNotify();</code></p>
<ul>
<li>(整型所以是<code>int</code>，如果是<code>double</code>则是<code>_NSSetDoubleValueAndNotify()</code>)</li>
</ul>
</li>
<li><p><code>_NSSetIntValueAndNotify()</code>内，类似实现的伪代码如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSKVONotifying_MJPerson</span>中<br>- (<span class="hljs-keyword">void</span>)setAge:(<span class="hljs-keyword">int</span>)age &#123;<br>    _NSSetIntValueAndNotify()<br>&#125;<br><br><span class="hljs-keyword">void</span> _NSSetIntValueAndNotify() &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">&quot;age&quot;</span>]<br>    [<span class="hljs-keyword">super</span> setAge:age]<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">&quot;age&quot;</span>] <span class="hljs-comment">//里面调用监听器的方法</span><br>&#125;<br><br>- (<span class="hljs-keyword">void</span>) didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [observer observeValueForKeyPath:key ofObject: change: content:]<span class="hljs-comment">//通知观察者</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>，如果内存中有个<code>NSKVONotifying_xxx</code>类，则相应的<code>kvo</code>无法实现</p>
</li>
<li><p>通过<code>[self.person1 methodForSelector:@selector(setAge:)]</code>找到对应方法的实现。</p>
<ul>
<li>在<code>lldb</code>中根据内存，用<code>p (IMP)0x7ff800bde9cb</code>即可找到实际实现的方法<code>Foundation _NSSetIntValueAndNotify</code></li>
</ul>
</li>
<li><p>此外，被<code>kvo</code>的对象，其元类对象也是不同的。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><code>KVO</code>的本质是什么</p>
<ul>
<li>利用<code>RuntimeAPI</code>动态生成一个子类，并且让<code>instance</code>对象的<code>isa</code>指向这个全新的子类</li>
<li>当修改<code>instance</code>对象的属性时，会调用<code>Foundation</code>的<code>_NSSetxxxValueAndNotif</code>函数。内部实际调用:<ul>
<li><code>willchangValueForKey</code></li>
<li>父类原来的<code>setter</code></li>
<li><code>didChangeValueForKey</code><ul>
<li>其内部会触发监听器<code>Obserser</code>的监听方法<code>（observeValueForKeyPath:ofObject:change:）</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何触发<code>KVO</code></p>
<ul>
<li>设置方法时，自动触发</li>
<li>手动调用<code>willChangeForKey：</code>和<code>didChangeForKey：</code> </li>
</ul>
</li>
<li><p>直接修改成员变量会触发KVO么？</p>
<ul>
<li>不会触发<code>KVO</code>,除非手动调用<code>willChangeForKey：</code>和<code>didChangeForKey：</code> </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>objc_class的结构</title>
    <url>/2022/12/21/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/objc_class%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="objc-class的结构"><a href="#objc-class的结构" class="headerlink" title="objc_class的结构"></a>objc_class的结构</h1><p><img src="16715558479895.png"></p>
<ul>
<li>如何去查看<code>objc_class</code>的源码在真实项目中用，吧<code>objc_class</code>结构体，在函数类直接写出来，用桥接的方式实现</li>
<li>也可以加入<code>objc</code>源码，通过<code>lldb</code>进行调试<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MJClassInfo_h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MJClassInfo_h</span><br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> __arm64__</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">elif</span> __x86_64__</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __LP64__</span><br><span class="hljs-keyword">typedef</span> uint32_t mask_t;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> uint16_t mask_t;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">typedef</span> uintptr_t cache_key_t;<br><br><span class="hljs-keyword">struct</span> bucket_t &#123;<br>    cache_key_t _key;<br>    IMP _imp;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> cache_t &#123;<br>    bucket_t *_buckets;<br>    mask_t _mask;<br>    mask_t _occupied;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> entsize_list_tt &#123;<br>    uint32_t entsizeAndFlags;<br>    uint32_t count;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> method_t &#123;<br>    SEL name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types;<br>    IMP imp;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> method_list_t : entsize_list_tt &#123;<br>    method_t first;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> ivar_t &#123;<br>    int32_t *offset;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *type;<br>    uint32_t alignment_raw;<br>    uint32_t size;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> ivar_list_t : entsize_list_tt &#123;<br>    ivar_t first;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> property_t &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *attributes;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> property_list_t : entsize_list_tt &#123;<br>    property_t first;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> chained_property_list &#123;<br>    chained_property_list *next;<br>    uint32_t count;<br>    property_t list[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> uintptr_t protocol_ref_t;<br><span class="hljs-keyword">struct</span> protocol_list_t &#123;<br>    uintptr_t count;<br>    protocol_ref_t list[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-keyword">struct</span> class_ro_t &#123;<br>    uint32_t flags;<br>    uint32_t instanceStart;<br>    uint32_t instanceSize;  <span class="hljs-comment">// instance对象占用的内存空间</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    uint32_t reserved;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">const</span> uint8_t * ivarLayout;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name;  <span class="hljs-comment">// 类名</span><br>    method_list_t * baseMethodList;<br>    protocol_list_t * baseProtocols;<br>    <span class="hljs-keyword">const</span> ivar_list_t * ivars;  <span class="hljs-comment">// 成员变量列表</span><br>    <span class="hljs-keyword">const</span> uint8_t * weakIvarLayout;<br>    property_list_t *baseProperties;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> class_rw_t &#123;<br>    uint32_t flags;<br>    uint32_t version;<br>    <span class="hljs-keyword">const</span> class_ro_t *ro;<br>    method_list_t * methods;    <span class="hljs-comment">// 方法列表</span><br>    property_list_t *properties;    <span class="hljs-comment">// 属性列表</span><br>    <span class="hljs-keyword">const</span> protocol_list_t * protocols;  <span class="hljs-comment">// 协议列表</span><br>    Class firstSubclass;<br>    Class nextSiblingClass;<br>    <span class="hljs-keyword">char</span> *demangledName;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="hljs-keyword">struct</span> class_data_bits_t &#123;<br>    uintptr_t bits;<br>public:<br>    class_rw_t* data() &#123;<br>        <span class="hljs-keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/* OC对象 */</span><br><span class="hljs-keyword">struct</span> mj_objc_object &#123;<br>    <span class="hljs-keyword">void</span> *isa;<br>&#125;;<br><br><span class="hljs-comment">/* 类对象 */</span><br><span class="hljs-keyword">struct</span> mj_objc_class : mj_objc_object &#123;<br>    Class superclass;<br>    cache_t cache;<br>    class_data_bits_t bits;<br>public:<br>    class_rw_t* data() &#123;<br>        <span class="hljs-keyword">return</span> bits.data();<br>    &#125;<br>    <br>    mj_objc_class* metaClass() &#123;<br>        <span class="hljs-keyword">return</span> (mj_objc_class *)((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)isa &amp; ISA_MASK);<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* MJClassInfo_h */</span></span><br></code></pre></td></tr></table></figure></li>
<li>实际使用,即可查看相关类<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        MJStudent *stu = [[MJStudent alloc] init];<br>        stu-&gt;_weight = <span class="hljs-number">10</span>;<br>        <br>        mj_objc_class *studentClass = (__bridge mj_objc_class *)([MJStudent <span class="hljs-keyword">class</span>]);<br>        mj_objc_class *personClass = (__bridge mj_objc_class *)([MJPerson <span class="hljs-keyword">class</span>]);<br>        <br>        class_rw_t *studentClassData = studentClass-&gt;data();<br>        class_rw_t *personClassData = personClass-&gt;data();<br>        <br>        class_rw_t *studentMetaClassData = studentClass-&gt;metaClass()-&gt;data();<br>        class_rw_t *personMetaClassData = personClass-&gt;metaClass()-&gt;data();<br><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1111&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>isa指针简介</title>
    <url>/2022/12/19/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/isa%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h1 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h1><ul>
<li>从<code>64bit</code>开始，<code>isa</code>需要进行一次位运算，才能计算出真实地址,<code>isa &amp; ISA_MASK</code>即为实际的<code>isa</code>地址<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> __arm64__</span><br><span class="hljs-meta">#     <span class="hljs-meta-keyword">define</span> ISA_MASK   0x0000000ffffffff8ULL</span><br>elif __x86_64__<br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span><br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>获取方式  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">&lt;LGPerson: <span class="hljs-number">0x6000002321a0</span>&gt;<br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x6000002321a0</span><br><span class="hljs-number">0x6000002321a0</span>: <span class="hljs-number">0x011d800100008609</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000002321b0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br>p/x <span class="hljs-number">0x011d800100008609</span> &amp; <span class="hljs-number">0x00007ffffffffff8</span><br>(<span class="hljs-keyword">long</span>) $<span class="hljs-number">0</span> = <span class="hljs-number">0x0000000100008608</span><br>(lldb) po $<span class="hljs-number">0</span><br>LGPerson<br></code></pre></td></tr></table></figure></li>
<li><code>Class</code>中的<code>isa</code>指针没有暴露出来，可以通过构建一个相同的结构体，通过桥接得到<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_class &#123;<br>    Class isa;<br>    Class superclass;<br>&#125;;<br><span class="hljs-keyword">struct</span> objc_class *personClass = (__bridge <span class="hljs-keyword">struct</span> objc_class *)([Person <span class="hljs-keyword">class</span>]);<br></code></pre></td></tr></table></figure></li>
<li><code>superclass</code>直接指向父类，不需要转换</li>
<li><code>isa</code>是一个union体结构，主要是位了节省消耗，数据共享一片内存。也是通过<code>mask</code>来获取属性<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">union</span> isa_t &#123;<br>    isa_t() &#123; &#125;<br>    isa_t(uintptr_t value) : bits(value) &#123; &#125;<br>    uintptr_t bits;<br><br>    <span class="hljs-keyword">struct</span> &#123;<br>        uintptr_t nonpointer        : <span class="hljs-number">1</span>;                                       <br>        uintptr_t has_assoc         : <span class="hljs-number">1</span>;                                       <br>        uintptr_t has_cxx_dtor      : <span class="hljs-number">1</span>;                                       <br>        uintptr_t shiftcls          : <span class="hljs-number">33</span>; <span class="hljs-comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> <br>        uintptr_t magic             : <span class="hljs-number">6</span>;                                       <br>        uintptr_t weakly_referenced : <span class="hljs-number">1</span>;                                       <br>        uintptr_t unused            : <span class="hljs-number">1</span>;                                       <br>        uintptr_t has_sidetable_rc  : <span class="hljs-number">1</span>;                                       <br>        uintptr_t extra_rc          : <span class="hljs-number">19</span>;  <span class="hljs-comment">// defined in isa.h</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>OC对象的分类</title>
    <url>/2022/12/18/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h2 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h2><p>主要分为3种</p>
<ol>
<li><code>instance</code>对象，实例对象 </li>
<li><code>class</code>对象，类对象</li>
<li><code>meta-class</code>对象，元类对象</li>
</ol>
<h3 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h3><ul>
<li>通过类<code>alloc</code>出来的对象，<code>instance</code>对象在内存中存储的信息（只有成员变量）包括<ul>
<li><code>isa</code>指针</li>
<li>其他成员变量</li>
</ul>
</li>
<li><code>isa</code>指针始终在对象结构体的前面，因此，<code>isa</code>指针的地址即实例对象的地址</li>
</ul>
<h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><ul>
<li><code>[objec class]</code>、<code>[NSObject class]</code>、<code>object_getClass(object)</code>都是获取<code>NSobject</code>的<code>class</code>对象</li>
<li>它们都是同一个对象，在内存中有且只有一个<code>class</code>对象</li>
<li><code>class</code>对象在内存中存储的信息主要包括</li>
</ul>
<ol>
<li><code>isa</code>指针</li>
<li><code>superclass</code>指针</li>
<li>类的属性信息（<code>@property</code>）、类的对象方法信息（<code>instance method</code>）</li>
<li>类的协议信息（<code>protocol</code>）、类的成员变量信息（<code>ivar</code>）<ol>
<li><code>ivar</code>并非成员变量的值，成员变量的值由<code>instance</code>决定</li>
<li><code>ivar</code>实际存储的类型，名称等描述信息</li>
</ol>
</li>
</ol>
<h3 id="元类对象"><a href="#元类对象" class="headerlink" title="元类对象"></a>元类对象</h3><p><code>object_getClass([NSObject class])</code>获取元类对象，元类对象结构和类结构一样都是<code>class</code>,其结构相同，不过元类对象中除<code>isa</code>指针、<code>superclass</code>指针、<code>类方法信息</code>外，其他均为<code>null</code></p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="16713605118546.png"></p>
<ul>
<li>关系总结<ol>
<li><code>instance</code>的<code>isa</code>指向<code>class</code></li>
<li><code>class</code>的<code>isa</code>指向<code>meta-class</code></li>
<li><code>meta-class</code>的<code>isa</code>指向基类<code>meta-class</code><ul>
<li>基类<code>meta-class</code>的<code>isa</code>指向自己</li>
</ul>
</li>
<li><code>class</code>的<code>superclass</code>指向父类的<code>class</code><ol>
<li>如果没有父类，<code>superclass</code>指针为<code>nil</code></li>
</ol>
</li>
<li><code>meta-class</code>的<code>superclass</code>指向父类的<code>meta-class</code><ol>
<li>基类<code>meta-class</code>的<code>superclass</code>指向基类<code>class</code></li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul>
<li><a href="https://www.jianshu.com/p/fd914bef940d?from=timeline">iOS 类和元类的关系</a></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>NSObject</title>
    <url>/2022/12/17/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/NSObject/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一个NSObject对象占用多少内存？"><a href="#一个NSObject对象占用多少内存？" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个<code>NSObject</code>对象占用多少内存？</h3><h4 id="一个NSObject对象占用多少内存？-1"><a href="#一个NSObject对象占用多少内存？-1" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个<code>NSObject</code>对象占用多少内存？</h4><ul>
<li>系统分配了<code>16</code>个字节给<code>NSObject</code>对象（通过<code>malloc_size</code>函数获得）</li>
<li>但<code>NSObject</code>对象内部只使用了<code>8</code>个字节（<code>isa</code>指针）的空间（<code>64bit</code>环境下，可以通过<code>class_getInstanceSize</code>函数（经过内存对齐过的值）获得<ol>
<li>用<code>clang -rewrite-objc main.m -o main.cpp</code>编译成<code>C++</code>文件（全平台），</li>
<li><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code>(推荐)编译成指定平台的</li>
<li><code>16字节</code>而不是<code>8字节</code>的原因,源码中可以看到，是<code>Foundation</code>框架规定的，最小<code>16字节</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> _class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="hljs-keyword">void</span> *zone)<br>&#123;<br>    <span class="hljs-keyword">void</span> *bytes;<br>    size_t size;<br><br>    <span class="hljs-comment">// Can&#x27;t create something for nothing</span><br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><br>    <span class="hljs-comment">// Allocate and initialize</span><br>    size = cls-&gt;alignedInstanceSize() + extraBytes;<br><br>    <span class="hljs-comment">// CF requires all objects be at least 16 bytes.</span><br>    <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">16</span>) size = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-keyword">if</span> (zone) &#123;<br>        bytes = malloc_zone_calloc((malloc_zone_t *)zone, <span class="hljs-number">1</span>, size);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bytes = calloc(<span class="hljs-number">1</span>, size);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> objc_constructInstance(cls, bytes);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>扩展的例子<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> _no;<br>    <span class="hljs-keyword">int</span> _age;<br>    <span class="hljs-keyword">int</span> _height; <br> &#125; <br> <span class="hljs-keyword">@end</span><br> <br> <span class="hljs-comment">// 实际为</span><br><span class="hljs-keyword">struct</span> Student_IMPL &#123;<br>    Class isa; <span class="hljs-comment">//8字节，（注意NSObect会分配16字节，但是isa结构体是8字节）</span><br>    <span class="hljs-keyword">int</span> _no; <span class="hljs-comment">//4字节</span><br>    <span class="hljs-keyword">int</span> _age; <span class="hljs-comment">//4 字节</span><br>    <span class="hljs-keyword">int</span> _height; <span class="hljs-comment">// 4 字节</span><br>&#125;<br><span class="hljs-comment">// 内存对齐: 结构体的大小必须是最大成员大小的倍数,实际为24字节，但是用`malloc_size`计算分配是32</span><br></code></pre></td></tr></table></figure></li>
<li>注意，<code>ios</code>操作系统的内存对齐，是按<code>16</code>倍为来进行分配的， 例如<code>class_getInstanceSize</code>计算<strong>只需(至少)</strong><code>24</code>位大小，但是用<code>malloc_size</code>计算<strong>实际</strong>分配的确是<code>32</code>位 </li>
<li>注意，<code>sizeof</code>实际上是运算符，并不是函数，和以上两个函数有区别，在编译的时候，就会决定了，例如<code>sizeof(指针)</code>，在编译就设置为<code>8</code>，实际不知道内存中的大小</li>
</ul>
<h4 id="alloc-init的问题"><a href="#alloc-init的问题" class="headerlink" title="alloc/init的问题"></a><code>alloc</code>/<code>init</code>的问题</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Student *s = [Student alloc];<br>Student *s1 = [s init];<br>Student *s2 = [s init];<br><span class="hljs-comment">//最终s,s1和s2返回的地址均相同</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>alloc</code>最终会调用<code>_class_createInstanceFromZone</code>创建了堆对象，即实例对象</li>
<li>而调用<code>init</code>实际上底层什么也没做，源码如下：<ul>
<li>这是种设计主要是为了让继承它的子类可以重写该方法，在返回实例变量之前初始化子类的额外属性<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> _objc_rootInit(<span class="hljs-keyword">id</span> obj)<br>  &#123;<br>       <span class="hljs-keyword">return</span> obj;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="swift类和OC类，内存分配的区别"><a href="#swift类和OC类，内存分配的区别" class="headerlink" title="swift类和OC类，内存分配的区别"></a>swift类和OC类，内存分配的区别</h4><ul>
<li><code>OC类</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JBPerson</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">//有个基础的isa指针，8字节</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name1; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 4</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">int</span> age1; <span class="hljs-comment">//4</span><br><span class="hljs-keyword">@end</span><br><br>修改后<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JBPerson</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">//有个基础的isa指针，8字节</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name1; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 4</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">int</span> age1; <span class="hljs-comment">//4</span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure></li>
<li><code>swift类</code>  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">//基本16</span><br>    <span class="hljs-keyword">var</span> age1:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">var</span> age2:<span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//4</span><br>&#125;<br><br>修改后<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">//基本16</span><br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">var</span> age1:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">var</span> age2:<span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//4</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li>对比声明位置，对内存的影响分析  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 16 + 8 + 4 + 4,//8字节对齐</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">Person</span>.<span class="hljs-keyword">self</span>))  <span class="hljs-comment">// 32</span><br><span class="hljs-comment">// 8 + + 8 + 4 + 4,// 8字节对齐</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">JBPerson</span>.<span class="hljs-keyword">self</span>)) <span class="hljs-comment">// 32</span><br><br>修改后<br><span class="hljs-comment">// 16 + 4 + 8 + 4,//8字节对齐，其中age由于age1为8字节，对其占用8字节，age2同样对齐</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">Person</span>.<span class="hljs-keyword">self</span>))  <span class="hljs-comment">// 40</span><br><span class="hljs-comment">//没有变化，很显然OC中属性的声明，会对属性的内存进行优化，采用最佳的内存分布</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">JBPerson</span>.<span class="hljs-keyword">self</span>)) <span class="hljs-comment">// 32</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，如果<code>OC</code>中的直接声明实例子变量，则和swift中一样，受到顺序的影响，下面情况，内存为<code>40</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JBPerson</span> : <span class="hljs-title">NSObject</span></span>&#123;<br><span class="hljs-built_in">NSString</span> *name1;<br><span class="hljs-keyword">int</span> _age;<br><span class="hljs-built_in">NSString</span> *_name;<br><span class="hljs-keyword">int</span> age1;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>OC中属性的声明，会对属性的内存进行优化，采用最佳的内存分布，不会受声明顺序的影响</li>
<li>而OC中直接声明实例变量的方式，则和swift中一样，受到顺序的影响</li>
</ul>
</li>
</ul>
<h3 id="对象的isa指针指向哪里"><a href="#对象的isa指针指向哪里" class="headerlink" title="对象的isa指针指向哪里"></a>对象的<code>isa</code>指针指向哪里</h3><ul>
<li><code>instance</code>对象的<code>isa</code>指针指向类对象</li>
<li>类对象的<code>isa</code>指针指向元类对象</li>
<li>元类对象的<code>isa</code>指针指向基类的元类对象</li>
</ul>
<h3 id="OC的类信息存放在哪里"><a href="#OC的类信息存放在哪里" class="headerlink" title="OC的类信息存放在哪里"></a><code>OC</code>的类信息存放在哪里</h3><ul>
<li>对象的方法、属性、协议信息、成员变量，存放在类对象</li>
<li>类方法存放在元类对象</li>
<li>成员变量的具体值，存放在<code>instance</code></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>FishHook</title>
    <url>/2022/12/10/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/FishHook/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FishHook"><a href="#FishHook" class="headerlink" title="FishHook"></a>FishHook</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>iOS</code>中通过<code>Method Swizzling</code>实现<code>hook</code>，其原理是利用<code>OC</code>的<code>Runtime</code>特性，动态改变<code>SEL</code>（方法编号）和<code>IMP</code>（方法实现）的对应关系，达到<code>OC</code>方法交换的目的。然而只适用于动态的<code>OC</code>方法，对于<code>C</code>函数<code>Hook</code>，可以引用<code>fishHook</code>，通过修改<code>machO</code>文件中<code>la_symbol_ptr</code>和<code>non_la_symbol_ptr</code>两个表的指针达到<code>C</code>函数<code>HOOK</code>的目的。</p>
<h2 id="框架地址"><a href="#框架地址" class="headerlink" title="框架地址"></a>框架地址</h2><p><code>fishhook</code>是一个非常简单的库，可以在模拟器和设备上运行在<code>iOS</code>上的<code>Mach-O</code>二进制文件中动态重新绑定符号,<a href="https://github.com/facebook/fishhook">代码地址</a></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>头文件导入<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;fishhook.h&quot;</span></span><br></code></pre></td></tr></table></figure></li>
<li>交换制定的C函数,构建<code>rebinding</code>结构体<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> rebinding rebindSend;<br>rebindSend.name = <span class="hljs-string">&quot;NSLog&quot;</span>;<br>rebindSend.replacement = (<span class="hljs-keyword">void</span> *)hook_Objc_nslog;<br>rebindSend.replaced = (<span class="hljs-keyword">void</span> **)&amp;orig_objc_nslog;<br></code></pre></td></tr></table></figure></li>
<li><code>rebind_symbols</code>重新绑定符号<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> rebinding rebs[] = &#123;rebindSend&#125;;<br>rebind_symbols(rebs, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
<li>完整使用用例<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//</span><br><span class="hljs-comment">//  FishHooklViewController.m</span><br><span class="hljs-comment">//  transitionController</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Created by 陈晶泊 on 2022/8/10.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;fishhook.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;FishHooklViewController.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">FishHooklViewController</span> ()</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FishHooklViewController</span></span><br>__unused <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>(*orig_objc_nslog)(<span class="hljs-built_in">NSString</span> *format, ...);<br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-keyword">self</span>.view.backgroundColor = <span class="hljs-built_in">UIColor</span>.whiteColor;<br>    <span class="hljs-keyword">struct</span> rebinding rebindSend;<br>    rebindSend.name = <span class="hljs-string">&quot;NSLog&quot;</span>;<br>    rebindSend.replacement = (<span class="hljs-keyword">void</span> *)hook_Objc_nslog;<br>    rebindSend.replaced = (<span class="hljs-keyword">void</span> **)&amp;orig_objc_nslog;<br>    <span class="hljs-keyword">struct</span> rebinding rebs[] = &#123;rebindSend&#125;;<br>    rebind_symbols(rebs, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> hook_Objc_nslog(<span class="hljs-built_in">NSString</span> *format, ...) &#123;<br>    format = [format stringByAppendingFormat:<span class="hljs-string">@&quot;已hook&quot;</span>];<br>    orig_objc_nslog(format);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;FishHooklViewController&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><ul>
<li><code>MachO</code>文件的<code>静态链接</code>在编译的时候，就确定了方法地址，位于代码段，是不可写的，因此<code>静态链接</code>的<code>函数方法</code>，在<code>运行时</code>是<code>无法更改的</code>。</li>
<li>然而动态链接，是在运行时进行方法链接的，在<code>MachO</code>文件中，<ul>
<li>访问动态库里的数据符号地址放在<code>got</code>(也称<code>Non-Lazy Symbol Pointers</code>)<code>数据段</code>，</li>
<li>调用动态库的函数的地址放在<code>la_symbol_ptr</code>数据段的<code>数据段</code>中，是可读写的，</li>
</ul>
</li>
<li>因此可以在程序运行期间修改<code>got</code>(<code>non_la_symbol_ptr</code>)和<code>la_symbol_ptr</code>数据段，来替换<code>函数</code>跟<code>全局变量</code>的地址。</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-传入需要替换的函数"><a href="#1-传入需要替换的函数" class="headerlink" title="1. 传入需要替换的函数"></a>1. 传入需要替换的函数</h4><p><img src="16706577321150.png"></p>
<ul>
<li><code>rebindings_head</code>的<code>next</code>为<code>nil</code>是第一次调用；去注册方法，<ul>
<li>其中<code>_dyld_register_func_for_add_image</code>方法做了<code>2</code>件事，<ol>
<li>是跟<code>else</code>里面一样，为每个<code>image</code>(镜像)调用<code>_rebind_symbols_for_image</code>，</li>
<li>是当<code>dyld</code>后面加载镜像时候，也为这个新镜像调用<code>_rebind_symbols_for_image</code>。<br><code>rebindings_head</code>采用的链表结构，具体如下:<br><img src="16706578333010.jpg"></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="2-计算地址"><a href="#2-计算地址" class="headerlink" title="2. 计算地址"></a>2. 计算地址</h4><blockquote>
<ul>
<li><code>rebind_symbols_for_image</code>方法的目的，主要是计算<code>基址</code>，找到<code>符号表</code>、<code>字符串表</code>、<code>间接符号表</code>、<code>nl_symbol_ptr(got)</code>以及<code>la_symbol_ptr</code>数据段的地址。</li>
</ul>
</blockquote>
<ol>
<li>首先遍历加载命令，获得<code>MachO</code>文件中<code>符号表</code>、<code>间接符号表</code>、<code>LINKEDIT</code>三个加载命令<br><img src="16706583225213.png"></li>
<li>根据<code>LINKEDIT</code>获取的<code>真实基址</code>，根据第一步中得到的加载命令，确定<code>符号表</code>、<code>间接符号表</code>、<code>字符串表</code>的虚拟内存地址<br><img src="16706584145390.png"></li>
<li>遍历加载命令，找到<code>数据段</code>，再从<code>数据段</code>的<code>section</code>中找到<code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code></li>
</ol>
<p><img src="16706586123063.png"></p>
<h4 id="3-方法替换"><a href="#3-方法替换" class="headerlink" title="3. 方法替换"></a>3. 方法替换</h4><blockquote>
<p>最后遍历<code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code>可修改的变量和数据地址，并结合<code>间接符号表</code>、<code>符号表</code>、以及<code>字符串表</code>，得到地址对应的<code>函数</code>，<code>变量名称</code>，找到<code>相同的名称</code>，即可进行地址的替换。</p>
</blockquote>
<p><img src="16706587741784.png"></p>
<h2 id="通过MachOView分析"><a href="#通过MachOView分析" class="headerlink" title="通过MachOView分析"></a>通过MachOView分析</h2><ol>
<li>计算出<code>符号表</code>、<code>间接符号表</code>、<code>字符串表</code>的地址<br><img src="16706010476870.png"></li>
<li><code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code>可修改的变量和函数数据地址，其中<code>reserved1</code>即为<code>数据段</code>中的函数在<code>间接符号表</code>中的位置<br><img src="1.png"></li>
<li><code>间接符号表</code>中的地址，和实际数据段地址是对应的，其中<code>间接符号表</code>中的数据，实际对应的是<code>符号表</code>中的<code>索引</code>。</li>
</ol>
<p> <img src="2.png"></p>
<p><img src="16706604848859.png"><br>4. <code>符号表</code>中，关联由<code>字符串表</code>，从而知道<code>函</code>数的名称，因此，最终，根据名称，从间接符号表中拿到原始函数地址，从而完成了方法的替换。<br><img src="16706604848859.png"></p>
<h2 id="FishHook应用实例"><a href="#FishHook应用实例" class="headerlink" title="FishHook应用实例"></a>FishHook应用实例</h2><p><code>SMCallTrace</code>通过hook<code>objc_msgSend</code>方法，<code>hook</code>了所有<code>OC</code>的方法，在<code>hook</code>方法中通过汇编语言来计算方法的耗时，可以用来项目中方法的执行情况。在需要检测耗时时间的地方调用 <code>[SMCallTrace start]</code>，结束时调用 <code>stop</code> 和 <code>save</code> 就可以打印出方法的调用层级和耗时了。还可以设置最大深度和最小耗时检测，来过滤不需要看到的信息。<a href="https://github.com/ming1016/GCDFetchFeed">源码地址</a><br>具体使用后的效果<img src="4.jpeg"></p>
]]></content>
      <categories>
        <category>应用技巧</category>
      </categories>
      <tags>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>越狱练习</title>
    <url>/2022/12/04/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/%E8%B6%8A%E7%8B%B1%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="练习一-喜玛拉广告去除"><a href="#练习一-喜玛拉广告去除" class="headerlink" title="练习一 喜玛拉广告去除"></a>练习一 喜玛拉广告去除</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><code>Revel</code>中查看广告的图层信息，通过Cycript<code>[#0x12333 removeFromSuperlayer]</code>只能暂时将广告屏蔽</li>
<li>用<code>CLutch</code>脱壳应用，<code>class-dump</code>指令拿到头文件信息，查看相关视图图层的信息，通过hook的方式去去除广告</li>
</ol>
<h1 id="练习二，桌面更新数字去除"><a href="#练习二，桌面更新数字去除" class="headerlink" title="练习二，桌面更新数字去除"></a>练习二，桌面更新数字去除</h1><ul>
<li>iOS桌面为<code>springboard</code>，位置在<code>/System/Library/CoreServices/SpringBoard.app</code></li>
<li><code>springboard</code>无法通过<code>revel</code>的方式查看，需要用<code>cycript</code>的方式查看</li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>theos</tag>
      </tags>
  </entry>
  <entry>
    <title>theos</title>
    <url>/2022/12/03/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/theos/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h2 id="用theos去hook"><a href="#用theos去hook" class="headerlink" title="用theos去hook"></a>用theos去hook</h2><ol>
<li><a href="media/16676513774655/07-theos%E7%9A%84%E5%89%AF%E6%9C%AC.pdf">theos安装教程</a></li>
<li><code>nic.pl</code>指令选择创建<code>iphone/tweak</code>项目,（自己的<code>bundId</code>，和越狱<code>app</code>的<code>bundId</code>）<ol>
<li>在生成的<code>Makefile</code>文件内，增加端口信息<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> THEOS_DEVICE_IP = localhost<br><span class="hljs-keyword">export</span> THEOS_DEVICE_PORT = <span class="hljs-number">100010</span><br>include $(THEOS)/makefiles/common.mk<br>TWEAK_NAME = tingweak<br></code></pre></td></tr></table></figure>
<ul>
<li><code>THES_DEVICE_IP</code>,<code>THEOS_DEVICE_PORT</code>可以配置到<code>.bash_profile</code>的文件下,全局配置</li>
</ul>
</li>
<li>实际在<code>Tweak.x</code>文件内进行<code>hook</code>，找到相应的<code>view</code>，然后写<code>hook</code>后的方法.<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIView.h&gt;</span></span><br> %hook XMNowPlayingADView<br>   - (id)initWithFrame:(struct CGRect)arg1 &#123;<br>       <span class="hljs-keyword">return</span> nil;<br>   &#125;<br> %end<br> <span class="hljs-comment">///%orig(arg1,arg2);调用原始方法</span><br> <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>make</code> 自动编译<code>makefile</code>中的文件</li>
<li><code>make package</code>打包成越狱插件</li>
<li><code>make install</code>默认安装到手机上</li>
<li>手机重启，则会看到修改后的程序，注入的包位置在<code>/library/MobileSubstrate/DynamicLibraries</code>位置，删除，则无效果了（<code>Cydia</code>中也有该插件）</li>
</ol>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>在生成的<code>Tweak.x</code>文件中的方法，一般均会被认为是要<code>hook</code>替换的，如果没有的话，则不会生效。如果是新方法的话，需要在方法前加<code>%new</code></li>
<li><code>%orig</code>为原始方法</li>
<li>资源文件，<ol>
<li>内部图片，则放到<code>对应应用内</code>,</li>
<li>如果加载自己的，则用<code>imageWithContentsOfFile:</code>加载图片路径，例如，<code>/text.png</code>则在文件根目录</li>
<li>在<code>theos</code>中直接打包资源文件，在中，构建一个<code>layout</code>文件夹(实际放在<code>根目录</code>下)，将资源放进去，一般会放到<code>layout/Library/PreferenceLoader/Preferences</code>目录下（偏好设置），其他的可以放到<code>layout/Library/Caches</code>文件中</li>
</ol>
</li>
<li>注意<code>theos</code>将其他类型认为是<code>id</code>，因此直接用<code>self.view</code>是会报错的，要用<code>[self view]</code></li>
<li>可以像<code>OC</code>项目一样,多文件开发，建立相关的<code>.h</code>和<code>.m</code>文件，然后在<code>Tweak.x</code>文件中按正常的<code>#import</code>导入(注意文件夹)即可，此外在<code>Makefile</code>中要指定编译的文件<code>tweaksp_FILES = xxx/Tweak.x xxx/xxxx.m</code>，也可以通过<code>tweaksp_FILES = xxx/*.x</code>导入，但是无法用<code>xxx/**/*.x</code>的方式,必须指定文件夹</li>
<li>生成<code>Realease</code>版本，<code>make package debug=0</code></li>
</ol>
<h2 id="theos-tweak原理"><a href="#theos-tweak原理" class="headerlink" title="theos-tweak原理"></a>theos-tweak原理</h2><ol>
<li><code>make</code>指令实际上是将<code>Tweak.xm</code>的代码编译成<code>动态库</code></li>
<li><code>make packpage</code>指令，将动态库文件打包成了<code>deb</code>文件，插件安装包</li>
<li><code>make install</code>指令，远程登录手机安装插件到<code>app</code>内，<code>Makefile</code>文件内配置<ol>
<li>安装完的包会在<code>/Library/MobileSubstrate/DynamicLibraries</code>文件夹内,包含动态库，以及相关的<code>.plist</code>文件(里面由相关应用的<code>bundlId</code>)</li>
<li>该文件夹由<code>Cydia</code>管理</li>
</ol>
</li>
<li>对应<code>bundlId</code>的应用打开后，会加载相关插件的动态库到内存中（不会缓存，每次重新打开，都会加载），去做交换方法的操作</li>
<li>实际上没次动态修改，并为修改代码</li>
</ol>
<h3 id="过程图"><a href="#过程图" class="headerlink" title="过程图"></a>过程图</h3><p><img src="16703398332015.png"></p>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>theos</tag>
      </tags>
  </entry>
  <entry>
    <title>Cycript</title>
    <url>/2022/12/03/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/Cycript/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h2 id="Cycript"><a href="#Cycript" class="headerlink" title="Cycript"></a><code>Cycript</code></h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><ul>
<li><code>cycript</code></li>
<li><code>cycript -p 进程ID</code> （越狱环境下，可以获取相关<code>app</code>的<code>进程id/名称</code>）</li>
<li><code>cycript -p 进程名称</code></li>
</ul>
<h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><ul>
<li><code>UIApp</code><ul>
<li><code>[UIApplication sharedApplication]</code></li>
</ul>
</li>
<li>定义变量<ul>
<li><code>var 变量名 = 变量值</code></li>
</ul>
</li>
<li>用内存地址获取对象<ul>
<li><code>#内存地址</code></li>
</ul>
</li>
<li><code>ObjectiveC.classes</code><ul>
<li>已加载的所有<code>OC类</code></li>
</ul>
</li>
<li>查看对象的所有成员变量<ul>
<li><code>*对象</code></li>
</ul>
</li>
<li>获取所有子视图的东西(<code>Cycripty</code>,可以多语言混用)<ul>
<li><code>[UIApp.keyWindow recursiveDescription].toString()</code></li>
<li><code>UIApp.keyWindow .recursiveDescription().toString()</code></li>
</ul>
</li>
<li>筛选出当前内存下某种类型的对象<ul>
<li><code>choose(UIViewController)</code></li>
</ul>
</li>
</ul>
<h3 id="将文件做成库"><a href="#将文件做成库" class="headerlink" title="将文件做成库"></a>将文件做成库</h3><hr>
<ul>
<li>将<code>.cy</code>文件编译成库导入到<code>/usr/lib/cycript0.9</code>中</li>
<li>然后用<code>@import</code>导入，就可以用文件中的方法了</li>
<li>示例代码<code>text.cy</code>，直接用<code>sum（1,2</code>）后者用<code>text.minus(1,2)</code><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">exports</span></span>)</span>&#123;<br>	sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>) </span>&#123;<br>		<span class="hljs-keyword">return</span> a + b;<br>	&#125;;<br>	sum123 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>) </span>&#123;<br>	<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br>	[arr addObject:a];<br>	[arr addObject:b];<br>		<span class="hljs-keyword">return</span> arr;<br>	&#125;;<br>	<span class="hljs-built_in">exports</span>.minus = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>) </span>&#123;<br>		<span class="hljs-keyword">return</span> a - b;<br>	&#125;;<br>	<span class="hljs-built_in">exports</span>.name = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>) </span>&#123;<br>		<span class="hljs-keyword">return</span> a * b;<br>	&#125;;<br>	<span class="hljs-built_in">exports</span>.appId = [NSBundle mainBundle].bundleIdentifier;<br><br>	<span class="hljs-built_in">exports</span>.rootVc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>		<span class="hljs-keyword">return</span> UIApp.keyWindow.rootViewController;<br>	&#125;<br><br>	docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[<span class="hljs-number">0</span>];<br>&#125;)(<span class="hljs-built_in">exports</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>Cycript</tag>
      </tags>
  </entry>
  <entry>
    <title>theos</title>
    <url>/2022/12/02/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><ul>
<li>利用特殊的算法，对可执行文件的编码进行改变（比如压缩、加密），以达到保护程序代码的目的</li>
</ul>
<hr>
<ul>
<li><code>ldyd</code> -&gt; 加密后的可执行文件程序,<code>ldyd</code>是无法识别的</li>
<li>加密后的<code>可执行文件</code>，有<code>壳程序</code>包装，<code>壳程序</code>可以对其进行解密，解密完之后，才通过<code>ldyd</code>去执行<code>可执行文件</code><br><img src="16675757633856.png"></li>
</ul>
<h3 id="判断是否加密，"><a href="#判断是否加密，" class="headerlink" title="判断是否加密，"></a>判断是否加密，</h3><ol>
<li><code>cryptId</code>为<code>0</code>表示加密<ol>
<li><img src="16675783941612.png"></li>
</ol>
</li>
<li>用<code>otool -l macho文件 | grep crypt</code>去查询<code>macho</code>文件</li>
</ol>
<h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><ul>
<li>摘掉壳程序，将未加密的可执行文件还原出来（有些人也称为“砸壳”）</li>
</ul>
<hr>
<ul>
<li>脱壳主要有<code>2</code>种方法：硬脱壳、动态脱壳<br><img src="16675780924102.png"></li>
<li><code>iOS</code>脱壳工具<ul>
<li><a href="https://github.com/KJCracks/Clutch/releases">Clutch</a>,<a href="https://github.com/stefanesser/dumpdecrypted/%0D">dumpdecrypted</a>,<code>AppCrackr</code>、<code>Crackulous</code></li>
</ul>
</li>
</ul>
<h3 id="CLutch脱壳"><a href="#CLutch脱壳" class="headerlink" title="CLutch脱壳"></a><code>CLutch</code>脱壳</h3><ul>
<li>载越狱手机内使用,(放到<code>/usr/lib</code>内)<ol>
<li><code>Clutch -i</code>,获取所有加载的应用</li>
<li><code>Clutch -d id/序号（1中的）</code>,导出解密后的包</li>
</ol>
</li>
</ul>
<h3 id="dumpdecrypted脱壳"><a href="#dumpdecrypted脱壳" class="headerlink" title="dumpdecrypted脱壳"></a><code>dumpdecrypted</code>脱壳</h3><ul>
<li>下载完之后，要进行编译,将<code>.c</code>文件编译成动态库，在当前目录下用<code>make</code>可直接编译成动态库，<code>make</code>会编译<code>Makefile</code>中的相关指令</li>
<li>与<code>clutch</code>命令不一样，为动态库，将动态库放到手机<code>/var/root</code>(其他位置会出现权限不足的问题，<code>注意后的版本和IOS系统版本要对应</code>) </li>
<li>使用环境变量<code>DYLD_INSERT_LIBRARIES</code>将编译生成的<code>dylib</code>注入到需要脱壳的可执行文件（可执行文件路径可以通过ps -A查看获取）-<ul>
<li><code>DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib 可执行文件路径</code></li>
<li>生成的<code>.decrypte</code>可执行文件</li>
<li><code>__attribute_(...)</code>方法，在注入的时候，就去执行，然后会去脱壳</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>theos</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-o文件</title>
    <url>/2022/11/04/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/Mach-o%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h2 id="Mach-o文件"><a href="#Mach-o文件" class="headerlink" title="Mach-o文件"></a><code>Mach-o</code>文件</h2><ul>
<li>一个<code>Mach-O</code>文件包含<code>3</code>个主要区域<ul>
<li><code>Header</code> <ul>
<li>文件类型、目标架构类型等</li>
</ul>
</li>
<li><code>Load commands</code><ul>
<li>描述文件在虚拟内存中的逻辑结构、布局</li>
</ul>
</li>
<li><code>Raw segment data</code><ul>
<li>在<code>Load commands</code>中定义的<code>Segment</code>的原始数据<br><img src="16674865436160.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常见的Mach-o文件"><a href="#常见的Mach-o文件" class="headerlink" title="常见的Mach-o文件"></a>常见的<code>Mach-o</code>文件</h2><ol>
<li><code>MH_OBJECT</code><ul>
<li>目标文件（<code>.o</code>）</li>
<li>静态库文件(<code>.a</code>），静态库其实就是<code>N</code>个<code>.o</code>合并在一起</li>
</ul>
</li>
<li><code>MH_EXECUTE</code>：可执行文件<ul>
<li><code>.app/xx</code></li>
</ul>
</li>
<li><code>MH_DYLIB</code>：动态库文件<ul>
<li><code>.dylib</code></li>
<li><code>.framework/xx</code></li>
</ul>
</li>
<li><code>MH_DYLINKER</code>：动态链接编辑器<ul>
<li><code>/usr/lib/dyld</code></li>
</ul>
</li>
<li><code>MH_DSYM</code>：存储着二进制文件符号信息的文件<ul>
<li><code>.dSYM/Contents/Resources/DWARF/xx</code>（常用于分析<code>APP</code>的崩溃信息）</li>
</ul>
</li>
</ol>
<h2 id="ios系统Mach-o文件在手机上"><a href="#ios系统Mach-o文件在手机上" class="headerlink" title="ios系统Mach-o文件在手机上"></a><code>ios</code>系统<code>Mach-o</code>文件在手机上</h2><ul>
<li>从<code>iOS3.1</code>开始，为了提高性能，绝大部分的系统动态库文件都打包存放到了一个缓存文件中（<code>dyld shared cache</code>）<ol>
<li>缓存文件路径：<code>/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armX</code></li>
<li>绝大部分的系统动态库都放在共享缓存中，一个文件中，（多个动态库<code>mach</code>会有多个描述信息，为了降低内存，放到了一个文件中。也就是<code>mach</code>文件中<code>dlyld</code>(命令在<code>/usr/lib</code>中)加载指令(通过这个指令去加载动态库)，只会加载到一处）</li>
<li>用<code>[[NSBundle bundleWithPath:&quot;/System/Library/Frameworks/UIKit.framework&quot;] load]</code>去加载动态库，实际上是调用<code>2.</code>中<code>dlyld</code>去判断是否在缓存中，有则去<code>1.</code>位置处的共享缓存去加载<code>UIKit.framework</code></li>
<li><a href="https://opensource.apple.com/tarballs/dyld/">dyld源码 </a></li>
<li><code>dlyld</code>中的<code>dsc_extractor</code>文件可以，将1中缓存文件抽取出压缩在里面的库<ol>
<li>先用<code>clang++</code>编译,<code>clang++ -o dsc_extractor dsc_extractor.cpp</code></li>
<li><code>/dsc_extractor dyld_shared_cache_armv7s armv7s</code>所有动态库在呵rmv7s文件夹中</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Universal-Binary（胖二进制文件）"><a href="#Universal-Binary（胖二进制文件）" class="headerlink" title="Universal Binary（胖二进制文件）"></a><code>Universal Binary</code>（胖二进制文件）</h2><ul>
<li>通用二进制文件同时适用于多种架构的二进制文件包含了多种不同架构的独立的二进制文件</li>
<li>因为需要储存多种架构的代码，通用二进制文件通常比单一平台二进制的程序要大</li>
<li>由于两种架构有共同的一些资源，所以并不会达到单一版本的两倍之多<br>由于执行过程中，只调用一部分代码，运行起来也不需要额外的内存</li>
</ul>
<hr>
<ul>
<li><code>lipo -info 文件</code>，获取胖二进制文件支持架构信息</li>
<li><code>lipo 文件 -thin armv64 - output Text_arm64</code>，抽出其中的arm64二进制文件</li>
<li><code>lipo -create Text_arm64 Text_armv7 -output test</code>，生成出胖二进制文件</li>
</ul>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="file"><a href="#file" class="headerlink" title="file"></a><code>file</code></h3><ul>
<li>查看<code>Mach-O</code>的文件类型<ul>
<li><code>file  文件路径</code></li>
</ul>
</li>
</ul>
<h3 id="otool"><a href="#otool" class="headerlink" title="otool"></a><code>otool</code></h3><ul>
<li>查看<code>Mach-O</code>特定部分和段的内容<ul>
<li><code>otool -L 文件路径</code>查看依赖的库</li>
<li><code>otool -h 文件路径</code>: <code>mach</code>中<code>head</code>的信息</li>
<li><code>otool -l 文件路径</code>: <code>mach</code>中<code>loadcommand</code>的信息</li>
</ul>
</li>
</ul>
<h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a><code>dyld</code></h3><ul>
<li><code>dyld</code>是<code>mach-o</code>文件（<code>MH_DYLINKER</code>），但是它也能加载<code>mach-o</code>文件，但是只能加载<ul>
<li><code>MH_EXEUTE</code>，可执行文件</li>
<li><code>MH_DYLIB</code>,动态库</li>
<li><code>MH_BUNDLE</code></li>
</ul>
</li>
</ul>
<h3 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a><code>class-dump</code></h3><ul>
<li>它的作用就是把<code>Mach-O</code>文件的<code>class</code>信息给<code>dump</code>出来（把类信息给导出来），生成对应的<code>.h</code>头文件<ul>
<li>命令放到<code>/usr/local/bin</code>目录下(<code>mac</code>下不能放到<code>/usr/bin</code>下)</li>
<li><code>class-dump  -H  Mach-O文件路径  -o  头文件存放目录</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>Mach-o</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH常用指令</title>
    <url>/2022/10/29/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/SSH%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h1 id="SSH常用指令"><a href="#SSH常用指令" class="headerlink" title="SSH常用指令"></a>SSH常用指令</h1><ul>
<li><code>ssh root@192.168.1.14</code>,跳转到指定<code>ip</code>的命令</li>
<li><code>ssh-keygen -R 192.168.1.14</code>,删除<code>ip</code>保存的公钥</li>
</ul>
<h2 id="客户端认证密钥"><a href="#客户端认证密钥" class="headerlink" title="客户端认证密钥"></a>客户端认证密钥</h2><ol>
<li><code>ssh-keygen -t rsa</code>,生成公钥和私钥,认证密钥，下次不用输入密码<ul>
<li>公钥追加到服务器授权文件（<code>.ssh/authorized_keys</code>）的尾部，<code>ssh-copy-id root@192.168.1.14</code>，追加到当前<code>ip</code>服务器授权文件的尾部</li>
</ul>
</li>
<li><code>scp ~/.ssh/id_rsa.pub root@192.168.1.14:~/.ssh</code>，基于<code>SSH</code>登录进行安全的远程文件拷贝命令,将<code>id_rsa.pub</code>文件拷贝到<code>.ssh</code>文件下<ul>
<li><code>cat id_rsa.pub &gt;&gt; authorized_keys</code>,将<code>id_rsa.pub</code>内容加到<code>authorized_keys</code>中(同样可以实现认证密钥，不用输入密码)</li>
</ul>
</li>
</ol>
<h2 id="权限赋予"><a href="#权限赋予" class="headerlink" title="权限赋予"></a>权限赋予</h2><ul>
<li><code>chmod 755 ~/.ssh</code> 给文件夹赋予权限，<code>755</code>含义<ul>
<li>读（<code>r=4</code>），写（<code>w=2</code>），执行（<code>x=1</code>）</li>
<li>文件所有者可读可写可执行     –<code>7</code></li>
<li>与文件所有者同属一个用户组的其他用户可读可执行      –<code>5</code></li>
<li>其它用户组可读可执行   –<code>5</code></li>
</ul>
</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul>
<li>每个端口都有个端口号，（范围是<code>0～65535</code>，公<code>2^16</code>）</li>
<li><code>21</code>端口，<code>FTP</code>服务</li>
<li><code>80</code>端口，<code>http</code>服务</li>
<li><code>22</code>端口，<code>ssh</code>服务</li>
</ul>
<h2 id="通过USB进行SSH登录"><a href="#通过USB进行SSH登录" class="headerlink" title="通过USB进行SSH登录"></a>通过<code>USB</code>进行<code>SSH</code>登录</h2><ul>
<li>默认会用网络登录，<code>USB</code>登录的方式是，先用<code>SSH</code>登录<code>MAC</code>上的<code>10010</code>端口(非保留端口均可)，在通过<code>usbmuxd</code>连接<code>22</code>端口</li>
<li>将<code>iPhone</code>的<code>22</code>端口（<code>SSH</code>端口）映射到Mac本地的<code>10010</code>端口</li>
<li>用<code>python</code>脚本，将<code>mac</code>上<code>10010</code>映射到<code>22</code>，<code>python3 tcprelay.py -t 22:10010</code></li>
<li><code>ssh root@localhost -p 10010</code>,直接连接本地的<code>10010</code>接口</li>
<li><code>scp -P 10010 ~/.ssh/id_rsa.pub root@localhost:~</code>,拷贝的方法</li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
  </entry>
  <entry>
    <title>flutter指令</title>
    <url>/2022/09/11/Flutter/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Flutter-常用指令"><a href="#Flutter-常用指令" class="headerlink" title="Flutter 常用指令"></a>Flutter 常用指令</h4><ul>
<li>flutter run –no-sound-null-safety  解决flutter插件旧版本兼容问题</li>
<li>flutter create –template=package hello 创建pakcage</li>
<li>flutter create -t module flutter_module 创建fluttermodule</li>
<li>flutter create example 创建flutter项目<h4 id="Flutter包发布指令"><a href="#Flutter包发布指令" class="headerlink" title="Flutter包发布指令"></a>Flutter包发布指令</h4></li>
<li>flutter packages pub publish –dry-run 检查发布前需要准备什么</li>
<li>flutter packages pub publish 直接发布，需要外网，还有授权（注意不要设置代理使用国内镜像）<h4 id="flutter插件"><a href="#flutter插件" class="headerlink" title="flutter插件"></a>flutter插件</h4></li>
<li>flutter create –org com.flutter_plugine –template=plugin –platforms=ios,macos -i swift flutter_plugin  插件新建</li>
</ul>
<h3 id="创建flutter"><a href="#创建flutter" class="headerlink" title="创建flutter"></a>创建flutter</h3><ol>
<li>集成SDK<ul>
<li><a href="https://flutter.cn/docs/get-started/install/macos#get-sdk">Flutter地址</a></li>
</ul>
</li>
<li>创建<code>flutter</code>项目<ul>
<li><code>flutter create -i swift -a java --org com.flutter. test_flutter</code></li>
</ul>
</li>
<li>运行<code>flutter</code>项目<ul>
<li><code>flutter run</code><h3 id="创建packages"><a href="#创建packages" class="headerlink" title="创建packages"></a>创建packages</h3><blockquote>
<ol>
<li>纯flutter的<code>Dart package</code></li>
<li>原生插件<code>Plugin packages</code></li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="Dart-package"><a href="#Dart-package" class="headerlink" title="Dart package"></a><code>Dart package</code></h4><ul>
<li><code>flutter create --template=package hello</code></li>
<li><code>flutter pub publish --dry-run</code><ul>
<li>发布检查包是否合法</li>
</ul>
</li>
</ul>
<h4 id="原生-plugin"><a href="#原生-plugin" class="headerlink" title="原生 plugin"></a><code>原生 plugin</code></h4><ul>
<li><code>flutter create --org com.example --template=plugin --platforms=android,ios -a kotlin -i swift hello</code></li>
<li>创建目录结构如下</li>
</ul>
]]></content>
      <categories>
        <category>flutter指令</category>
      </categories>
  </entry>
  <entry>
    <title>flutter和iOS交互</title>
    <url>/2022/09/11/Flutter/%E6%8C%87%E4%BB%A4/flutter%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="flutter的创建"><a href="#flutter的创建" class="headerlink" title="flutter的创建"></a>flutter的创建</h3><ol>
<li>集成SDK<ul>
<li><a href="https://flutter.cn/docs/get-started/install/macos#get-sdk">Flutter地址</a></li>
</ul>
</li>
<li>创建<code>flutter</code>项目<ul>
<li><code>flutter create -i swift -a java --org com.flutter. test_flutter</code></li>
</ul>
</li>
<li>运行<code>flutter</code>项目<ul>
<li><code>flutter run</code><h3 id="创建packages"><a href="#创建packages" class="headerlink" title="创建packages"></a>创建packages</h3><blockquote>
<ol>
<li>纯flutter的<code>Dart package</code></li>
<li>原生插件<code>Plugin packages</code></li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="Dart-package"><a href="#Dart-package" class="headerlink" title="Dart package"></a><code>Dart package</code></h4><ul>
<li><code>flutter create --template=package hello</code></li>
<li><code>flutter pub publish --dry-run</code><ul>
<li>发布检查包是否合法</li>
</ul>
</li>
</ul>
<h4 id="原生-plugin"><a href="#原生-plugin" class="headerlink" title="原生 plugin"></a><code>原生 plugin</code></h4><ul>
<li><code>flutter create --org com.example --template=plugin --platforms=android,ios -a kotlin -i swift hello</code></li>
<li>创建插件目录结构如下<ul>
<li><code>TestPlugin</code>是原生的插件代码，在这里实现原生代码</li>
<li><code>lib</code>文件下的是，<code>flutter</code>项目调用插件功能的相关接口，以及和原生交互的<code>channel</code><br><img src="1.png"></li>
</ul>
</li>
<li>创建插件时，会顺带生成一个示例的<code>flutter</code>项目，其中的iOS文件夹内<code>GeneratedPluginRegistrant</code>,将插件注册的<code>AppDelegate</code>中<br><img src="2.png"></li>
</ul>
<h3 id="在iOS项目中集合flutter项目"><a href="#在iOS项目中集合flutter项目" class="headerlink" title="在iOS项目中集合flutter项目"></a>在iOS项目中集合flutter项目</h3><blockquote>
<p>创建<code>plugin</code>的方式，是在以<code>flutter</code>为主的项目中使用的，这里介绍下，在原生为主的项目中，如何嵌入<code>flutter</code></p>
</blockquote>
<ol>
<li>创建<code>Flutter-Flutter module</code><ul>
<li><code>flutter create --template module test_module</code></li>
</ul>
</li>
<li>将创建的<code>module</code>加入iOS工程中，并在<code>Podfile</code>文件中加入以下代码，然后<code>pod install</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">flutter_application_path = &#x27;../my_flutter&#x27;<br>load File.join(flutter_application_path, &#x27;.ios&#x27;, &#x27;Flutter&#x27;, &#x27;podhelper.rb&#x27;)<br>target &#x27;MyApp&#x27; do<br>     install_all_flutter_pods(flutter_application_path)<br>end<br><br>post_install do |installer|<br>    flutter_post_install(installer) if defined?(flutter_post_install)<br>end<br></code></pre></td></tr></table></figure></li>
<li>热重载调试Flutter<ol>
<li>项目中需要配置网络权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;key&gt;NSBonjourServices&lt;/key&gt;<br>&lt;array&gt;<br>&lt;string&gt;_dartobservatory._tcp&lt;/string&gt;<br> &lt;/array&gt;<br> &lt;key&gt;NSLocalNetworkUsageDescription&lt;/key&gt;<br>&lt;string&gt;需要访问本地网络权限&lt;/string&gt;<br></code></pre></td></tr></table></figure></li>
<li>运行<code>iOS</code>项目</li>
<li>在flutter项目中，输入指令<code>flutter attach</code>,即可,<ul>
<li><code>r</code>为热重载，<code>R</code>为热启动，<code>q</code>退出调试</li>
</ul>
</li>
</ol>
</li>
<li>创建<code>FlutterViewController</code><ol>
<li><code>Flutter</code>设置路由的代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">MaterialApp(<br>    routes: &#123;<br>      &quot;/one_page&quot;: ((context) =&gt; const AnimationHomePage()),<br>      &quot;/two_page&quot;: ((context) =&gt;<br>          const MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;))<br>    &#125;,<br>    title: &#x27;Flutter Demo&#x27;,<br>    theme: ThemeData(<br>      primarySwatch: Colors.blue,<br>    ),<br>    home: _widgetForRoute(window.defaultRouteName));<br></code></pre></td></tr></table></figure></li>
<li>每次都会生成一新的<code>flutterEngine</code>,很占内存<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let flutterVc = FlutterViewController(project: nil, initialRoute: &quot;/two_page&quot;, nibName: nil, bundle: nil)<br>self.navigationController?.pushViewController(flutterVc, animated: true)<br></code></pre></td></tr></table></figure></li>
<li>设置一个全局变量<code>flutterEngine</code>，每次根据<code>flutter</code>的路由运行不同的结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">static let flutterVC =  &#123;<br>    let engine =  FlutterEngine(name: &quot;my flutter engine&quot;)<br>    engine.run(withEntrypoint: nil, initialRoute: &quot;/two_page&quot;)<br>    let vc = FlutterViewController(engine: engine, nibName: nil, bundle: nil)<br>    return vc<br>&#125;()<br><br>Self.flutterVC.pushRoute(&quot;/two_page&quot;)<br>navigationController?.pushViewController(Self.flutterVC, animated: true)<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="flutter和原生的交互"><a href="#flutter和原生的交互" class="headerlink" title="flutter和原生的交互"></a>flutter和原生的交互</h3><blockquote>
<p>Flutter定义了三种不同的Channel</p>
<ul>
<li><code>MethodChannel</code>：传递方法调用，一次通讯</li>
<li><code>BasicMessageChannel</code>：持续通讯，</li>
<li><code>EventChannel</code>：数据流，仅原生到flutter传递数据,<code>flutter</code>端，可以控制、暂停、取消</li>
</ul>
</blockquote>
<h4 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a><code>MethodChannel</code></h4><ul>
<li><code>flutter</code>代码  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">final channel = const MethodChannel(&#x27;methodChannel&#x27;);<br><br>//监听消息<br>channel.setMethodCallHandler((call) &#123;<br>  switch (call.method) &#123;<br>    case &quot;nativeInvoke&quot;:<br>      setState(() &#123;<br>        _message = &#x27;MethodChannel :$&#123;call.arguments as String&#125;&#x27;;<br>      &#125;);<br>      break;<br>    default:<br>  &#125;<br>  return Future((() =&gt; &#x27;MethodCall消息&#x27;));<br>&#125;);<br><br>//下发消息<br>channel.invokeMethod(&#x27;toRoot&#x27;).then((value) =&gt; print(&quot;收到原生结果的回调,$value&quot;))<br></code></pre></td></tr></table></figure></li>
<li><code>原生</code>代码，注意这里的消息通道是<code>flutterVC</code>的<code>binaryMessenger</code>即<code>/two_page</code>，也就是最后，在Flutter中创建的<code>MethodChannel</code>,也要在<code>/two_page</code>的<code>Widget</code>生成，<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"> Self.flutterVC.pushRoute(&quot;/two_page&quot;)<br>let channel = FlutterMethodChannel(name: &quot;methodChannel&quot;, binaryMessenger: Self.flutterVC.binaryMessenger)<br>channel.invokeMethod(&quot;nativeInvoke&quot;, arguments: &quot;来自native的methodChannel---\(Self.time)&quot;)<br>channel.setMethodCallHandler &#123;[weak self] call, result in<br>    switch call.method &#123;<br>    case &quot;toRoot&quot;:self?.navigationController?.popToRootViewController(animated: true)<br>    default:break<br>     &#125;<br> &#125;<br>navigationController?.pushViewController(Self.flutterVC, animated: true)<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="BasicMessageChannel"><a href="#BasicMessageChannel" class="headerlink" title="BasicMessageChannel"></a><code>BasicMessageChannel</code></h4><ul>
<li><code>flutter</code>代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">final _messageChannel =<br>  const BasicMessageChannel(&quot;basicMessageChannel&quot;, StandardMessageCodec());<br>  <br>_methodChanel.invokeMethod(&quot;toRoot&quot;)<br><br> _messageChannel.setMessageHandler((message) &#123;<br>  print(&#x27;收到来自iOS的$message&#x27;);<br>  return Future((() =&gt; &#x27;messageChannel&#x27;));<br>&#125;);<br></code></pre></td></tr></table></figure></li>
<li>原生代码  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let  messageChannel = FlutterBasicMessageChannel(name: &quot;basicMessageChannel&quot;, binaryMessenger: Self.flutterVC.binaryMessenger)<br>messageChannel.sendMessage(&quot;methodChannelTwo&quot;) &#123; result in<br>        print(&quot;原生：methodChannelTwo---\(String(describing: result))&quot;)<br>    &#125;<br>messageChannel.setMessageHandler &#123; data, reply in<br>        print(&quot;收到了Flutter的数据\(String(describing: data))&quot;)<br>        reply(&quot;收到了&quot;)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a><code>EventChannel</code></h3></li>
<li><code>flutter</code>代码  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">final _evenChannel = const EventChannel(&quot;eventChannel&quot;);<br>StreamSubscription? _streamSubscription;<br><br>_streamSubscription =<br>    _evenChannel.receiveBroadcastStream([&quot;abc&quot;, 123, &quot;dasw&quot;]).listen(<br>  (event) &#123;<br>    print(&quot;evenChannel$event&quot;);<br>  &#125;,<br>  onDone: () &#123;&#125;,<br>);<br><br><br>//取消监听<br>_streamSubscription?.cancel();<br></code></pre></td></tr></table></figure></li>
<li>原生代码  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let eventChannel = FlutterEventChannel(name: &quot;eventChannel&quot;, binaryMessenger: Self.flutterVC.binaryMessenger)<br>eventChannel.setStreamHandler(self)<br>  <br>  //MARK: FlutterStreamHandler<br>func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -&gt; FlutterError? &#123;<br>    print(&quot;onListen收到了Flutter的数据\(String(describing: arguments))&quot;)<br>    timer = Observable&lt;Int&gt;.timer(.seconds(0),period: .seconds(1), scheduler: MainScheduler.instance).subscribe &#123; num in<br>        events(num)<br>    &#125;<br>    timer?.disposed(by: bag)<br>    return nil<br>&#125;<br><br>func onCancel(withArguments arguments: Any?) -&gt; FlutterError? &#123;<br>    print(&quot;onCancel收到了Flutter的数据\(String(describing: arguments))&quot;)<br>    timer?.dispose()<br>    return nil<br>&#125;  <br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="flutter嵌入原生的view"><a href="#flutter嵌入原生的view" class="headerlink" title="flutter嵌入原生的view"></a>flutter嵌入原生的view</h3><ol>
<li><p>自定义的视图view</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">class TestView:NSObject,FlutterPlatformView &#123;<br>        lazy var nameLabel: UILabel = &#123;<br>            let label = UILabel()<br>            label.font = .systemFont(ofSize: 15)<br>            label.textColor = .white<br>            label.backgroundColor = .red<br>            label.textAlignment = .center<br>            return label<br>          &#125;()<br>        <br>        func view() -&gt; UIView &#123;<br>            return nameLabel<br>        &#125;<br>        <br>        init(_ frame: CGRect,viewID: Int64,args :Any?,messenger:FlutterBinaryMessenger) &#123;<br>            super.init()<br>            if let map = args as? [String:String],<br>               let text = map[&quot;text&quot;] &#123;<br>                nameLabel.text = text<br>            &#125;<br>            methodChannel(messenger: messenger)<br>        &#125;<br>        <br>        private func methodChannel(messenger:FlutterBinaryMessenger)&#123;<br>            let  messageChannel = FlutterBasicMessageChannel(name: &quot;TestViewMessageChannel&quot;, binaryMessenger: messenger)<br>            messageChannel.setMessageHandler &#123;[weak self] data, reply in<br>                if let text = data as? String &#123;<br>                    self?.nameLabel.text = text<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    class TestViewFactory:NSObject, FlutterPlatformViewFactory &#123;<br>        <br>     <br>      var messenger: FlutterBinaryMessenger<br>      init(messenger:FlutterBinaryMessenger) &#123;<br>         self.messenger = messenger<br>         super.init()<br>       &#125;<br>        <br>       <br>       func createArgsCodec() -&gt; FlutterMessageCodec &amp; NSObjectProtocol &#123;<br>         return FlutterStandardMessageCodec.sharedInstance()<br>       &#125;<br>      <br>      func create(withFrame frame: CGRect, viewIdentifier viewId: Int64, arguments args: Any?) -&gt; FlutterPlatformView &#123;<br>            return TestView(frame, viewID: viewId, args: args,messenger: messenger)<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在iOS中注册该view,只执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">static let register: () = &#123;<br>        GeneratedPluginRegistrant.register(with: TextFlutterViewController.flutterVC)<br>        <br>        if let registrar = TextFlutterViewController.flutterVC.registrar(forPlugin: &quot;custom_platform_view_plugin&quot;) &#123;<br>            let factory = TestViewFactory(messenger: registrar.messenger())<br>            registrar.register(factory, withId: &quot;custom_platform_view&quot;)<br>        &#125;<br>&#125;()<br></code></pre></td></tr></table></figure></li>
<li><p><code>flutter</code>中使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">UiKitView(<br>    viewType: &#x27;custom_platform_view&#x27;,<br>    creationParams: &#123;&#x27;text&#x27;: &#x27;Flutter传给IOSTextView的参数&#x27;&#125;,<br>    creationParamsCodec: StandardMessageCodec(),<br>);<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>flutter和原生交互</category>
      </categories>
  </entry>
  <entry>
    <title>详解iOS的presentViewController</title>
    <url>/2021/07/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E8%AF%A6%E8%A7%A3iOS%E7%9A%84presentViewController/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS中显示ViewController的方式有两种push和modal，modal也叫模态，模态显示VC是iOS的重要特性之一，其主要用于有以下场景：</p>
<ol>
<li>收集用户输入信息 </li>
<li> 临时呈现一些内容 </li>
<li>临时改变工作模式 </li>
<li>相应设备方向变化（用于针对不同方向分别是想两个ViewController的情况）</li>
<li> 显示一个新的view层级</li>
</ol>
<p>这些场景都会暂时中断APP的正常执行流程，主要作用是收集信息以及显示一些重要的提示等。当VCA模态的弹出了VCB，那么VCA就是<code>presenting view controller</code>，VCB就是<code>presented view controller</code></p>
</blockquote>
<h3 id="ModalPresentationStyle-amp-Presentation-Context"><a href="#ModalPresentationStyle-amp-Presentation-Context" class="headerlink" title="ModalPresentationStyle &amp; Presentation Context"></a>ModalPresentationStyle &amp; Presentation Context</h3><h4 id="ModalPresentationStyle"><a href="#ModalPresentationStyle" class="headerlink" title="ModalPresentationStyle"></a>ModalPresentationStyle</h4><p>​        <code>presented VC </code>的<code>modalPresentationStyle</code>属性决定了此次<code>presentation</code>的行为方式及UIKit寻找<code>presentation context</code>的方法，iOS提供了以下几种常用的<code>presentation style</code></p>
<ol>
<li><p><strong>UIModalPresentationFullScreen</strong></p>
<p>UIKit默认的<code>presentation style</code>。 使用这种模式时，<code>presented VC</code>的宽高与屏幕相同，并且UIKit会直接使用<code>rootViewController</code>做为<code>presentation context</code>，在此次presentation完成之后，UIKit会将<code>presentation context及其子VC</code>都移出UI栈，这时候观察VC的层级关系，会发现UIWindow下只有<code>presented VC</code>（视图层级下UIWindow上只有presented VC）.</p>
</li>
<li><p><strong>UIModalPresentationCurrentContext</strong></p>
<p>使用这种方式<code>present VC</code>时，<code>presented VC</code>的宽高取决于<code>presentation context</code>的宽高，并且UIKit会寻找属性<code>definesPresentationContext</code>为YES的VC作为<code>presentation context</code> 。当此次<code>presentation</code>完成之后，<code>presentation context</code>及其子VC都将被暂时移出当前的UI栈。</p>
</li>
<li><p><strong>UIModalPresentationCustom</strong></p>
<p>自定义模式，需要实现UIViewControllerTransitioningDelegate的相关方法，并将presented VC的transitioningDelegate 设置为实现了UIViewControllerTransitioningDelegate协议的对象。</p>
</li>
<li><p><strong>UIModalPresentationOverFullScreen</strong></p>
<p>与<code>UIModalPresentationFullScreen</code>的唯一<strong>区别</strong>在于，UIWindow下除了<code>presented VC</code>，还有其他正常的VC层级关系。也就是说该模式下，UIKit以<code>rootViewController</code>为<code>presentation context</code>，但presentation完成之后不会将<code>rootViewController移出当前的UI栈</code>。</p>
</li>
<li><p><strong>UIModalPresentationOverCurrentContext</strong></p>
<p>寻找<code>presentation context</code>的方式与<code>UIModalPresentationCurrentContext</code>相同，所不同的是<code>presentation</code>完成之后，不会将<code>context及其子VC移出当前UI栈</code>。但是，这种方式只<strong>适用于transition style为UIModalTransitionStyleCoverVertical的情况</strong>(UIKit默认就是这种transition style)。其他transition style下使用这种方式将会触发异常。</p>
</li>
<li><p><strong>UIModalPresentationBlurOverFullScreen</strong></p>
<p><code>presentation</code>完成之后，如果<code>presented VC</code>的背景有透明部分，会看到presented VC下面的VC会变得模糊，其他与<code>UIModalPresentationOverFullScreen</code>模式没有区别。</p>
</li>
<li><p><strong>UIModalPresentationPageSheet</strong></p>
<p>在常规型设备（大屏手机，例如plus系列以及iPad系列）的水平方向，<code>presented VC</code>的高为当前屏幕的高度，宽为该设备竖直方向屏幕的宽度，其余部分用透明背景做填充。对于紧凑型设备（小屏手机）的水平方向及所有设备的竖直方向，其显示效果与<code>UIModalPresentationFullScreen</code>相同。</p>
</li>
<li><p><strong>UIModalPresentationFormSheet</strong></p>
<p>在常规型设备的水平方向，<code>presented VC</code>的宽高均小于屏幕尺寸，其余部分用透明背景填充。对于紧凑型设备的水平方向及所有设备的竖直方向，其显示效果与<code>UIModalPresentationFullScreen</code>相同</p>
</li>
</ol>
<p><code>UIModalPresentationFullScreen</code>、<code>UIModalPresentationCurrentContext</code>在转场完成后会将<code>context及其子VC移出当前UI栈</code>,因此转场结束后是无法看到presenting的视图的，而其他情况下的style是可以看到的</p>
<h4 id="presentation-context"><a href="#presentation-context" class="headerlink" title="presentation context"></a>presentation context</h4><blockquote>
<p><code>presentation context</code>是指为本次<code>present</code>提供上下文环境的类，需要指出的是，<code>presenting VC</code>通常并不是<code>presentation context</code></p>
</blockquote>
<p>​        当我们需要<code>present VC</code>的时候，除非我们指定了<code>context</code>，否则UIKit会优先选择<code>presenting VC</code>所属的容器类做为<code>presentation context</code>，如果没有容器类，那么会选择<code>rootViewController</code>。但是，UIKit搜索context的方式还与<code>presented VC</code>的<code>modalPresentationStyle</code>属性有关，当<code>modalPresentationStyle</code>为<code>UIModalPresentationFullScreen</code>、<code>UIModalPresentationOverFullScreen</code>等模式时，UIKit会直接选择<code>rootViewController</code>做为<code>context</code>。当<code>modalPresentationStyle</code>为<code>UIModalPresentationOverCurrentContext</code>、<code>UIModalPresentationCurrentContext</code>模式时，UIKit搜索<code>context</code>的方式如下：</p>
<ul>
<li><p><code>UIModalPresentationOverCurrentContext</code>、<code>UIModalPresentationCurrentContext</code>模式下，一个VC能否成为<code>presentation context</code> 是由VC的<code>definesPresentationContext</code>属性决定的，这是一个<code>BOOL</code>值，默认<code>UIViewController的definesPresentationContext</code>属性值是<code>NO</code>，而<strong>container view controller</strong>（容器控制器）的<code>definesPresentationContext</code>默认值是<code>YES</code>，这也是上文中，UIKit总是将<code>container view controller</code>做为<code>presentation context</code>的原因。如果我们想指定<code>presenting VC</code>做为<code>context</code>，只需要在<code>presenting VC</code>的<code>viewDidLoad</code>方法里添加如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">self.definesPresentationContext = YES<br></code></pre></td></tr></table></figure></li>
</ul>
<p>UIKit搜索<code>presentation context</code>的顺序为： </p>
<ol>
<li><code>presenting VC</code> </li>
<li><code>presenting VC</code> 的<code>父VC </code></li>
<li><code>presenting VC</code> 所属的<code>container VC </code></li>
<li><code>rootViewController</code></li>
</ol>
<h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><blockquote>
<p><strong>presented VC 总是与 presentation context 处于同一层级，而与presenting VC所在的层级无关，且同一个presentation context同时只能有一个presented VC。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>协议注意的点</title>
    <url>/2021/07/10/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="已重写的限制条件会在某些泛型上下文中失效"><a href="#已重写的限制条件会在某些泛型上下文中失效" class="headerlink" title="已重写的限制条件会在某些泛型上下文中失效"></a>已重写的限制条件会在某些泛型上下文中失效</h2><p>对于一些通过条件遵循获得了特定行为的类型，在某些泛型上下文中，并不能够确保能够使用协议限制中的特定实现。为了说明这个行为，下面的例子中定义了两个协议以及一个有条件地遵循两个协议的泛型类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Loggable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span>()</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Loggable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TitledLoggable</span>: <span class="hljs-title">Loggable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> logTitle: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TitledLoggable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-keyword">Self</span>.logTitle)</span>: <span class="hljs-subst">\(<span class="hljs-keyword">self</span>)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt;: <span class="hljs-title">CustomStringConvertible</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> first: <span class="hljs-type">T</span><br>    <span class="hljs-keyword">let</span> second: <span class="hljs-type">T</span><br>    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(<span class="hljs-subst">\(first)</span>, <span class="hljs-subst">\(second)</span>)&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Pair</span>: <span class="hljs-title">Loggable</span> <span class="hljs-title">where</span> <span class="hljs-title">T</span>: <span class="hljs-title">Loggable</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Pair</span>: <span class="hljs-title">TitledLoggable</span> <span class="hljs-title">where</span> <span class="hljs-title">T</span>: <span class="hljs-title">TitledLoggable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> logTitle: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pair of &#x27;<span class="hljs-subst">\(T.logTitle)</span>&#x27;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">String</span>: <span class="hljs-title">TitledLoggable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> logTitle: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;String&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当其泛型类型遵循<code>Loggable</code> 协议以及 <code>TitleLoggale</code> 协议时，结构体 <code>Pair</code> 遵循 <code>Loggable</code> 协议以及 <code>TitleLoggale</code> 协议。下面的例子中，<code>oneAndTwo</code> 是 <code>Pair&lt;String&gt; </code>的一个实例。因为 <code>String</code> 遵循 <code>TitleLoggable</code>，因此 <code>oneAndTwo</code> 也遵循此协议。当 <code>log()</code> 方法被 <code>oneAndTwo</code> 直接调用时，此方法使用的是包含标题的特定版本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> oneAndTwo <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;Pair of &#x27;String&#x27;: (one, two)&quot;</span><br></code></pre></td></tr></table></figure>
<p>虽然如此，当<code>oneAndTwo</code> 在泛型上下文中使用，或者它是 <code>Loggable/TitledLoggable</code> 类型的实例时，包含标题的特定版本 <code>log()</code> 方法不会被使用。</p>
<ol>
<li>会根据该协议查找方法，如果实现了(即<code>Pair</code>中重新实现了<code>log()</code>方法)，则直接用<code>Pair</code>中实现了的，否则<strong>Swift 只会根据这样的规则来选择 log() 的实现版本—— <code>Pair 遵循 Loggable 所需要的最少的限制条件</code>。因此 <code>Loggable</code> 所提供的默认实现版本会被使用</strong>。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> oneAndTwo:<span class="hljs-type">Loggable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;(one, two)&quot;</span><br><span class="hljs-keyword">let</span> oneAndTwo:<span class="hljs-type">TitledLoggable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;(one, two)&quot;</span><br></code></pre></td></tr></table></figure></li>
<li>如果<code>Loggable</code>协议中没有定义<code>func log()</code>方法，则会走各自协议默认的<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> oneAndTwo:<span class="hljs-type">Loggable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;(one, two)&quot;</span><br><span class="hljs-keyword">let</span> oneAndTwo:<span class="hljs-type">TitledLoggable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;Pair of &#x27;String&#x27;: (one, two)&quot;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="协议的动态派发"><a href="#协议的动态派发" class="headerlink" title="协议的动态派发"></a>协议的动态派发</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Chef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeFood</span>()</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Chef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeFood</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;makeFood&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeafoodChef</span>: <span class="hljs-title">Chef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeFood</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Cook Seafood&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> chefone:<span class="hljs-type">Chef</span> <span class="hljs-operator">=</span> <span class="hljs-type">SeafoodChef</span>()<br><span class="hljs-keyword">let</span> cheftwo:<span class="hljs-type">SeafoodChef</span> <span class="hljs-operator">=</span>  <span class="hljs-type">SeafoodChef</span>()<br>chefone.makeFood() <span class="hljs-comment">//Cook Seafood</span><br>cheftwo.makeFood() <span class="hljs-comment">//Cook Seafood</span><br></code></pre></td></tr></table></figure>
<ul>
<li>上述的结果均为<code>Cook Seafood</code>，因为<code>SeafoodChef</code>实现了该方法，协议中是动态派发(<code>SeafoodChef</code>继承了该协议，会生成<code>wintess table</code>，会去<code>wintess table</code>中查找到类)、扩展中是静态派发，如果是协议的方法会根据对象的<code>实际类型</code>进行调用</li>
<li>如果将协议中的<code>makeFood()</code>方法去掉，则会打印<code>makeFood / Cook Seafood</code>,如果没有协议方法，则会根据<code>声明类型</code>进行调用。</li>
<li>如果将<code>SeafoodChef</code>中实现的方法取消，则会打印<code>makeFood / makeFood</code>,走静态派发</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>碰到的一些问题</title>
    <url>/2021/07/10/iOS%E5%AD%A6%E4%B9%A0/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="场景图片的问题"><a href="#场景图片的问题" class="headerlink" title="场景图片的问题"></a>场景图片的问题</h3><ol>
<li>从相册中导出全场景图片存在的问题<ul>
<li>压缩图片的质量</li>
</ul>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[[PHCachingImageManager defaultManager]<br>        requestImageDataForAsset:mAsset<br>                         options:<span class="hljs-literal">nil</span><br>                   resultHandler:^(<span class="hljs-built_in">NSData</span> *_Nullable imageData, <span class="hljs-built_in">NSString</span> *_Nullable dataUTI, <span class="hljs-built_in">UIImageOrientation</span> orientation, <span class="hljs-built_in">NSDictionary</span> *_Nullable info) &#123;<br>                     <span class="hljs-built_in">UIImage</span> *resultImage = [<span class="hljs-built_in">UIImage</span> imageWithData:imageData];<br>                     <span class="hljs-comment">//获得的image要转换为正确的方向</span><br>                    <span class="hljs-comment">// 然后将该image导入到本地文件中</span><br>                     <span class="hljs-comment">//注意要用jpg的形式导入本地，否则，图片文件的大小会激增，有4M多变成90Mb（原因未知）</span><br>                      <span class="hljs-built_in">BOOL</span> result = [<span class="hljs-built_in">UIImageJPEGRepresentation</span>(image, <span class="hljs-number">0.5</span>) writeToFile:filePath atomically:<span class="hljs-literal">YES</span>];<br>                     <span class="hljs-comment">//采用png的形式保存场景图片，会出现存储图片内存激增</span><br>                     <span class="hljs-built_in">BOOL</span> result = [<span class="hljs-built_in">UIImagePNGRepresentation</span>(image) writeToFile:filePath atomically:<span class="hljs-literal">YES</span>];<br>                   &#125;];<br></code></pre></td></tr></table></figure>

<p>​        2. 全场景图片一般为十几万✖️几千的分辨率，上述压缩的方式可以使全场景图片在iphone6plus上显示，没有卡顿现象，但是这样的图片在iphone6上仍有有明显的卡顿，</p>
<h3 id="单例block引用导致内存泄漏的问题"><a href="#单例block引用导致内存泄漏的问题" class="headerlink" title="单例block引用导致内存泄漏的问题"></a>单例block引用导致内存泄漏的问题</h3><ol>
<li>注意如果block为单例的属性，那么在该block中要注意内存泄露的问题，因为单例会一直无法释放，会一直持有属性，而属性会一直持有block中的对象，那么就会导致block中捕获的对象，造成对象无法释放</li>
<li>如果是方法中的block，那么方法在执行完毕之后，便会释放block，不会一直持有，不用担心内存泄露的问题</li>
</ol>
]]></content>
      <categories>
        <category>零碎知识点</category>
      </categories>
  </entry>
  <entry>
    <title>iOS视图控制器转场详解</title>
    <url>/2021/07/02/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/iOS%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BD%AC%E5%9C%BA%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>视图控制器中的视图显示在屏幕上有两种方式：</p>
<ol>
<li>最主要的方式是内嵌在容器控制器中，比如<code>UINavigationController</code>（<code>push</code>或<code>pop</code>一个<code>viewController</code>），<code>UITabBarController</code>（切换到其他<code>viewController</code>）, <code>UISplitController</code>；</li>
<li>由另一个视图控制器显示它，也就是模态(<code>Modal</code>)显示(以Model方式显示另一个<code>viewController</code>)</li>
</ol>
<p>在 <code>storyboard</code> 里，每个<code>View Controller</code>是一个<code> Scene</code>，<code>View Controller Transition </code>便是从一个 <code>Scene</code> 转换到另外一个 <code>Scene</code>。</p>
<p>在<code>iOS7</code>之前，只能使用系统提供的转场效果，<code>iOS7</code>之后开放相关<code>API</code>运行对转场效果进行定制</p>
</blockquote>
<span id="more"></span>

<h1 id="Transition-解释"><a href="#Transition-解释" class="headerlink" title="Transition 解释"></a>Transition 解释</h1><p>转场时视图控制器和其对应的视图在结构上的变化：</p>
<p><img src="1.png" alt="1.png"></p>
<ul>
<li>转场过程中，作为容器的父 <code>VC</code> 维护着多个子 <code>VC</code>，但在视图结构上，只保留一个子 <code>VC</code> 的视图，所以转场的本质是下一场景(子 <code>VC</code>)的视图替换当前场景(子 <code>VC</code>)的视图以及相应的控制器(子 <code>VC</code>)的替换，表现为当前视图消失和下一视图出现。</li>
</ul>
<h1 id="系统自带的方式"><a href="#系统自带的方式" class="headerlink" title="系统自带的方式"></a>系统自带的方式</h1><h2 id="CATransition"><a href="#CATransition" class="headerlink" title="CATransition"></a>CATransition</h2><p><code>CATransition</code>是<code>CAAnimation</code>的子类，用于过渡动画或转场动画。为视图层移入移除屏幕提供转场动画。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">CATransition</span> *animation = [<span class="hljs-built_in">CATransition</span> animation];<br>animation.type = type;<br>animation.subtype = kCATransitionFromRight;<br>animation.duration = <span class="hljs-number">1.0</span>;<br>[vc.view.window.layer addAnimation:animation forKey:kCATransition];<br></code></pre></td></tr></table></figure>

<ul>
<li><code>type</code>：转场动画的类型。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">fade=<span class="hljs-number">1</span>,                   <span class="hljs-comment">//淡入淡出</span><br>  pageCurl,                 <span class="hljs-comment">//翻页</span><br>  push,                     <span class="hljs-comment">//推挤</span><br>  pageUnCurl,               <span class="hljs-comment">//反翻页</span><br>  reveal,                   <span class="hljs-comment">//揭开</span><br>  cameraIrisHollowOpen,     <span class="hljs-comment">//开镜头</span><br>  moveIn,                   <span class="hljs-comment">//覆盖</span><br>  cameraIrisHolowClose,     <span class="hljs-comment">//关镜头</span><br>  cube,                     <span class="hljs-comment">//立方体</span><br>  suckEffect,               <span class="hljs-comment">//吮吸</span><br>  oglFlip,                  <span class="hljs-comment">//翻转</span><br>  rippleEffect,             <span class="hljs-comment">//波纹</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>subtype</code>：动画类型的方向，<code>4</code>个方向上下左右</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">kCATransitionFromRight,<br>kCATransitionFromLeft,<br>kCATransitionFromTop,<br>kCATransitionFromBottom<br></code></pre></td></tr></table></figure>

<h2 id="TransitionFromViewController"><a href="#TransitionFromViewController" class="headerlink" title="TransitionFromViewController"></a>TransitionFromViewController</h2><ul>
<li>同一页面显示多个视图的方式，采用<code>UIViewController</code>自带的方法：<code>transitionFromViewController:toViewController:duration:options:animations:completion:</code>这种转场动画是在当一个父视图控制器中有几个<code>childViewController</code>，当要在这个几个子视图控制器之间切换时可以用这个方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//1. 在一个控制器内加入多个子控制器</span><br>[<span class="hljs-keyword">self</span> addChildViewCOntroller:fristVc];<br>[<span class="hljs-keyword">self</span> addChildViewCOntroller:secondVc];<br><span class="hljs-comment">//2. 当前控制器显示的视图</span><br>[<span class="hljs-keyword">self</span>.view addSubview:[<span class="hljs-keyword">self</span>.childViewControllers[<span class="hljs-number">0</span>] view]];<br><span class="hljs-comment">//3. 多视图的转换</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">     *  fromViewController      当前显示在父视图控制器中的子视图控制器</span><br><span class="hljs-comment">     *  toViewController        将要显示的姿势图控制器</span><br><span class="hljs-comment">     *  duration                动画时间(这个属性,old friend 了 O(∩_∩)O)</span><br><span class="hljs-comment">     *  options                 动画效果(渐变,从下往上等等,具体查看API)</span><br><span class="hljs-comment">     *  animations              转换过程中的动画</span><br><span class="hljs-comment">     *  completion              转换完成</span><br><span class="hljs-comment">*/</span><br>[<span class="hljs-keyword">self</span> transitionFromViewController:<span class="hljs-keyword">self</span>.childViewControllers[<span class="hljs-number">0</span>] toViewController:<span class="hljs-keyword">self</span>.childViewControllers[<span class="hljs-number">1</span>] duration:<span class="hljs-number">0.5</span> options:<span class="hljs-built_in">UIViewAnimationOptionTransitionCurlUp</span> animations:^&#123;<br>        <br> &#125; completion:^(<span class="hljs-built_in">BOOL</span> finished) &#123;<br>        <br>&#125;];<br></code></pre></td></tr></table></figure>

<h2 id="Transition-Animation（自定义转场动画的实现）"><a href="#Transition-Animation（自定义转场动画的实现）" class="headerlink" title="Transition Animation（自定义转场动画的实现）"></a>Transition Animation（自定义转场动画的实现）</h2><p>官方支持以下几种方式的自定义转场：</p>
<ol>
<li><code>UINavigationController</code> 中<code> push</code> 和 <code>pop</code></li>
<li><code> UITabBarController</code> 中切换 <code>Tab</code></li>
<li><code>Modal</code>转场：<code>presentation</code> 和 <code>dismissal</code>，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code> 这两种模式;</li>
<li><code>UICollectionViewController</code> 的布局转场：<code>UICollectionViewController </code>与 <code>UINavigationController </code>结合的转场方式</li>
</ol>
<p>转场协议由<code>5</code>种协议组成，实际中只需要提供其中的两个或者三个便能实现绝大部分的转场动画</p>
<h3 id="转场代理（Transition-Delegate）"><a href="#转场代理（Transition-Delegate）" class="headerlink" title="转场代理（Transition Delegate）"></a>转场代理（<strong>Transition Delegate</strong>）</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">&lt;<span class="hljs-built_in">UINavigationControllerDelegate</span>&gt; <span class="hljs-comment">//UINavigationController 的 delegate 属性遵守该协议。</span><br>&lt;<span class="hljs-built_in">UITabBarControllerDelegate</span>&gt; <span class="hljs-comment">//UITabBarController 的 delegate 属性遵守该协议。</span><br>&lt;<span class="hljs-built_in">UIViewControllerTransitioningDelegate</span>&gt; <span class="hljs-comment">//UIViewController 的 transitioningDelegate 属性遵守该协议。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>转场发生时，<code>UIKit </code>将要求转场代理将提供转场动画的核心构件：动画控制器和交互控制器(可选的)；由我们实现。</li>
</ul>
<h3 id="动画控制器-Animation-Controller-："><a href="#动画控制器-Animation-Controller-：" class="headerlink" title="动画控制器(Animation Controller)："></a>动画控制器(Animation Controller)：</h3><ul>
<li>最重要的部分，负责添加视图以及执行动画；遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议。</li>
</ul>
<h3 id="交互控制器-Interaction-Controller-："><a href="#交互控制器-Interaction-Controller-：" class="headerlink" title="交互控制器(Interaction Controller)："></a>交互控制器(Interaction Controller)：</h3><p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议；系统已经打包好现成的类供我们使用。</p>
<h3 id="转场环境-Transition-Context"><a href="#转场环境-Transition-Context" class="headerlink" title="转场环境(Transition Context):"></a>转场环境(Transition Context):</h3><p>提供转场中需要的数据；遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议；由 <code>UIKit </code>在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</p>
<h3 id="转场协调器-Transition-Coordinator-："><a href="#转场协调器-Transition-Coordinator-：" class="headerlink" title="转场协调器(Transition Coordinator)："></a>转场协调器(Transition Coordinator)：</h3><p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<code>&lt;UIViewCOntrollerTrabsitionCoordinator&gt;</code>协议；由<code> UIKit</code> 在转场时生成，<code>UIViewController</code> 在 iOS 7 中新增了方法<code> transitionCoordinator()</code>返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</p>
<h1 id="阶段一：非交互转场"><a href="#阶段一：非交互转场" class="headerlink" title="阶段一：非交互转场"></a>阶段一：非交互转场</h1><blockquote>
<p>这个阶段要做两件事，提供转场代理并由代理提供动画控制器。在转场代理协议里动画控制器和交互控制器都是可选实现的，没有实现或者返回 nil 的话则使用默认的转场效果。动画控制器是表现转场效果的核心部分</p>
</blockquote>
<h2 id="动画控制器协议"><a href="#动画控制器协议" class="headerlink" title="动画控制器协议"></a>动画控制器协议</h2><ol>
<li>动画控制器实现代理<code>&lt;UIViewControllerAnimatedTransitioning&gt;</code></li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">-(<span class="hljs-keyword">void</span>)animateTransition:(<span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123; <br>  <span class="hljs-comment">//1. </span><br>  <span class="hljs-built_in">UIView</span> *container = [transitionContext containerView];<br>  <br>  <span class="hljs-comment">//2. </span><br> <span class="hljs-keyword">if</span> ([transitionContext respondsToSelector:<span class="hljs-keyword">@selector</span>(viewForKey:)]) &#123;<br>        <span class="hljs-comment">// iOS8以上新增加API获取参与转场的视图，能精确获取参与转场的视图</span><br>        fromView = [transitionContext viewForKey:<span class="hljs-built_in">UITransitionContextFromViewKey</span>];<br>        toView = [transitionContext viewForKey:<span class="hljs-built_in">UITransitionContextToViewKey</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>   		<span class="hljs-comment">//获取参与转场的控制器视图</span><br>        fromView = [transitionContext viewControllerForKey:<span class="hljs-built_in">UITransitionContextFromViewControllerKey</span>].view;<br>        toView = [transitionContext viewControllerForKey:<span class="hljs-built_in">UITransitionContextToViewControllerKey</span>].view;<br>    &#125;<br>  <br>  <span class="hljs-comment">//3. </span><br>  [container addSubview:toView];<br>  ......<br>  [<span class="hljs-built_in">UIView</span> animateWithDuration:[<span class="hljs-keyword">self</span> transitionDuration:transitionContext] 					animations:^&#123;<br>  				  ......<br>        &#125; completion:^(<span class="hljs-built_in">BOOL</span> finished) &#123;<br>    <span class="hljs-comment">//4. </span><br>   					<span class="hljs-built_in">BOOL</span> isCancelled = [transitionContext transitionWasCancelled];<br>            [transitionContext completeTransition:!isCancelled];<br>        &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>返回容器视图，也就是转场动画发生的地方</li>
<li>通过<code>viewForKey:</code>获取的视图是<code>viewControllerForKey:</code>返回的控制器的根视图，或者<code> nil</code>。<code>viewForKey:</code>方法返回<code> nil</code> 只有一种情况：<code> UIModalPresentationCustom</code>以及 <code> UIModalPresentationOverFullScreen</code>等模式下的<code> Modal</code> 转场 （这些转场结束后不会移除<code>preserting</code>），通过此方法获取 <code>presentingView </code>时得到的将是 <code>nil</code>。</li>
<li>将<code>toView</code>添加到容器视图中，使得<code>toView</code>在屏幕上显示（<code>Modal</code>转场中此点稍有不同）</li>
<li>正确地结束转场过程。转场的结果有两种：完成或取消。非交互转场的结果只有完成一种情况，不过交互式转场需要考虑取消的情况。如何结束取决于转场的进度，通过<code>transitionWasCancelled</code>方法来获取转场的状态，使用<code>completeTransition:</code>来完成或取消转场</li>
</ol>
<ul>
<li><p>转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的场景的视图为<code> fromView</code>，对应的视图控制器为<code> fromVC</code>，即将出现的视图为 <code>toView</code>，对应的视图控制器称之为<code> toVC</code>。几种转场方式的转场操作都是可逆的，一种操作里的<code> fromView</code> 和 <code>toView</code> 在逆向操作里的角色互换成对方，<code>fromVC</code> 和<code>toVC</code>也是如此。在动画控制器里，参与转场的视图只有 <code>fromView </code>和<code> toView</code> 之分，与转场方式无关。</p>
</li>
<li><p>实际上无论是简单的转场动画，还是那些很复杂的转场动画在转场的部分要做的事情都是上面提到的<code>4</code>个过程，它们的区别主要在于动画的部分。</p>
</li>
</ul>
<h3 id="逐帧播放的动画方式"><a href="#逐帧播放的动画方式" class="headerlink" title="逐帧播放的动画方式"></a>逐帧播放的动画方式</h3><blockquote>
<p>与原来的动画相比能在动画里面，在通过帧率逐帧的实现</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-built_in">UIView</span> animateKeyframesWithDuration:<span class="hljs-keyword">self</span>.duration delay:<span class="hljs-number">0</span> options:<span class="hljs-number">0</span> animations:^&#123;<br>            [<span class="hljs-built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="hljs-number">0</span> relativeDuration:<span class="hljs-number">0.9</span> animations:^&#123;<br>                ......<br>            &#125;];<br>            [<span class="hljs-built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="hljs-number">0.9</span> relativeDuration:<span class="hljs-number">0.1</span> animations:^&#123;<br>                ......<br>            &#125;];<br>        &#125; completion:^(<span class="hljs-built_in">BOOL</span> finished) &#123;<br>            [imageView removeFromSuperview];<br>            <span class="hljs-built_in">BOOL</span> wasCancelled = [transitionContext transitionWasCancelled];<br>            [transitionContext completeTransition:!wasCancelled];<br>        &#125;];<br></code></pre></td></tr></table></figure>

<h2 id="特殊的Modal转场"><a href="#特殊的Modal转场" class="headerlink" title="特殊的Modal转场"></a>特殊的Modal转场</h2><blockquote>
<p><code>Modal</code> 转场中需要做的事情和两种容器 <code>V</code>C 的转场一样，但在细节上有些差异。</p>
</blockquote>
<p><img src="2.png" alt="2.png"></p>
<ol>
<li><p>根视图是否参与转场</p>
<ul>
<li><code>UINavigationController </code>和<code>UITabBarController</code>这两个容器 <code>VC</code> 的根视图在屏幕上是不可见的(或者说是透明的)，可见的只是内嵌在这两者中的<code>子 VC </code>中的视图，转场是从<code>子 VC </code>的视图转换到另外一个<code>子 VC </code>的视图，其根视图并未参与转场；而<code>Modal</code>转场，以 <code>presentation </code>为例，是从 <code>presentingView </code>转换到 <code>presentedView</code>，根视图 <code>presentingView </code>也就是<code>fromView</code>参与了转场。而且 <code>NavigationController</code> 和 <code>TabBarController</code> 转场中的<code> containerView</code> 也并非这两者的根视图。</li>
</ul>
</li>
<li><p>转场后的<code>fromView</code>是否依然可见</p>
<ul>
<li><code>Modal </code>转场结束后 <code>presentingView </code>可能依然可见，除<code>UIModalPresentationFullScreen</code>之外，其他模式就是这样。这种不同导致了 <code>Modal </code>转场和<code>容器 VC</code> 的转场对 <code>fromView</code> 的处理差异：<code>容器 VC</code> 的转场结束后 <code>fromView </code>会被主动移出视图结构，这是可预见的结果，我们也可以在转场结束前手动移除；而<code>Modal</code> 转场中，<code>presentation</code> 结束后 <code>presentingView(fromView) </code>并未主动被从视图结构中移除。准确来说，是 <code>UIModalPresentationCustom </code>这种模式下的 <code>Modal</code> 转场结束时<code>fromView</code>并未从视图结构中移除；<code>UIModalPresentationFullScreen </code>模式的<code> Modal</code> 转场结束后<code>fromView</code>依然主动被从视图结构中移除了。这种差异导致在处理<code> dismissal</code> 转场的时候很容易出现问题，没有意识到这个不同点的话出错时就会毫无头绪。</li>
</ul>
</li>
</ol>
<ul>
<li><p>下面来看看 <code>dismissal</code> 转场时的场景：</p>
<ol>
<li><code>UIModalPresentationFullScreen </code>模式：:转场时 <code>containerView </code>并不管理 <code>presentingView</code> ，<code>presentation</code> 后，<code>presentingView </code>被主动移出视图结构，在 <code>dismissal</code> 中<code> presentingView</code> 是 <code>toView</code> 的角色，其将会重新加入<code>containerView</code>中，实际上，我们不主动将其加入，<code>UIKit </code>也会这么做，前面的两种容器控制器的转场里不是这样处理的，不过这个差异基本没什么影响。</li>
<li><code>UIModalPresentationCustom 模式</code>:转场时 <code>containerView </code>并不担任 <code>presentingView</code> 的父视图，后者由 <code>UIKit</code> 另行管理。在 <code>presentation</code> 后，<code>fromView(presentingView) </code>未被移出视图结构，在 <code>dismissal </code>中，注意不要像其他转场中那样将 <code>toView(presentingView)</code> 加入 <code>containerView </code>中，否则本来可见的<code> presentingView</code> 将会被移除出自身所处的视图结构消失不见<ul>
<li>这里注意：如果采用<code>viewForKey</code>直接获取视图，那么<code>custon模式</code>下，**present时，<code>fromView（presentingView）为nil</code>，而<code>dimissal</code>时，<code>toView（presentingView）为nil</code>**，也就是用这种方式获取的视图，添加到containerView中，<code>dismissal</code>不会出问题。但是如果通过<code>viewControllerForKey</code>直接获取控制器中的<code>View</code>则不会为<code>nil</code>，这时候添加则会出现问题</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="实现代理"><a href="#实现代理" class="headerlink" title="实现代理"></a>实现代理</h2><ol>
<li><code>UINavigationController</code>转场动画的实现，实现代理 <code>&lt;UINavigationControllerDelegate&gt;</code></li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//self.navigationController.delegate = self;</span><br><br>-(<span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span>&gt;)navigationController:(<span class="hljs-built_in">UINavigationController</span> *)navigationController animationControllerForOperation:(<span class="hljs-built_in">UINavigationControllerOperation</span>)operation fromViewController:(<span class="hljs-built_in">UIViewController</span> *)fromVC toViewController:(<span class="hljs-built_in">UIViewController</span> *)toVC &#123; <br>  ....<br>    <span class="hljs-comment">//返回自定义的动画控制器，push和pop都在这个方法中返回</span><br>  <span class="hljs-keyword">switch</span> (operation) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UINavigationControllerOperationPush</span>:<br>            animationController.type = AnimationTypePush;<br>            <span class="hljs-keyword">return</span>  animationController;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UINavigationControllerOperationPop</span>:<br>            animationController.type = AnimationTypePop;<br>            <span class="hljs-keyword">return</span> animationController;<br>        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><code>presenting</code>出的视图</li>
</ol>
<h1 id="阶段二：交互式转场"><a href="#阶段二：交互式转场" class="headerlink" title="阶段二：交互式转场"></a>阶段二：交互式转场</h1><blockquote>
<p>实现交互化，在非交互转场的基础上将之交互化需要两个条件：</p>
</blockquote>
<ol>
<li>由转场代理提供交互控制器，这是一个遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。</li>
<li>交互控制器还需要交互手段的配合，最常见的是使用手势</li>
</ol>
<ul>
<li>正确的提供交互控制器:<ul>
<li>转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程（比如手势），转场过程将一直处于开始阶段无法结束，应用界面也会失去响应：在<code>NavigationController </code>中点击 <code>NavigationBar </code>也能实现 <code>pop </code>返回操作，但此时没有了交互手段的支持，转场过程卡壳；在 <code>TabBarController </code>的代理里提供交互控制器存在同样的问题，点击 <code>TabBar</code> 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。、</li>
</ul>
</li>
</ul>
<h2 id="UINavigationControllerDelegaate的交互转场"><a href="#UINavigationControllerDelegaate的交互转场" class="headerlink" title="UINavigationControllerDelegaate的交互转场"></a>UINavigationControllerDelegaate的交互转场</h2><ol>
<li>实现代理方法</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span> &lt;<span class="hljs-built_in">UIViewControllerInteractiveTransitioning</span>&gt;)navigationController:(<span class="hljs-built_in">UINavigationController</span> *)navigationController<br>                          interactionControllerForAnimationController:(<span class="hljs-keyword">id</span> &lt;<span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span>&gt;) animationController &#123;<br>    <span class="hljs-comment">//注意没有手势的时候要返回nil，否则无法通过点击导航栏左边的item正常退出                        </span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.interactiveAnimation.isInteractive) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.interactiveAnimation;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-literal">nil</span><br>                          &#125;<br></code></pre></td></tr></table></figure>

<h2 id="modal弹窗显示交互手势"><a href="#modal弹窗显示交互手势" class="headerlink" title="modal弹窗显示交互手势"></a>modal弹窗显示交互手势</h2><ol>
<li>实现代理</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span> &lt;<span class="hljs-built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="hljs-keyword">id</span> &lt;<span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span> &lt;<span class="hljs-built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="hljs-keyword">id</span> &lt;<span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.interactiveAnimation.isInteractive) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.interactiveAnimation;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="交互控制器的实现"><a href="#交互控制器的实现" class="headerlink" title="交互控制器的实现"></a>交互控制器的实现</h2><p>交互控制器为继承<code>UIPercentDrivenInteractiveTransition</code>的类，主要结合边缘滑动手势</p>
<p><code>UIScreenEdgePanGestureRecognizer</code>，其中主要依靠的方法</p>
<ol>
<li><p><code>[self updateInteractiveTransition:_percent]</code>,更新交互转场完成的百分比;</p>
</li>
<li><p><code>[self finishInteractiveTransition]</code>完成交互转场</p>
</li>
<li><p><code>[self cancelInteractiveTransition];</code>取消交互转场</p>
</li>
</ol>
<h3 id="具体的实现"><a href="#具体的实现" class="headerlink" title="具体的实现"></a>具体的实现</h3><ol>
<li>给页面添加边缘滑动手势</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">UIScreenEdgePanGestureRecognizer</span> *interactiveTransitionRecognizer  = [[<span class="hljs-built_in">UIScreenEdgePanGestureRecognizer</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(panAction:)];<br>interactiveTransitionRecognizer.edges = <span class="hljs-built_in">UIRectEdgeLeft</span>;<br>[vc.view addGestureRecognizer:interactiveTransitionRecognizer];<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>找到转场动画的容器</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)startInteractiveTransition:(<span class="hljs-keyword">id</span>&lt;<span class="hljs-built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;<br>    [<span class="hljs-keyword">super</span> startInteractiveTransition:transitionContext];<br>    <span class="hljs-keyword">self</span>.transitionContext = transitionContext;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>实际手势的实现</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)panAction:(<span class="hljs-built_in">UIPanGestureRecognizer</span> *)pan&#123;<br>    _percent = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-comment">//UIView *transitionContainerView = pan.view;从手势中也可以获取手势滑动的view，但是转场动画中涉及3d变化的动画操作，那么将无法从手势中获取相应变换的相对位置</span><br>    <span class="hljs-built_in">UIView</span> *transitionContainerView = <span class="hljs-keyword">self</span>.transitionContext.containerView;<br>    <span class="hljs-built_in">CGFloat</span> totalWidth  = <span class="hljs-built_in">CGRectGetWidth</span>(transitionContainerView.bounds);<br>    <span class="hljs-built_in">CGFloat</span> totalHeight = <span class="hljs-built_in">CGRectGetHeight</span>(transitionContainerView.bounds);<br>  	<span class="hljs-built_in">CGFloat</span> x = [pan translationInView:transitionContainerView].x;<br>            _percent = -x/totalWidth;<br>  <span class="hljs-keyword">switch</span> (pan.state) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateBegan</span>:<br>            _isInter = <span class="hljs-literal">YES</span>;<br>            [<span class="hljs-keyword">self</span>.vc.navigationController popViewControllerAnimated:<span class="hljs-literal">YES</span>];<br>    			<span class="hljs-comment">//  [self.vc dismissViewControllerAnimated:YES completion:nil];</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateChanged</span>:<br>            [<span class="hljs-keyword">self</span> updateInteractiveTransition:_percent];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateEnded</span>:<br>            _isInter = <span class="hljs-literal">NO</span>;<br>            [<span class="hljs-keyword">self</span> continueAction];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>手势结束后动画UI的变化，</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//采用gui定时器的方式来处理转场动画变换</span><br>- (<span class="hljs-keyword">void</span>)continueAction&#123;<br>    <span class="hljs-keyword">if</span> (_displayLink) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _displayLink = [<span class="hljs-built_in">CADisplayLink</span> displayLinkWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(<span class="hljs-built_in">UIChange</span>)];<br>    [_displayLink  addToRunLoop:[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<br><br>&#125;<br><span class="hljs-comment">//转场uI的变换</span><br>- (<span class="hljs-keyword">void</span>)<span class="hljs-built_in">UIChange</span> &#123;<br>    <span class="hljs-built_in">CGFloat</span> timeDistance = <span class="hljs-number">2.0</span>/<span class="hljs-number">60</span>;<br>    <span class="hljs-keyword">if</span> (_percent &gt; <span class="hljs-number">0.4</span>) &#123;<br>        _percent += timeDistance;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        _percent -= timeDistance;<br>    &#125;<br>    [<span class="hljs-keyword">self</span> updateInteractiveTransition:_percent];<br>    <span class="hljs-keyword">if</span> (_percent &gt;= <span class="hljs-number">1.0</span>) &#123;<br>        [<span class="hljs-keyword">self</span> finishInteractiveTransition];<br>        [<span class="hljs-keyword">self</span> stopDisplayLink];<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (_percent &lt;= <span class="hljs-number">0.0</span>) &#123;<br>        [<span class="hljs-keyword">self</span> stopDisplayLink];<br>        [<span class="hljs-keyword">self</span> cancelInteractiveTransition];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>​        </p>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>图层视觉效果</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%B1%82%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图层蒙板"><a href="#图层蒙板" class="headerlink" title="图层蒙板"></a>图层蒙板</h2><blockquote>
<p><code>CALayer</code>有一个属性叫做<code>mask</code>可以解决这个问题，这个属性本身就是个<code>CALayer</code>类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，不同于那些绘制在父图层中的子图层，<code>mask</code>图层定义了父图层的部分可见区域。</p>
</blockquote>
<ul>
<li><code>mask</code>图层的Color属性是无关紧要的，真正重要的是图层的轮廓。其显示的轮廓即为图层能显示的区域</li>
</ul>
<span id="more"></span>

<h2 id="拉伸过滤算法"><a href="#拉伸过滤算法" class="headerlink" title="拉伸过滤算法"></a>拉伸过滤算法</h2><blockquote>
<p>当图片需要显示不同的大小的时候<code>minificationFilter</code>和<code>magnificationFilter</code>属性。，有一种叫做拉伸过滤的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
</blockquote>
<ul>
<li>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。<code>CALayer</code>为此提供了三种拉伸过滤方法，他们是：<ol>
<li> kCAFilterLinear</li>
<li> kCAFilterNearest</li>
<li> kCAFilterTrilinear</li>
</ol>
</li>
</ul>
<h3 id="kCAFilterLinear和kCAFilterTrilinear"><a href="#kCAFilterLinear和kCAFilterTrilinear" class="headerlink" title="kCAFilterLinear和kCAFilterTrilinear"></a><code>kCAFilterLinear</code>和<code>kCAFilterTrilinear</code></h3><ul>
<li><p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是<code>kCAFilterLinear</code>，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。</p>
</li>
<li><p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<h3 id="kCAFilterNearest"><a href="#kCAFilterNearest" class="headerlink" title="kCAFilterNearest"></a><code>kCAFilterNearest</code></h3></li>
<li><p><code>kCAFilterNearest</code>是一种比较武断的方法,这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3></li>
<li><p>总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。因此对于大图来说，双线性滤波和三线性滤波表现得更出色,而对于没有斜线的小图来说，最近过滤算法要好很多。</p>
</li>
<li><p>用法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//对于小图片极少斜线的图，用最近的放大算法较好<br>view.layer.magnificationFilter = kCAFilterNearest;<br></code></pre></td></tr></table></figure>
<h2 id="组透明"><a href="#组透明" class="headerlink" title="组透明"></a>组透明</h2><blockquote>
<p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
</blockquote>
<ul>
<li>下图展示了一个内嵌UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</li>
</ul>
<p><img src="1.png" alt="1.png"></p>
<ul>
<li>这是由透明度混合叠加造成的，当你显示一个个50%透明度的图层时，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来自图层本身的颜色，另外的25%则来自背景色。所以合起来中间标签可见度为75%</li>
<li>处理方法<ul>
<li>可以设置CALayer的一个叫做<code>shouldRasterize</code>属性来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了.</li>
<li>为了启用<code>shouldRasterize</code>属性，我们设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了<code>shouldRasterize</code>属性，你就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕(Retina的像素比和一般屏幕不一样)像素化的问题。</li>
<li>代码</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">button2.layer.shouldRasterize = YES;<br>button2.layer.rasterizationScale = [UIScreen mainScreen].scale;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>视频H264硬编码</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E8%A7%86%E9%A2%91H264%E7%A1%AC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>像素的大小是8bit，一张1920✖️1080的图片需要1920✖️1080✖️8✖️3bit / (1024✖️1024) = 47Mbit = 5.8MB；在观看30FPS的视频时，1s需要30张图片，也就是需要47 ✖️ 30 = 1.4Gbit，也就是1.4Gbit的带宽；以我们现在的网络带宽远远不够。所以必须进行视频源压缩编码。</p>
</blockquote>
<span id="more"></span>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS视频采集的格式类型</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/iOS%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86%E7%9A%84%E6%A0%BC%E5%BC%8F%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS定义了很多的视频格式，这里简单介绍一下它的命名规则，具体还需要看开发文档。</p>
</blockquote>
<span id="more"></span>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>在视频采集中，设置视频输出</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">COPYNSDictionary *videoSetting = @&#123;(<span class="hljs-keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;<br><br><span class="hljs-keyword">self</span>.videoPutData = [[<span class="hljs-built_in">AVCaptureVideoDataOutput</span> alloc] init];<br><span class="hljs-keyword">self</span>.videoPutData.videoSettings = videoSetting;<br></code></pre></td></tr></table></figure>

<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol>
<li>命名规则</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">COPYkCVPixelFormatType_&#123;长度|序列&#125;&#123;颜色空间&#125;&#123;Planar|BiPlanar&#125;&#123;VideoRange|FullRange&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>Planar</code>：平面；<code>BiPlanar</code>：双平面</p>
<ul>
<li>平面/双平面主要用在<code>YUV</code>上。<code>UV</code>分开存储为<code>Planar</code>，反之是<code>BiPlanar</code>。所以：<ul>
<li><code>kCVPixelFormatType_420YpCbCr8PlanarFullRange</code>是420p</li>
<li><code>kCVPixelFormatType_420YpCbCr8BiPlanarFullRange</code>是nv12</li>
</ul>
</li>
</ul>
</li>
<li><p><code>VideoRange</code>和<code>FullRange</code> 的区别在于数值的范围，<code>FullRange</code>比<code>VideoRange</code>大一些，颜色也更丰富一些</p>
<ul>
<li>如果没有指定颜色范围，默认都是<code>FullRange</code>。但有一种情况除外，例如:<ul>
<li><code>kCVPixelFormatType_420YpCbCr8Planar</code>和<code>kCVPixelFormatType_420YpCbCr8PlanarFullRange</code>,因为已经有FullRange了，所以未指定的应该为<code>VideoRange</code></li>
</ul>
</li>
</ul>
</li>
<li><p>颜色空间对应的就是它在内存中的顺序。比如<code>  kCVPixelFormatType_32BGRA</code>，内存中的顺序是<code>B G R A B G R A B…</code>。</p>
<ul>
<li>也有一些特别的，比如<code>kCVPixelFormatType_16BE555</code>，这里需要用BE或LE指定字节顺序。其后面还带有一种数字，用于表示bit长度</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS拍摄流程</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/iOS%E6%8B%8D%E6%91%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS相机拍摄所需框架为<code>&lt;ACFoundation/AVFoundation.h&gt;</code>，该框架中基本上包含了视频中所需的全部方法。</p>
</blockquote>
<span id="more"></span>

<h1 id="拍摄的流程"><a href="#拍摄的流程" class="headerlink" title="拍摄的流程"></a>拍摄的流程</h1><h2 id="session-初始化"><a href="#session-初始化" class="headerlink" title="session 初始化"></a><code>session</code> 初始化</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-built_in">AVCaptureSession</span> alloc] init]<br></code></pre></td></tr></table></figure>

<h2 id="Input初始化"><a href="#Input初始化" class="headerlink" title="Input初始化"></a>Input初始化</h2><ol>
<li><code>device</code>初始化</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//音频设备初始化，AVMediaTypeAudio替换为AVMediaTypeVideo即为视频，默认为后置摄像头</span><br>[<span class="hljs-built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:[<span class="hljs-built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="hljs-built_in">AVMediaTypeAudio</span>] error:&amp;error];<br><span class="hljs-comment">//视频设置初始化，详细版</span><br><span class="hljs-built_in">AVCaptureDeviceDiscoverySession</span> *captureDeviceDiscoverySession =<br>            [<span class="hljs-built_in">AVCaptureDeviceDiscoverySession</span> discoverySessionWithDeviceTypes:@[ <span class="hljs-built_in">AVCaptureDeviceTypeBuiltInWideAngleCamera</span> ] mediaType:<span class="hljs-built_in">AVMediaTypeVideo</span> position:<span class="hljs-built_in">AVCaptureDevicePositionBack</span>];<span class="hljs-comment">//发现所有后置视频设备的会话</span><br>[[captureDeviceDiscoverySession devices] enumeratObjectsUsingBlock:^(<span class="hljs-built_in">AVCaptureDevice</span> *camera, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> *_Nonnull stop) &#123;<br>            <span class="hljs-keyword">if</span> (camera.position == <span class="hljs-built_in">AVCaptureDevicePositionBack</span>) &#123;<br>                backCamera = camera;<br>            &#125;<br>        &#125;];<span class="hljs-comment">//遍历会话获取后置设备，可以对设备进行一些属性设置，例如曝光模式，但是，要调用lockForConfiguration:调用完之后使用unlockForConfiguration方法解锁，</span><br>[<span class="hljs-built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:backCamera error:<span class="hljs-literal">nil</span>];<span class="hljs-comment">//同样的方式初始化设备输入</span><br></code></pre></td></tr></table></figure>

<ol>
<li>然后通过<code>canAddInput</code>来判断是否能在会话中，通过<code>addInput</code>将<code>input</code>添加到会话中，视频要添加<code>2</code>个会话，视频输入以及语音输入</li>
<li>如果要切换摄像头<ol>
<li>在<code>session</code>的<code>beginConfiguration</code>和<code>commitConfiguration</code>之间重新设置摄像头，</li>
<li><code>removeInput</code>删除原来的媒体设备输入</li>
<li>获取后置的摄像头的设备<code>AVCaptureDevice</code></li>
<li><code>[AVCaptureDeviceInput deviceInputWithDevice:swithToDevice error:**nil**];</code>重新设置摄像头，并将其添加到<code>session</code>中</li>
<li><strong>注意</strong>，如果为前置摄像头，遍历会话中的<code>outputs</code>，将其输入和输出的连接会话<code>AVCaptureConnection</code>的视频镜像属性<code>videoMirrored</code>，设为<code>YES</code></li>
</ol>
</li>
</ol>
<h2 id="output初始化"><a href="#output初始化" class="headerlink" title="output初始化"></a><code>output</code>初始化</h2><ol>
<li><p><code>AVCaptureMovieFileOutput</code> 输出视频，</p>
<ol>
<li><p>只用初始化<code>AVCaptureMovieFileOutput</code>，将视频输出加到会话当中</p>
</li>
<li><p>调用<code>startRecordingToOutputFileURl:recordingDelegate:</code>处理输出的视频，通过调用<code>stopRecod</code>停止录屏</p>
</li>
<li><p>实现<code>AVCaptureFileOutputRecordingDelegate</code></p>
<ol>
<li><code>captureOutput:didStartRecordingToOutputFileAtURL:fromConnections:</code>开始写入视频文件时调用</li>
<li><code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>写入完成时调用</li>
</ol>
</li>
</ol>
</li>
<li><p><a href="#jump"><code>AVAssetWriter</code>输出数据</a></p>
</li>
</ol>
<h2 id="初始化预览层AVCaptureVideoPreviewLayer"><a href="#初始化预览层AVCaptureVideoPreviewLayer" class="headerlink" title="初始化预览层AVCaptureVideoPreviewLayer"></a>初始化预览层AVCaptureVideoPreviewLayer</h2><ol>
<li>根据媒体会话初始化视图层，也就是预览层，该属性可以添加到相应图层的子层中</li>
<li><code>[AVCaptureVideoPreviewLayer layerWithSession:self.captureSession];</code>获取一个预览图层</li>
<li><code>addSublayer</code>加到要显示的视图图层内</li>
</ol>
<h3 id="开始录制"><a href="#开始录制" class="headerlink" title="开始录制"></a>开始录制</h3><ol>
<li><code>[session StartRunning]</code>，会话开始，开始录制（每次录制都需要<code>StartRunning</code>）</li>
</ol>
<h1 id="AVAssetWriter实现拍摄"><a href="#AVAssetWriter实现拍摄" class="headerlink" title="AVAssetWriter实现拍摄"></a><span id="jump">AVAssetWriter实现拍摄</span></h1><h2 id="初始化视频-音频数据输出"><a href="#初始化视频-音频数据输出" class="headerlink" title="初始化视频/音频数据输出"></a>初始化视频/音频数据输出</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSDictionary</span> *videoSetting = @&#123;(<span class="hljs-keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;<span class="hljs-comment">//32BGRA像素格式，和后面要取的视频帧数据对应</span><br><span class="hljs-keyword">self</span>.videoPutData = [[<span class="hljs-built_in">AVCaptureVideoDataOutput</span> alloc] init];<br><span class="hljs-keyword">self</span>.videoPutData.videoSettings = videoSetting;<br><br>[[<span class="hljs-built_in">AVCaptureAudioDataOutput</span> alloc] init];<br></code></pre></td></tr></table></figure>

<p>在<code>canAddOutput</code>判断后，通过<code>addOutput</code>添加到<code>session</code>中</p>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>通过<code>setSampleBufferDelegate:queue: </code>设置应该调用回调的缓冲区委托和队列,获取视频流</p>
<h2 id="配置AVAssetWriter"><a href="#配置AVAssetWriter" class="headerlink" title="配置AVAssetWriter"></a>配置<code>AVAssetWriter</code></h2><ol>
<li><p>配置并发队列<code>DISPATCH_QUEUE_CONCURRENT</code>，<code>dispatch_async</code>异步执行</p>
</li>
<li><p>在队列中配置<code>AVAssetWriter</code>，用<code>[AVAssetWriter assWriterWithURL:文件输出地址 fileType:AVFileTypeMPEG4 error:&amp;error]</code>初始化<code>AVAssetWriter</code>;</p>
</li>
<li><p>配置详细参数，视频硬编码参数</p>
<ol>
<li><p>码率和帧率的设置</p>
<ol>
<li><p><code>AVVideoAverageBitRateKey</code>：指单位时间内处理的数据位数，单位是 <code>b/s</code> 。码率=<code>视频文件大小/视频时长</code>。数值越大，显示越精细</p>
</li>
<li><p><code>AVVideoMaxKeyFrameIntervalKey</code>：关键帧最大间隔，<code>1</code>为每个都是关键帧，数值越大压缩率越高，也就是文件越小（如果画面包含大量场景变换或迅速移动的动作或动画，那么减少关键帧距离将会提高图像的整体品质。一个较小的关键帧距离对应于一个较大的输出文件。注意减少了关键帧间距，注意增大比特率也就是码率，保证视频质量）</p>
</li>
<li><p><code>AVVideoProfileLevelKey</code>：<code>H.264</code>专用参数，代表画质级别，从低到高分贝为<code>BP</code>、<code>EP</code>、<code>MP</code>、<code>HP</code></p>
<ol>
<li><p>而<code>H264</code>最大的优势就是低码率情况下提供高质量的视频图像，总的来说编码流程可以分为五部分：帧间和帧内预测（<code>Estimation</code>）、变换（<code>Transform</code>）和反变换、量化（<code>Quantization</code>）和反量化、环路滤波（<code>Loop Filter</code>）、熵编码（<code>Entropy Coding</code>）</p>
</li>
<li><p><code>H264</code>为了满足不同设备不同场景的需要（比如直播注重实时性，存储注重压缩比）定义了多种编码层次也就是<code>Profile</code>，具体如下</p>
<ol>
<li><p><code>BaslineProfile</code>：支持<code>I/P</code> 帧，只支持无交错（<code>Progressive</code>）和<code>CAVLC</code></p>
</li>
<li><p><code>Extended Profile</code>：支持<code>I/P/B/SP/SI</code> 帧，只支持无交错（<code>Progressive</code>）和<code>CAVLC</code></p>
</li>
<li><p><code>MainProfile</code>：提供<code>I/P/B</code> 帧，支持无交错（<code>Progressive</code>）和交错（<code>Interlaced</code>），也支持<code>CAVLC</code> 和<code>CABAC</code></p>
</li>
<li><p><code>High Profile</code>：在<code>mainProfile</code> 的基础上增加了<code>8x8</code>内部预测、自定义量化、 <code>无损视频编码</code>和更多的<code>YUV</code> 格式；</p>
</li>
<li><p>视频压缩很重要的一个就是帧间预测，也就是视频相邻的几帧有很大的相关性，变化不会太大，所以存在很多冗余信息，压缩要做的就是去除这些冗余信息。帧类型主要有以下几种</p>
<ol>
<li><code>I帧</code>表示关键帧，这一帧保留完整的画面数据，解码时只需要本帧数据就可以完成</li>
<li><code>P帧</code>，前向预测帧，表示的是这一帧跟之前的一个关键帧（或<code>P帧</code>）的差别，解码时需要用之前的画面叠加上本帧定义的差别，生成最终画面。</li>
<li><code>B帧</code>是双向预测帧，也就是<code>B帧</code>记录的是本帧与前后帧的差别，要解码<code>B帧</code>，不仅要取得之前的画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。<code>B帧</code>压缩率高，但是解码时比较耗费<code>CPU</code>。</li>
</ol>
</li>
<li><p><code>Profile</code> 越高，压缩比就越高，但是编码、解码时要求的设备性能也就越高，编码、解码的效率也就越低。</p>
</li>
<li><p>这里的<code>level</code>就是对每个<code>profile</code>的能力细分。</p>
<ol>
<li>实时直播</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">COPY低清Baseline Level <span class="hljs-number">1.3</span><br>标清Baseline Level <span class="hljs-number">3</span><br>半高清Baseline Level <span class="hljs-number">3.1</span><br>全高清Baseline Level <span class="hljs-number">4.1</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>存储媒体</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">低清 Main Level <span class="hljs-number">1.3</span><br>标清 Main Level <span class="hljs-number">3</span><br>半高清 Main Level <span class="hljs-number">3.1</span><br>全高清 Main Level <span class="hljs-number">4.1</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>高清存储</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">半高清 High Level <span class="hljs-number">3.1</span><br>全高清 High Level <span class="hljs-number">4.1</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>iPad 支持：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Baseline Level <span class="hljs-number">1</span><span class="hljs-number">-3.1</span><br>Main Level <span class="hljs-number">1</span><span class="hljs-number">-3.1</span><br>High Level <span class="hljs-number">1</span><span class="hljs-number">-3.1</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p><code>AVVideoExpectedSourceFrameRateKey</code>：预期的源帧速率，不用于控制帧速率，作为提示提供给视频编码器的，如果使用率自动级别的<code>AVVideoProfileLevelKey</code>，或者源内容的帧率高于<code>30fps</code>，则应设置此项。如果没有指定的话，编码器可能必须丢弃帧以满足位流要求</p>
</li>
</ol>
</li>
<li><p>视频属性设置</p>
<ol>
<li><code>AVVideoCodecKey</code>:用于压缩视频的编码器的名称，这里用的是硬编码<code>AVVideoCodecTypeH264</code></li>
<li><code>AVVideoWidthKey</code>、<code>AVVideoHeightKey</code>：设定视频的宽高</li>
<li><code>AVVideoScalingModeKey</code>：视频压缩填充的方式，<code>AVVideoScalingModeResizeAspectFill</code></li>
<li><code>AVVideoCompressionPropertiesKey</code>：视频压缩编码器，压缩的属性字典，即1中码率和帧率的设置</li>
</ol>
</li>
<li><p>音频设置</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSDictionary</span> *audioSetting =<br>                @&#123;<span class="hljs-built_in">AVEncoderBitRatePerChannelKey</span> : @(<span class="hljs-number">28000</span>),<span class="hljs-comment">//声道采样率</span><br>                  <span class="hljs-built_in">AVFormatIDKey</span> : @(kAudioFormatMPEG4AAC),<span class="hljs-comment">//音频格式，在视频中也是mp4格式</span><br>                  <span class="hljs-built_in">AVNumberOfChannelsKey</span> : @(<span class="hljs-number">1</span>),<span class="hljs-comment">//声道数</span><br>                  <span class="hljs-built_in">AVSampleRateKey</span> : @(<span class="hljs-number">22050</span>)&#125;;<span class="hljs-comment">//采样率</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>初始化视频采集<code>AVAssetWriterInput</code>，采用方法<code>[AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSetting:视频设置]</code>，也用同样方式设置音频采集<code>AVAssetWriterInput</code></li>
<li>对于视频采集，可以通过视频采集的<code>transform</code>来调整视频流的方向，横屏还是竖屏，拍摄完默认是横的，要调整<code>transform</code>属性，<code>self.writerVideoInput.transform = CGAffineTransformMakeRotation(-M_PI / 2.0);</code></li>
<li>最后将视频采集和声音采集，通过<code>canAddInput</code>判断，<code>addInput</code>添加到创建的写入<code>AVAssetWrite</code>中</li>
</ol>
</li>
</ol>
<h2 id="代理实现"><a href="#代理实现" class="headerlink" title="代理实现"></a>代理实现</h2><p>实现<code>AVCaptureAudioDataOutSampleBufferDelegate</code>、<code>AVCaptureVideoDataOutSampleBufferDelegate</code>，具体是在<code>captureOutput:didOutputSampleBuffer:fromConnection:</code>方法中实现（每当输出捕获和输出新视频帧时，委托将接收此消息，并按照其<code>videoSetting</code>属性指定对其进行解码或重新编码，该方法在输出的<code>sampleBufferCallbackQueue</code>属性指定的调度队列上调用，为周期性的调用）</p>
<ol>
<li><p><code>CMSampleBufferRef</code>，是相关媒体流数据，可以获取媒体流的类型为语音还是视频流以及资源的时间戳</p>
</li>
<li><p>在媒体流属性为视频里(确保写入的第一帧为视频图像，保证不会出现有声音但无画面的情况)，调用（<code>AVAssetWriter</code>）的<code>startWriting</code>方法开始写入，从视频流中获取最早时间戳，调用<code>startSessionAtSourceTime</code>，开始写入</p>
<ol>
<li>视频和音频开始写入的判断<code>canWritting</code>（<code>Bool</code>）放在<code>startSessionAtSourceTime</code>下，会导致视频前几帧相同，因为调用<code>startSessionAtSourceTime</code>就开始录制了，所以要放在<code>startsessionAtSourceTime</code>的上面</li>
</ol>
</li>
<li><p>配置中初始化的视频采集以及声音采集<code>AVAssetWriterInput</code>，在其属性<code>readyForMoreMediaData</code>（输入准备好接收更多数据），调用<code>apppendSampleBuffer:</code>方法，将<code>CMSampleBufferRef</code>添加进去</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - AVCaptureVideoDataOutputSampleBufferDelegate method</span><br>- (<span class="hljs-keyword">void</span>)captureOutput:(<span class="hljs-built_in">AVCaptureOutput</span> *)output didOutputSampleBuffer:(<span class="hljs-built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="hljs-built_in">AVCaptureConnection</span> *)connection &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.videoRecording) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">CMFormatDescriptionRef</span> desMedia = <span class="hljs-built_in">CMSampleBufferGetFormatDescription</span>(sampleBuffer);<br>    <span class="hljs-built_in">CMMediaType</span> mediaType = <span class="hljs-built_in">CMFormatDescriptionGetMediaType</span>(desMedia);<br><br>    <span class="hljs-keyword">if</span> (mediaType == kCMMediaType_Video) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.canWritting) &#123;<br>            [<span class="hljs-keyword">self</span>.writer startWriting];<br><br>            <span class="hljs-built_in">CMTime</span> timestamp = <span class="hljs-built_in">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer);<br><br>            <span class="hljs-keyword">self</span>.canWritting = <span class="hljs-literal">YES</span>;<br>            [<span class="hljs-keyword">self</span>.writer startSessionAtSourceTime:timestamp];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.canWritting) &#123;<br>        <span class="hljs-keyword">if</span> (mediaType == kCMMediaType_Video) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.writerVideoInput.readyForMoreMediaData) &#123;<br>                <span class="hljs-built_in">BOOL</span> success = [<span class="hljs-keyword">self</span>.writerVideoInput appendSampleBuffer:sampleBuffer];<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    LOG_DEBUG(<span class="hljs-string">@&quot;video write failed&quot;</span>);<br>                &#125;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mediaType == kCMMediaType_Audio &amp;&amp; <span class="hljs-keyword">self</span>.canWritting) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.writerAudioInput.readyForMoreMediaData) &#123;<br>                <span class="hljs-built_in">BOOL</span> success = [<span class="hljs-keyword">self</span>.writerAudioInput appendSampleBuffer:sampleBuffer];<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    LOG_DEBUG(<span class="hljs-string">@&quot;audio write failed&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="录制完成"><a href="#录制完成" class="headerlink" title="录制完成"></a>录制完成</h3><p><code>AVCaptureSession</code>的<code>startRunning</code>方法是个耗时操作，如果在主线程调用的话会卡<code>UI</code>。完成写入，<code>AVAssetWriter</code>的状态为正在写入，则调用<code>finishWritingWithCompletionHandler:</code>完成数据的写入</p>
<h1 id="视频压缩"><a href="#视频压缩" class="headerlink" title="视频压缩"></a>视频压缩</h1><h2 id="传统视频压缩的方式"><a href="#传统视频压缩的方式" class="headerlink" title="传统视频压缩的方式"></a>传统视频压缩的方式</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">AVURLAsset</span> *avAsset = [<span class="hljs-built_in">AVURLAsset</span> URLAssetWithURL:inputURL options:<span class="hljs-literal">nil</span>];<br><span class="hljs-built_in">AVAssetExportSession</span> *exportSession = [[<span class="hljs-built_in">AVAssetExportSession</span> alloc] initWithAsset:avAsset presetName:<span class="hljs-built_in">AVAssetExportPresetMediumQuality</span>];<span class="hljs-comment">//视频压缩的类型，还有AVAssetExportPresset960x540具体压缩的分辨率</span><br>   exportSession.outputURL = outputURL;<br>   exportSession.outputFileType = <span class="hljs-built_in">AVFileTypeMPEG4</span>;<br>   exportSession.shouldOptimizeForNetworkUse = <span class="hljs-literal">YES</span>;<br>   [exportSession exportAsynchronouslyWithCompletionHandler:^(<span class="hljs-keyword">void</span>) &#123;<br>       <span class="hljs-keyword">switch</span>(exportSession.status) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVAssetExportSessionStatusCompleted</span>:<span class="hljs-comment">//压缩完成</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVAssetExportSessionStatusFailed</span>:<span class="hljs-comment">//压缩失败</span><br>         <span class="hljs-keyword">default</span>:<br>       &#125;<br>   &#125;];<br></code></pre></td></tr></table></figure>

<p>绝大多数的情况下可以通过传统的压缩方式对视频进行压缩。为了获得最大的视频压缩率(最低的码率)最好的方式是</p>
<ol>
<li>指定<code>high</code>的<code>profile</code></li>
<li>降低帧率</li>
<li>适当降低分辨率</li>
</ol>
<p>但是传统的压缩方式不支持指定<code>profile</code>，帧率和码率，所以只有通过其他方式来实现。可以在相机录像时需要将拍摄的每一帧<code>sampleBuffer</code>（音频或者视频）传给<code>AVassetWriter</code>，并制定压缩参数。</p>
<h2 id="AVAassetWriter实现视频压缩"><a href="#AVAassetWriter实现视频压缩" class="headerlink" title="AVAassetWriter实现视频压缩"></a><code>AVAassetWriter</code>实现视频压缩</h2><h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><p><img src="1.png" alt="img"></p>
<h3 id="代码的实现"><a href="#代码的实现" class="headerlink" title="代码的实现"></a>代码的实现</h3><ol>
<li>初始化<code>reader</code>，<code>writer</code>，<code>video/audio track</code>, <code>video/audio input</code>, <code>video/audio output</code></li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)comppressVideoUrl:(<span class="hljs-built_in">NSURL</span> *) videoUrl withOutputUrl:(<span class="hljs-built_in">NSURL</span> *)outputUrl &#123;<br>    <span class="hljs-built_in">AVAsset</span> *asset = [<span class="hljs-built_in">AVAsset</span> assetWithURL:videoUrl];<br>    <span class="hljs-built_in">AVAssetReader</span> *reader = [<span class="hljs-built_in">AVAssetReader</span> assetReaderWithAsset:asset error:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-built_in">AVAssetWriter</span> *writer = [<span class="hljs-built_in">AVAssetWriter</span> assetWriterWithURL:outputUrl fileType:<span class="hljs-built_in">AVFileTypeMPEG4</span> error:<span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-built_in">AVAssetTrack</span> *videoTrack = [[asset tracksWithMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span>] firstObject];<span class="hljs-comment">//获取轨道，一般视频至少两个轨道，一个播放声音的一个播放画面的</span><br>    <br>    <span class="hljs-comment">//视频输出源</span><br>    <span class="hljs-built_in">NSDictionary</span> *videoOuptSetting = @&#123;(<span class="hljs-keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;<br>    <span class="hljs-built_in">AVAssetReaderTrackOutput</span> *videoOutput = [<span class="hljs-built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:videoTrack outputSettings:videoOuptSetting];<br>    <br>    <span class="hljs-comment">//视频采集输入设置，</span><br>    <span class="hljs-comment">// 码率和帧率设置</span><br>    <span class="hljs-built_in">NSDictionary</span> *compressionProperties = @&#123;<br>        <span class="hljs-built_in">AVVideoAverageBitRateKey</span> : @(DSScreenWidth() * DSScreenHeight()*<span class="hljs-number">12</span>),<br>        <span class="hljs-built_in">AVVideoExpectedSourceFrameRateKey</span> : @(<span class="hljs-number">15</span>),<br>        <span class="hljs-built_in">AVVideoMaxKeyFrameIntervalKey</span> : @(<span class="hljs-number">10</span>),<br>        <span class="hljs-built_in">AVVideoProfileLevelKey</span> : <span class="hljs-built_in">AVVideoProfileLevelH264BaselineAutoLevel</span><br>    &#125;;<br><br>    <span class="hljs-comment">//视频属性</span><br>    <span class="hljs-built_in">NSDictionary</span> *videoSetting = @&#123;<br>        <span class="hljs-built_in">AVVideoCodecKey</span> : <span class="hljs-built_in">AVVideoCodecTypeH264</span>,<br>        <span class="hljs-built_in">AVVideoWidthKey</span> : @(DSScreenHeight() * <span class="hljs-number">2</span>),<br>        <span class="hljs-built_in">AVVideoHeightKey</span> : @(DSScreenWidth() * <span class="hljs-number">2</span>),<br>        <span class="hljs-built_in">AVVideoScalingModeKey</span> : <span class="hljs-built_in">AVVideoScalingModeResizeAspectFill</span>,<br>        <span class="hljs-built_in">AVVideoCompressionPropertiesKey</span> : compressionProperties<br>    &#125;;<br>    <span class="hljs-built_in">AVAssetWriterInput</span> *videoInput = [<span class="hljs-built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span> outputSettings:videoSetting];<br>  <span class="hljs-comment">//注意要设置视频的方向，每个视频都有方向，这里先获取视频的方向</span><br>  <span class="hljs-keyword">int</span> degress = [<span class="hljs-keyword">self</span> degressFromVideoFileWithAsset:asset];<br>    videoInput.transform = <span class="hljs-built_in">CGAffineTransformMakeRotation</span>(M_PI * (degress / <span class="hljs-number">180.0</span>));<br>    <span class="hljs-keyword">if</span>([reader canAddOutput:videoOutput])&#123;<br>        [reader addOutput:videoOutput];<br>    &#125;<br>    <span class="hljs-keyword">if</span> ([writer canAddInput:videoInput]) &#123;<br>        [writer addInput:videoInput];<br>    &#125;<br>    <br>    <span class="hljs-comment">//音频部分</span><br>  <span class="hljs-comment">//音频输出设置，和视频拍摄不一样，视频拍摄时，指点了缓存流的格式，而文件压缩的时候则没有因此视频和音频一定要设置输出格式</span><br>  <span class="hljs-built_in">NSDictionary</span> *readerOutputSettings = @&#123;<span class="hljs-built_in">AVFormatIDKey</span>: @(kAudioFormatLinearPCM)&#125;;<br>    <span class="hljs-built_in">AVAssetTrack</span> *audioTrack = [[asset tracksWithMediaType:<span class="hljs-built_in">AVMediaTypeAudio</span>] firstObject];<br>    <span class="hljs-built_in">AVAssetReaderTrackOutput</span> *audioOutput = [<span class="hljs-built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:audioTrack outputSettings:readerOutputSettings];<br>    <span class="hljs-comment">//声音采集设置</span><br>    <span class="hljs-built_in">NSDictionary</span> *audioSetting =<br>        @&#123;<span class="hljs-built_in">AVEncoderBitRatePerChannelKey</span> : @(<span class="hljs-number">28000</span>),<br>          <span class="hljs-built_in">AVFormatIDKey</span> : @(kAudioFormatMPEG4AAC),<br>          <span class="hljs-built_in">AVNumberOfChannelsKey</span> : @(<span class="hljs-number">1</span>),<br>          <span class="hljs-built_in">AVSampleRateKey</span> : @(<span class="hljs-number">22050</span>)&#125;;<br>    <span class="hljs-built_in">AVAssetWriterInput</span> *audioInput = [<span class="hljs-built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="hljs-built_in">AVMediaTypeAudio</span> outputSettings:audioSetting];<br>    <span class="hljs-keyword">if</span> ([reader canAddOutput:audioOutput]) &#123;<br>        [reader addOutput:audioOutput];<br>    &#125;<br>    <span class="hljs-keyword">if</span> ([writer canAddInput:audioInput]) &#123;<br>        [writer addInput:audioInput];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>获取视频的方向</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// 获取视频的方向</span><br>+ (<span class="hljs-keyword">int</span>)degressFromVideoFileWithAsset:(<span class="hljs-built_in">AVAsset</span> *)asset &#123;<br>    <span class="hljs-keyword">int</span> degress = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">NSArray</span> *tracks = [asset tracksWithMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span>];<br>    <span class="hljs-keyword">if</span> ([tracks count] &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">AVAssetTrack</span> *videoTrack = [tracks objectAtIndex:<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">CGAffineTransform</span> t = videoTrack.preferredTransform;<br>        <span class="hljs-keyword">if</span> (t.a == <span class="hljs-number">0</span> &amp;&amp; t.b == <span class="hljs-number">1.0</span> &amp;&amp; t.c == <span class="hljs-number">-1.0</span> &amp;&amp; t.d == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Portrait</span><br>            degress = <span class="hljs-number">90</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.a == <span class="hljs-number">0</span> &amp;&amp; t.b == <span class="hljs-number">-1.0</span> &amp;&amp; t.c == <span class="hljs-number">1.0</span> &amp;&amp; t.d == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// PortraitUpsideDown</span><br>            degress = <span class="hljs-number">270</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.a == <span class="hljs-number">1.0</span> &amp;&amp; t.b == <span class="hljs-number">0</span> &amp;&amp; t.c == <span class="hljs-number">0</span> &amp;&amp; t.d == <span class="hljs-number">1.0</span>) &#123;<br>            <span class="hljs-comment">// LandscapeRight</span><br>            degress = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.a == <span class="hljs-number">-1.0</span> &amp;&amp; t.b == <span class="hljs-number">0</span> &amp;&amp; t.c == <span class="hljs-number">0</span> &amp;&amp; t.d == <span class="hljs-number">-1.0</span>) &#123;<br>            <span class="hljs-comment">// LandscapeLeft</span><br>            degress = <span class="hljs-number">180</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> degress;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>开始读写</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[reader startReading];<br>[writer startWriting];<br>[writer startSessionAtSourceTime:KCMTimeZero];<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>设置写入的队列，注意音频、视频写入的队列要一样的，并且是<code>FIFO</code>队列。因为是写入同一个<code>writer</code>，如果用并发，会出现<code>reader</code>的状态不对，导致崩溃</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_queue_t</span> writeQueueCreate = dispatch_queue_create(<span class="hljs-string">&quot;writeQueueCreate&quot;</span>, DISPATCH_QUEUE_SERIAL);<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>视频逐帧写入</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dispatch_group_t group = dispatch_group_create();<br>dispatch_group_enter(group);<br>[videoInout requestMediaDataWhenReadyOnQueue:writeQueueCreate  usingBlock:^&#123;<br>  <span class="hljs-keyword">while</span> ([videoInput isReadyForMoreMediaData]) &#123;<br>    <span class="hljs-built_in">CMSampleBufferRef</span> sampleBuffer;<br>    <span class="hljs-keyword">if</span> ([reader status] == <span class="hljs-built_in">AVAssetReaderStatusReading</span> &amp;&amp; (sampleBuffer = [videoOutput copyNextSampleBuffer]))&#123;<br>      <span class="hljs-built_in">BOOL</span> result = [videoInput appendSampleBuffer:sampleBuffer];<br>      <span class="hljs-built_in">CFRelease</span>(sampleBuffer);<br>      <span class="hljs-keyword">if</span> (!result) &#123;<br>        [reader cancelReading];<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    [videoInput markAsFinished];<br>    dispatch_group_leave(group);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;];<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>音频逐帧写入</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dispatch_group_enter(group);<br>[audioInout requestMediaDataWhenReadyOnQueue:writeQueueCreate  usingBlock:^&#123;<br>  <span class="hljs-keyword">while</span> ([audioInput isReadyForMoreMediaData]) &#123;<br>    <span class="hljs-built_in">CMSampleBufferRef</span> sampleBuffer;<br>    <span class="hljs-keyword">if</span> ([reader status] == <span class="hljs-built_in">AVAssetReaderStatusReading</span> &amp;&amp; (sampleBuffer = [audioOutput copyNextSampleBuffer]))&#123;<br>      <span class="hljs-built_in">BOOL</span> result = [audioInput appendSampleBuffer:sampleBuffer];<br>      <span class="hljs-built_in">CFRelease</span>(sampleBuffer);<br>      <span class="hljs-keyword">if</span> (!result) &#123;<br>        [reader cancelReading];<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    [audioInput markAsFinished];<br>    dispatch_group_leave(group);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;];<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>完成压缩</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dispatch_group_notify(group,dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAYLT,<span class="hljs-number">0</span>),^&#123;<br>  <span class="hljs-keyword">if</span> ([reader status] == <span class="hljs-built_in">AVAssetReaderStatusReading</span>)&#123;<br>    [reader cancelReading];<br>  &#125;<br>  <span class="hljs-keyword">switch</span> (writer.status) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVAssetWriterStatusWriting</span>:<br>      &#123;<br>        [writer finishWritingWithCompletionHandler:^&#123;<br>          <br>        &#125;];<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>图层几何学</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%B1%82%E5%87%A0%E4%BD%95%E5%AD%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图层布局"><a href="#图层布局" class="headerlink" title="图层布局"></a>图层布局</h2><blockquote>
<p>UIView有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，CALayer对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。<code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>（也可以理解为中心）所在的位置。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>下图显示了这些属性是如何展示的：<br><img src="1.png" alt="img"></p>
</li>
<li><p>视图的<code>frame</code> ，<code>bounds</code>和<code>center</code>属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<ul>
<li>对于视图或者图层而言，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，<code>frame</code>都会变化。相反，改变frame的值同样会影响到他们当中的值</li>
<li>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了,具体见下图</li>
</ul>
</li>
</ul>
<p><img src="2.png" alt="img"></p>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><blockquote>
<p>视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置。默认来说<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。对于UIView而言，没有暴露<code>anchorPoint</code>,只有center；而图层的暴露出来了，<code>anchorPoint</code>可以被移动。anchorPoint为单位坐标</p>
</blockquote>
<p><img src="3.png" alt="img"></p>
<ul>
<li>改变<code>anchorPoint</code>，图层的内容会向右下角的<code>position</code>方向移动，而并不是居中了;图中当改变anchorPoint，position是<code>anchorPoint</code>与父图层的位置，由于锚点的变化，相对位置的基础点，发生改变（从原来中心点，变成了右上角），图层右下角移动，frame改变了。</li>
<li><code>anchorPoint</code>属性为锚点，一般在<code>transform</code>图层旋转中常用到，作为旋转的基点.</li>
</ul>
<h3 id="Z坐标轴"><a href="#Z坐标轴" class="headerlink" title="Z坐标轴"></a>Z坐标轴</h3><blockquote>
<p>和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了<code>position</code>和<code>anchorPoint</code>属性之外，CALayer还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
</blockquote>
<ul>
<li><code>zPosition</code>常用的地方<ul>
<li><code>CATransform3D</code>,在三维空间移动和旋转图层</li>
<li>改变图层的显示顺序<ul>
<li>通常，图层是根据它们子图层的sublayers出现的顺序来类绘制的，后被绘制上的图层将会遮盖住之前的图层。</li>
<li>但是通过增加图层的<code>zPosition</code>,可以把图层前置显示，在其他图层的前面，（图层是很薄的，在这里只用提高一个像素即可实现前置）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图层中常用的方法"><a href="#图层中常用的方法" class="headerlink" title="图层中常用的方法"></a>图层中常用的方法</h2><blockquote>
<p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。这里有两个常见的方法帮处理事件：</p>
<ol>
<li><code>-containsPoint:</code></li>
<li><code>-hitTest:</code></li>
</ol>
</blockquote>
<ul>
<li><code>-containsPoint:</code>,接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层frame范围内就返回YES</li>
<li><code>-hitTest:</code>,方法同样接受一个<code>CGPoint</code>类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。<ul>
<li><code>注意</code>当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上<code>图层的顺序</code>，但不能改变<code>事件传递的顺序</code>。</li>
<li>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。</li>
</ul>
</li>
</ul>
<h2 id="图层的视觉效果展示"><a href="#图层的视觉效果展示" class="headerlink" title="图层的视觉效果展示"></a>图层的视觉效果展示</h2><blockquote>
<p>一些常用的视觉显示所需要的图层属性</p>
</blockquote>
<ol>
<li><p>圆角:</p>
<ol>
<li><code>cornerRadius</code>,控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角）</li>
<li><code> masksToBounds</code>,默认情况下，<code>cornerRadius</code>只影响背景颜色而不影响背景图片或是子图层,把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会受到影响，被截取。</li>
</ol>
</li>
<li><p>图层边框</p>
<ol>
<li><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0</li>
<li><code>borderColor</code>定义了边框的颜色，默认为黑色。(CGColorRef类型，而不是UIColor)</li>
</ol>
</li>
<li><p>阴影</p>
<ol>
<li><code>shadowOpacity</code>:给<code>shadowOpacity</code>属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下</li>
<li><code>shadowColor</code>属性控制着阴影的颜色,(CGColorRef),默认是黑色</li>
<li><code>shadowOffset</code>属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。默认值是 {0, -3}(Mac与iphone的y轴颠倒的，因此在mac上是向下，而iphone是向上)</li>
<li><code>shadowRadius</code>属性控制着阴影的模糊度，为0的时候，阴影就和视图一样有一个非常确定的边界线，当值越来越大的时候，边界线看上去就会越来越模糊和自然。<ol>
<li>注意，阴影通常就是在layer的边界之外，如果开启masksToBounds属性，所有从图层中突出来的内容都会被裁剪掉，阴影也就不存在了</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="shadowPath属性"><a href="#shadowPath属性" class="headerlink" title="shadowPath属性"></a><code>shadowPath</code>属性</h3><blockquote>
<p><code>shadowPath</code>属性,图层阴影是从图层内容的形状继承而来,实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候</p>
</blockquote>
<ol>
<li>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。<ol>
<li><code>shadowPath</code>是一个<code>CGPathRef</code>类型(一个指向CGPath的指针)。CGPath是一个<code>Core Graphics</code>对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</li>
<li>代码</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">//enable layer shadows<br>  self.layerView1.layer.shadowOpacity = 0.5f;<br>  self.layerView2.layer.shadowOpacity = 0.5f;<br><br>  //方形的阴影<br>  CGMutablePathRef squarePath = CGPathCreateMutable();<br>  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);<br>  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);<br><br>  ￼//圆形的阴影<br>  CGMutablePathRef circlePath = CGPathCreateMutable();<br>  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);<br>  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS核心动画技巧</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/iOS%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CALayer和UIView的区别"><a href="#CALayer和UIView的区别" class="headerlink" title="CALayer和UIView的区别"></a>CALayer和UIView的区别</h2><blockquote>
<p><code>CALayer</code>类在概念上和<code>UIView</code>类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和<code>UIView</code>最大的不同是<code>CALayer</code>不处理用户的交互。<code>CALayer</code>并不清楚具体的<em>响应链</em>（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
</blockquote>
<span id="more"></span>

<h3 id="平行层级关系"><a href="#平行层级关系" class="headerlink" title="平行层级关系"></a>平行层级关系</h3><ul>
<li><p>每一个<code>UIview</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<em>backing layer</em>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作</p>
</li>
<li><p>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，<code>UIView</code>仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
</li>
<li><p>但是为什么iOS要基于<code>UIView</code> 和 <code>CALayer</code></p>
<p>提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？</p>
<ul>
<li>原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和<code>UIView</code>，但是Mac OS有AppKit和<code>NSView</code>的原因。他们功能上很相似，但是在实现上有着显著的区别。</li>
<li>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</li>
</ul>
</li>
<li><p>图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些<code>UIView</code>没有暴露出来的CALayer的功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
</li>
</ul>
<h3 id="CALayer一些特殊属性"><a href="#CALayer一些特殊属性" class="headerlink" title="CALayer一些特殊属性"></a>CALayer一些特殊属性</h3><h3 id="contents属性"><a href="#contents属性" class="headerlink" title="contents属性"></a>contents属性</h3><ul>
<li>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</li>
<li>事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的<code>contents</code>，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象(OC对象)，而是一个Core Foundation类型。实际要用<code>layer.contents = (__bridge id)image.CGImage;</code></li>
</ul>
<h3 id="contentsGravity"><a href="#contentsGravity" class="headerlink" title="contentsGravity"></a>contentsGravity</h3><blockquote>
<p>对于加载的图片无法适应视图时，对于UIimageView有一个contentMode属性，<code>view.contentMode = UIViewContentModeScaleAspectFit;</code>，而CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。</p>
</blockquote>
<ul>
<li><code>self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</code>，<code>kCAGravityResizeAspect</code>，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</li>
</ul>
<h3 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h3><blockquote>
<p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。它的优先级要低于了<code>contentsGravity</code>。</p>
</blockquote>
<ul>
<li><code>contentsScale</code>属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置<code>contentsGravity</code>属性）。UIView有一个类似功能但是非常少用到的<code>contentScaleFactor</code>属性。</li>
<li>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕</li>
<li>这并不会对我们在使用<code>kCAGravityResizeAspect</code>时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把<code>contentsGravity</code>设置为<code>kCAGravityCenter</code>（这个值并不会拉伸图片）。</li>
<li>和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。可以通过设置<code>self.layerView.layer.contentsScale = image.scale;</code></li>
</ul>
<h3 id="maskToBounds"><a href="#maskToBounds" class="headerlink" title="maskToBounds"></a>maskToBounds</h3><blockquote>
<p>默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。UIView有一个叫做<code>clipsToBounds</code>的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做<code>masksToBounds</code>。</p>
</blockquote>
<h3 id="contentsRect"><a href="#contentsRect" class="headerlink" title="contentsRect"></a>contentsRect</h3><blockquote>
<p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比<code>contentsGravity</code>灵活多了和<code>bounds</code>，<code>frame</code>不同，<code>contentsRect</code>不是按点来计算的，它使用了<em>单位坐标</em>，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。</p>
</blockquote>
<ul>
<li>iOS使用了以下的坐标系统：<ol>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ol>
</li>
<li>默认的<code>contentsRect</code>是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪。事实上给<code>contentsRect</code>设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</li>
<li>可以通过<code>contentsRect</code>从大图中截取小图，分给其他的视图（1个image，分给不同的视图显示），因为单张大图比多张小图载入地更快，可以有效地提高了载入性能</li>
</ul>
<h3 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h3><blockquote>
<p><code>contentsCenter</code>其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
</blockquote>
<ul>
<li>默认情况下，<code>contentsCenter</code>是{0, 0, 1, 1}，这意味着如果大小（由<code>conttensGravity</code>决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。下图展示了<code>contentsCenter</code>设置为{0.25, 0.25, 0.5, 0.5}的效果。</li>
</ul>
<p><img src="1.png" alt="img"></p>
<h2 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h2><blockquote>
<p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
</blockquote>
<ul>
<li><p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
</li>
<li><p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费。这为屏外渲染而非GPU渲染</p>
</li>
<li><p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来(屏外渲染的缓存区)直到它需要被更新（通常是因为开发者调用了<code>-setNeedsDisplay</code>方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
</li>
<li><p>CALayer有一个可选的<code>delegate</code>属性，实现了<code>CALayerDelegate</code> 协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议（凡是NSObject或其子类的类别，都是非正式协议）。其代理方法有：</p>
<ul>
<li><code>- (void)displayLayer:(CALayerCALayer *)layer;</code></li>
<li><code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</code></li>
<li>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</li>
</ul>
</li>
<li><p>当使用寄宿了视图的图层的时候，你也不必实现<code>-displayLayer:</code>和<code>-drawLayer:inContext:</code>方法来绘制你的寄宿图。通常做法是实现UIView的<code>-drawRect:</code>方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用<code>-display</code>方法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>碎片化笔记</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A2%8E%E7%89%87%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>记录偶尔发现有用的知识点</p>
</blockquote>
<span id="more"></span>

<h2 id="delegate能一对多吗"><a href="#delegate能一对多吗" class="headerlink" title="delegate能一对多吗"></a>delegate能一对多吗</h2><ul>
<li><p>在不同控制页面实现同一代理，并且执行代理的类为单例执行；代码验证时发现</p>
<ul>
<li>尽管为单例，但是其属性<code>delegate</code>为唯一，与当前控制页是相互持有关系，因此，在页面1时，只会执行页面1上的代理方法；</li>
<li>当从页面1进入页面2后，<code>delegate</code>的对象变成了页面2，因此，在页面2时，只会执行页面2上的代理方法</li>
<li>当从页面2退到页面1后，页面1销毁，由于为weak，弱引用，在页面1上也不会执行代理方法，被销毁的页面2上更不会执行了</li>
</ul>
</li>
<li><p>通过相关的设计也可以实现一对多的关系</p>
<ol>
<li><p>用多播代理的方式，多播代理相比一般的只是多了一个中间层，由中间层实现代理，获取数据；中间层与控制器之间</p>
<ol>
<li>用一个block数组，作为中间层单例的属性</li>
<li>在其他控制器中，都设置一个回调的block，并将该block添加到数组中</li>
<li>在中间层实现代理获取数据的时候，遍历这个blcok数组，将数据进行分发</li>
</ol>
</li>
<li><p>1个代理在多个页面内实现，</p>
<ol>
<li><p>关键点在于</p>
<ol>
<li>协议名称和对象构成一个健值对，形成1-1对应关系</li>
<li><code>NSPointerArray</code>的使用，使得弱引用对象，且在对象释放时自动删除<code>NSPointerArray</code>中的元素。</li>
</ol>
</li>
<li><p>使用</p>
<ol>
<li><p>将其他页面要实现的代理同样均设为一个单例消息分发中心，有一个字典数据(键为协议，值为<code>NSPointerArray</code>，数组中存有各个页面的对象)</p>
</li>
<li><p>在一个页面触发代理后，首先会实现代理的消息分发中心是否实现了，在这里是没有实现相关的代理方法的，</p>
<ol>
<li><p>借助</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;<br></code></pre></td></tr></table></figure>

<p>，判断本管理对象是否可以响应方法</p>
<ol>
<li>如果存的<code>pointArray</code>中可以响应方法则返回YES</li>
</ol>
</li>
<li><p>下面有两种方式实现</p>
<ol>
<li>借助<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</code>以及<code>-(void)forwardInvocation:(NSInvocation *)anInvocation;</code>（这两个方法是一起的）。可以实现在多个未销毁页面中，同时实现代理，达成通知的效果，实现消息的分发</li>
<li>也可以单独实现<code>- (id)forwardingTargetForSelector:(SEL)aSelector;</code>（返回未识别消息应首先指向的对象（本来默认是向上传的）），但这是在相应的NSPointArray中找到能实现该方法的对象，只能实现消息的转发，在多个页面的对象中找到真正一个能响应该方法的</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><hr>
<blockquote>
<p>众所周知，当某个对象持有着一个Block的时候，如果在Block内部使用强引用反过来持有这个对象，就会导致引用循环。为了避免引用循环，可以使用__weak修饰符。</p>
</blockquote>
<h4 id="block中的引用"><a href="#block中的引用" class="headerlink" title="block中的引用"></a>block中的引用</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br><span class="hljs-keyword">self</span>.block = ^&#123;<br>  _<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) strongSelf = weakSelf;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>C语言编译后可以发现，<code>Block</code>本身对<code>self</code>的引用仍然只是弱引用，并不造成引用循环</li>
<li><code>strongSelf</code>只存在于Block对应的函数里，它的生命周期只在这个函数执行的过程中，函数执行前它不会存在，函数执行完它立刻就被释放了.因此<ol>
<li>如果函数执行前self变为nil了，那么函数不会执行，没有任何引用循环发生；</li>
<li>如果函数执行过程中self变为nil了，那么函数一开始声明的strongSelf会暂时持有着self，此时会有一个暂时的引用循环。当函数执行完（即是Block执行完），strongSelf超出作用域被释放，引用循环从这里开始打破。接下来，由于没有任何强引用持有self了，于是self被释放，最后Block也因为没有任何强引用持有它也被释放了。所有对象就都被顺利释放了。</li>
</ol>
</li>
</ol>
<h5 id="解决block循环引用"><a href="#解决block循环引用" class="headerlink" title="解决block循环引用"></a>解决block循环引用</h5><ol>
<li>通过Weak修饰的方式来处理的。 weak是弱引用，用weak来修饰、描述所引用对象的计数器并不会加1，weak会在引用对象被释放的时候自动置为nil</li>
<li><code>__block</code>修饰变量，依赖于中介者模式，属于手动释放。其实现是通过<code>__block</code>修饰对象，因为<code>__block</code>修饰的对象是可以改变的，可以在block中手动的释放掉引用的对象</li>
<li>直接将对象作为参数，直接将对象作为参数传入了block中，block中并没有对对象进行持有，因此也不会造出循环引用的问题</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">typedef void(^TBlock)(ViewController *); <br>@property(nonatomic, copy) TBlock tBlock; <br>self.tBlock = ^(ViewController *vc)&#123; <br>  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(),    ^&#123; <br>       NSLog(@&quot;%@&quot;,vc.name);<br>   &#125;);<br> &#125;; <br>self.tBlock(self);<br><br></code></pre></td></tr></table></figure>

<ol start="4">
<li><code>NSProxy</code>转发消息打破循环引用，实际上也是使用了<code>weak</code>修饰,在<code>NSProxt</code>中使用了<code>weak</code>来修饰对象属性</li>
</ol>
<h4 id="block中变量捕获"><a href="#block中变量捕获" class="headerlink" title="block中变量捕获"></a>block中变量捕获</h4><ol>
<li>局部变量捕获瞬时值,局部静态变量捕获指针。</li>
<li>全局变量、全局静态变量直接使用不捕获</li>
<li>成员变量是指针捕获</li>
<li>_block修饰自动变量，会将本来传值的，变为地址</li>
</ol>
<h3 id="UIView用weak修饰还是strong修饰"><a href="#UIView用weak修饰还是strong修饰" class="headerlink" title="UIView用weak修饰还是strong修饰"></a>UIView用weak修饰还是strong修饰</h3><hr>
<ol>
<li>从stroryboard中拖出来的控件一般用weak来修饰，这么做的原因是因为stroryboard已经持有控件的，引用计数已经加1了，不需要在用strong时引用数加1，但是用strong修饰也可以，因为在控制器销毁后，不管是strong还是weak，引用计数都会变为0。</li>
<li>在控制器中手写UI也可以用weak修饰，因为subViews为copy修饰的强引用数组，因为会持有控件，但是要注意一定要在addSubview作用范围内进行赋值属性，否则出来作用范围，由于用weak修饰，属性的引用计数为0，会销毁掉；同样用strong修饰的话也可以，在控制器销毁后，不管是strong还是weak，引用计数都会变为0<ol>
<li>注意这里的不能直接对成员变量进行赋值，否则会直接提醒无引用计数，要设置一个临时变量，这样临时变量会暂时持有，等addsubview添加后，由控制器持有</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>零碎知识点</category>
      </categories>
  </entry>
</search>
