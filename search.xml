<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>泛型原理</title>
    <url>/2023/07/02/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型底层原理"><a href="#泛型底层原理" class="headerlink" title="泛型底层原理"></a>泛型底层原理</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">func testGenric&lt;T&gt;(_ value: T) -&gt; T &#123;<br>    let tmp = value<br>    return value<br>&#125;<br><br>testGenric(10)<br></code></pre></td></tr></table></figure>

<ul>
<li>对于编译器来说，它不知道<code>T</code>到底是什么具体的类型（可能是值类型，也可能是引用类型）,那编译器就不知道 <code>tmp</code> / <code>value</code> 到底分配多少内存空间、步长是多少、对齐的字段是多少…只有当真正传递参数才知道真实类型。</li>
<li>那<code>tmp</code>在方法栈占据内存空间编译器是怎么决断的</li>
</ul>
<h3 id="IR分析"><a href="#IR分析" class="headerlink" title="IR分析"></a>IR分析</h3><blockquote>
<p>将代码编译成IR格式分析</p>
</blockquote>
<ul>
<li><p><code>main</code>函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define i32 <span class="hljs-keyword">@main</span>(i32 <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span><span class="hljs-type">TSi</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span><span class="hljs-type">TSi</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to i8<span class="hljs-operator">*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.start.p0i8(i64 <span class="hljs-number">8</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>)<br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.start.p0i8(i64 <span class="hljs-number">8</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">6</span>)<br>  <span class="hljs-operator">%</span>._value <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span><span class="hljs-type">TSi</span>, <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br>  store i64 <span class="hljs-number">10</span>, i64<span class="hljs-operator">*</span> <span class="hljs-operator">%</span>._value, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span><br>  <span class="hljs-comment">//调用函数</span><br>  call swiftcc void @<span class="hljs-string">&quot;$s10Genericity10testGenricyxxlF&quot;</span>(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture sret(<span class="hljs-operator">%</span>swift.opaque) <span class="hljs-operator">%</span><span class="hljs-number">7</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture <span class="hljs-operator">%</span><span class="hljs-number">8</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$sSiN&quot;</span>)<br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.end.p0i8(i64 <span class="hljs-number">8</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">9</span>)<br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.end.p0i8(i64 <span class="hljs-number">8</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">10</span>)<br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>实际泛型函数<code>s10Genericity10testGenricyxxlF</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define hidden swiftcc void @<span class="hljs-string">&quot;$s10Genericity10testGenricyxxlF&quot;</span>(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture sret(<span class="hljs-operator">%</span>swift.opaque) <span class="hljs-operator">%</span><span class="hljs-number">0</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-type">T1</span> <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span>tmp.debug <span class="hljs-operator">=</span> alloca i8<span class="hljs-operator">*</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>tmp.debug to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.memset.p0i8.i64(i8<span class="hljs-operator">*</span> align <span class="hljs-number">8</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i8 <span class="hljs-number">0</span>, i64 <span class="hljs-number">8</span>, i1 <span class="hljs-literal">false</span>)<br>  <span class="hljs-operator">%</span>value.debug <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>value.debug to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.memset.p0i8.i64(i8<span class="hljs-operator">*</span> align <span class="hljs-number">8</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span>, i8 <span class="hljs-number">0</span>, i64 <span class="hljs-number">8</span>, i1 <span class="hljs-literal">false</span>)<br>  store <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-type">T1</span>, align <span class="hljs-number">8</span><br><span class="hljs-comment">//类型T</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span> to i8<span class="hljs-operator">***</span><br><span class="hljs-operator">/</span>类型<span class="hljs-type">T向前偏移向前移动</span><span class="hljs-operator">-</span><span class="hljs-number">1</span>的位置<br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> getelementptr inbounds i8<span class="hljs-operator">**</span>, i8<span class="hljs-operator">***</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, i64 <span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-comment">//valueWitnesses是值见证表记录着size、stride、aligment、内存管理的函数</span><br>  <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses <span class="hljs-operator">=</span> load i8<span class="hljs-operator">**</span>, i8<span class="hljs-operator">***</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span>, <span class="hljs-operator">!</span>dereferenceable <span class="hljs-operator">!</span><span class="hljs-number">19</span><br><span class="hljs-comment">//将存储值的valueWitnesses转换为swift.vwtable值见证表类型</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses to <span class="hljs-operator">%</span>swift.vwtable<span class="hljs-operator">*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.vwtable, <span class="hljs-operator">%</span>swift.vwtable<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">6</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span>size <span class="hljs-operator">=</span> load i64, i64<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">7</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> alloca i8, i64 <span class="hljs-operator">%</span>size, align <span class="hljs-number">16</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.start.p0i8(i64 <span class="hljs-operator">-</span><span class="hljs-number">1</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span>)<br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span><br>  store i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>tmp.debug, align <span class="hljs-number">8</span><br>  store <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>value.debug, align <span class="hljs-number">8</span><br><span class="hljs-comment">//从值见证表中获取initializeWithCopy</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> getelementptr inbounds i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses, i32 <span class="hljs-number">2</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">11</span> <span class="hljs-operator">=</span> load i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">10</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span><br>  <span class="hljs-operator">%</span>initializeWithCopy <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">11</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> (<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">12</span> <span class="hljs-operator">=</span> call <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> <span class="hljs-operator">%</span>initializeWithCopy(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">9</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>) #<span class="hljs-number">3</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> call <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> <span class="hljs-operator">%</span>initializeWithCopy(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">0</span>, <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>) #<span class="hljs-number">3</span><br><span class="hljs-comment">//从值见证表中获取destroy</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> getelementptr inbounds i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses, i32 <span class="hljs-number">1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">15</span> <span class="hljs-operator">=</span> load i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">14</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span><br>  <span class="hljs-operator">%</span>destroy <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">15</span> to void (<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span><br>  call void <span class="hljs-operator">%</span>destroy(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias <span class="hljs-operator">%</span><span class="hljs-number">9</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-type">T</span>) #<span class="hljs-number">3</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">16</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">9</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.end.p0i8(i64 <span class="hljs-operator">-</span><span class="hljs-number">1</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">16</span>)<br>  ret void<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在调用<code>testGenric</code>时候可以看到一个值见证表<code>valueWitnesses</code>，并且可以看出到<code>initializeWithCopy</code>、<code>destroy</code>等函数都是从值见证表来的，所以泛型是通过<code>ValueWitnessTable</code>(<code>swift.vwtable</code>)去管理内存的。</p>
<ul>
<li>前面的几个<code>i8*</code>其实就是<code>void *</code>代表内存管理函数，剩下的就是<code>size</code>、<code>stride</code>、<code>flags</code>、<code>extraInhabitantCount</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">%</span>swift.type <span class="hljs-operator">=</span> type &#123; i64 &#125;<br><span class="hljs-operator">%</span><span class="hljs-type">TSi</span> <span class="hljs-operator">=</span> type <span class="hljs-operator">&lt;</span>&#123; i64 &#125;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">%</span>swift.opaque <span class="hljs-operator">=</span> type opaque<br><span class="hljs-operator">%</span>swift.vwtable <span class="hljs-operator">=</span> type &#123; i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">*</span>, i64, i64, i32, i32 &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类型<code>T</code>(<code>metaData</code>)向前偏移一个指针位置可以拿到<code>ValueWitnessTable</code>,即见证表是在<code>metaData</code>向前减1的位置</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//类型T向前偏移向前移动-1的位置</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> getelementptr inbounds i8<span class="hljs-operator">**</span>, i8<span class="hljs-operator">***</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, i64 <span class="hljs-operator">-</span><span class="hljs-number">1</span><br>  <span class="hljs-comment">//valueWitnesses是值见证表记录着size、stride、aligment、内存管理的函数</span><br>  <span class="hljs-operator">%</span><span class="hljs-type">T</span>.valueWitnesses <span class="hljs-operator">=</span> load i8<span class="hljs-operator">**</span>, i8<span class="hljs-operator">***</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, align <span class="hljs-number">8</span>, <span class="hljs-operator">!</span>invariant.load <span class="hljs-operator">!</span><span class="hljs-number">18</span>, <span class="hljs-operator">!</span>dereferenceable <span class="hljs-operator">!</span><span class="hljs-number">19</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValueWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> unknow1: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow2: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow3: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow4: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow5: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow6: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow7: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow8: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> size: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> stride: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> extraInhabitantCount: <span class="hljs-type">UInt32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>不管<code>testGenric</code>函数的参数传递的是<code>值</code>/<code>引用</code>类型，不管什么类型，总之它的<code>metadata</code>一定有<code>ValueWitnessTable</code>,并且保存着这个类型的<code>size</code>、<code>stride</code>、<code>flags</code>、<code>extraInhabitantCount</code>还有一些内存管理函数等信息。</li>
</ul>
<h3 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h3><ul>
<li><p>验证，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>        <span class="hljs-keyword">var</span> year <span class="hljs-operator">=</span> <span class="hljs-number">2023</span><br>    &#125;<br><br>    <span class="hljs-comment">// 所有类型的最终基类 Metadata</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <span class="hljs-comment">// kind用于区分类型的</span><br>&#125;<br><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br><br><span class="hljs-comment">//偏移指针的大小，8</span><br>    <span class="hljs-keyword">let</span> valueWitnessTable <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(ptr).advanced(by: <span class="hljs-operator">-</span><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size).assumingMemoryBound(to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">ValueWitnessTable</span>&gt;.<span class="hljs-keyword">self</span>).pointee<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size) <span class="hljs-comment">// 8</span><br><span class="hljs-comment">//相差0x60, 偏移的0x8 + ValueWitnessTable本身的大小是0x58</span><br><span class="hljs-built_in">print</span>(ptr,valueWitnessTable) <span class="hljs-comment">// 0x00000001000191a8 0x0000000100019148</span><br><br><span class="hljs-built_in">print</span>(valueWitnessTable.pointee.size) <span class="hljs-comment">// 16 如果只有age则是8</span><br><br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow1) <span class="hljs-comment">// 0x0000000100004b80</span><br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow2) <span class="hljs-comment">// 0x0000000100004930</span><br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow3) <span class="hljs-comment">// 0x0000000100004b80</span><br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow4)<br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow5)<br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow6)<br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow7)<br>    <span class="hljs-built_in">print</span>(valueWitnessTable.pointee.unknow8) <br><br></code></pre></td></tr></table></figure></li>
<li><p>通过<code>cat address 0x0000000100004b80</code>指令打印出函数名</p>
</li>
</ul>
<h4 id="最终结构"><a href="#最终结构" class="headerlink" title="最终结构"></a>最终结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValueWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> initializeBufferWithCopyOfBuffer: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> destroy: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> initializeWithCopy: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> assignWithCopy: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> initializeWithTake: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> assignWithTake: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> getEnumTagSinglePayload: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> storeEnumTagSinglePayload: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> size: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> stride: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> extraInhabitantCount: <span class="hljs-type">UInt32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里的<code>initializeWithCopy</code>方法和<code>destroy</code>即之前，<code>IR分析</code>中对应的方法,</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>泛型是通过<code>ValueWitnessTable</code> (简称<code>VWT</code> 是由编译器产生的) 来进行内存管理，<code>VWT</code>存储了<code>size</code>、<code>stride</code>、<code>alignment</code>和一些内存管理函数等；</li>
<li>对于值类型来说，实际上是通过内存的拷贝；<code>copy/move</code>等操作；</li>
<li>对于引用类型来说，就是堆区内存块的引用，通过引用计数的方式。</li>
</ul>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><h3 id="泛型中传递的参数是泛型"><a href="#泛型中传递的参数是泛型" class="headerlink" title="泛型中传递的参数是泛型"></a>泛型中传递的参数是泛型</h3><ul>
<li>例子,编译成<code>IR</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>()</span> -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>(<span class="hljs-params">mount</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> mount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genric</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>)</span> &#123;    <br>&#125;<br><br><span class="hljs-keyword">let</span> increment <span class="hljs-operator">=</span> makeIncrementer()<br>genric(t: increment)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="IR分析-1"><a href="#IR分析-1" class="headerlink" title="IR分析"></a><code>IR</code>分析</h3><ul>
<li><p><code>main</code>函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define i32 <span class="hljs-keyword">@main</span>(i32 <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span>swift.function, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to i8<span class="hljs-operator">*</span><br>  <span class="hljs-comment">//调用makeIncrementer，生成闭包</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> call swiftcc &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; @<span class="hljs-string">&quot;$s10Genericity15makeIncrementerS2icyF&quot;</span>()<br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> extractvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">4</span>, <span class="hljs-number">0</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> extractvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">4</span>, <span class="hljs-number">1</span><br>  <br>  <span class="hljs-comment">// 将指针存储到increment变量里</span><br>  store i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, i8<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s10Genericity9incrementyS2icvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), align <span class="hljs-number">8</span><br>  <br>  <span class="hljs-comment">// 将捕获的变量存储到increment变量里</span><br>  store <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">6</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s10Genericity9incrementyS2icvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span>), align <span class="hljs-number">8</span><br>  <br>  <span class="hljs-comment">// 把function类型转换成void *</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.start.p0i8(i64 <span class="hljs-number">16</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">7</span>)<br>  <br>  <span class="hljs-comment">// 从increment变量取出指针和捕获的变量</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> load i8<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s10Genericity9incrementyS2icvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s10Genericity9incrementyS2icvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span>), align <span class="hljs-number">8</span><br>  <br>  <span class="hljs-comment">// 一些内存管理的函数</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> call <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-meta">@swift_retain</span>(<span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> returned <span class="hljs-operator">%</span><span class="hljs-number">9</span>) #<span class="hljs-number">3</span><br>  <br>  <span class="hljs-comment">// swift_allocObject创建了堆区的内存空间</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">11</span> <span class="hljs-operator">=</span> call noalias <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-meta">@swift_allocObject</span>(<span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.full_boxmetadata, <span class="hljs-operator">%</span>swift.full_boxmetadata<span class="hljs-operator">*</span> <span class="hljs-meta">@metadata</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">2</span>), i64 <span class="hljs-number">32</span>, i64 <span class="hljs-number">7</span>) #<span class="hljs-number">4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">12</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">11</span> to <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, <span class="hljs-operator">%</span>swift.function &#125;<span class="hljs-operator">&gt;*</span><br>  <br>  <span class="hljs-comment">// 取出第一个成员是function这个结构体</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, <span class="hljs-operator">%</span>swift.function &#125;<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, <span class="hljs-operator">%</span>swift.function &#125;<span class="hljs-operator">&gt;*</span> <span class="hljs-operator">%</span><span class="hljs-number">12</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br>  <br>  <span class="hljs-comment">// 从function这个结构体取出函数地址</span><br>  <span class="hljs-operator">%</span>.fn <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">13</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br>  store i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.fn, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span>.data <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">13</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br>  store <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">9</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.data, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span>.fn1 <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br>  store i8<span class="hljs-operator">*</span> bitcast (void (<span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span>, <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$sS2iIegyd_S2iIegnr_TRTA&quot;</span> to i8<span class="hljs-operator">*</span>), i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.fn1, align <span class="hljs-number">8</span><br>  <br>  <span class="hljs-operator">%</span>.data2 <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br>  store <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">11</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.data2, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to <span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span><br>  <br>  <span class="hljs-comment">// 后面又对这个function又做了一层重新的抽象</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">15</span> <span class="hljs-operator">=</span> call <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-meta">@__swift_instantiateConcreteTypeFromMangledName</span>(&#123; i32, i32 &#125;<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$sS2icMD&quot;</span>) #<span class="hljs-number">15</span><br>  call swiftcc void @<span class="hljs-string">&quot;$s10Genericity6genric1tyx_tlF&quot;</span>(<span class="hljs-operator">%</span>swift.opaque<span class="hljs-operator">*</span> noalias nocapture <span class="hljs-operator">%</span><span class="hljs-number">14</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">15</span>)<br>  <span class="hljs-operator">%</span>.data3 <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">16</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> <span class="hljs-operator">%</span>.data3, align <span class="hljs-number">8</span><br>  call void <span class="hljs-meta">@swift_release</span>(<span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">16</span>) #<span class="hljs-number">4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">17</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span> to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.lifetime.end.p0i8(i64 <span class="hljs-number">16</span>, i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">17</span>)<br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>可以看到<code>func genric&lt;T&gt;(t: T)</code> 当泛型参数接收一个<code>闭包/函数</code>时，会对这个<code>闭包/函数</code>原有数据结构上又抽象封装了一层。因为我们传入可能是是<code>函数</code>，也可能传入的是<code>闭包表达式</code>，编译器不知道呀，它就和协议设计一样不知道谁遵循了<code>协议</code>，所以它就抽象了<code>一层中间层</code>为了<code>泛型管理</code>统一区分类型。</p>
</li>
<li><p>当去调用的时候，是通过这个抽象出来的<code>中间层</code>来取调用，如果不调用而用来传值的话，依旧是通过上面的<code>ValueWitnessTable</code>进行内存管理的。（注意：<code>函数/闭包</code>也是引用类型）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genric</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>)</span> &#123;    <br>    <span class="hljs-comment">// VWT管理内存</span><br>    <span class="hljs-keyword">let</span> tmp <span class="hljs-operator">=</span> t<br>    <span class="hljs-comment">// 函数调用，抽象中间层统一管理函数/闭包</span><br>    <span class="hljs-keyword">var</span> t1 <span class="hljs-operator">=</span> t <span class="hljs-keyword">as!</span> (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span><br>    t1()<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>泛型参数接收闭包/函数后对其进行调用，又抽象一层封装的数据结构：<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 闭包作为泛型参数，又包装了一层</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ReabstractionThunkContext</span>&lt;<span class="hljs-title">Context</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">HeapObject</span><br>    <span class="hljs-keyword">var</span> function: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Context</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>闭包的结构<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClosureData</span>&lt;<span class="hljs-title">Box</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> ptr: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 闭包函数地址地址</span><br>    <span class="hljs-keyword">var</span> box: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Box</span>&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> object: <span class="hljs-type">HeapObject</span> <span class="hljs-comment">// 实例对象的内存地址</span><br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">T</span>  <span class="hljs-comment">//存的捕获的值</span><br>&#125;<br><br><span class="hljs-comment">///实例对象的内存地址</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> refcount1: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> refcount2: <span class="hljs-type">Int32</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="验证数据结构"><a href="#验证数据结构" class="headerlink" title="验证数据结构"></a>验证数据结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>()</span> -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>(<span class="hljs-params">mount</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> mount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genric</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">T</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">//给定的值初始化</span><br>    ptr.initialize(to: t)<br>    <br>    <span class="hljs-keyword">defer</span> &#123;<br>        ptr.deinitialize(count: <span class="hljs-number">1</span>)<br>        ptr.deallocate()<br>    &#125;<br>    <span class="hljs-comment">//降至进行绑定</span><br>    <span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">ReabstractionThunkContext</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt;&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; <span class="hljs-variable">$0</span> &#125;<br>    <span class="hljs-keyword">let</span> ctx <span class="hljs-operator">=</span> closure_ptr.pointee.box.pointee.function.box<br>    <span class="hljs-comment">//相比之前的block对象，包了一层</span><br>    <span class="hljs-built_in">print</span>(ctx.pointee.value) <span class="hljs-comment">// 10    得到捕获的外部变量的值</span><br>&#125;<br><br><span class="hljs-keyword">let</span> increment <span class="hljs-operator">=</span> makeIncrementer()<br>genric(t: increment)<br><br><span class="hljs-comment">//正常的闭包结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NoMeanStruct</span></span>&#123;<br>    <span class="hljs-keyword">var</span> closure: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-keyword">let</span> funcStruct <span class="hljs-operator">=</span> <span class="hljs-type">NoMeanStruct</span>(closure: increment)<br><span class="hljs-keyword">let</span> func_ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">NoMeanStruct</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>func_ptr.initialize(to: funcStruct)<br><br><span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> func_ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable">$0</span>.pointee &#125;<br><span class="hljs-built_in">print</span>(closure_ptr.box.pointee.value) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>协议分析</title>
    <url>/2023/06/26/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="协议方法调度"><a href="#协议方法调度" class="headerlink" title="协议方法调度"></a>协议方法调度</h1><blockquote>
<p>类的方法调度是通过函数表<code>v-table</code>的方式，那么类遵循协议方法的方法调度是如何的</p>
</blockquote>
<h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">MyProtocol</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">logInfo</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">something</span>: <span class="hljs-keyword">Any</span>)</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span>: <span class="hljs-title">MyProtocol</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">logInfo</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">something</span>: <span class="hljs-keyword">Any</span>)</span> &#123;<br>        <span class="hljs-built_in">print</span>(something)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t: <span class="hljs-type">Teacher</span> <span class="hljs-operator">=</span> <span class="hljs-type">Teacher</span>()<br>t.logInfo(<span class="hljs-string">&quot;123&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="sil"><a href="#sil" class="headerlink" title="sil"></a><code>sil</code></h3><ul>
<li><p><code>swiftc ProtocolText.swift -emit-sil -o ProtocolText.sil</code>,编译成<code>Sil</code>找到调用<code>logInfo</code>的地方</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// main</span><br>sil <span class="hljs-keyword">@main</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Int32</span>, <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="hljs-type">Int32</span> &#123;<br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$Int32</span>, <span class="hljs-operator">%</span><span class="hljs-number">1</span> : <span class="hljs-variable">$UnsafeMutablePointer</span><span class="hljs-operator">&lt;</span><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;<span class="hljs-operator">&gt;</span>):<br>  alloc_global @<span class="hljs-variable">$s12ProtocolText1tAA7TeacherCvp</span>   <span class="hljs-comment">// id: %2</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s12ProtocolText1tAA7TeacherCvp</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span> <span class="hljs-comment">// users: %7, %8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>              <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-comment">// function_ref Teacher.__allocating_init()</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$s12ProtocolText7TeacherCACycfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">Teacher</span> <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">5</span>(<span class="hljs-operator">%</span><span class="hljs-number">4</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">Teacher</span> <span class="hljs-comment">// user: %7</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">6</span> to <span class="hljs-operator">%</span><span class="hljs-number">3</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                      <span class="hljs-comment">// id: %7</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> begin_access [read] [<span class="hljs-keyword">dynamic</span>] <span class="hljs-operator">%</span><span class="hljs-number">3</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span> <span class="hljs-comment">// users: %9, %11</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span><span class="hljs-number">8</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                        <span class="hljs-comment">// users: %25, %21, %22, %10</span><br>  strong_retain <span class="hljs-operator">%</span><span class="hljs-number">9</span> : <span class="hljs-variable">$Teacher</span>                     <span class="hljs-comment">// id: %10</span><br>  end_access <span class="hljs-operator">%</span><span class="hljs-number">8</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                       <span class="hljs-comment">// id: %11</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">12</span> <span class="hljs-operator">=</span> alloc_stack <span class="hljs-variable">$Any</span>                          <span class="hljs-comment">// users: %24, %23, %22, %19</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> string_literal utf8 <span class="hljs-string">&quot;123&quot;</span>                 <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-number">3</span>          <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">15</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-operator">-</span><span class="hljs-number">1</span>         <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">16</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>               <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-comment">// function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">17</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">String</span> <span class="hljs-comment">// user: %18</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">18</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">17</span>(<span class="hljs-operator">%</span><span class="hljs-number">13</span>, <span class="hljs-operator">%</span><span class="hljs-number">14</span>, <span class="hljs-operator">%</span><span class="hljs-number">15</span>, <span class="hljs-operator">%</span><span class="hljs-number">16</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">String</span> <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">19</span> <span class="hljs-operator">=</span> init_existential_addr <span class="hljs-operator">%</span><span class="hljs-number">12</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>, <span class="hljs-variable">$String</span> <span class="hljs-comment">// user: %20</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">18</span> to <span class="hljs-operator">%</span><span class="hljs-number">19</span> : $<span class="hljs-operator">*</span><span class="hljs-type">String</span>                     <span class="hljs-comment">// id: %20</span><br>  <span class="hljs-comment">//调用Teacher.logInfo 方法</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">21</span> <span class="hljs-operator">=</span> class_method <span class="hljs-operator">%</span><span class="hljs-number">9</span> : <span class="hljs-variable">$Teacher</span>, #<span class="hljs-type">Teacher</span>.logInfo : (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; (), $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; () <span class="hljs-comment">// user: %22</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">22</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">21</span>(<span class="hljs-operator">%</span><span class="hljs-number">12</span>, <span class="hljs-operator">%</span><span class="hljs-number">9</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; ()<br>  destroy_addr <span class="hljs-operator">%</span><span class="hljs-number">12</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>                        <span class="hljs-comment">// id: %23</span><br>  dealloc_stack <span class="hljs-operator">%</span><span class="hljs-number">12</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>                       <span class="hljs-comment">// id: %24</span><br>  strong_release <span class="hljs-operator">%</span><span class="hljs-number">9</span> : <span class="hljs-variable">$Teacher</span>                    <span class="hljs-comment">// id: %25</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">26</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int32</span>, <span class="hljs-number">0</span>         <span class="hljs-comment">// user: %27</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">27</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int32</span> (%26 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int32</span>)      // <span class="hljs-title">user</span>: %28</span><br><span class="hljs-class">  <span class="hljs-title">return</span> %27 : <span class="hljs-title">$Int32</span>                             // <span class="hljs-title">id</span>: %28</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">main</span>&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><p>此时<code>logInfo</code>就被声明在<code>v-Table</code>，并且可以看到还产生出了<code>sil_witness_table</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">sil_vtable <span class="hljs-type">Teacher</span> &#123;<br>  #<span class="hljs-type">Teacher</span>.logInfo: (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherC7logInfoyyypF</span>	<span class="hljs-comment">// Teacher.logInfo(_:)</span><br>  #<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">init</span><span class="hljs-operator">!</span>allocator: (<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; () -&gt; <span class="hljs-type">Teacher</span> : @<span class="hljs-variable">$s12ProtocolText7TeacherCACycfC</span>	<span class="hljs-comment">// Teacher.__allocating_init()</span><br>  #<span class="hljs-type">Teacher</span>.deinit<span class="hljs-operator">!</span>deallocator: @<span class="hljs-variable">$s12ProtocolText7TeacherCfD</span>	<span class="hljs-comment">// Teacher.__deallocating_deinit</span><br>&#125;<br><br>sil_witness_table hidden <span class="hljs-type">Teacher</span>: <span class="hljs-type">MyProtocol</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>  method #<span class="hljs-type">MyProtocol</span>.logInfo: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocol.logInfo(_:) in conformance Teacher</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="class-method"><a href="#class-method" class="headerlink" title="class_method"></a><code>class_method</code></h3><blockquote>
<p>查看<a href="https://github.com/apple/swift/blob/main/docs/SIL.rst#dynamic-dispatch">官方文档</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">class_method<br><br>sil<span class="hljs-operator">-</span>instruction ::<span class="hljs-operator">=</span> &#x27;class_method&#x27; sil<span class="hljs-operator">-</span>method<span class="hljs-operator">-</span>attributes<span class="hljs-operator">?</span><br>                      sil<span class="hljs-operator">-</span>operand &#x27;,&#x27; sil<span class="hljs-operator">-</span>decl<span class="hljs-operator">-</span>ref &#x27;:&#x27; sil<span class="hljs-operator">-</span>type<br><br><span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> class_method <span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$T</span>, #<span class="hljs-type">T</span>.method : $<span class="hljs-meta">@convention</span>(class_method) <span class="hljs-type">U</span> -&gt; <span class="hljs-type">V</span><br><span class="hljs-comment">// %0 must be of a class type or class metatype $T</span><br><span class="hljs-comment">// #T.method must be a reference to a Swift native method of T or</span><br><span class="hljs-comment">// of one of its superclasses</span><br><span class="hljs-comment">// %1 will be of type $U -&gt; V</span><br><br><span class="hljs-comment">//元类的动态类型查找方法</span><br><span class="hljs-type">Looks</span> up a method based on the <span class="hljs-keyword">dynamic</span> type of a <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">or</span> <span class="hljs-title">class</span> <span class="hljs-title">metatype</span> <span class="hljs-title">instance</span>. <span class="hljs-title">It</span> <span class="hljs-title">is</span> <span class="hljs-title">undefined</span> <span class="hljs-title">behavior</span> <span class="hljs-title">if</span> <span class="hljs-title">the</span> <span class="hljs-title">class</span> <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">null</span>.</span><br><span class="hljs-class"></span><br><span class="hljs-class">//如果类实例的静态类型是已知的，或者方法已知是最终的，则该指令是去虚拟化优化的候选者。去虚拟化通行证可以查阅模块的<span class="hljs-title">VTables</span>，以找到实现该方法的<span class="hljs-title">SIL</span>函数，并将指令提升为静态函数<span class="hljs-title">_ref</span>。</span><br><span class="hljs-class"><span class="hljs-title">If</span> <span class="hljs-title">the</span> <span class="hljs-title">static</span> <span class="hljs-title">type</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">class</span> <span class="hljs-title">instance</span> <span class="hljs-title">is</span> <span class="hljs-title">known</span>, <span class="hljs-title">or</span> <span class="hljs-title">the</span> <span class="hljs-title">method</span> <span class="hljs-title">is</span> <span class="hljs-title">known</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">final</span>, <span class="hljs-title">then</span> <span class="hljs-title">the</span> <span class="hljs-title">instruction</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">candidate</span> <span class="hljs-title">for</span> <span class="hljs-title">devirtualization</span> <span class="hljs-title">optimization</span>. <span class="hljs-title">A</span> <span class="hljs-title">devirtualization</span> <span class="hljs-title">pass</span> <span class="hljs-title">can</span> <span class="hljs-title">consult</span> <span class="hljs-title">the</span> <span class="hljs-title">module</span>&#x27;<span class="hljs-title">s</span> <span class="hljs-title">VTables</span> <span class="hljs-title">to</span> <span class="hljs-title">find</span> <span class="hljs-title">the</span> <span class="hljs-title">SIL</span> <span class="hljs-title">function</span> <span class="hljs-title">that</span> <span class="hljs-title">implements</span> <span class="hljs-title">the</span> <span class="hljs-title">method</span> <span class="hljs-title">and</span> <span class="hljs-title">promote</span> <span class="hljs-title">the</span> <span class="hljs-title">instruction</span> <span class="hljs-title">to</span> <span class="hljs-title">a</span> <span class="hljs-title">static</span> <span class="hljs-title">function_ref</span>.</span><br></code></pre></td></tr></table></figure>

<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><blockquote>
<p>如果把<code>var t: Teacher = Teacher()</code>改成<code>var t: Myprotocol = Teacher()</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> t: <span class="hljs-type">MyProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-type">Teacher</span>()<br>t.logInfo(<span class="hljs-string">&quot;123&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="sil-1"><a href="#sil-1" class="headerlink" title="sil"></a><code>sil</code></h3><ul>
<li><p><code>swiftc ProtocolText.swift -emit-sil -o ProtocolText.sil</code>,编译成<code>Sil</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// main</span><br>sil <span class="hljs-keyword">@main</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Int32</span>, <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="hljs-type">Int32</span> &#123;<br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$Int32</span>, <span class="hljs-operator">%</span><span class="hljs-number">1</span> : <span class="hljs-variable">$UnsafeMutablePointer</span><span class="hljs-operator">&lt;</span><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;<span class="hljs-operator">&gt;</span>):<br>  alloc_global @<span class="hljs-variable">$s12ProtocolText1tAA02MyA0_pvp</span>    <span class="hljs-comment">// id: %2</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s12ProtocolText1tAA02MyA0_pvp</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span> <span class="hljs-comment">// users: %9, %7</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>              <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-comment">// function_ref Teacher.__allocating_init()</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$s12ProtocolText7TeacherCACycfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">Teacher</span> <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">5</span>(<span class="hljs-operator">%</span><span class="hljs-number">4</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@thick</span> <span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">Teacher</span> <span class="hljs-comment">// user: %8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> init_existential_addr <span class="hljs-operator">%</span><span class="hljs-number">3</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>, <span class="hljs-variable">$Teacher</span> <span class="hljs-comment">// user: %8</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">6</span> to <span class="hljs-operator">%</span><span class="hljs-number">7</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                      <span class="hljs-comment">// id: %8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> begin_access [read] [<span class="hljs-keyword">dynamic</span>] <span class="hljs-operator">%</span><span class="hljs-number">3</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span> <span class="hljs-comment">// users: %12, %11</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> alloc_stack <span class="hljs-variable">$any</span> <span class="hljs-type">MyProtocol</span>               <span class="hljs-comment">// users: %28, %27, %13, %11</span><br>  copy_addr <span class="hljs-operator">%</span><span class="hljs-number">9</span> to [<span class="hljs-keyword">init</span>] <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>   <span class="hljs-comment">// id: %11</span><br>  end_access <span class="hljs-operator">%</span><span class="hljs-number">9</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>                <span class="hljs-comment">// id: %12</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> open_existential_addr immutable_access <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span> to $<span class="hljs-operator">*</span><span class="hljs-meta">@opened</span>(<span class="hljs-string">&quot;29B7E2B4-1442-11EE-938A-ACDE48001122&quot;</span>, any <span class="hljs-type">MyProtocol</span>) <span class="hljs-keyword">Self</span> <span class="hljs-comment">// users: %24, %24, %23</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> alloc_stack <span class="hljs-variable">$Any</span>                          <span class="hljs-comment">// users: %26, %25, %24, %21</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">15</span> <span class="hljs-operator">=</span> string_literal utf8 <span class="hljs-string">&quot;123&quot;</span>                 <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">16</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-number">3</span>          <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">17</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-operator">-</span><span class="hljs-number">1</span>         <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">18</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>               <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-comment">// function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">19</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">String</span> <span class="hljs-comment">// user: %20</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">20</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">19</span>(<span class="hljs-operator">%</span><span class="hljs-number">15</span>, <span class="hljs-operator">%</span><span class="hljs-number">16</span>, <span class="hljs-operator">%</span><span class="hljs-number">17</span>, <span class="hljs-operator">%</span><span class="hljs-number">18</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-meta">@owned</span> <span class="hljs-type">String</span> <span class="hljs-comment">// user: %22</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">21</span> <span class="hljs-operator">=</span> init_existential_addr <span class="hljs-operator">%</span><span class="hljs-number">14</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>, <span class="hljs-variable">$String</span> <span class="hljs-comment">// user: %22</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">20</span> to <span class="hljs-operator">%</span><span class="hljs-number">21</span> : $<span class="hljs-operator">*</span><span class="hljs-type">String</span>                     <span class="hljs-comment">// id: %22</span><br>  <span class="hljs-comment">//当前调用的是witness_method，是MyProtocol.logInfo方法</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">23</span> <span class="hljs-operator">=</span> witness_method $<span class="hljs-meta">@opened</span>(<span class="hljs-string">&quot;29B7E2B4-1442-11EE-938A-ACDE48001122&quot;</span>, any <span class="hljs-type">MyProtocol</span>) <span class="hljs-keyword">Self</span>, #<span class="hljs-type">MyProtocol</span>.logInfo : <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; (), <span class="hljs-operator">%</span><span class="hljs-number">13</span> : $<span class="hljs-operator">*</span><span class="hljs-meta">@opened</span>(<span class="hljs-string">&quot;29B7E2B4-1442-11EE-938A-ACDE48001122&quot;</span>, any <span class="hljs-type">MyProtocol</span>) <span class="hljs-keyword">Self</span> : $<span class="hljs-meta">@convention</span>(witness_method: <span class="hljs-type">MyProtocol</span>) <span class="hljs-operator">&lt;</span>τ_0_0 <span class="hljs-keyword">where</span> τ_0_0 : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@in_guaranteed</span> τ_0_0) -&gt; () <span class="hljs-comment">// type-defs: %13; user: %24</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">24</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">23</span><span class="hljs-operator">&lt;</span><span class="hljs-meta">@opened</span>(<span class="hljs-string">&quot;29B7E2B4-1442-11EE-938A-ACDE48001122&quot;</span>, any <span class="hljs-type">MyProtocol</span>) <span class="hljs-keyword">Self</span><span class="hljs-operator">&gt;</span>(<span class="hljs-operator">%</span><span class="hljs-number">14</span>, <span class="hljs-operator">%</span><span class="hljs-number">13</span>) : $<span class="hljs-meta">@convention</span>(witness_method: <span class="hljs-type">MyProtocol</span>) <span class="hljs-operator">&lt;</span>τ_0_0 <span class="hljs-keyword">where</span> τ_0_0 : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@in_guaranteed</span> τ_0_0) -&gt; () <span class="hljs-comment">// type-defs: %13</span><br>  destroy_addr <span class="hljs-operator">%</span><span class="hljs-number">14</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>                        <span class="hljs-comment">// id: %25</span><br>  dealloc_stack <span class="hljs-operator">%</span><span class="hljs-number">14</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>                       <span class="hljs-comment">// id: %26</span><br>  destroy_addr <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>             <span class="hljs-comment">// id: %27</span><br>  dealloc_stack <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span>any <span class="hljs-type">MyProtocol</span>            <span class="hljs-comment">// id: %28</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">29</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int32</span>, <span class="hljs-number">0</span>         <span class="hljs-comment">// user: %30</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">30</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int32</span> (%29 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int32</span>)      // <span class="hljs-title">user</span>: %31</span><br><span class="hljs-class">  <span class="hljs-title">return</span> %30 : <span class="hljs-title">$Int32</span>                             // <span class="hljs-title">id</span>: %31</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">main</span></span><br></code></pre></td></tr></table></figure></li>
<li><p>当前调用<code>logInfo</code>就要去协议见证表<code>sil_witness_table</code>上查找实现。<code>witness_method</code>其实是记录着类实现这个协议的方法的编码信息</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">sil_witness_table hidden <span class="hljs-type">Teacher</span>: <span class="hljs-type">MyProtocol</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>  method #<span class="hljs-type">MyProtocol</span>.logInfo: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocol</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocol.logInfo(_:) in conformance Teacher</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW</code>方法实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// protocol witness for MyProtocol.logInfo(_:) in conformance Teacher</span><br>sil <span class="hljs-keyword">private</span> [transparent] [thunk] @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW</span> : $<span class="hljs-meta">@convention</span>(witness_method: <span class="hljs-type">MyProtocol</span>) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@in_guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; () &#123;<br><span class="hljs-comment">// %0                                             // user: %4</span><br><span class="hljs-comment">// %1                                             // user: %2</span><br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-keyword">Any</span>, <span class="hljs-operator">%</span><span class="hljs-number">1</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>):<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span><span class="hljs-number">1</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Teacher</span>                        <span class="hljs-comment">// users: %3, %4</span><br>  <span class="hljs-comment">//该方法实现，class_method 去调用Teacher.logInfo 方法</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> class_method <span class="hljs-operator">%</span><span class="hljs-number">2</span> : <span class="hljs-variable">$Teacher</span>, #<span class="hljs-type">Teacher</span>.logInfo : (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; (), $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; () <span class="hljs-comment">// user: %4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">3</span>(<span class="hljs-operator">%</span><span class="hljs-number">0</span>, <span class="hljs-operator">%</span><span class="hljs-number">2</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@in_guaranteed</span> <span class="hljs-keyword">Any</span>, <span class="hljs-meta">@guaranteed</span> <span class="hljs-type">Teacher</span>) -&gt; ()<br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> tuple ()                                   <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span> : $()                                 <span class="hljs-comment">// id: %6</span><br>&#125; <span class="hljs-comment">// end sil function &#x27;$s12ProtocolText7TeacherCAA02MyA0A2aDP7logInfoyyypFTW&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="witness-method"><a href="#witness-method" class="headerlink" title="witness_method"></a><code>witness_method</code></h3><blockquote>
<p>查看<a href="https://github.com/apple/swift/blob/main/docs/SIL.rst#dynamic-dispatch">官方文档</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">witness_method<br><br>sil<span class="hljs-operator">-</span>instruction ::<span class="hljs-operator">=</span> &#x27;witness_method&#x27; sil<span class="hljs-operator">-</span>method<span class="hljs-operator">-</span>attributes<span class="hljs-operator">?</span><br>                      sil<span class="hljs-operator">-</span>type &#x27;,&#x27; sil<span class="hljs-operator">-</span>decl<span class="hljs-operator">-</span>ref &#x27;:&#x27; sil<span class="hljs-operator">-</span>type<br><br><span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> witness_method <span class="hljs-variable">$T</span>, #<span class="hljs-type">Proto</span>.method \<br>  : $<span class="hljs-meta">@convention</span>(witness_method) <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span>: <span class="hljs-type">Proto</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">U</span> -&gt; <span class="hljs-type">V</span><br><span class="hljs-comment">// $T must be an archetype</span><br><span class="hljs-comment">// #Proto.method must be a reference to a method of one of the protocol</span><br><span class="hljs-comment">//   constraints on T</span><br><span class="hljs-comment">// &lt;Self: Proto&gt; U -&gt; V must be the type of the referenced method,</span><br><span class="hljs-comment">//   generic on Self</span><br><span class="hljs-comment">// %1 will be of type $@convention(thin) &lt;Self: Proto&gt; U -&gt; V</span><br><span class="hljs-comment">//查找受该协议约束的泛型类型变量的协议方法的实现。协议见证表sil_witness_table(简称PWT)上查找实现。如果引用的协议是@objc协议，则生成的类型具有objc调用约定。</span><br><span class="hljs-type">Looks</span> up the implementation of a <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">method</span> <span class="hljs-title">for</span> <span class="hljs-title">a</span> <span class="hljs-title">generic</span> <span class="hljs-title">type</span> <span class="hljs-title">variable</span> <span class="hljs-title">constrained</span> <span class="hljs-title">by</span> <span class="hljs-title">that</span> <span class="hljs-title">protocol</span>. <span class="hljs-title">The</span> <span class="hljs-title">result</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">generic</span> <span class="hljs-title">on</span> <span class="hljs-title">the</span> <span class="hljs-title">Self</span> <span class="hljs-title">archetype</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">original</span> <span class="hljs-title">protocol</span> <span class="hljs-title">and</span> <span class="hljs-title">have</span> <span class="hljs-title">the</span> <span class="hljs-title">witness_method</span> <span class="hljs-title">calling</span> <span class="hljs-title">convention</span>. <span class="hljs-title">If</span> <span class="hljs-title">the</span> <span class="hljs-title">referenced</span> <span class="hljs-title">protocol</span> <span class="hljs-title">is</span> <span class="hljs-title">an</span> @<span class="hljs-title">objc</span> <span class="hljs-title">protocol</span>, <span class="hljs-title">the</span> <span class="hljs-title">resulting</span> <span class="hljs-title">type</span> <span class="hljs-title">has</span> <span class="hljs-title">the</span> <span class="hljs-title">objc</span> <span class="hljs-title">calling</span> <span class="hljs-title">convention</span>.</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>witness_method</code>其实是记录着类实现这个协议的方法的编码信息</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>一个类实现了协议上的方法，并且创建这个类的对象时，<ol>
<li>如果把这个对象声明成<code>本身类</code>的类型，会通过<code>v-Table</code>的方式调度函数；</li>
<li>如果把这个对象声明成<code>协议类型</code>，那么在对象调用实现协议的方法的时候会先去<code>witness_table</code>查找这个对象的具体类型和具体实现(<code>v-Table</code>)，并完成当前的方法调度。</li>
</ol>
</li>
<li>注意：<ol>
<li>注意每一个遵循协议的类并实现了方法，都会为每一个类创建<code>witness_table</code></li>
<li>举例<code>Person</code>类遵循了<code>ProtocolA</code>并实现了协议方法，而<code>Teacher</code>类继承于<code>Person</code>类且没有遵循<code>ProtocolA</code>，<code>Teacher</code>类就不会创建<code>witness_table</code><ul>
<li>尽管没有创建，当出现<code>Teacher</code>重写了<code>Person</code>中的协议方法时，用<code>var t: MyProtocolA = Teacher()</code>，调用重写的协议方法时，仍然是重写后的方法，而非父类方法。因为<code>witness_table</code>是将当前<code>Teacher</code>的数据转成<code>Person</code>之后再去调用的，而<code>Teacher</code>重写了方法，因此会调用重写后的方法<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">sil_vtable <span class="hljs-type">Person</span> &#123;<br>      #<span class="hljs-type">Person</span>.logInfo: (<span class="hljs-type">Person</span>) -&gt; () -&gt; () : @<span class="hljs-variable">$s12ProtocolText6PersonC7logInfoyyF</span>	<span class="hljs-comment">// Person.logInfo()</span><br>      #<span class="hljs-type">Person</span>.<span class="hljs-keyword">init</span><span class="hljs-operator">!</span>allocator: (<span class="hljs-type">Person</span>.<span class="hljs-keyword">Type</span>) -&gt; () -&gt; <span class="hljs-type">Person</span> : @<span class="hljs-variable">$s12ProtocolText6PersonCACycfC</span>	<span class="hljs-comment">// Person.__allocating_init()</span><br>      #<span class="hljs-type">Person</span>.deinit<span class="hljs-operator">!</span>deallocator: @<span class="hljs-variable">$s12ProtocolText6PersonCfD</span>	<span class="hljs-comment">// Person.__deallocating_deinit</span><br>    &#125;<br>    <br>sil_vtable <span class="hljs-type">Teatcher</span> &#123;<br>      #<span class="hljs-type">Person</span>.logInfo: (<span class="hljs-type">Person</span>) -&gt; () -&gt; () : @<span class="hljs-variable">$s12ProtocolText6PersonC7logInfoyyF</span> [inherited]	<span class="hljs-comment">// Person.logInfo()</span><br>      #<span class="hljs-type">Person</span>.<span class="hljs-keyword">init</span><span class="hljs-operator">!</span>allocator: (<span class="hljs-type">Person</span>.<span class="hljs-keyword">Type</span>) -&gt; () -&gt; <span class="hljs-type">Person</span> : @<span class="hljs-variable">$s12ProtocolText8TeatcherCACycfC</span> [<span class="hljs-keyword">override</span>]	<span class="hljs-comment">// Teatcher.__allocating_init()</span><br>      #<span class="hljs-type">Teatcher</span>.deinit<span class="hljs-operator">!</span>deallocator: @<span class="hljs-variable">$s12ProtocolText8TeatcherCfD</span>	<span class="hljs-comment">// Teatcher.__deallocating_deinit</span><br>    &#125;<br>    <br><span class="hljs-comment">//Teacher继承了Person但不会为他创建一个sil_witness_table</span><br>sil_witness_table hidden <span class="hljs-type">Person</span>: <span class="hljs-type">MyProtocolMetadata</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>      method #<span class="hljs-type">MyProtocolMetadata</span>.logInfo: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocolMetadata</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; () -&gt; () : @<span class="hljs-variable">$s12ProtocolText6PersonCAA02MyA8MetadataA2aDP7logInfoyyFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocolMetadata.logInfo() in conformance Person</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>Person</code>类遵循了<code>ProtocolA</code>和<code>ProtocolB</code>并都实现了协议方法，它会为<code>Person</code>类分别创建两个<code>Protocol Witness Table(PWT)</code> <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">sil_vtable <span class="hljs-type">Teacher</span> &#123;<br>      #<span class="hljs-type">Teacher</span>.logInfo: (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherC7logInfoyyypF</span>	<span class="hljs-comment">// Teacher.logInfo(_:)</span><br>      #<span class="hljs-type">Teacher</span>.name: (<span class="hljs-type">Teacher</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherC4nameyyypF</span>	<span class="hljs-comment">// Teacher.name(_:)</span><br>      #<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">init</span><span class="hljs-operator">!</span>allocator: (<span class="hljs-type">Teacher</span>.<span class="hljs-keyword">Type</span>) -&gt; () -&gt; <span class="hljs-type">Teacher</span> : @<span class="hljs-variable">$s12ProtocolText7TeacherCACycfC</span>	<span class="hljs-comment">// Teacher.__allocating_init()</span><br>      #<span class="hljs-type">Teacher</span>.deinit<span class="hljs-operator">!</span>deallocator: @<span class="hljs-variable">$s12ProtocolText7TeacherCfD</span>	<span class="hljs-comment">// Teacher.__deallocating_deinit</span><br>    &#125;<br>    <span class="hljs-comment">//分别创建了两个sil_witness_table</span><br>    sil_witness_table hidden <span class="hljs-type">Teacher</span>: <span class="hljs-type">MyProtocolA</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>      method #<span class="hljs-type">MyProtocolA</span>.logInfo: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocolA</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA1AA2aDP7logInfoyyypFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocolA.logInfo(_:) in conformance Teacher</span><br>    &#125;<br>    <br>    sil_witness_table hidden <span class="hljs-type">Teacher</span>: <span class="hljs-type">MyProtocolB</span> module <span class="hljs-type">ProtocolText</span> &#123;<br>      method #<span class="hljs-type">MyProtocolB</span>.name: <span class="hljs-operator">&lt;</span><span class="hljs-keyword">Self</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span> : <span class="hljs-type">MyProtocolB</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">Self</span>) -&gt; (<span class="hljs-keyword">Any</span>) -&gt; () : @<span class="hljs-variable">$s12ProtocolText7TeacherCAA02MyA1BA2aDP4nameyyypFTW</span>	<span class="hljs-comment">// protocol witness for MyProtocolB.name(_:) in conformance Teacher</span><br> &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="协议源码分析"><a href="#协议源码分析" class="headerlink" title="协议源码分析"></a>协议源码分析</h1><blockquote>
<p><code>Class</code>在内存中的数据结构是有一个<code>typeDescription</code>类描述器，里面记录着类的信息（属性描述器、方法<code>v-table</code>等）；那么协议在内存中又是一个什么样的东西呢</p>
</blockquote>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> area: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">Shape</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> radious: <span class="hljs-type">Int</span> <span class="hljs-comment">// 存储型属性 8</span><br>        <span class="hljs-keyword">var</span> time: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>        <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">radious</span>: <span class="hljs-type">Int</span>)</span> &#123;<br>            <span class="hljs-keyword">self</span>.radious <span class="hljs-operator">=</span> radious<br>        &#125;<br>        <br>       <br>        <span class="hljs-keyword">var</span> area: <span class="hljs-type">Int</span> &#123;<br>            <span class="hljs-keyword">get</span> &#123;<br>                <span class="hljs-keyword">return</span> radious <span class="hljs-operator">*</span> radious<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="对象内存"><a href="#对象内存" class="headerlink" title="对象内存"></a>对象内存</h3><ul>
<li>查看对象内存,注意<code>MemoryLayout.size</code>拿到的是指针的大小<code>8</code>,实际大小为<code>32</code> = <code>metaData</code> + <code>refcount</code> + <code>Int</code> + <code>Int</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>circle) &#123; <span class="hljs-variable">$0</span> &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象指针地址:&quot;</span>,ptr) <span class="hljs-comment">// 对象指针地址: 0x00007ff7bfefecd0</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">Circle</span>.<span class="hljs-keyword">self</span>)) <span class="hljs-comment">//32</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle)) <span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看对象内存中存放的值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>xg <span class="hljs-number">0x00007ff7bfefecd0</span><br><span class="hljs-comment">//堆地址</span><br><span class="hljs-number">0x7ff7bfefecd0</span>: <span class="hljs-number">0x00006000002042a0</span><br>(lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x00006000002042a0</span><br>                <span class="hljs-comment">//metaData。     refcount</span><br><span class="hljs-number">0x6000002042a0</span>: <span class="hljs-number">0x00000001000187e0</span> <span class="hljs-number">0x0000000000000003</span><br>                <span class="hljs-comment">//radious         time</span><br><span class="hljs-number">0x6000002042b0</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x6000002042c0</span>: <span class="hljs-number">0x2c656c62756f4428</span> <span class="hljs-number">0x29656c62756f4420</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="协议内存"><a href="#协议内存" class="headerlink" title="协议内存"></a>协议内存</h3><ul>
<li>查看协议内存,此时<code>MemoryLayout.size</code>获取的内存大小为<code>40</code>,<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle1: <span class="hljs-type">Shape</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">let</span> ptr1 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>circle1) &#123; <span class="hljs-variable">$0</span> &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;协议对象地址:&quot;</span>,ptr1) <span class="hljs-comment">// 协议对象地址: 0x00007ff7bfefec98</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle1)) <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看对象内存中存放的值,前<code>40</code>个字节存放的内容,<ul>
<li>第一个字节存放堆对象，即<code>Circle(10)</code>的值</li>
<li>第四个存储<code>metadata</code></li>
<li>第五个存放<code>witness table</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x00007ff7bfefec98</span><br>                <span class="hljs-comment">// 堆对象</span><br><span class="hljs-number">0x7ff7bfefec98</span>: <span class="hljs-number">0x000060000020a820</span> <span class="hljs-number">0x0000000000000000</span><br>                                    <span class="hljs-comment">//是circle的metaData</span><br><span class="hljs-number">0x7ff7bfefeca8</span>: <span class="hljs-number">0x00007ff7bfefe0d0</span> <span class="hljs-number">0x00000001000187e0</span><br>                <span class="hljs-comment">//witness table</span><br><span class="hljs-number">0x7ff7bfefecb8</span>: <span class="hljs-number">0x0000000100014df0</span> <span class="hljs-number">0x00007ff7bfefecd0</span><br>(lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x000060000020a820</span> <br><span class="hljs-number">0x60000020a820</span>: <span class="hljs-number">0x00000001000187e0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x60000020a830</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x60000020a840</span>: <span class="hljs-number">0x2c676e6972745328</span> <span class="hljs-number">0x2c676e6972745320</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>将<code>var circle:Shape = Circle(10)</code>转换成<code>IR</code>可得<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define i32 <span class="hljs-keyword">@main</span>(i32 <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to i8<span class="hljs-operator">*</span><br>  <span class="hljs-comment">// 获取Circle的Metadata</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> call swiftcc <span class="hljs-operator">%</span>swift.metadata_response @<span class="hljs-string">&quot;$s12ProtocolText6CircleCMa&quot;</span>(i64 <span class="hljs-number">0</span>) #<span class="hljs-number">9</span><br>  <span class="hljs-comment">// %4存储Metadata</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> extractvalue <span class="hljs-operator">%</span>swift.metadata_response <span class="hljs-operator">%</span><span class="hljs-number">3</span>, <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 调用allocating-init</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> call swiftcc <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCyACSicfC&quot;</span>(i64 <span class="hljs-number">10</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> swiftself <span class="hljs-operator">%</span><span class="hljs-number">4</span>)<br>  <span class="hljs-comment">// s12ProtocolText6circleAA5Shape_pvp是circle实例对象。 这一行代码意思是：把Metadata存储到circle</span><br>  store <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span>, <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6circleAA5Shape_pvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span>), align <span class="hljs-number">8</span><br>  <span class="hljs-comment">// s12ProtocolText6CircleCAA5ShapeAAW是protocol witess table它是一个数组（[2 x i8*]代表数组）</span><br>  store i8<span class="hljs-operator">**</span> getelementptr inbounds ([<span class="hljs-number">2</span> x i8<span class="hljs-operator">*</span>], [<span class="hljs-number">2</span> x i8<span class="hljs-operator">*</span>]<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeAAWP&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), i8<span class="hljs-operator">***</span> getelementptr inbounds (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span>, <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6circleAA5Shape_pvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">2</span>), align <span class="hljs-number">8</span><br>  <span class="hljs-comment">// 这里是把生成的堆对象存在Circle</span><br>  store <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">**</span> bitcast (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6circleAA5Shape_pvp&quot;</span> to <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">**</span>), align <span class="hljs-number">8</span><br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>s12ProtocolText6CircleCAA5ShapeAAW</code>是数组由<code>swift.protocol_conformance_descriptor</code>和<code>s12ProtocolText6CircleCAA5ShapeA2aDP4areaSivgTW</code>组成  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">@<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeAAWP&quot;</span> <span class="hljs-operator">=</span> hidden constant [<span class="hljs-number">2</span> x i8<span class="hljs-operator">*</span>] [i8<span class="hljs-operator">*</span> bitcast (<span class="hljs-operator">%</span>swift.protocol_conformance_descriptor<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeAAMc&quot;</span> to i8<span class="hljs-operator">*</span>), i8<span class="hljs-operator">*</span> bitcast (i64 (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText6CircleC</span><span class="hljs-operator">**</span>, <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span>)<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeA2aDP4areaSivgTW&quot;</span> to i8<span class="hljs-operator">*</span>)], align <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li>
<li>注意，如果协议列表中增加了一个协议，则会变成长度为3的数组<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">store i8<span class="hljs-operator">**</span> getelementptr inbounds ([<span class="hljs-number">3</span> x i8<span class="hljs-operator">*</span>], [<span class="hljs-number">3</span> x i8<span class="hljs-operator">*</span>]<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6CircleCAA5ShapeAAWP&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), i8<span class="hljs-operator">***</span> getelementptr inbounds (<span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span>, <span class="hljs-operator">%</span><span class="hljs-type">T12ProtocolText5ShapeP</span><span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s12ProtocolText6circleAA5Shape_pvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">2</span>), align <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li>
<li>因此<code>witness_table</code>这个数据结构：<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> protocol_conformance_descriptor: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> witnessMethod: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 协议见证里的方法的起始地址</span><br>    <span class="hljs-comment">// 如果实现了协议的多个方法，则在后面加成员</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>可以得到一个初版的<code>protocol</code>在内存上的数据结构</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow1: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow2: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> protocol_conformance_descriptor: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> witnessMethod: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 协议见证里的方法的起始地址</span><br>    <span class="hljs-comment">// 如果实现了协议的多个方法，则在后面加成员</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>下面分析最后一个成员<code>witness_table</code>内存结构到底长啥样</li>
<li>为什么第一个成员<code>heapObject</code>有<code>metadata</code>，而第四个成员还要存放一个<code>metadata</code></li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="TargetWitnessTable"><a href="#TargetWitnessTable" class="headerlink" title="TargetWitnessTable"></a><code>TargetWitnessTable</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// A witness table for a protocol.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// With the exception of the initial protocol conformance descriptor,</span><br><span class="hljs-comment">/// the layout of a witness table is dependent on the protocol being</span><br><span class="hljs-comment">/// represented.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetWitnessTable</span> &#123;</span><br>  <span class="hljs-comment">/// The protocol conformance descriptor from which this witness table</span><br>  <span class="hljs-comment">/// was generated.</span><br>  ConstTargetMetadataPointer&lt;Runtime, TargetProtocolConformanceDescriptor&gt;<br>    Description;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetProtocolConformanceDescriptor&lt;Runtime&gt; *<span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">using</span> WitnessTable = TargetWitnessTable&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>

<h3 id="TargetProtocolConformanceDescriptor"><a href="#TargetProtocolConformanceDescriptor" class="headerlink" title="TargetProtocolConformanceDescriptor"></a><code>TargetProtocolConformanceDescriptor</code></h3><blockquote>
<p>协议一致性结构</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of a protocol conformance.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This contains enough static information to recover the witness table for a</span><br><span class="hljs-comment">/// type&#x27;s conformance to a protocol.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolConformanceDescriptor</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">  :</span> <span class="hljs-keyword">public</span> swift::ABI::TrailingObjects&lt;<br>             TargetProtocolConformanceDescriptor&lt;Runtime&gt;,<br>             TargetRelativeContextPointer&lt;Runtime&gt;,<br>             TargetGenericRequirementDescriptor&lt;Runtime&gt;,<br>             TargetResilientWitnessesHeader&lt;Runtime&gt;,<br>             TargetResilientWitness&lt;Runtime&gt;,<br>             TargetGenericWitnessTable&lt;Runtime&gt;&gt; &#123;<br><br>  <span class="hljs-keyword">using</span> TrailingObjects = swift::ABI::TrailingObjects&lt;<br>                             TargetProtocolConformanceDescriptor&lt;Runtime&gt;,<br>                             TargetRelativeContextPointer&lt;Runtime&gt;,<br>                             TargetGenericRequirementDescriptor&lt;Runtime&gt;,<br>                             TargetResilientWitnessesHeader&lt;Runtime&gt;,<br>                             TargetResilientWitness&lt;Runtime&gt;,<br>                             TargetGenericWitnessTable&lt;Runtime&gt;&gt;;<br>  <span class="hljs-keyword">friend</span> TrailingObjects;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">using</span> OverloadToken = <span class="hljs-keyword">typename</span> TrailingObjects::<span class="hljs-keyword">template</span> OverloadToken&lt;T&gt;;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> GenericRequirementDescriptor =<br>    TargetGenericRequirementDescriptor&lt;Runtime&gt;;<br><br>  <span class="hljs-keyword">using</span> ResilientWitnessesHeader = TargetResilientWitnessesHeader&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> ResilientWitness = TargetResilientWitness&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> GenericWitnessTable = TargetGenericWitnessTable&lt;Runtime&gt;;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/// The protocol being conformed to.</span><br>  TargetRelativeContextPointer&lt;Runtime, TargetProtocolDescriptor&gt; Protocol;<br>  <br>  <span class="hljs-comment">// Some description of the type that conforms to the protocol.</span><br>  TargetTypeReference&lt;Runtime&gt; TypeRef;<br><br>  <span class="hljs-comment">/// The witness table pattern, which may also serve as the witness table.</span><br>  RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> TargetWitnessTable&lt;Runtime&gt;&gt; WitnessTablePattern;<br><br>  <span class="hljs-comment">/// Various flags, including the kind of conformance.</span><br>  ConformanceFlags Flags;<br><br><span class="hljs-keyword">public</span>:<br>  ConstTargetPointer&lt;Runtime, TargetProtocolDescriptor&lt;Runtime&gt;&gt;<br>  <span class="hljs-built_in">getProtocol</span>() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> Protocol;<br>  &#125;<br><br>  <span class="hljs-function">TypeReferenceKind <span class="hljs-title">getTypeKind</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getTypeReferenceKind</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">getDirectObjCClassName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TypeRef.<span class="hljs-built_in">getDirectObjCClassName</span>(<span class="hljs-built_in">getTypeKind</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetClassMetadataObjCInterop&lt;Runtime&gt; *<span class="hljs-keyword">const</span> *</span><br><span class="hljs-function">  <span class="hljs-title">getIndirectObjCClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TypeRef.<span class="hljs-built_in">getIndirectObjCClass</span>(<span class="hljs-built_in">getTypeKind</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *<span class="hljs-title">getTypeDescriptor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TypeRef.<span class="hljs-built_in">getTypeDescriptor</span>(<span class="hljs-built_in">getTypeKind</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span></span><br><span class="hljs-function">  <span class="hljs-title">getTypeRefDescriptorOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> -&gt; <span class="hljs-keyword">typename</span> Runtime::StoredSize </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">typename</span> std::remove_reference&lt;<span class="hljs-keyword">decltype</span>(*<span class="hljs-keyword">this</span>)&gt;::type, TypeRef);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span></span><br><span class="hljs-function">  <span class="hljs-title">getProtocolDescriptorOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> -&gt; <span class="hljs-keyword">typename</span> Runtime::StoredSize </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">typename</span> std::remove_reference&lt;<span class="hljs-keyword">decltype</span>(*<span class="hljs-keyword">this</span>)&gt;::type, Protocol);<br>  &#125;<br><br>  TargetContextDescriptor&lt;Runtime&gt; * __ptrauth_swift_type_descriptor *<br>  _getTypeDescriptorLocation() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getTypeKind</span>() != TypeReferenceKind::IndirectTypeDescriptor)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> TypeRef.IndirectTypeDescriptor.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the context of a retroactive conformance.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *<span class="hljs-title">getRetroactiveContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!Flags.<span class="hljs-built_in">isRetroactive</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;<br>        TargetRelativeContextPointer&lt;Runtime&gt;&gt;();<br>  &#125;<br><br>  <span class="hljs-comment">/// Whether this conformance is non-unique because it has been synthesized</span><br>  <span class="hljs-comment">/// for a foreign type.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSynthesizedNonUnique</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isSynthesizedNonUnique</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/// Whether this conformance has any conditional requirements that need to</span><br>  <span class="hljs-comment">/// be evaluated.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasConditionalRequirements</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getNumConditionalRequirements</span>() &gt; <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the conditional requirements that must also be</span><br>  <span class="hljs-comment">/// satisfied</span><br>  <span class="hljs-function">llvm::ArrayRef&lt;GenericRequirementDescriptor&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getConditionalRequirements</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;GenericRequirementDescriptor&gt;(),<br>            Flags.<span class="hljs-built_in">getNumConditionalRequirements</span>()&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/// Get the directly-referenced witness table pattern, which may also</span><br>  <span class="hljs-comment">/// serve as the witness table.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> swift::TargetWitnessTable&lt;Runtime&gt; *<span class="hljs-title">getWitnessTablePattern</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> WitnessTablePattern;<br>  &#125;<br><br>  <span class="hljs-comment">/// Get the canonical metadata for the type referenced by this record, or</span><br>  <span class="hljs-comment">/// return null if the record references a generic or universal type.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *<span class="hljs-title">getCanonicalTypeMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>  <br>  <span class="hljs-comment">/// Get the witness table for the specified type, realizing it if</span><br>  <span class="hljs-comment">/// necessary, or return null if the conformance does not apply to the</span><br>  <span class="hljs-comment">/// type.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> swift::TargetWitnessTable&lt;Runtime&gt; *</span><br><span class="hljs-function">  <span class="hljs-title">getWitnessTable</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *type)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Retrieve the resilient witnesses.</span><br>  <span class="hljs-function">llvm::ArrayRef&lt;ResilientWitness&gt; <span class="hljs-title">getResilientWitnesses</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!Flags.<span class="hljs-built_in">hasResilientWitnesses</span>())<br>      <span class="hljs-keyword">return</span> &#123; &#125;;<br><br>    <span class="hljs-keyword">return</span> llvm::ArrayRef&lt;ResilientWitness&gt;(<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;ResilientWitness&gt;(),<br>        <span class="hljs-built_in">numTrailingObjects</span>(OverloadToken&lt;ResilientWitness&gt;()));<br>  &#125;<br><br>  <span class="hljs-function">ConstTargetPointer&lt;Runtime, GenericWitnessTable&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getGenericWitnessTable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!Flags.<span class="hljs-built_in">hasGenericWitnessTable</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;GenericWitnessTable&gt;();<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(NDEBUG) &amp;&amp; SWIFT_OBJC_INTEROP</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>  <span class="hljs-comment">/// Verify that the protocol descriptor obeys all invariants.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// We currently check that the descriptor:</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// 1. Has a valid TypeReferenceKind.</span><br>  <span class="hljs-comment">/// 2. Has a valid conformance kind.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">verify</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                        OverloadToken&lt;TargetRelativeContextPointer&lt;Runtime&gt;&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isRetroactive</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;GenericRequirementDescriptor&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getNumConditionalRequirements</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;ResilientWitnessesHeader&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasResilientWitnesses</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;ResilientWitness&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasResilientWitnesses</span>()<br>      ? <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;ResilientWitnessesHeader&gt;()<br>          -&gt;NumWitnesses<br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;GenericWitnessTable&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasGenericWitnessTable</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> ProtocolConformanceDescriptor<br>  = TargetProtocolConformanceDescriptor&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolConformanceDescriptor</span> </span>&#123;<br>    <span class="hljs-comment">// TargetRelativeDirectPointer相对类型的指针，实质存放偏移量</span><br>    <span class="hljs-keyword">var</span> protocolDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">TargetProtocolDescriptor</span>&gt;<br>    <span class="hljs-keyword">var</span> typeRef: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">WitnessTablePattern</span>: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>其第一个成员变量是<code>TargetProtocolDescriptor</code></li>
</ul>
<h3 id="TargetProtocolDescriptor"><a href="#TargetProtocolDescriptor" class="headerlink" title="TargetProtocolDescriptor"></a><code>TargetProtocolDescriptor</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// A protocol descriptor.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Protocol descriptors contain information about the contents of a protocol:</span><br><span class="hljs-comment">/// it&#x27;s name, requirements, requirement signature, context, and so on. They</span><br><span class="hljs-comment">/// are used both to identify a protocol and to reason about its contents.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Only Swift protocols are defined by a protocol descriptor, whereas</span><br><span class="hljs-comment">/// Objective-C (including protocols defined in Swift as @objc) use the</span><br><span class="hljs-comment">/// Objective-C protocol layout.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolDescriptor</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">    :</span> TargetContextDescriptor&lt;Runtime&gt;,<br>      swift::ABI::TrailingObjects&lt;<br>        TargetProtocolDescriptor&lt;Runtime&gt;,<br>        TargetGenericRequirementDescriptor&lt;Runtime&gt;,<br>        TargetProtocolRequirement&lt;Runtime&gt;&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">using</span> TrailingObjects<br>    = swift::ABI::TrailingObjects&lt;<br>        TargetProtocolDescriptor&lt;Runtime&gt;,<br>        TargetGenericRequirementDescriptor&lt;Runtime&gt;,<br>        TargetProtocolRequirement&lt;Runtime&gt;&gt;;<br><br>  <span class="hljs-keyword">friend</span> TrailingObjects;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">using</span> OverloadToken = <span class="hljs-keyword">typename</span> TrailingObjects::<span class="hljs-keyword">template</span> OverloadToken&lt;T&gt;;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            OverloadToken&lt;TargetGenericRequirementDescriptor&lt;Runtime&gt;&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> NumRequirementsInSignature;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            OverloadToken&lt;TargetProtocolRequirement&lt;Runtime&gt;&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> NumRequirements;<br>  &#125;<br><br><br>  <span class="hljs-comment">/// The name of the protocol.</span><br>  TargetRelativeDirectPointer&lt;Runtime, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>, <span class="hljs-comment">/*nullable*/</span> <span class="hljs-literal">false</span>&gt; Name;<br><br>  <span class="hljs-comment">/// The number of generic requirements in the requirement signature of the</span><br>  <span class="hljs-comment">/// protocol.</span><br>  <span class="hljs-keyword">uint32_t</span> NumRequirementsInSignature;<br><br>  <span class="hljs-comment">/// The number of requirements in the protocol.</span><br>  <span class="hljs-comment">/// If any requirements beyond MinimumWitnessTableSizeInWords are present</span><br>  <span class="hljs-comment">/// in the witness table template, they will be not be overwritten with</span><br>  <span class="hljs-comment">/// defaults.</span><br>  <span class="hljs-keyword">uint32_t</span> NumRequirements;<br><br>  <span class="hljs-comment">/// Associated type names, as a space-separated list in the same order</span><br>  <span class="hljs-comment">/// as the requirements.</span><br>  RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>, <span class="hljs-comment">/*Nullable=*/</span><span class="hljs-literal">true</span>&gt; AssociatedTypeNames;<br><br>  <span class="hljs-function">ProtocolContextDescriptorFlags <span class="hljs-title">getProtocolContextDescriptorFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ProtocolContextDescriptorFlags</span>(<span class="hljs-keyword">this</span>-&gt;Flags.<span class="hljs-built_in">getKindSpecificFlags</span>());<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the requirements that make up the requirement signature of</span><br>  <span class="hljs-comment">/// this protocol.</span><br>  llvm::ArrayRef&lt;TargetGenericRequirementDescriptor&lt;Runtime&gt;&gt;<br>  <span class="hljs-built_in">getRequirementSignature</span>() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;<br>                             TargetGenericRequirementDescriptor&lt;Runtime&gt;&gt;(),<br>            NumRequirementsInSignature&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the requirements of this protocol.</span><br>  llvm::ArrayRef&lt;TargetProtocolRequirement&lt;Runtime&gt;&gt;<br>  <span class="hljs-built_in">getRequirements</span>() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;<br>                             TargetProtocolRequirement&lt;Runtime&gt;&gt;(),<br>            NumRequirements&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span></span><br><span class="hljs-function">  <span class="hljs-title">getNameOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> -&gt; <span class="hljs-keyword">typename</span> Runtime::StoredSize </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">typename</span> std::remove_reference&lt;<span class="hljs-keyword">decltype</span>(*<span class="hljs-keyword">this</span>)&gt;::type, Name);<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the requirement base descriptor address.</span><br>  ConstTargetPointer&lt;Runtime, TargetProtocolRequirement&lt;Runtime&gt;&gt;<br>  <span class="hljs-built_in">getRequirementBaseDescriptor</span>() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRequirements</span>().<span class="hljs-built_in">data</span>() - WitnessTableFirstRequirementOffset;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>  [[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;Only meant for use in the debugger&quot;</span>)]] <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *cd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Protocol;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>TargetProtocolDescriptor</code>继承自<code>TargetContextDescriptor</code>,而<code>TargetContextDescriptor</code>的结构为<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetContextDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Name</span>: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumRequirementsInSignature</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumRequirements</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">AssociatedTypeNames</span>: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Existential-Container"><a href="#Existential-Container" class="headerlink" title="Existential Container"></a>Existential Container</h2><blockquote>
<p><code>Existential Container</code>也就是本章所说的<code>ProtocolBox</code>实际上有两类,<code>Opaque Existential Container</code>和<code>ClassExistentialContainer</code></p>
</blockquote>
<h3 id="Opaque-Existential-Container"><a href="#Opaque-Existential-Container" class="headerlink" title="Opaque Existential Container"></a><code>Opaque Existential Container</code></h3><blockquote>
<p><code>Opaque Existential Container</code> — 用于没有类约束的 <code>Protocol</code> (<code>no class constraint on protocol</code>)，也就是说这种协议背后的真实类型可能是类、结构体以及枚举等。因此其存储就非常复杂</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpaqueExistentialContainer</span> &#123;</span><br>  <span class="hljs-keyword">void</span> *fixedSizeBuffer[<span class="hljs-number">3</span>];<br>  Metadata *type;<br>  WitnessTable *witnessTables[NUM_WITNESS_TABLES];<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>fixedSizeBuffer</code>:<code>3</code> 个指针大小的 <code>buffer</code> 空间，当真实类型的 <code>size</code> (内存对齐后的大小) 小于 <code>3</code> 个字时则其内容直接存储在 <code>fixedSizeBuffer</code> 中，否则在 <code>heap</code> 上另辟空间存储，并将指针存储在 <code>fixedSizeBuffer</code> 中；</li>
<li><code>type</code>:指向真实类型的 <code>Metadata</code>，最重要的就是引用其中的 <code>VWT</code> 用于完成内存的各种操作；</li>
<li><code>witnessTables</code>: 指向协议函数表 (<code>Protocol Witness Table</code>, <code>PWT</code>)，协议函数表中存储的是真实类型中对应函数的地址。</li>
</ul>
<h3 id="Class-Existential-Container"><a href="#Class-Existential-Container" class="headerlink" title="Class Existential Container"></a>Class Existential Container</h3><blockquote>
<p>用于有类约束的 <code>Protocol</code>，该协议背后真实的类型只能是类，而类的实例都是在 <code>Heap</code> 上分配内存的。<br>因此，在 <code>Existential Container</code> 中只需要一个指向堆内存的指针即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClassExistentialContainer</span> &#123;</span><br>  HeapObject *value;<br>  WitnessTable *witnessTables[NUM_WITNESS_TABLES];<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>value</code>:指向堆内存的指针；</li>
<li><code>witnessTables</code>:<code>PWT</code> 指针。</li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><blockquote>
<p>继承<code>AnyObject</code>只用于类的协议，<code>swift</code>会进行优化,其内存占用不是之前的40字节，而变成16。</p>
</blockquote>
<ul>
<li><p>如果协议只能用于类，例如协议继承了<code>AnyObject</code>，则协议的结构<code>ProtocolBox</code>会发生改变,其内存大小会变成<code>16</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-comment">// IR分析出：它本是一个数组，就用一样大小和结构相同的结构体代替</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>如果协议能用于类、结构体、枚举，则协议的结构<code>ProtocolBox</code>会和此前分析的一致，其内存大小会变成<code>40</code></p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow1: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow2: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-comment">// IR分析出：它本是一个数组，就用一样大小和结构相同的结构体代替</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="验证协议本质"><a href="#验证协议本质" class="headerlink" title="验证协议本质"></a>验证协议本质</h1><ul>
<li><p>总的协议数据结构如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//继承了AnyObject,只用于类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolClassBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-comment">// IR分析出：它本是一个数组，就用一样大小和结构相同的结构体代替</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolBox</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> heapObject: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow1: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> unknow2: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-comment">// IR分析出：它本是一个数组，就用一样大小和结构相同的结构体代替</span><br>    <span class="hljs-keyword">var</span> witness_table: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolWitnessTable</span>&gt; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolWitnessTable</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> protocol_conformance_descriptor: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetProtocolConformanceDescriptor</span>&gt;<br>    <span class="hljs-keyword">var</span> witnessMethod: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 协议见证里的方法</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolConformanceDescriptor</span> </span>&#123;<br>    <span class="hljs-comment">// TargetRelativeDirectPointer相对类型的指针，实质存放偏移量</span><br>    <span class="hljs-keyword">var</span> protocolDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">TargetProtocolDescriptor</span>&gt;<br>    <span class="hljs-keyword">var</span> typeRef: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">WitnessTablePattern</span>: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetProtocolDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Name</span>: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumRequirementsInSignature</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumRequirements</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">AssociatedTypeNames</span>: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>验证代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle1: <span class="hljs-type">Shape</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>.<span class="hljs-keyword">init</span>(<span class="hljs-number">10.0</span>)<br><span class="hljs-comment">// 拿到circle1堆区地址，然后内存绑定ProtocolBox类型</span><br><span class="hljs-keyword">let</span> circle1_ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>circle1) &#123; ptr <span class="hljs-keyword">in</span><br>    <span class="hljs-keyword">return</span> ptr.withMemoryRebound(to: <span class="hljs-type">ProtocolBox</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; pointer <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">return</span> pointer<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> desc <span class="hljs-operator">=</span> circle1_ptr.pointee.witness_table.pointee.protocol_conformance_descriptor.pointee.protocolDescriptor.getmeasureRelativeOffset()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: desc.pointee.<span class="hljs-type">Name</span>.getmeasureRelativeOffset())) <span class="hljs-comment">// Shape</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: desc.pointee.<span class="hljs-type">AssociatedTypeNames</span>.getmeasureRelativeOffset())) <span class="hljs-comment">//无关联类型是空</span><br>    <span class="hljs-built_in">print</span>(desc.pointee.<span class="hljs-type">NumRequirements</span>) <span class="hljs-comment">// 1</span><br>    <br>    <span class="hljs-built_in">print</span>(circle1_ptr.pointee.witness_table.pointee.witnessMethod) <span class="hljs-comment">// 0x00000001000101a0</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br></code></pre></td></tr></table></figure></li>
<li><p>打印出<code>witnessMethod</code>的地址是 <code>0x0000000100004e40</code>就是<code>Circle</code>类实现协议<code>Shape</code>的属性<code>area</code>的地址,可以在<code>Mach-O</code>上能找到；下面这个命令还原出来</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//地址在Mach-O上是不带0x的</span><br>$  nm <span class="hljs-operator">-</span>p <span class="hljs-type">SwiftSource</span> <span class="hljs-operator">|</span> grep 00000001000101a0<br><span class="hljs-comment">// 输出了一个混写的名称</span><br>00000001000101a0 t <span class="hljs-keyword">_</span><span class="hljs-variable">$s11SwiftSource6CircleL_CAA5ShapeA2aDP4areaSivgTW</span><br><br>$ xcrun swift<span class="hljs-operator">-</span>demangle s11SwiftSource6CircleL_CAA5ShapeA2aDP4areaSivgTW<br><span class="hljs-comment">// 最后得到下面的内容</span><br><span class="hljs-variable">$s11SwiftSource6CircleL_CAA5ShapeA2aDP4areaSivgTW</span> <span class="hljs-operator">---&gt;</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">witness</span> <span class="hljs-title">for</span> <span class="hljs-title">SwiftSource</span>.<span class="hljs-title">Shape</span>.<span class="hljs-title">area</span>.get<span class="hljs-title">ter</span> : <span class="hljs-title">Swift</span>.<span class="hljs-title">Int</span> <span class="hljs-title">in</span> <span class="hljs-title">conformance</span> <span class="hljs-title">Circle</span> #1 <span class="hljs-title">in</span> <span class="hljs-title">SwiftSource</span> : <span class="hljs-title">SwiftSource</span>.<span class="hljs-title">Shape</span> <span class="hljs-title">in</span> <span class="hljs-title">SwiftSource</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>每个遵守了协议的类，都会有自己的<code>Protocol Witness Table (PWT)</code>，遵守的协议越多，<code>PWT</code>中存储的函数地址就越多；</li>
<li><code>PWT</code>的本质是一个指针数组，第一个成员存储<code>TargetProtocolConformanceDescriptor</code>，其后面存储的是实现协议函数的地址；</li>
<li><code>PWT</code>的数量与协议数量一致。</li>
</ol>
<h2 id="ProtocolBox的作用"><a href="#ProtocolBox的作用" class="headerlink" title="ProtocolBox的作用"></a><code>ProtocolBox</code>的作用</h2><blockquote>
<ul>
<li><code>Existential Container</code>即<code>ProtocolBox</code>是编译器生成的一种特殊的数据类型，用于管理<code>class</code>/<code>struct</code>/<code>enum</code>等遵守了同一个协议类型，因为这些<code>class</code>/<code>struct</code>/<code>enum</code>等类型的内存大小不一致，所以通过当前的<code>Existential Container</code>统一管理；</li>
<li>对于小容量的数据，直接存储在<code>Value Buffer</code>；(小于等于<code>24</code>字节),前三个8字节中</li>
<li>对于大容量的数据，通过堆区分配，存储堆空间的地址。（大于<code>24</code>字节）</li>
</ul>
</blockquote>
<ul>
<li>将<code>Circle</code>换成<code>struct</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">Shape</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> radious: <span class="hljs-type">Int</span> <span class="hljs-comment">// 存储型属性 8</span><br>        <span class="hljs-keyword">var</span> time: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>        <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">radious</span>: <span class="hljs-type">Int</span>)</span> &#123;<br>            <span class="hljs-keyword">self</span>.radious <span class="hljs-operator">=</span> radious<br>        &#125;<br>        <br>       <br>        <span class="hljs-keyword">var</span> area: <span class="hljs-type">Int</span> &#123;<br>            <span class="hljs-keyword">get</span> &#123;<br>                <span class="hljs-keyword">return</span> radious <span class="hljs-operator">*</span> radious<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>查看打印的<code>circle</code>对象依旧是<code>40</code>个字节。<ul>
<li>因为当实例变量声明为协议类型的时候，程序在编译时并不能推导出实例变量的真实类型，那就导致没有办法为实例变量分配具体的内存空间。</li>
<li>于是就不管它到底需要多大是什么类型统一塞到<code>40</code>字节的存在容器统一管理。</li>
<li>所以编译器就用一种特殊的数据类型<code>Existential Container</code>去统一管理遵循协议的<code>class</code>/<code>struct</code>/<code>enum</code>等（<code>Existential Container</code>本质是上面分析出的<code>ProtocolBox</code>）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle1:<span class="hljs-type">Shape</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">let</span> ptr1 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>circle1) &#123; <span class="hljs-variable">$0</span> &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;协议对象地址:&quot;</span>,ptr1) <span class="hljs-comment">// 0x00007ff7bfefec78</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle1)) <span class="hljs-comment">//40</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>前<code>24</code>个字节存放的数据,第四个<code>8</code>字节存放的是依旧是<code>metadata</code>,此时是<code>TargetStructMetadata</code>,在真实调用实现协议的方法的时候就会找到这个<code>metadata</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x00007ff7bfefec78</span><br><span class="hljs-comment">//存的radious 10            存的age 4</span><br><span class="hljs-number">0x7ff7bfefec78</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000004</span><br>                                    <span class="hljs-comment">// metaData</span><br><span class="hljs-number">0x7ff7bfefec88</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000100015050</span><br>        <span class="hljs-comment">// wentesstable</span><br><span class="hljs-number">0x7ff7bfefec98</span>: <span class="hljs-number">0x0000000100015068</span> <span class="hljs-number">0x00007ff7bfefeca8</span><br></code></pre></td></tr></table></figure></li>
<li>如果增加成员变量<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">Shape</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> radious: <span class="hljs-type">Int</span> <span class="hljs-comment">// 存储型属性 8</span><br>        <span class="hljs-keyword">var</span> radious1 <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>        <span class="hljs-keyword">var</span> radious2 <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br>        <span class="hljs-keyword">var</span> radious3 <span class="hljs-operator">=</span> <span class="hljs-number">40</span><br>        <span class="hljs-keyword">var</span> time: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>        <br>        <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">radious</span>: <span class="hljs-type">Int</span>)</span> &#123;<br>            <span class="hljs-keyword">self</span>.radious <span class="hljs-operator">=</span> radious<br>        &#125;<br>        <br>       <br>        <span class="hljs-keyword">var</span> area: <span class="hljs-type">Int</span> &#123;<br>            <span class="hljs-keyword">get</span> &#123;<br>                <span class="hljs-keyword">return</span> radious <span class="hljs-operator">*</span> radious<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看,超过三个之后，需要把所有的内容移至堆区开辟一块内存空间去存放，<code>ProtocolBox</code>第一个成员就变成了一块堆区的地址，它存放了那五个成员变量的值。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x00007ff7bfefebd0</span><br><span class="hljs-number">0x7ff7bfefebd0</span>: <span class="hljs-number">0x0000600001710140</span> <span class="hljs-number">0x00007ff7bfefebd0</span><br><span class="hljs-number">0x7ff7bfefebe0</span>: <span class="hljs-number">0x0000005002000000</span> <span class="hljs-number">0x0000000100015078</span><br><span class="hljs-number">0x7ff7bfefebf0</span>: <span class="hljs-number">0x00000001000150a0</span> <span class="hljs-number">0x00007ff7bfefec00</span><br><br>lldb) x<span class="hljs-operator">/</span>8xg <span class="hljs-number">0x0000600001710140</span><br><span class="hljs-number">0x600001710140</span>: <span class="hljs-number">0x0000000100014dd0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001710150</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000014</span><br><span class="hljs-number">0x600001710160</span>: <span class="hljs-number">0x000000000000001e</span> <span class="hljs-number">0x0000000000000028</span><br><span class="hljs-number">0x600001710170</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>闭包分析</title>
    <url>/2023/06/24/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/%E9%97%AD%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="闭包分析"><a href="#闭包分析" class="headerlink" title="闭包分析"></a>闭包分析</h1><h2 id="闭包的数据结构"><a href="#闭包的数据结构" class="headerlink" title="闭包的数据结构"></a>闭包的数据结构</h2><ul>
<li>把下面代码<code>block.swift</code>编译成<code>IR</code>,分析还原出闭包的数据结构<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>()</span> -&gt; () -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-keyword">let</span> increm <span class="hljs-operator">=</span> makeIncrementer()<br></code></pre></td></tr></table></figure></li>
<li><code>swiftc block.swift -emit-ir -o block.ll</code> 编译成<code>ir</code>文件</li>
</ul>
<h3 id="IR结构分析"><a href="#IR结构分析" class="headerlink" title="IR结构分析"></a>IR结构分析</h3><ul>
<li>主要的<code>main</code>函数<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define i32 <span class="hljs-keyword">@main</span>(i32 <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>) #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> bitcast i8<span class="hljs-operator">**</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to i8<span class="hljs-operator">*</span><br><span class="hljs-comment">//返回值是个结构体 s5block15makeIncrementerSiycyF是调用的函数</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> call swiftcc &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; @<span class="hljs-string">&quot;$s5block15makeIncrementerSiycyF&quot;</span>()<br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> extractvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">3</span>, <span class="hljs-number">0</span> <span class="hljs-comment">//取第一个值i8*</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> extractvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">3</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//取第二个值%swift.refcounted</span><br>  store i8<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, i8<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s5block6incremSiycvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>), align <span class="hljs-number">8</span><br>  store <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">**</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.function, <span class="hljs-operator">%</span>swift.function<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s5block6incremSiycvp&quot;</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span>), align <span class="hljs-number">8</span><br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>查看混写函数<code>s5block15makeIncrementerSiycyF</code>的具体实现<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">xcrun swift<span class="hljs-operator">-</span>demangle s5block15makeIncrementerSiycyF<br><span class="hljs-variable">$s5block15makeIncrementerSiycyF</span> <span class="hljs-operator">---&gt;</span> block.makeIncrementer() -&gt; () -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="swift-refcounted"><a href="#swift-refcounted" class="headerlink" title="swift.refcounted"></a><code>swift.refcounted</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">%</span>swift.function <span class="hljs-operator">=</span> type &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125;<br><span class="hljs-operator">%</span>swift.refcounted <span class="hljs-operator">=</span> type &#123; <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>, i64 &#125;<br><span class="hljs-operator">%</span>swift.type <span class="hljs-operator">=</span> type &#123; i64 &#125;<br><span class="hljs-operator">%</span>swift.full_boxmetadata <span class="hljs-operator">=</span> type &#123; void (<span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span>, i8<span class="hljs-operator">**</span>, <span class="hljs-operator">%</span>swift.type, i32, i8<span class="hljs-operator">*</span> &#125;<br><span class="hljs-operator">%</span><span class="hljs-type">TSi</span> <span class="hljs-operator">=</span> type <span class="hljs-operator">&lt;</span>&#123; i64 &#125;<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>swift.refcounted</code>由<code>swift.type</code>和一个<code>64</code>位<code>int</code>组成,而<code>swift.type</code>是一个<code>i64</code>结构，因此<code>swift.refcounted</code>的结构是<code>&#123; i64,i64&#125;</code></li>
</ul>
<h3 id="初步数据结构"><a href="#初步数据结构" class="headerlink" title="初步数据结构"></a>初步数据结构</h3><blockquote>
<p>结合上面分析，初步得出闭包的最初的数据结构</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClosureData</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> unkown: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// i8*</span><br>    <span class="hljs-keyword">var</span> closureHeapObject: <span class="hljs-type">ClosureHeapObject</span> <span class="hljs-comment">// swift.refcounted</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClosureHeapObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> refcount1: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> refcount2: <span class="hljs-type">Int32</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>unkown</code>是第一个参数<code>i8</code>,<code>closureHeapObject</code>即<code>swift.refcounted</code>结构</li>
</ul>
<h4 id="闭包构建分析"><a href="#闭包构建分析" class="headerlink" title="闭包构建分析"></a>闭包构建分析</h4><blockquote>
<p>下面看下<code>s5block15makeIncrementerSiycyF</code>也就是<code>makeIncrementer</code>函数到底是怎么构造出返回的东西<code>&#123; i8*, %swift.refcounted* &#125;</code>的:</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">define hidden swiftcc &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; @<span class="hljs-string">&quot;$s5block15makeIncrementerSiycyF&quot;</span>() #<span class="hljs-number">0</span> &#123;<br>entry:<br>  <span class="hljs-operator">%</span>runningTotal.debug <span class="hljs-operator">=</span> alloca <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span>, align <span class="hljs-number">8</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">0</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">**</span> <span class="hljs-operator">%</span>runningTotal.debug to i8<span class="hljs-operator">*</span><br>  call void <span class="hljs-meta">@llvm</span>.memset.p0i8.i64(i8<span class="hljs-operator">*</span> align <span class="hljs-number">8</span> <span class="hljs-operator">%</span><span class="hljs-number">0</span>, i8 <span class="hljs-number">0</span>, i64 <span class="hljs-number">8</span>, i1 <span class="hljs-literal">false</span>)<br><span class="hljs-comment">// %1堆空间的内存地址</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> call noalias <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-meta">@swift_allocObject</span>(<span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span> getelementptr inbounds (<span class="hljs-operator">%</span>swift.full_boxmetadata, <span class="hljs-operator">%</span>swift.full_boxmetadata<span class="hljs-operator">*</span> <span class="hljs-meta">@metadata</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">2</span>), i64 <span class="hljs-number">24</span>, i64 <span class="hljs-number">7</span>) #<span class="hljs-number">1</span><br><span class="hljs-comment">// 做了一个指针类型的转换，相当于UnsafeBitcast</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> bitcast <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span> to <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, [<span class="hljs-number">8</span> x i8] &#125;<span class="hljs-operator">&gt;*</span><br><span class="hljs-comment">// 取出指向[8 x i8]的指针</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, [<span class="hljs-number">8</span> x i8] &#125;<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span>&#123; <span class="hljs-operator">%</span>swift.refcounted, [<span class="hljs-number">8</span> x i8] &#125;<span class="hljs-operator">&gt;*</span> <span class="hljs-operator">%</span><span class="hljs-number">2</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">1</span><br><span class="hljs-comment">// 把它转换成 %TSi* 类型  （%TSi* 其实是一个 type&lt;&#123; i64 &#125;&gt;   64位的结构体）</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> bitcast [<span class="hljs-number">8</span> x i8]<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">3</span> to <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span><br><span class="hljs-comment">// 存储</span><br>  store <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">**</span> <span class="hljs-operator">%</span>runningTotal.debug, align <span class="hljs-number">8</span><br><span class="hljs-comment">//取出%4也就是%TSi* 类型的地址,赋值给._value</span><br>  <span class="hljs-operator">%</span>._value <span class="hljs-operator">=</span> getelementptr inbounds <span class="hljs-operator">%</span><span class="hljs-type">TSi</span>, <span class="hljs-operator">%</span><span class="hljs-type">TSi</span><span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">4</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br><span class="hljs-comment">// 把10这个值放到%._value地址偏移`8字节`的内存空间里，也就是type&lt;&#123; i64 &#125;&gt;(即swift.refcounted,是它的首地址内容)，往下偏移8字节存放内容</span><br>  store i64 <span class="hljs-number">10</span>, i64<span class="hljs-operator">*</span> <span class="hljs-operator">%</span>._value, align <span class="hljs-number">8</span><br><span class="hljs-comment">// 将func里的内嵌闭包地址转换成 void * 插入到 &#123; i8*, %swift.refcounted* &#125; 的第一个元素是函数地址，第二个元素是%1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> insertvalue &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; &#123; i8<span class="hljs-operator">*</span> bitcast (i64 (<span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span>)<span class="hljs-operator">*</span> @<span class="hljs-string">&quot;$s5block15makeIncrementerSiycyF11incrementerL_SiyFTA&quot;</span> to i8<span class="hljs-operator">*</span>), <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> undef &#125;, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> <span class="hljs-operator">%</span><span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>  ret &#123; i8<span class="hljs-operator">*</span>, <span class="hljs-operator">%</span>swift.refcounted<span class="hljs-operator">*</span> &#125; <span class="hljs-operator">%</span><span class="hljs-number">5</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="最终数据结构"><a href="#最终数据结构" class="headerlink" title="最终数据结构"></a>最终数据结构</h3><blockquote>
<p>根据上面的<code>IR</code>代码，还原出 <code>ClosureData</code> 的数据结构为：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClosureData</span>&lt;<span class="hljs-title">Box</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> ptr: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 闭包函数地址地址</span><br>    <span class="hljs-keyword">var</span> box: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Box</span>&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> object: <span class="hljs-type">HeapObject</span> <span class="hljs-comment">// 实例对象的内存地址</span><br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">T</span>  <span class="hljs-comment">//存的捕获的值</span><br>&#125;<br><br><span class="hljs-comment">///实例对象的内存地址</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span><br>    <span class="hljs-keyword">var</span> refcount1: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> refcount2: <span class="hljs-type">Int32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>ClosureData</code> 的数据结构 = <code>闭包的执行地址</code> + <code>捕获变量堆空间的地址</code></li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>()</span> -&gt; ()-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NoMeanStruct</span></span>&#123;<br>    <span class="hljs-keyword">var</span> closure: () -&gt; <span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> closure <span class="hljs-operator">=</span> <span class="hljs-type">NoMeanStruct</span>(closure: makeIncrementer())<br><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">NoMeanStruct</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>ptr.initialize(to: closure)<br><br><span class="hljs-comment">// 内存绑定</span><br><span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>)&#123; <span class="hljs-variable">$0</span>.pointee &#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭包地址: <span class="hljs-subst">\(closure_ptr.ptr)</span>&quot;</span>) <span class="hljs-comment">//闭包地址: 0x000000010000e100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例对象的内存地址: <span class="hljs-subst">\(closure_ptr.box)</span>&quot;</span>) <span class="hljs-comment">//实例对象的内存地址: 0x0000600000218340</span><br><br><span class="hljs-built_in">print</span>(closure_ptr.box.pointee.value) <span class="hljs-comment">//10 ,也就是0x600000218350上的值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br>ptr.deinitialize(count: <span class="hljs-number">1</span>)<br>ptr.deallocate()<br></code></pre></td></tr></table></figure>

<ul>
<li>断点查看实例对象的内存情况<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>4xg <span class="hljs-number">0x0000600000218340</span><br>                <span class="hljs-comment">// metadata.       // refcount</span><br><span class="hljs-number">0x600000218340</span>: <span class="hljs-number">0x0000000100010cf8</span> <span class="hljs-number">0x0000000200000003</span><br>                <span class="hljs-comment">//value</span><br><span class="hljs-number">0x600000218350</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li>输出的闭包地址<code>0x000000010000e100</code>一定能在<code>Mach-O</code>上面找到，所以可以使用下面的命令查找起来，可以证明输出的地址就是闭包地址：<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">$ nm <span class="hljs-operator">-</span>p <span class="hljs-type">SwiftSource</span> <span class="hljs-operator">|</span> grep <span class="hljs-number">000000010000e100</span><br>    <span class="hljs-number">000000010000e100</span> t  <span class="hljs-keyword">_</span><span class="hljs-variable">$s11SwiftSource15makeIncrementerL_SiycyF11incrementerL_SiyFTA</span><br>$ xcrun swift<span class="hljs-operator">-</span>demangle s11SwiftSource15makeIncrementerL_SiycyF11incrementerL_SiyFTA<br><br>    <span class="hljs-variable">$s11SwiftSource15makeIncrementerL_SiycyF11incrementerL_SiyFTA</span> <span class="hljs-operator">---&gt;</span> partial apply forwarder <span class="hljs-keyword">for</span> incrementer #<span class="hljs-number">1</span> () -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> makeIncrementer #<span class="hljs-number">1</span> () -&gt; () -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> <span class="hljs-type">SwiftSource</span><br></code></pre></td></tr></table></figure>
<h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h3><blockquote>
<p>如果<code>makeIncrementer</code>有参数呢？那么<code>Box</code>的数据结构就变了</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeIncrementer</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Int</span>)</span> -&gt; ()-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> runningTotal <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incrementer</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        runningTotal <span class="hljs-operator">+=</span> amount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>改变后的<code>Box</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> object: <span class="hljs-type">HeapObject</span>  <span class="hljs-comment">// 把value1、value2统一当成object的属性</span><br>    <span class="hljs-keyword">var</span> value1: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">T1</span>&gt;<br>    <span class="hljs-keyword">var</span> value2: <span class="hljs-type">T2</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> funcStruct <span class="hljs-operator">=</span> <span class="hljs-type">NoMeanStruct</span>(closure: makeIncrementer(<span class="hljs-number">20</span>))<br><span class="hljs-keyword">let</span> func_ptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">NoMeanStruct</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)<br>func_ptr.initialize(to: funcStruct)<br><br><span class="hljs-keyword">let</span> closure_ptr <span class="hljs-operator">=</span> func_ptr.withMemoryRebound(to: <span class="hljs-type">ClosureData</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>&gt;&gt;.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable">$0</span>.pointee &#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭包地址：<span class="hljs-subst">\(closure_ptr.ptr)</span>&quot;</span>) <span class="hljs-comment">// 闭包地址：0x0000000100011eb0</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例对象的内存地址: <span class="hljs-subst">\(closure_ptr.box)</span>&quot;</span>) <span class="hljs-comment">// 实例对象的内存地址: 0x00006000002084a0</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;捕获的地址：<span class="hljs-subst">\(closure_ptr.box.pointee.value1)</span>&quot;</span>) <span class="hljs-comment">// 捕获的地址：0x00006000002080a0 // 也就是0x6000002084b0上的值</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;参数的值：<span class="hljs-subst">\(closure_ptr.box.pointee.value2)</span>&quot;</span>) <span class="hljs-comment">// 参数的值：20 0x6000002084b8</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br>func_ptr.deinitialize(count: <span class="hljs-number">1</span>)<br>func_ptr.deallocate()<br></code></pre></td></tr></table></figure>
<ul>
<li>断点查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">(lldb) x<span class="hljs-operator">/</span>8xg <span class="hljs-number">0x00006000002084a0</span><br>         <span class="hljs-comment">// metadata.       // refcount</span><br><span class="hljs-number">0x6000002084a0</span>: <span class="hljs-number">0x0000000100014e08</span> <span class="hljs-number">0x0000000200000003</span><br>        <span class="hljs-comment">// value</span><br><span class="hljs-number">0x6000002084b0</span>: <span class="hljs-number">0x00006000002080a0</span> <span class="hljs-number">0x0000000000000014</span><br><span class="hljs-number">0x6000002084c0</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x00007ff8540dd570</span><br><span class="hljs-number">0x6000002084d0</span>: <span class="hljs-number">0x00007ff8540dd718</span> <span class="hljs-number">0x0000000000000000</span><br><br>(lldb) x<span class="hljs-operator">/</span>8xg <span class="hljs-number">0x00006000002080a0</span><br>    <span class="hljs-comment">// metadata.       // refcount</span><br><span class="hljs-number">0x6000002080a0</span>: <span class="hljs-number">0x0000000100014de0</span> <span class="hljs-number">0x0000000000000003</span><br>    <span class="hljs-comment">// value 存的10</span><br><span class="hljs-number">0x6000002080b0</span>: <span class="hljs-number">0x000000000000000a</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000002080c0</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x00007ffb1ec507f8</span><br><span class="hljs-number">0x6000002080d0</span>: <span class="hljs-number">0x00007ff810ba46a8</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>IR语法</title>
    <url>/2023/06/20/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/IR%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IR语法"><a href="#IR语法" class="headerlink" title="IR语法"></a>IR语法</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">[<span class="hljs-operator">&lt;</span>elementnumber<span class="hljs-operator">&gt;</span> x <span class="hljs-operator">&lt;</span>elementtype<span class="hljs-operator">&gt;</span>]   <span class="hljs-comment">// 元素个数 x 元素类型</span><br><br><span class="hljs-comment">//example:</span><br>alloca [<span class="hljs-number">24</span> x i8], align <span class="hljs-number">8</span>      <span class="hljs-number">24</span>个i8都是<span class="hljs-number">0</span> <br><br>alloca [<span class="hljs-number">4</span> x i32] <span class="hljs-operator">===</span> array<br></code></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">%</span>swift.refcounted <span class="hljs-operator">=</span> type &#123; <span class="hljs-operator">%</span>swift.type<span class="hljs-operator">*</span>, i64 &#125;<br><br><span class="hljs-comment">//example:</span><br><span class="hljs-operator">%</span><span class="hljs-type">T</span> <span class="hljs-operator">=</span> type &#123;<span class="hljs-operator">&lt;</span>type list<span class="hljs-operator">&gt;</span>&#125; <span class="hljs-comment">//这种和C语言的结构体类似</span><br></code></pre></td></tr></table></figure>

<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&lt;</span>type<span class="hljs-operator">&gt;</span> <span class="hljs-operator">*</span><br><br><span class="hljs-comment">//example:</span><br>i64<span class="hljs-operator">*</span> <span class="hljs-comment">//64位的整形</span><br></code></pre></td></tr></table></figure>

<h2 id="getelementptr-指令"><a href="#getelementptr-指令" class="headerlink" title="getelementptr 指令"></a><code>getelementptr</code> 指令</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">munger_struct</span> </span>&#123;<br>  int f1;<br>  int f2;<br>&#125;;<br><br>void munge(<span class="hljs-keyword">struct</span> munger_struct <span class="hljs-operator">*</span><span class="hljs-type">P</span>) &#123;<br>  <span class="hljs-type">P</span>[<span class="hljs-number">0</span>].f1 <span class="hljs-operator">=</span> <span class="hljs-type">P</span>[<span class="hljs-number">1</span>].f1 <span class="hljs-operator">+</span> <span class="hljs-type">P</span>[<span class="hljs-number">2</span>].f2;<br>&#125;<br><br><span class="hljs-comment">// 取出结构体首地址</span><br>getelementptr inbounds <span class="hljs-operator">%</span><span class="hljs-keyword">struct</span>.munger_struct, <span class="hljs-operator">%</span><span class="hljs-keyword">struct</span>.munger_struct <span class="hljs-operator">%</span><span class="hljs-number">1</span>, i64 <span class="hljs-number">0</span> <br><br><span class="hljs-comment">// 1.取出结构体首地址，2.然后取出结构体第一个元素</span><br>getelementptr inbounds <span class="hljs-operator">%</span><span class="hljs-keyword">struct</span>.munger_struct, <span class="hljs-operator">%</span><span class="hljs-keyword">struct</span>.munger_struct <span class="hljs-operator">%</span><span class="hljs-number">1</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 下面是一个案例：</span><br>int main(int argc, const char <span class="hljs-operator">*</span> argv[]) &#123;<br>    int array[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    int a <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>其中 int a <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>] 这句对应的<span class="hljs-type">LLVM代码应该是这样的：</span><br>a <span class="hljs-operator">=</span> getelementptr inbounds [<span class="hljs-number">4</span> x i32], [<span class="hljs-number">4</span> x i32]<span class="hljs-operator">*</span> array, i64 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span>, i32 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>TargetFunctionTypeMetadata</title>
    <url>/2023/06/18/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/TargetFunctionTypeMetadata/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><blockquote>
<p>函数本身也有自己的类型，它由形参类型和返回类型组成。<br>引用类型，其指向的地址第一个<code>8</code>字节存储的是函数类型的<code>metadata</code></p>
</blockquote>
<h2 id="TargetFunctionTypeMetadata"><a href="#TargetFunctionTypeMetadata" class="headerlink" title="TargetFunctionTypeMetadata"></a><code>TargetFunctionTypeMetadata</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of function type metadata.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetFunctionTypeMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br>  <span class="hljs-keyword">using</span> Parameter = ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt;;<br><br><span class="hljs-comment">//标识了函数的类型</span><br>  TargetFunctionTypeFlags&lt;StoredSize&gt; Flags;<br><br>  <span class="hljs-comment">/// The type metadata for the result type.</span><br>  ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt; ResultType;<br><br>  <span class="hljs-function">Parameter *<span class="hljs-title">getParameters</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;Parameter *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>); &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> Parameter *<span class="hljs-title">getParameters</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Parameter *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-function">Parameter <span class="hljs-title">getParameter</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(index &lt; <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getParameters</span>()[index];<br>  &#125;<br><br>  <span class="hljs-function">ParameterFlags <span class="hljs-title">getParameterFlags</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(index &lt; <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">auto</span> flags = <span class="hljs-built_in">hasParameterFlags</span>() ? <span class="hljs-built_in">getParameterFlags</span>()[index] : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ParameterFlags::<span class="hljs-built_in">fromIntValue</span>(flags);<br>  &#125;<br><br>  <span class="hljs-function">StoredSize <span class="hljs-title">getNumParameters</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getNumParameters</span>();<br>  &#125;<br>  <span class="hljs-function">FunctionMetadataConvention <span class="hljs-title">getConvention</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">getConvention</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAsync</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isAsync</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isThrowing</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isThrowing</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSendable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isSendable</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDifferentiable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isDifferentiable</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasParameterFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasParameterFlags</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEscaping</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isEscaping</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasGlobalActor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">hasGlobalActor</span>(); &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> StoredSize OffsetToFlags = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TargetMetadata&lt;Runtime&gt;);<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Function;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> *<span class="hljs-title">getParameterFlags</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(<span class="hljs-built_in">getParameters</span>() + <span class="hljs-built_in">getNumParameters</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *<span class="hljs-title">getParameterFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *&gt;(<span class="hljs-built_in">getParameters</span>() +<br>                                              <span class="hljs-built_in">getNumParameters</span>());<br>  &#125;<br><br>  <span class="hljs-function">TargetFunctionMetadataDifferentiabilityKind&lt;StoredSize&gt; *</span><br><span class="hljs-function">  <span class="hljs-title">getDifferentiabilityKindAddress</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isDifferentiable</span>());<br>    <span class="hljs-keyword">void</span> *previousEndAddr = <span class="hljs-built_in">hasParameterFlags</span>()<br>        ? <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getParameterFlags</span>() + <span class="hljs-built_in">getNumParameters</span>())<br>        : <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getParameters</span>() + <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<br>        TargetFunctionMetadataDifferentiabilityKind&lt;StoredSize&gt; *&gt;(<br>        llvm::<span class="hljs-built_in">alignAddr</span>(previousEndAddr,<br>                        llvm::<span class="hljs-built_in">Align</span>(<span class="hljs-built_in"><span class="hljs-keyword">alignof</span></span>(<span class="hljs-keyword">typename</span> Runtime::StoredPointer))));<br>  &#125;<br><br>  <span class="hljs-function">TargetFunctionMetadataDifferentiabilityKind&lt;StoredSize&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getDifferentiabilityKind</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDifferentiable</span>()) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">const_cast</span>&lt;TargetFunctionTypeMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>          -&gt;<span class="hljs-built_in">getDifferentiabilityKindAddress</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> TargetFunctionMetadataDifferentiabilityKind&lt;StoredSize&gt;<br>        ::NonDifferentiable;<br>  &#125;<br><br>  <span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt; *</span><br><span class="hljs-function">  <span class="hljs-title">getGlobalActorAddr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasGlobalActor</span>());<br>    <br>    <span class="hljs-keyword">void</span> *endAddr =<br>        <span class="hljs-built_in">isDifferentiable</span>()<br>          ? <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getDifferentiabilityKindAddress</span>() + <span class="hljs-number">1</span>) :<br>        <span class="hljs-built_in">hasParameterFlags</span>()<br>          ? <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getParameterFlags</span>() + <span class="hljs-built_in">getNumParameters</span>()) :<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(<span class="hljs-built_in">getParameters</span>() + <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<br>        ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt; *&gt;(<br>          llvm::<span class="hljs-built_in">alignAddr</span>(<br>              endAddr, llvm::<span class="hljs-built_in">Align</span>(<span class="hljs-built_in"><span class="hljs-keyword">alignof</span></span>(<span class="hljs-keyword">typename</span> Runtime::StoredPointer))));<br>  &#125;<br><br>  <span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getGlobalActor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">hasGlobalActor</span>())<br>      <span class="hljs-keyword">return</span> ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt;();<br><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">const_cast</span>&lt;TargetFunctionTypeMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>      -&gt;<span class="hljs-built_in">getGlobalActorAddr</span>();<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> FunctionTypeMetadata = TargetFunctionTypeMetadata&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>
<ol>
<li><code>TargetFunctionTypeMetadata</code>继承自<code>TargetMetadata</code>说明它拥有<code>Kind</code>属性</li>
<li><code>TargetFunctionTypeFlags&lt;StoredSize&gt; Flags;</code>，作用是标识了函数的类型,具体类型如下 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// Flags in a function type metadata record.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> int_type&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetFunctionTypeFlags</span> &#123;</span><br>  <span class="hljs-comment">// If we were ever to run out of space for function flags (8 bits)</span><br>  <span class="hljs-comment">// one of the flag bits could be used to identify that the rest of</span><br>  <span class="hljs-comment">// the flags is going to be stored somewhere else in the metadata.</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> :</span> int_type &#123;<br>    NumParametersMask      = <span class="hljs-number">0x0000FFFF</span>U,<br>    ConventionMask         = <span class="hljs-number">0x00FF0000</span>U,<br>    ConventionShift        = <span class="hljs-number">16U</span>,<br>    ThrowsMask             = <span class="hljs-number">0x01000000</span>U,<br>    ParamFlagsMask         = <span class="hljs-number">0x02000000</span>U,<br>    EscapingMask           = <span class="hljs-number">0x04000000</span>U,<br>    DifferentiableMask     = <span class="hljs-number">0x08000000</span>U,<br>    GlobalActorMask        = <span class="hljs-number">0x10000000</span>U,<br>    AsyncMask              = <span class="hljs-number">0x20000000</span>U,<br>    SendableMask           = <span class="hljs-number">0x40000000</span>U,<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The next bit will need to introduce a separate flags word.</span><br>  &#125;;<br>  int_type Data;<br></code></pre></td></tr></table></figure></li>
<li><code>ConstTargetMetadataPointer&lt;Runtime, swift::TargetMetadata&gt; ResultType;</code>是返回值类型</li>
<li>实际上<code>TargetFunctionTypeMetadata</code>还拥有一个参数列表，它其实是一个连续的内存空间 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <span class="hljs-function">Parameter *<span class="hljs-title">getParameters</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;Parameter *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>); &#125;<br><span class="hljs-function"><span class="hljs-keyword">const</span> Parameter *<span class="hljs-title">getParameters</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Parameter *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>  <span class="hljs-function">Parameter <span class="hljs-title">getParameter</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> index)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(index &lt; <span class="hljs-built_in">getNumParameters</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getParameters</span>()[index];<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="TargetFunctionTypeMetadata数据结构"><a href="#TargetFunctionTypeMetadata数据结构" class="headerlink" title="TargetFunctionTypeMetadata数据结构"></a><code>TargetFunctionTypeMetadata</code>数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetFunctionTypeMetadata</span></span>&#123;<br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <span class="hljs-comment">// isa</span><br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">Int</span> <span class="hljs-comment">//函数的类型</span><br>    <span class="hljs-keyword">var</span> resultType: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 返回值类型</span><br>    <span class="hljs-keyword">var</span> arguments: <span class="hljs-type">ArgumentsBuffer</span>&lt;<span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>&gt; <span class="hljs-comment">// 参数类型列表</span><br>    <span class="hljs-comment">// 获取参数个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberArguments</span>()</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x0000FFFF</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArgumentsBuffer</span>&lt;<span class="hljs-title">Element</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> element: <span class="hljs-type">Element</span><br><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buffer</span>(<span class="hljs-params">n</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeBufferPointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span>.withMemoryRebound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; start <span class="hljs-keyword">in</span><br>                <span class="hljs-keyword">return</span> start<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeBufferPointer</span>(start: ptr, count: n)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span>(<span class="hljs-params">of</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating: <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>).assumingMemoryBound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>).advanced(by: i))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>获取参数的个数，实际会调用<code>Flags</code>属性的<code>Flags.getNumParameters()</code>方法,<code>NumParametersMask</code>为<code>0x0000FFFFU</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">getNumParameters</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> Data &amp; NumParametersMask; &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="验证TargetFunctionTypeMetadata数据结构"><a href="#验证TargetFunctionTypeMetadata数据结构" class="headerlink" title="验证TargetFunctionTypeMetadata数据结构"></a>验证<code>TargetFunctionTypeMetadata</code>数据结构</h2><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swift_add</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">a</span>: <span class="hljs-type">Double</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">b</span>: <span class="hljs-type">Double</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Int</span>(a <span class="hljs-operator">+</span> b)<br>&#125;<br><br><span class="hljs-keyword">let</span> functionType <span class="hljs-operator">=</span> <span class="hljs-built_in">type</span>(of: swift_add)<br><span class="hljs-keyword">let</span> functionPointer <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(functionType <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetFunctionTypeMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br><span class="hljs-comment">//参数的数量</span><br><span class="hljs-built_in">print</span>(functionPointer.pointee.numberArguments())<span class="hljs-comment">//2</span><br><span class="hljs-comment">//第一个参数的类型</span><br><span class="hljs-built_in">print</span>(functionPointer.pointee.arguments.index(of: <span class="hljs-number">0</span>).pointee) <span class="hljs-comment">// Double</span><br><span class="hljs-comment">//函数的返回结果类型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">unsafeBitCast</span>(functionPointer.pointee.resultType, to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>)) <span class="hljs-comment">// Int</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>TargetEnumMetadata</title>
    <url>/2023/06/14/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/TargetEnumMetadata/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="TargetEnumMetadata"><a href="#TargetEnumMetadata" class="headerlink" title="TargetEnumMetadata"></a><code>TargetEnumMetadata</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of type metadata for enums.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetEnumMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetValueMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br>  <span class="hljs-keyword">using</span> TargetValueMetadata&lt;Runtime&gt;::TargetValueMetadata;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetEnumDescriptor&lt;Runtime&gt; *<span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> llvm::cast&lt;TargetEnumDescriptor&lt;Runtime&gt;&gt;(<span class="hljs-keyword">this</span>-&gt;Description);<br>  &#125;<br><br>  <span class="hljs-comment">// The first trailing field of enum metadata is always the generic</span><br>  <span class="hljs-comment">// argument array.</span><br><br>  <span class="hljs-comment">/// True if the metadata records the size of the payload area.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPayloadSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">hasPayloadSizeOffset</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/// Retrieve the size of the payload area.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// `hasPayloadSize` must be true for this to be valid.</span><br>  <span class="hljs-function">StoredSize <span class="hljs-title">getPayloadSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasPayloadSize</span>());<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">getPayloadSizeOffset</span>();<br>    <span class="hljs-keyword">const</span> StoredSize *asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> StoredSize *&gt;(<span class="hljs-keyword">this</span>);<br>    asWords += offset;<br>    <span class="hljs-keyword">return</span> *asWords;<br>  &#125;<br><br>  <span class="hljs-function">StoredSize &amp;<span class="hljs-title">getPayloadSize</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasPayloadSize</span>());<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">getPayloadSizeOffset</span>();<br>    StoredSize *asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;StoredSize *&gt;(<span class="hljs-keyword">this</span>);<br>    asWords += offset;<br>    <span class="hljs-keyword">return</span> *asWords;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span> *trailingFlags = <span class="hljs-built_in">getTrailingFlags</span>();<br>    <span class="hljs-keyword">if</span> (trailingFlags == <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> trailingFlags-&gt;<span class="hljs-built_in">isStaticSpecialization</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCanonicalStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span> *trailingFlags = <span class="hljs-built_in">getTrailingFlags</span>();<br>    <span class="hljs-keyword">if</span> (trailingFlags == <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> trailingFlags-&gt;<span class="hljs-built_in">isCanonicalStaticSpecialization</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> MetadataTrailingFlags *<span class="hljs-title">getTrailingFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">auto</span> flags = description-&gt;<span class="hljs-built_in">getFullGenericContextHeader</span>()<br>                     .DefaultInstantiationPattern-&gt;PatternFlags;<br>    <span class="hljs-keyword">if</span> (!flags.<span class="hljs-built_in">hasTrailingFlags</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> offset =<br>        <span class="hljs-built_in">getGenericArgumentOffset</span>() +<br>        description-&gt;<span class="hljs-built_in">getFullGenericContextHeader</span>().Base.<span class="hljs-built_in">getNumArguments</span>() +<br>        (<span class="hljs-built_in">hasPayloadSize</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> *&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> MetadataTrailingFlags *&gt;(asWords + offset);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">getGenericArgumentOffset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TargetEnumMetadata&lt;Runtime&gt;) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StoredPointer);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Enum<br>      || metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Optional;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> EnumMetadata = TargetEnumMetadata&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>TargetEnumMetadata</code>中没有成员变量， 其继承自<code>TargetValueMetadata</code>,该结构在<code>TargetStructMetadata分析</code>中已经介绍过了,而<code>TargetValueMetadata</code>继承<code>TargetMetadata</code>。因此<code>TargetEnumMetadata</code>数据结构体为：</li>
</ul>
<h3 id="TargetEnumMetadata数据结构"><a href="#TargetEnumMetadata数据结构" class="headerlink" title="TargetEnumMetadata数据结构"></a><code>TargetEnumMetadata</code>数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 枚举Metadata</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetEnumMetadata</span> </span>&#123;<br>    <span class="hljs-comment">//TargetValueMetadata</span><br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span><br>    <span class="hljs-comment">//TargetValueMetadata,根据不同的kind有不同的Descriptor</span><br>    <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetEnumDescriptor</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TargetEnumDescriptor"><a href="#TargetEnumDescriptor" class="headerlink" title="TargetEnumDescriptor"></a><code>TargetEnumDescriptor</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetEnumDescriptor</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">    :</span> <span class="hljs-keyword">public</span> TargetValueTypeDescriptor&lt;Runtime&gt;,<br>      <span class="hljs-keyword">public</span> TrailingGenericContextObjects&lt;TargetEnumDescriptor&lt;Runtime&gt;,<br>                            TargetTypeGenericContextDescriptorHeader,<br>                            <span class="hljs-comment">/*additional trailing objects*/</span><br>                            TargetForeignMetadataInitialization&lt;Runtime&gt;,<br>                            TargetSingletonMetadataInitialization&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasListCount&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasListEntry&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasCachingOnceToken&lt;Runtime&gt;&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> SingletonMetadataInitialization =<br>    TargetSingletonMetadataInitialization&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> ForeignMetadataInitialization =<br>    TargetForeignMetadataInitialization&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> Metadata =<br>    TargetRelativeDirectPointer&lt;Runtime, TargetMetadata&lt;Runtime&gt;, <span class="hljs-comment">/*Nullable*/</span> <span class="hljs-literal">false</span>&gt;;<br>  <span class="hljs-keyword">using</span> MetadataListCount =<br>    TargetCanonicalSpecializedMetadatasListCount&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> MetadataListEntry =<br>    TargetCanonicalSpecializedMetadatasListEntry&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> MetadataCachingOnceToken =<br>      TargetCanonicalSpecializedMetadatasCachingOnceToken&lt;Runtime&gt;;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects =<br>    swift::TrailingGenericContextObjects&lt;TargetEnumDescriptor&lt;Runtime&gt;,<br>                                        TargetTypeGenericContextDescriptorHeader,<br>                                        ForeignMetadataInitialization,<br>                                        SingletonMetadataInitialization,<br>                                        MetadataListCount,<br>                                        MetadataListEntry, <br>                                        MetadataCachingOnceToken&gt;;<br><br>  <span class="hljs-keyword">using</span> TrailingObjects =<br>    <span class="hljs-keyword">typename</span> TrailingGenericContextObjects::TrailingObjects;<br>  <span class="hljs-keyword">friend</span> TrailingObjects;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">using</span> OverloadToken = <span class="hljs-keyword">typename</span> TrailingObjects::<span class="hljs-keyword">template</span> OverloadToken&lt;T&gt;;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::numTrailingObjects;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;ForeignMetadataInitialization&gt;)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasForeignMetadataInitialization</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;SingletonMetadataInitialization&gt;)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasSingletonMetadataInitialization</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataListCount&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ?<br>      <span class="hljs-number">1</span><br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataListEntry&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ?<br>      <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListCount&gt;()-&gt;count<br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataCachingOnceToken&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericContext;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericContextHeader;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getFullGenericContextHeader;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericParams;<br><br>  <span class="hljs-comment">/// The number of non-empty cases in the enum are in the low 24 bits;</span><br>  <span class="hljs-comment">/// the offset of the payload size in the metadata record in words,</span><br>  <span class="hljs-comment">/// if any, is stored in the high 8 bits.</span><br>  <span class="hljs-comment">//有关联值枚举的数量</span><br>  <span class="hljs-keyword">uint32_t</span> NumPayloadCasesAndPayloadSizeOffset;<br><br>  <span class="hljs-comment">/// The number of empty cases in the enum.</span><br>  <span class="hljs-comment">/// 没有关联值枚举的数量</span><br>  <span class="hljs-keyword">uint32_t</span> NumEmptyCases;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">getNumPayloadCases</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> NumPayloadCasesAndPayloadSizeOffset &amp; <span class="hljs-number">0x00FFFFFF</span>U;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">getNumEmptyCases</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> NumEmptyCases;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">getNumCases</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getNumPayloadCases</span>() + NumEmptyCases;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">getPayloadSizeOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((NumPayloadCasesAndPayloadSizeOffset &amp; <span class="hljs-number">0xFF000000</span>U) &gt;&gt; <span class="hljs-number">24</span>);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPayloadSizeOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getPayloadSizeOffset</span>() != <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">getGenericArgumentOffset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TargetEnumMetadata&lt;Runtime&gt;::<span class="hljs-built_in">getGenericArgumentOffset</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> ForeignMetadataInitialization &amp;<span class="hljs-title">getForeignMetadataInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasForeignMetadataInitialization</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;ForeignMetadataInitialization&gt;();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> SingletonMetadataInitialization &amp;<span class="hljs-title">getSingletonMetadataInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasSingletonMetadataInitialization</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;SingletonMetadataInitialization&gt;();<br>  &#125;<br><br>  <span class="hljs-function">llvm::ArrayRef&lt;Metadata&gt; <span class="hljs-title">getCanonicalMetadataPrespecializations</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>()) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> *listCount = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListCount&gt;();<br>    <span class="hljs-keyword">auto</span> *list = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListEntry&gt;();<br>    <span class="hljs-keyword">return</span> llvm::ArrayRef&lt;Metadata&gt;(<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Metadata *&gt;(list),<br>        listCount-&gt;count<br>        );<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">swift_once_t</span> *<span class="hljs-title">getCanonicalMetadataPrespecializationCachingOnceToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> box = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataCachingOnceToken&gt;();<br>    <span class="hljs-keyword">return</span> box-&gt;token.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *cd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Enum;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>  [[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;Only meant for use in the debugger&quot;</span>)]] <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-keyword">using</span> EnumDescriptor = TargetEnumDescriptor&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>TargetEnumDescriptor</code>中有<code>NumPayloadCasesAndPayloadSizeOffset</code>和<code>NumEmptyCases</code>两个成员变量，其继承自<code>TargetValueTypeDescriptor</code>–&gt;<code>TargetTypeContextDescriptor</code> –&gt; <code>TargetContextDescriptor</code>的方式。这种继承方式中的属性，具体见<code>TargetStructMetadata分析</code>，其结构为</li>
</ul>
<h3 id="TargetEnumDescriptor数据结构"><a href="#TargetEnumDescriptor数据结构" class="headerlink" title="TargetEnumDescriptor数据结构"></a><code>TargetEnumDescriptor</code>数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetEnumDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumPayloadCasesAndPayloadSizeOffset</span>: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">NumEmptyCases</span>: <span class="hljs-type">UInt32</span><br>    <br>    <span class="hljs-keyword">var</span> genericArgumentOffset: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="验证TargetEnumDescriptor数据结构"><a href="#验证TargetEnumDescriptor数据结构" class="headerlink" title="验证TargetEnumDescriptor数据结构"></a>验证<code>TargetEnumDescriptor</code>数据结构</h1><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a><code>验证代码</code></h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TerminalChar</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> plain(<span class="hljs-type">Bool</span>)<br>    <span class="hljs-keyword">case</span> bold(<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> empty<br>    <span class="hljs-keyword">case</span> cursor<br>&#125;<br><br><span class="hljs-keyword">let</span> enumMetadata_ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(<span class="hljs-type">TerminalChar</span>.<span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetEnumMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br><span class="hljs-comment">//拿到枚举的名字</span><br><span class="hljs-keyword">let</span> namePtr <span class="hljs-operator">=</span> enumMetadata_ptr.pointee.typeDescriptor.pointee.name.getmeasureRelativeOffset()<br><span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: namePtr)) <span class="hljs-comment">// TerminalChar</span><br><span class="hljs-comment">// 有关联值的</span><br><span class="hljs-built_in">print</span>(enumMetadata_ptr.pointee.typeDescriptor.pointee.<span class="hljs-type">NumPayloadCasesAndPayloadSizeOffset</span>) <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 无关联值的</span><br> <span class="hljs-built_in">print</span>(enumMetadata_ptr.pointee.typeDescriptor.pointee.<span class="hljs-type">NumEmptyCases</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>注意，这里必须将<code>TerminalChar.self</code>视为<code>Any.Type</code>,因为<code>unsafeBitCast</code>需要两个参数的内存大小相同，而<code>TerminalChar.Typ</code>的内存大小是<code>0</code>和<code>UnsafeMutablePointer</code>的<code>8</code>字节不等，会报错。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TerminalChar</span>.<span class="hljs-keyword">Type</span>&gt;.size,<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>&gt;.size)<br><span class="hljs-comment">// 0 8</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 拿到属性描述器指针</span><br><span class="hljs-keyword">let</span> fieldDesc_ptr <span class="hljs-operator">=</span> enumMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset()<br>   <br><span class="hljs-comment">//输出枚举的类型，有两种不同类型的关联值，所以是3，如果去掉 一个则是2</span><br><span class="hljs-built_in">print</span>(fieldDesc_ptr.pointee.kind) <span class="hljs-comment">// 3</span><br><span class="hljs-comment">//数量，有4个枚举</span><br><span class="hljs-built_in">print</span>(fieldDesc_ptr.pointee.numFields) <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>
<h4 id="FieldDescriptor中的kind"><a href="#FieldDescriptor中的kind" class="headerlink" title="FieldDescriptor中的kind"></a>FieldDescriptor中的kind</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FieldDescriptorKind</span> : <span class="hljs-title">uint16_t</span> </span>&#123;<br>  <span class="hljs-comment">// Swift nominal types.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Struct</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Class</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Enum</span><br><br>  <span class="hljs-comment">// Fixed-size multi-payload enums have a special descriptor format that</span><br>  <span class="hljs-comment">// encodes spare bits.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> Actually implement this. For now, a descriptor with this kind</span><br>  <span class="hljs-comment">// just means we also have a builtin descriptor from which we get the</span><br>  <span class="hljs-comment">// size and alignment.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">MultiPayloadEnum</span>,<br><br>  <span class="hljs-comment">// A Swift opaque protocol. There are no fields, just a record for the</span><br>  <span class="hljs-comment">// type itself.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Protocol</span>,<br><br>  <span class="hljs-comment">// A Swift class-bound protocol.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">ClassProtocol</span>,<br><br>  <span class="hljs-comment">// An Objective-C protocol, which may be imported or defined in Swift.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">ObjCProtocol</span>,<br><br>  <span class="hljs-comment">// An Objective-C class, which may be imported or defined in Swift.</span><br>  <span class="hljs-comment">// In the former case, field type metadata is not emitted, and</span><br>  <span class="hljs-comment">// must be obtained from the Objective-C runtime.</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">ObjCClass</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="枚举中属性的类型"><a href="#枚举中属性的类型" class="headerlink" title="枚举中属性的类型"></a>枚举中属性的类型</h3><blockquote>
<p>注意只有有关联值的，其枚举才有类型，否则是没有的</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//泛型向量</span><br><span class="hljs-keyword">let</span> genericVector <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(enumMetadata_ptr).advanced(by: enumMetadata_ptr.pointee.typeDescriptor.pointee.genericArgumentOffset <span class="hljs-operator">*</span> <span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size).assumingMemoryBound(to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>)<br><br><span class="hljs-keyword">let</span> mangledName <span class="hljs-operator">=</span> fieldDesc_ptr.pointee.fields.index(of: <span class="hljs-number">0</span>).pointee.mangledTypeName.getmeasureRelativeOffset()<br>    <span class="hljs-keyword">let</span> fieldType <span class="hljs-operator">=</span> _getTypeByMangledNameInContext(mangledName,<br>                                                   <span class="hljs-number">256</span>,<br>                                                   genericContext: <span class="hljs-type">UnsafeRawPointer</span>(enumMetadata_ptr.pointee.typeDescriptor),<br>                                                   genericArguments: <span class="hljs-type">UnsafeRawPointer</span>(genericVector)<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.<span class="hljs-keyword">self</span>))<span class="hljs-operator">!</span><br>                                                   <br><span class="hljs-built_in">print</span>(fieldType) <span class="hljs-comment">// Bool</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: fieldDesc_ptr.pointee.fields.index(of: <span class="hljs-number">0</span>).pointee.fieldName.getmeasureRelativeOffset()))  <span class="hljs-comment">//plain</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>Mirror</title>
    <url>/2023/06/12/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/Mirror/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>对象的内存在堆中，其前<code>8</code>字节是<code>metadata</code>、随后<code>8</code>字节是引用计数，最后是成员变量<br><a href="https://github.com/apple/swift/blob/master/docs/ABI/TypeMetadata.rst">Metadata文档</a></p>
</blockquote>
<h1 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h1><blockquote>
<ul>
<li>反射就是可以动态获取 类型、成员信息，在运行时可调用方法、属性 等行为的特性。</li>
<li>基于原生<code>Swift</code>使用<code>Runtime</code>的诸多局限性，它的标准库提供了<code>反射机制</code>来让我们访问成员信息。<br><code>Swift</code>的反射机制是基于一个叫<code>Mirror</code>的结构体来实现的。，是比较弱的反射，不如直接从<code>metadata</code>中获取数据</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Tome&quot;</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">say</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;say hi&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> mirr <span class="hljs-operator">=</span> <span class="hljs-type">Mirror</span>(reflecting: <span class="hljs-type">Person</span>())<br><span class="hljs-built_in">print</span>(mirr.displayStyle)<br><span class="hljs-built_in">print</span>(mirr.subjectType)<br><span class="hljs-keyword">for</span> (label,value) <span class="hljs-keyword">in</span> mirr.children &#123;<br>    <span class="hljs-built_in">print</span>(label,value)<br>&#125;<br><br><span class="hljs-comment">//输出</span><br><span class="hljs-type">Optional</span>(<span class="hljs-type">Swift</span>.<span class="hljs-type">Mirror</span>.<span class="hljs-type">DisplayStyle</span>.class)<br><span class="hljs-type">Person</span><br><span class="hljs-type">Optional</span>(<span class="hljs-string">&quot;num&quot;</span>) <span class="hljs-number">0</span><br><span class="hljs-type">Optional</span>(<span class="hljs-string">&quot;name&quot;</span>) <span class="hljs-type">Tome</span><br></code></pre></td></tr></table></figure>
<ul>
<li>但是这种没有办法访问到当前的函数<code>teach</code>，如果想要访问函数，需要把函数定义成属性信息。<br>那我们可以简单地封装一下，得到一个对象的<code>key-value</code>：<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 调用函数直接得到一个对象的key-value</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getKeyValue</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">mirrorObj</span>: <span class="hljs-keyword">Any</span>)</span> -&gt; <span class="hljs-keyword">Any</span> &#123;<br>        <span class="hljs-keyword">let</span> mirror <span class="hljs-operator">=</span> <span class="hljs-type">Mirror</span>(reflecting: mirrorObj)<br>        <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>mirror.children.isEmpty <span class="hljs-keyword">else</span>&#123; <span class="hljs-keyword">return</span> mirrorObj &#125;<br>        <span class="hljs-keyword">var</span> result: [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] <span class="hljs-operator">=</span> [:]<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> mirror.children&#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> key <span class="hljs-operator">=</span> child.label&#123;<br>                result[key] <span class="hljs-operator">=</span> getKeyValue(child.value)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No Keys&quot;</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-built_in">print</span>(getKeyValue(<span class="hljs-type">Person</span>())) <span class="hljs-comment">//[&quot;name&quot;: &quot;Tome&quot;, &quot;num&quot;: 0]</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>TargetStructMetadata分析</title>
    <url>/2023/06/11/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/TargetStructMetadata%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TargetStructMetadata"><a href="#TargetStructMetadata" class="headerlink" title="TargetStructMetadata"></a>TargetStructMetadata</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h2 id="TargetStructMetadata-1"><a href="#TargetStructMetadata-1" class="headerlink" title="TargetStructMetadata"></a><code>TargetStructMetadata</code></h2><ul>
<li>源码声明：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of type metadata for structs.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetStructMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetValueMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> TargetValueMetadata&lt;Runtime&gt;::TargetValueMetadata;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> TargetStructDescriptor&lt;Runtime&gt; *<span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> llvm::cast&lt;TargetStructDescriptor&lt;Runtime&gt;&gt;(<span class="hljs-keyword">this</span>-&gt;Description);<br>  &#125;<br><br>  <span class="hljs-comment">// The first trailing field of struct metadata is always the generic</span><br>  <span class="hljs-comment">// argument array.</span><br><br>  <span class="hljs-comment">/// Get a pointer to the field offset vector, if present, or null.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *<span class="hljs-title">getFieldOffsets</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;FieldOffsetVectorOffset;<br>    <span class="hljs-keyword">if</span> (offset == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span>*&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *&gt;(asWords + offset);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span> *trailingFlags = <span class="hljs-built_in">getTrailingFlags</span>();<br>    <span class="hljs-keyword">if</span> (trailingFlags == <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> trailingFlags-&gt;<span class="hljs-built_in">isStaticSpecialization</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCanonicalStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span> *trailingFlags = <span class="hljs-built_in">getTrailingFlags</span>();<br>    <span class="hljs-keyword">if</span> (trailingFlags == <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> trailingFlags-&gt;<span class="hljs-built_in">isCanonicalStaticSpecialization</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> MetadataTrailingFlags *<span class="hljs-title">getTrailingFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">auto</span> flags = description-&gt;<span class="hljs-built_in">getFullGenericContextHeader</span>()<br>                     .DefaultInstantiationPattern-&gt;PatternFlags;<br>    <span class="hljs-keyword">if</span> (!flags.<span class="hljs-built_in">hasTrailingFlags</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> fieldOffset = description-&gt;FieldOffsetVectorOffset;<br>    <span class="hljs-keyword">auto</span> offset =<br>        fieldOffset +<br>        <span class="hljs-comment">// Pad to the nearest pointer.</span><br>        ((description-&gt;NumFields * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">uint32_t</span>) + <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *) - <span class="hljs-number">1</span>) /<br>         <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *));<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> *&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> MetadataTrailingFlags *&gt;(asWords + offset);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">getGenericArgumentOffset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TargetStructMetadata&lt;Runtime&gt;) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StoredPointer);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Struct;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> StructMetadata = TargetStructMetadata&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure></li>
<li><code>TargetStructMetadata</code>没有啥的属性，看看它父类<code>TargetValueMetadata</code>。</li>
</ul>
<h2 id="TargetValueMetadata"><a href="#TargetValueMetadata" class="headerlink" title="TargetValueMetadata"></a><code>TargetValueMetadata</code></h2><ul>
<li>源码声明：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The common structure of metadata for structs and enums.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetValueMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-built_in">TargetValueMetadata</span>(MetadataKind Kind,<br>                      <span class="hljs-keyword">const</span> TargetTypeContextDescriptor&lt;Runtime&gt; *description)<br>      : TargetMetadata&lt;Runtime&gt;(Kind), <span class="hljs-built_in">Description</span>(description) &#123;&#125;<br><br>  <span class="hljs-comment">/// An out-of-line description of the type.</span><br>  TargetSignedPointer&lt;Runtime, <span class="hljs-keyword">const</span> TargetValueTypeDescriptor&lt;Runtime&gt; * __ptrauth_swift_type_descriptor&gt; Description;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Struct<br>      || metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Enum<br>      || metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Optional;<br>  &#125;<br><br>  <span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, TargetValueTypeDescriptor&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">typename</span> Runtime::StoredSignedPointer</span><br><span class="hljs-function">  <span class="hljs-title">getDescriptionAsSignedPointer</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> ValueMetadata = TargetValueMetadata&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure></li>
<li><code>TargetValueMetadata</code>继承自<code>TargetMetadata</code>,而<code>TargetMatedata</code>中只有一个属性<code>Kind</code></li>
</ul>
<h2 id="TargetStructMetadata的数据结构"><a href="#TargetStructMetadata的数据结构" class="headerlink" title="TargetStructMetadata的数据结构"></a><code>TargetStructMetadata</code>的数据结构</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetStructMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span>: <span class="hljs-type">Int</span><br>     <span class="hljs-comment">// 结构体描述器 (TargetStructDescriptor是解析后的自定义的，它可以替代TargetValueTypeDescriptor)</span><br>    <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetStructDescriptor</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="TargetStructDescriptor"><a href="#TargetStructDescriptor" class="headerlink" title="TargetStructDescriptor"></a>TargetStructDescriptor</h1><h2 id="TargetStructDescriptor-1"><a href="#TargetStructDescriptor-1" class="headerlink" title="TargetStructDescriptor"></a>TargetStructDescriptor</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetStructDescriptor</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">    :</span> <span class="hljs-keyword">public</span> TargetValueTypeDescriptor&lt;Runtime&gt;,<br>      <span class="hljs-keyword">public</span> TrailingGenericContextObjects&lt;TargetStructDescriptor&lt;Runtime&gt;,<br>                            TargetTypeGenericContextDescriptorHeader,<br>                            <span class="hljs-comment">/*additional trailing objects*/</span><br>                            TargetForeignMetadataInitialization&lt;Runtime&gt;,<br>                            TargetSingletonMetadataInitialization&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasListCount&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasListEntry&lt;Runtime&gt;,<br>                            TargetCanonicalSpecializedMetadatasCachingOnceToken&lt;Runtime&gt;&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> ForeignMetadataInitialization =<br>    TargetForeignMetadataInitialization&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> SingletonMetadataInitialization =<br>    TargetSingletonMetadataInitialization&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> Metadata =<br>    TargetRelativeDirectPointer&lt;Runtime, TargetMetadata&lt;Runtime&gt;, <span class="hljs-comment">/*Nullable*/</span> <span class="hljs-literal">false</span>&gt;;<br>  <span class="hljs-keyword">using</span> MetadataListCount =<br>    TargetCanonicalSpecializedMetadatasListCount&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> MetadataListEntry =<br>    TargetCanonicalSpecializedMetadatasListEntry&lt;Runtime&gt;;<br>  <span class="hljs-keyword">using</span> MetadataCachingOnceToken =<br>      TargetCanonicalSpecializedMetadatasCachingOnceToken&lt;Runtime&gt;;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects =<br>      swift::TrailingGenericContextObjects&lt;TargetStructDescriptor&lt;Runtime&gt;,<br>                                           TargetTypeGenericContextDescriptorHeader,<br>                                           ForeignMetadataInitialization,<br>                                           SingletonMetadataInitialization,<br>                                           MetadataListCount,<br>                                           MetadataListEntry,<br>                                           MetadataCachingOnceToken&gt;;<br><br>  <span class="hljs-keyword">using</span> TrailingObjects =<br>    <span class="hljs-keyword">typename</span> TrailingGenericContextObjects::TrailingObjects;<br>  <span class="hljs-keyword">friend</span> TrailingObjects;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">using</span> OverloadToken = <span class="hljs-keyword">typename</span> TrailingObjects::<span class="hljs-keyword">template</span> OverloadToken&lt;T&gt;;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::numTrailingObjects;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;ForeignMetadataInitialization&gt;)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasForeignMetadataInitialization</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;SingletonMetadataInitialization&gt;)</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasSingletonMetadataInitialization</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataListCount&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ?<br>      <span class="hljs-number">1</span><br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataListEntry&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ?<br>      <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListCount&gt;()-&gt;count<br>      : <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">numTrailingObjects</span><span class="hljs-params">(OverloadToken&lt;MetadataCachingOnceToken&gt;)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericContext;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericContextHeader;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getFullGenericContextHeader;<br>  <span class="hljs-keyword">using</span> TrailingGenericContextObjects::getGenericParams;<br><br>  <span class="hljs-comment">/// The number of stored properties in the struct.</span><br>  <span class="hljs-comment">/// If there is a field offset vector, this is its length.</span><br>  <span class="hljs-keyword">uint32_t</span> NumFields;<br>  <span class="hljs-comment">/// The offset of the field offset vector for this struct&#x27;s stored</span><br>  <span class="hljs-comment">/// properties in its metadata, if any. 0 means there is no field offset</span><br>  <span class="hljs-comment">/// vector.</span><br>  <span class="hljs-keyword">uint32_t</span> FieldOffsetVectorOffset;<br>  <br>  <span class="hljs-comment">/// True if metadata records for this type have a field offset vector for</span><br>  <span class="hljs-comment">/// its stored properties.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasFieldOffsetVector</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> FieldOffsetVectorOffset != <span class="hljs-number">0</span>; &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> ForeignMetadataInitialization &amp;<span class="hljs-title">getForeignMetadataInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasForeignMetadataInitialization</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;ForeignMetadataInitialization&gt;();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> SingletonMetadataInitialization &amp;<span class="hljs-title">getSingletonMetadataInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasSingletonMetadataInitialization</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;SingletonMetadataInitialization&gt;();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">getGenericArgumentOffset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TargetStructMetadata&lt;Runtime&gt;::<span class="hljs-built_in">getGenericArgumentOffset</span>();<br>  &#125;<br><br>  <span class="hljs-function">llvm::ArrayRef&lt;Metadata&gt; <span class="hljs-title">getCanonicalMetadataPrespecializations</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>()) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> *listCount = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListCount&gt;();<br>    <span class="hljs-keyword">auto</span> *list = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataListEntry&gt;();<br>    <span class="hljs-keyword">return</span> llvm::ArrayRef&lt;Metadata&gt;(<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Metadata *&gt;(list),<br>        listCount-&gt;count<br>        );<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">swift_once_t</span> *<span class="hljs-title">getCanonicalMetadataPrespecializationCachingOnceToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">hasCanonicalMetadataPrespecializations</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> box = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> getTrailingObjects&lt;MetadataCachingOnceToken&gt;();<br>    <span class="hljs-keyword">return</span> box-&gt;token.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *cd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Struct;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetStructDescriptor</span> </span>&#123;<br>    <span class="hljs-comment">//父类TargetValueTypeDescriptor中的</span><br>    <span class="hljs-operator">....</span><br>    <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TargetValueTypeDescriptor"><a href="#TargetValueTypeDescriptor" class="headerlink" title="TargetValueTypeDescriptor"></a><code>TargetValueTypeDescriptor</code></h2><ul>
<li>源码分析：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetValueTypeDescriptor</span></span><br><span class="hljs-class">    :</span> <span class="hljs-keyword">public</span> TargetTypeContextDescriptor&lt;Runtime&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetContextDescriptor&lt;Runtime&gt; *cd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Struct ||<br>           cd-&gt;<span class="hljs-built_in">getKind</span>() == ContextDescriptorKind::Enum;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><code>TargetValueTypeDescriptor</code>是继承自<code>TargetTypeContextDescriptor</code>的。而在<code>swift类分析</code>章中可以知道，类的整个继承链是<code>TargetClassDescriptor</code> –&gt;<code>TargetTypeContextDescriptor</code> –&gt; <code>TargetContextDescriptor</code>。因此总的结构如下<br><img src="1.png"></li>
</ul>
<h3 id="TargetTypeContextDescriptor的数据结构"><a href="#TargetTypeContextDescriptor的数据结构" class="headerlink" title="TargetTypeContextDescriptor的数据结构"></a><code>TargetTypeContextDescriptor</code>的数据结构</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetStructDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 类名</span><br>    <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt; <span class="hljs-comment">// 属性描述器</span><br>    <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 每一个属性值距离当前实例对象地址的偏移量</span><br>    <br>    <span class="hljs-comment">// 泛型参数的偏移量 - 源码里是经过一系列计算 而HandyJSON直接给2</span><br>    <span class="hljs-keyword">var</span> genericArgumentOffset: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFieldOffsets</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">metadata</span>: <span class="hljs-type">UnsafeRawPointer</span>)</span> -&gt; <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">UInt32</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> offset:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">numericCast</span>(<span class="hljs-keyword">self</span>.fieldOffsetVectorOffset)<br>        <span class="hljs-comment">//int是8字节，偏移，则是8 * offset =FieldOffsets - metadata地址</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeRawPointer</span>(metadata.assumingMemoryBound(to: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>).advanced(by: offset)).assumingMemoryBound(to: <span class="hljs-type">UInt32</span>.<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>注意这里和<code>getFieldOffsets</code>返回的是<code>UnsafePointer&lt;Int32&gt;</code>确定的<code>UInt32</code>这是因为在源码中和类不同<ul>
<li>类的<code>StoredPointer</code>是种<code>泛型类型</code>，这里统一返回<code>UnsafePointer&lt;Int&gt;</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">/// Get a pointer to the field offset vector, if present, or null.</span><br><span class="hljs-function"><span class="hljs-keyword">const</span> StoredPointer *<span class="hljs-title">getFieldOffsets</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>  <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">getFieldOffsetVectorOffset</span>();<br>  <span class="hljs-keyword">if</span> (offset == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span>*&gt;(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> StoredPointer *&gt;(asWords + offset);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>结构体的<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//指定返回 uint32_t</span><br>    <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *<span class="hljs-title">getFieldOffsets</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;FieldOffsetVectorOffset;<br>    <span class="hljs-keyword">if</span> (offset == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span>*&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *&gt;(asWords + offset);<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="验证TargetStructMetadata数据结构"><a href="#验证TargetStructMetadata数据结构" class="headerlink" title="验证TargetStructMetadata数据结构"></a>验证TargetStructMetadata数据结构</h1><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a><code>验证代码</code></h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PersonStruct</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">let</span> name:<span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Test&quot;</span><br>    <span class="hljs-keyword">let</span> sex <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">var</span> address <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SZ-2023&quot;</span><br>    <span class="hljs-keyword">var</span> birthday <span class="hljs-operator">=</span> (<span class="hljs-string">&quot;2005&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;26&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> person <span class="hljs-operator">=</span> <span class="hljs-type">PersonStruct</span>()<br><span class="hljs-keyword">let</span> struct_ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(<span class="hljs-type">PersonStruct</span>.<span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetStructMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>注意，这里必须将<code>PersonStruct.self</code>视为<code>Any.Type</code>,因为<code>unsafeBitCast</code>需要两个参数的内存大小相同，而<code>PersonStruct.Typ</code>的内存大小是<code>0</code>和<code>UnsafeMutablePointer</code>的<code>8</code>字节不等，会报错。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">PersonStruct</span>.<span class="hljs-keyword">Type</span>&gt;.size,<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>&gt;.size)<br><span class="hljs-comment">// 0 8</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//类名</span><br>    <span class="hljs-keyword">let</span> name_ptr <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.name.getmeasureRelativeOffset()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: name_ptr)) <span class="hljs-comment">// PersonStruct</span><br></code></pre></td></tr></table></figure>

<h3 id="属性数量"><a href="#属性数量" class="headerlink" title="属性数量"></a>属性数量</h3><ul>
<li><code>typeDescriptor</code>内的数量，和<code>fieldDescriptor</code>的数量是一样的<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//属性的数量,下面两种方式获取的数量是一致的</span><br>    <span class="hljs-keyword">let</span> numFileds <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.numFields<br><span class="hljs-comment">//    let numFileds = struct_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.numFields</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;numFileds: <span class="hljs-subst">\(numFileds)</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="打印所有的属性"><a href="#打印所有的属性" class="headerlink" title="打印所有的属性"></a>打印所有的属性</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> bufferPtr <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.getFieldOffsets(<span class="hljs-type">UnsafeRawPointer</span>(struct_ptr))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>numFileds &#123;<br>        <span class="hljs-keyword">let</span> filedName <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.fieldName.getmeasureRelativeOffset()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;filedName: <span class="hljs-subst">\(String(cString: filedName))</span>&quot;</span>)<br>        <br>        <span class="hljs-comment">// 混写过的mangleTypeName</span><br>        <span class="hljs-keyword">let</span> mangledTypeName <span class="hljs-operator">=</span> struct_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.mangledTypeName.getmeasureRelativeOffset()<br>        <br>        <span class="hljs-comment">// 泛型向量</span><br>        <span class="hljs-keyword">let</span> genericVector <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(struct_ptr).advanced(by: struct_ptr.pointee.typeDescriptor.pointee.genericArgumentOffset <span class="hljs-operator">*</span> <span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size).assumingMemoryBound(to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>)<br>        <br>        <br>        <span class="hljs-comment">// 获取属性类型:</span><br>        <span class="hljs-keyword">let</span> fieldType <span class="hljs-operator">=</span> _getTypeByMangledNameInContext(mangledTypeName,<br>                                                       <span class="hljs-number">256</span>,<br>                                                       genericContext: <span class="hljs-type">UnsafeRawPointer</span>(classMetadata_ptr.pointee.typeDescriptor),<br>                                                       genericArguments: <span class="hljs-type">UnsafeRawPointer</span>(genericVector)<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.<span class="hljs-keyword">self</span>))<span class="hljs-operator">!</span><br>        <span class="hljs-comment">// 属性类型 （</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;filedType: <span class="hljs-subst">\(fieldType)</span>&quot;</span>)<br>        <br>        <span class="hljs-comment">// 对象的起始地址</span><br>        <span class="hljs-keyword">let</span> instanceAddress <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafeMutablePointer</span>(to: <span class="hljs-operator">&amp;</span>person)&#123;<span class="hljs-variable">$0</span>&#125; <span class="hljs-comment">// Person()的起始地址</span><br>        <span class="hljs-comment">// 每个属性的偏移量</span><br>        <span class="hljs-keyword">let</span> fieldOffset <span class="hljs-operator">=</span> bufferPtr[<span class="hljs-type">Int</span>(i)]<br>        <span class="hljs-comment">// 真实属性类型</span><br>        <span class="hljs-keyword">let</span> realType <span class="hljs-operator">=</span> getBitCast(type: fieldType) <span class="hljs-comment">// 把真实类型信息，保存到protocol的metadata，再通过Self.self获取真实类型</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;realType: <span class="hljs-subst">\(realType)</span>&quot;</span>)<br>        <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> realType.get(from: <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-type">UnsafeRawPointer</span>(instanceAddress).advanced(by: <span class="hljs-built_in">numericCast</span>(fieldOffset))))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;filedValue: <span class="hljs-subst">\(value)</span>&quot;</span>)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;========================================&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">PersonStruct</span><br>numFileds: <span class="hljs-number">5</span><br>filedName: age<br>filedType: <span class="hljs-type">Int</span><br>realType: <span class="hljs-type">Int</span><br>filedValue: <span class="hljs-number">18</span><br><span class="hljs-operator">========================================</span><br>filedName: name<br>filedType: <span class="hljs-type">String</span><br>realType: <span class="hljs-type">String</span><br>filedValue: <span class="hljs-type">Test</span><br><span class="hljs-operator">========================================</span><br>filedName: sex<br>filedType: <span class="hljs-type">Bool</span><br>realType: <span class="hljs-type">Bool</span><br>filedValue: <span class="hljs-literal">false</span><br><span class="hljs-operator">========================================</span><br>filedName: address<br>filedType: <span class="hljs-type">String</span><br>realType: <span class="hljs-type">String</span><br>filedValue: <span class="hljs-type">SZ</span><span class="hljs-operator">-</span><span class="hljs-number">2023</span><br><span class="hljs-operator">========================================</span><br>filedName: birthday<br>filedType: (<span class="hljs-type">String</span>, <span class="hljs-type">String</span>, <span class="hljs-type">String</span>)<br>realType: (<span class="hljs-type">String</span>, <span class="hljs-type">String</span>, <span class="hljs-type">String</span>)<br>filedValue: (<span class="hljs-string">&quot;2005&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;26&quot;</span>)<br><span class="hljs-operator">========================================</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>TargetClassMetadata结构分析</title>
    <url>/2023/06/09/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/TargetClassMetadata%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TargetClassMetadata的完整数据结构"><a href="#TargetClassMetadata的完整数据结构" class="headerlink" title="TargetClassMetadata的完整数据结构"></a>TargetClassMetadata的完整数据结构</h1><blockquote>
<p>结合前面的类分析和属性分析，可以确定<code>TargetClassMetadata</code>的完整数据结构</p>
</blockquote>
<h2 id="TargetClassMetadata"><a href="#TargetClassMetadata" class="headerlink" title="TargetClassMetadata"></a>TargetClassMetadata</h2><blockquote>
<p>类 <code>Metadata</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 类 Metadata</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> superClass: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span><br>    <span class="hljs-keyword">var</span> cacheData: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span><br>    <br>    <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <span class="hljs-comment">// swift特有的标志</span><br>    <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 实例独享内存首地址</span><br>    <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 实例对象内存大小</span><br>    <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <span class="hljs-comment">// 实例对象内存对齐方式</span><br>    <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <span class="hljs-comment">// 运行时保留字段</span><br>    <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 类的内存大小</span><br>    <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <span class="hljs-comment">//类的内存首地址</span><br>    <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetClassDescriptor</span>&gt; <span class="hljs-comment">// 类型描述器</span><br>    <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 实例销毁器</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TargetClassDescriptor"><a href="#TargetClassDescriptor" class="headerlink" title="TargetClassDescriptor"></a>TargetClassDescriptor</h2><blockquote>
<p>类描述器</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 类描述器</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassDescriptor</span></span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;   <span class="hljs-comment">// class/struct/enum 的名称</span><br>    <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>    <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt; <span class="hljs-comment">// 属性描述器</span><br>    <br>    <span class="hljs-keyword">var</span> superClassType: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 父类类型</span><br>    <span class="hljs-keyword">var</span> metadataNegativeSizeInWords: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> metadataPositiveSizeInWords: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> numImmediateMembers: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span><br>    <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 每一个属性值距离当前实例对象地址的偏移量</span><br>    <span class="hljs-comment">//var Offset: UInt32</span><br>    <span class="hljs-comment">// var size: UInt32</span><br>    <span class="hljs-comment">// V-Table  (methods)</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFieldOffsets</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">metadata</span>: <span class="hljs-type">UnsafeRawPointer</span>)</span> -&gt; <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> metadata.assumingMemoryBound(to: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>).advanced(by: <span class="hljs-built_in">numericCast</span>(<span class="hljs-keyword">self</span>.fieldOffsetVectorOffset))<br>    &#125;<br>    <br>    <span class="hljs-comment">// 泛型参数的偏移量 - 源码里是经过一系列计算 而HandyJSON直接给2</span><br>    <span class="hljs-keyword">var</span> genericArgumentOffset: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TargetRelativeDirectPointer"><a href="#TargetRelativeDirectPointer" class="headerlink" title="TargetRelativeDirectPointer"></a>TargetRelativeDirectPointer</h2><blockquote>
<p>相对地址指针</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 相对地址信息 - 存储的是偏移量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetRelativeDirectPointer</span>&lt;<span class="hljs-title">Pointee</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> offset: <span class="hljs-type">Int32</span><br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getmeasureRelativeOffset</span>()</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Pointee</span>&gt;&#123;<br>        <span class="hljs-keyword">let</span> offset <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.offset<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123; p <span class="hljs-keyword">in</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             获得self，变为raw，然后+offset</span><br><span class="hljs-comment">             </span><br><span class="hljs-comment">             - UnsafeRawPointer(p) 表示this</span><br><span class="hljs-comment">             - advanced(by: numericCast(offset) 表示移动的步长，即offset</span><br><span class="hljs-comment">             - assumingMemoryBound(to: T.self) 表示假定类型是T，即自己指定的类型</span><br><span class="hljs-comment">             - UnsafeMutablePointer(mutating:) 表示返回的指针类型</span><br><span class="hljs-comment">            */</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating: <span class="hljs-type">UnsafeRawPointer</span>(p).advanced(by: <span class="hljs-built_in">numericCast</span>(offset)).assumingMemoryBound(to: <span class="hljs-type">Pointee</span>.<span class="hljs-keyword">self</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="FieldDescriptor"><a href="#FieldDescriptor" class="headerlink" title="FieldDescriptor"></a>FieldDescriptor</h2><blockquote>
<p>属性描述器,通用<code>class</code>/<code>struct</code>/<code>enum</code>类 - 属性信息</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 属性描述器</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> mangledTypeName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> superclass: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">UInt16</span><br>    <span class="hljs-keyword">var</span> fieldRecordSize: <span class="hljs-type">UInt16</span><br>    <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 属性个数</span><br>    <span class="hljs-keyword">var</span> fields: <span class="hljs-type">FiledRecordBuffer</span>&lt;<span class="hljs-type">FieldRecord</span>&gt; <span class="hljs-comment">// 属性列表</span><br>&#125;<br><br><span class="hljs-comment">// 属性</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldRecord</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> mangledTypeName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 属性的类型</span><br>    <span class="hljs-keyword">var</span> fieldName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UInt8</span>&gt; <span class="hljs-comment">// 属性的名称</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FiledRecordBuffer</span>&lt;<span class="hljs-title">Element</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> element: <span class="hljs-type">Element</span><br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buffer</span>(<span class="hljs-params">n</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeBufferPointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span>.withMemoryRebound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; start <span class="hljs-keyword">in</span><br>                <span class="hljs-keyword">return</span> start<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeBufferPointer</span>(start: ptr, count: n)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span>(<span class="hljs-params">of</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating: <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>).assumingMemoryBound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>).advanced(by: i))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="验证TargetClassMetadata数据结构"><a href="#验证TargetClassMetadata数据结构" class="headerlink" title="验证TargetClassMetadata数据结构"></a>验证TargetClassMetadata数据结构</h1><blockquote>
<p>通过解析下面<code>Person</code>类的数据结构，分析下<code>Metadata</code>数据结构</p>
</blockquote>
<h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a><code>验证代码</code></h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;验证Metadata&quot;</span><br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> time <span class="hljs-operator">=</span> <span class="hljs-number">15.4</span><br>&#125;<br><span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>() <span class="hljs-comment">// 创建一个Person实例</span><br><span class="hljs-keyword">var</span> pClazz <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>.<span class="hljs-keyword">self</span> <span class="hljs-comment">// 拿到类对象</span><br><span class="hljs-comment">// 拿到ClassMetadata指针</span><br><span class="hljs-keyword">let</span> classMetadata_ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(pClazz, to: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">TargetClassMetadata</span>&gt;.<span class="hljs-keyword">self</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>unsafeBitCast</code>的作用：按位转换成指针 <code>UnsafeMutablePointer&lt;TargetClassMetadata&gt;</code>，就可以对指针进行操作。</li>
</ul>
<h2 id="类的名字"><a href="#类的名字" class="headerlink" title="类的名字"></a>类的名字</h2><ul>
<li><code>typeDescriptor</code>是直接指针，而其变量<code>name</code>存储的是间接指针，需要通过<code>getmeasureRelativeOffset</code>,即当前<code>name</code>的地址，加上其存储的偏移量，即为真实地址<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> name_ptr <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.name.getmeasureRelativeOffset()<br><span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(cString: name_ptr)) <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="属性个数"><a href="#属性个数" class="headerlink" title="属性个数"></a>属性个数</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> numFileds <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.numFields<br><span class="hljs-built_in">print</span>(numFileds)  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<h2 id="输出所有的属性"><a href="#输出所有的属性" class="headerlink" title="输出所有的属性"></a>输出所有的属性</h2><h3 id="首个属性的偏移地址"><a href="#首个属性的偏移地址" class="headerlink" title="首个属性的偏移地址"></a>首个属性的偏移地址</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> offsets <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.getFieldOffsets(<span class="hljs-type">UnsafeRawPointer</span>(classMetadata_ptr))<br></code></pre></td></tr></table></figure>
<ul>
<li>在<code>TargetClassDescriptor</code>里有一个属性叫<code>fieldOffsetVectorOffset</code>，它存储的是每一个属性值距离当前<code>实例对象地址</code>的偏移量；从<code>classMetadata_ptr</code>指针偏移<code>fieldOffsetVectorOffset</code>。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//person对象的实例地址</span><br><span class="hljs-keyword">let</span> instanceAddress <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passUnretained(person).toOpaque()<br><span class="hljs-comment">// 第一个属性的偏移量</span><br><span class="hljs-keyword">let</span> fieldOffset <span class="hljs-operator">=</span> offsets[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// valueAddess即第一个属性值存放的地址</span><br><span class="hljs-keyword">let</span> valueAddess <span class="hljs-operator">=</span> instanceAddress.advanced(by: fieldOffset)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="属性的类型，值"><a href="#属性的类型，值" class="headerlink" title="属性的类型，值"></a>属性的类型，值</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>numFileds &#123;<br>    <span class="hljs-comment">// 获取属性名</span><br>    <span class="hljs-keyword">let</span> fieldName <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.fieldName.getmeasureRelativeOffset()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fieldName：<span class="hljs-subst">\(String(cString: fieldName))</span>&quot;</span>)<br>    <br>    <span class="hljs-comment">// 混写过的类型名称</span><br>    <span class="hljs-keyword">let</span> mangledTypeName <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.mangledTypeName.getmeasureRelativeOffset()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mangledTypeName：<span class="hljs-subst">\(String(cString: mangledTypeName))</span>&quot;</span>)<br>    <br>    <span class="hljs-comment">// 泛型向量</span><br>    <span class="hljs-keyword">let</span> genericVector <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(classMetadata_ptr).advanced(by: classMetadata_ptr.pointee.typeDescriptor.pointee.genericArgumentOffset <span class="hljs-operator">*</span> <span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.size).assumingMemoryBound(to: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>)<br>                                                   <span class="hljs-type">UnsafeRawPointer</span>(genericVector)<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.<span class="hljs-keyword">self</span>))<br>    <span class="hljs-comment">//这个方式实际调用的系统方法库，去解析泛混合类型</span><br>    <span class="hljs-keyword">let</span> realType <span class="hljs-operator">=</span> _getTypeByMangledNameInContext(mangledTypeName,<br>                                                  <span class="hljs-number">256</span>,<br>                                                  genericContext: <span class="hljs-type">UnsafeRawPointer</span>(classMetadata_ptr.pointee.typeDescriptor),<br>                                                  genericArguments: <span class="hljs-type">UnsafeRawPointer</span>(genericVector)<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;.<span class="hljs-keyword">self</span>))<span class="hljs-operator">!</span><br>    <span class="hljs-comment">//拿到解析后的真实类型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;realType: <span class="hljs-subst">\(realType)</span>&quot;</span>)<br>    <br>    <span class="hljs-comment">// 把真实类型信息，保存到protocol的metadata，再通过Self.self获取真实类型</span><br>    <span class="hljs-keyword">let</span> protocolType <span class="hljs-operator">=</span> getBitCast(type: realType)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;protocolType: <span class="hljs-subst">\(protocolType)</span>&quot;</span>)<br>    <span class="hljs-comment">// 对象的起始地址</span><br>    <span class="hljs-keyword">let</span> instanceAddress <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passUnretained(person).toOpaque() <span class="hljs-comment">// Teacher()的起始地址</span><br>    <span class="hljs-comment">// 每个属性的偏移量</span><br>    <span class="hljs-keyword">let</span> fieldOffset <span class="hljs-operator">=</span> offsets[<span class="hljs-type">Int</span>(i)]<br>    <br>    <span class="hljs-comment">// 获取属性的值</span><br>    <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> protocolType.get(from: instanceAddress.advanced(by: fieldOffset))<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fieldValue: <span class="hljs-subst">\(value)</span>&quot;</span>)   <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==================&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="获取属性名"><a href="#获取属性名" class="headerlink" title="获取属性名"></a>获取属性名</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> fieldName <span class="hljs-operator">=</span> classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: <span class="hljs-type">Int</span>(i)).pointee.fieldName.getmeasureRelativeOffset()<br></code></pre></td></tr></table></figure>
<ol>
<li><p><code>classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee</code></p>
<ul>
<li>在<code>TargetClassDescriptor</code>中的<code>fieldDescriptor</code>是相对地址信息类型，通过调用<code>getmeasureRelativeOffset()</code>来做地址偏移，才能获取到真正的<code>fieldDescriptor</code>对象</li>
</ul>
</li>
<li><p><code>classMetadata_ptr.pointee.typeDescriptor.pointee.fieldDescriptor.getmeasureRelativeOffset().pointee.fields.index(of: Int(i)).pointee</code></p>
<ul>
<li>拿到真正的<code>fieldDescriptor</code>对象后，可以找到<code>fields</code>属性列表，可以发现它是一个<code>FiledRecordBuffer&lt;FieldRecord&gt;</code>类型，通过源码可知属性列表是一片连续的内存空间，需要逐个拿出对应地址的<code>field</code>指针；再<code>.pointee</code>得到<code>FieldRecord</code>实例对象，才能继续对<code>FieldRecord</code>实例的属性进行访问。</li>
</ul>
</li>
</ol>
<h4 id="获取属性类型"><a href="#获取属性类型" class="headerlink" title="获取属性类型"></a>获取属性类型</h4><ol>
<li><code>_getTypeByMangledNameInContext</code>的作用是将混写后的<code>属性类型名</code>解析还原，调用的是同一个<code>C</code>标准库里的函数,只需要声明即可（如果系统库，没有<code>swift_getTypeByMangledNameInContext</code>函数，则会崩溃） <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@_silgen_name</span>(<span class="hljs-string">&quot;swift_getTypeByMangledNameInContext&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_getTypeByMangledNameInContext</span>(</span><br><span class="hljs-function">    <span class="hljs-keyword">_</span> <span class="hljs-params">name</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">CChar</span>&gt;,</span><br><span class="hljs-function">    <span class="hljs-keyword">_</span> <span class="hljs-params">nameLength</span>: <span class="hljs-type">Int</span>,</span><br><span class="hljs-function">    <span class="hljs-params">genericContext</span>: <span class="hljs-type">UnsafeRawPointer</span>?,</span><br><span class="hljs-function">    <span class="hljs-params">genericArguments</span>: <span class="hljs-type">UnsafeRawPointer</span>?)</span><br>    -&gt; <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span><span class="hljs-operator">?</span><br></code></pre></td></tr></table></figure></li>
<li>返回的类型是一个<code>Any.Type</code>类型,无法知道其类型，实际上可以通过把真实类型信息，保存到<code>protocol</code>的<code>metadata</code>，再通过<code>Self.self</code>获取真实类型的方式 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 将一个Any.Type转换成BrigeProtocol</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBitCast</span>(<span class="hljs-params">type</span>: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>)</span> -&gt; <span class="hljs-type">BrigeProtocol</span>.<span class="hljs-keyword">Type</span> &#123;<br>        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-type">ProtocolMetadata</span>(type: type, witness: <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">let</span> bitCast <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(container, to: <span class="hljs-type">BrigeProtocol</span>.<span class="hljs-keyword">Type</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">// 将struct保存到Protocol的Metadata</span><br>        <span class="hljs-keyword">return</span> bitCast<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="BrigeProtocol"><a href="#BrigeProtocol" class="headerlink" title="BrigeProtocol"></a>BrigeProtocol</h5><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">BrigeProtocol</span>:<span class="hljs-title">Anyobject</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BrigeProtocol</span> </span>&#123;<br>    <span class="hljs-comment">// 获取真实类型信息的值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span>(<span class="hljs-params">from</span> <span class="hljs-params">pointer</span>: <span class="hljs-type">UnsafeRawPointer</span>)</span> -&gt; <span class="hljs-keyword">Any</span> &#123;<br>        <span class="hljs-keyword">return</span> pointer.assumingMemoryBound(to: <span class="hljs-keyword">Self</span>.<span class="hljs-keyword">self</span>).pointee<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 协议的Metadata。这里作为转换成确定类信息的协议metadata</span><br><span class="hljs-comment">// 协议见证表,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolMetadata</span> </span>&#123; <span class="hljs-comment">// TargetWitnessTable</span><br>    <span class="hljs-keyword">let</span> type: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span> <span class="hljs-comment">// 真实类型</span><br>    <span class="hljs-keyword">let</span> witness: <span class="hljs-type">Int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>这里是写入的类的元类类型，注意这里构建的是类的元类的协议，是<code>Class Existential Container</code>类型，其大小只有<code>16</code>字节<ul>
<li><code>getBitCast</code>返回的是<code>元类协议</code>(<code>BrigeProtocol.Type</code>),如果是协议返回<code>BrigeProtocol</code>，则其结构要转为<code>40</code>字节大小的类型<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> circle1:<span class="hljs-type">Shape</span>.<span class="hljs-keyword">Type</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>.<span class="hljs-keyword">self</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle1)) <span class="hljs-comment">// 16</span><br><br><span class="hljs-keyword">var</span> circle1:<span class="hljs-type">Shape</span> <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.size(ofValue: circle1)) <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="实际输出"><a href="#实际输出" class="headerlink" title="实际输出"></a>实际输出</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">fieldName：name<br>mangledTypeName：<span class="hljs-type">SS</span><br>realType: <span class="hljs-type">String</span><br>fieldType: <span class="hljs-type">String</span><br>fieldValue: 验证<span class="hljs-type">Metadata</span><br><span class="hljs-operator">==================</span><br>fieldName：age<br>mangledTypeName：<span class="hljs-type">Si</span><br>realType: <span class="hljs-type">Int</span><br>fieldType: <span class="hljs-type">Int</span><br>fieldValue: <span class="hljs-number">18</span><br><span class="hljs-operator">==================</span><br>fieldName：time<br>mangledTypeName：<span class="hljs-type">Sd</span><br>realType: <span class="hljs-type">Double</span><br>fieldType: <span class="hljs-type">Double</span><br>fieldValue: <span class="hljs-number">15.4</span><br><span class="hljs-operator">==================</span><br></code></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>swift内存管理</title>
    <url>/2023/05/25/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/swift%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p>核心概念`</p>
<ul>
<li><code>强引用</code>对象会持有这个实例，并且只要<code>强引用</code>仍然存在，就不允许对其进行释放。</li>
<li><code>弱引用</code>是一种<code>引用</code>，它不会持有所引用的实例，因此也不会阻止<code>ARC</code>销毁所引用的实例。</li>
<li><code>Unowned</code>引用方式也是<code>弱引用</code>的一种。区别是访问<code>计数器</code>为零的引用会导致运行时错误。当另一个实例的寿命相同或更长时，可以使用它。</li>
</ul>
</li>
<li><p><code>Swift</code>中的对象有三种计数器：<code>强引用</code>，<code>弱引用</code>和<code>无主引用</code>。这些<code>计数器</code>存储在<code>metadata</code>之后或者存储在<code>Side table</code>中</p>
</li>
<li><p><code>弱引用</code>和<code>无主引用</code>的计数器比强引用多<code>+1</code>。当对象执行完析构和销毁内存后，这个附加值将减小。</p>
</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ol>
<li>通过汇编调试和<code>swift</code>源码知道我们的 纯<code>swift</code>类的对象的内存分配：<code>__allocating_init</code>-&gt; <code>_swift_allocObject_</code> -&gt; <code>swift_slowAlloc</code> -&gt; <code>malloc</code><ol>
<li><code>_swift_allocObject_</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> HeapObject *_swift_allocObject_(HeapMetadata <span class="hljs-keyword">const</span> *metadata,<br>                                       <span class="hljs-keyword">size_t</span> requiredSize,<br>                                       <span class="hljs-keyword">size_t</span> requiredAlignmentMask) &#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isAlignmentMask</span>(requiredAlignmentMask));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SWIFT_STDLIB_HAS_MALLOC_TYPE</span><br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(<span class="hljs-built_in">swift_slowAllocTyped</span>(<br>      requiredSize, requiredAlignmentMask, <span class="hljs-built_in">getMallocTypeId</span>(metadata)));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(<br>      <span class="hljs-built_in">swift_slowAlloc</span>(requiredSize, requiredAlignmentMask));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this relies on the C++17 guaranteed semantics of no null-pointer</span><br>  <span class="hljs-comment">// check on the placement new allocator which we have observed on Windows,</span><br>  <span class="hljs-comment">// Linux, and macOS.</span><br>  ::<span class="hljs-keyword">new</span> (object) <span class="hljs-built_in">HeapObject</span>(metadata);<br><br>  <span class="hljs-comment">// If leak tracking is enabled, start tracking this object.</span><br>  <span class="hljs-built_in">SWIFT_LEAKS_START_TRACKING_OBJECT</span>(object);<br><br>  <span class="hljs-built_in">SWIFT_RT_TRACK_INVOCATION</span>(object, swift_allocObject);<br><br>  <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>_swift_allocObject_</code>里面创建一个 <code>HeapObject</code>对象并将其返回了，所以这个<code>HeapObject</code>就是我们实际创建的对象，来看看其初始化函数：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Initialize a HeapObject header as appropriate for a newly-allocated object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">HeapObject</span><span class="hljs-params">(HeapMetadata <span class="hljs-keyword">const</span> *newMetadata)</span> </span><br><span class="hljs-function">    : metadata(newMetadata)</span><br><span class="hljs-function">    , refCounts(InlineRefCounts::Initialized)</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="lldb调试"><a href="#lldb调试" class="headerlink" title="lldb调试"></a>lldb调试</h2><ol>
<li>调试代码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-keyword">var</span> diameter:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-keyword">let</span> cir <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br><span class="hljs-comment">//Unmanaged指定内存管理，转换成指针，</span><br><span class="hljs-comment">//passUnretained不会增加引用计数</span><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passUnretained(cir).toOpaque()<br><span class="hljs-built_in">print</span>(ptr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>调试,前<code>16</code>个字节就是<code>matadata</code>和<code>refcounts</code>,注意不要用<code>po</code>指令，会对<code>cir</code>强引用，增加引用计数<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0x00006000002013a0</span><br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x00006000002013a0</span><br><span class="hljs-number">0x6000002013a0</span>: <span class="hljs-number">0x0000000100008400</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x6000002013b0</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br><br>lldb) po cir<br>&lt;Circle: <span class="hljs-number">0x60000020d360</span>&gt;<br><br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x000060000020d360</span><br><span class="hljs-number">0x60000020d360</span>: <span class="hljs-number">0x0000000100008400</span> <span class="hljs-number">0x0000000200000003</span><br><span class="hljs-number">0x60000020d370</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br></code></pre></td></tr></table></figure></li>
<li>然后为何引用计数增加会导致计数从<code>0x0000000000000003</code> -&gt; <code>0x0000000200000003</code>,这是下面需要讨论的问题</li>
</ol>
<h1 id="引用计数的实质"><a href="#引用计数的实质" class="headerlink" title="引用计数的实质"></a>引用计数的实质</h1><h2 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h2><ol>
<li>从源码中<code>HeapObject.h</code>的找到<code>refcounts</code>的定义 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// standard Objective-C instance</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS       \</span><br><span class="hljs-meta">  InlineRefCounts refCounts</span><br><br><span class="hljs-comment">/// The Swift heap-object header.</span><br><span class="hljs-comment">/// This must match RefCountedStructTy in IRGen.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapObject</span> &#123;</span><br>  <span class="hljs-comment">/// This is always a valid pointer to a metadata object.</span><br>  HeapMetadata <span class="hljs-keyword">const</span> *__ptrauth_objc_isa_pointer metadata;<br><br>  SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __swift__</span><br>  <span class="hljs-built_in">HeapObject</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">// Initialize a HeapObject header as appropriate for a newly-allocated object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">HeapObject</span><span class="hljs-params">(HeapMetadata <span class="hljs-keyword">const</span> *newMetadata)</span> </span><br><span class="hljs-function">    : metadata(newMetadata)</span><br><span class="hljs-function">    , refCounts(InlineRefCounts::Initialized)</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
<li>从源码中<code>RefCount.h</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> RefCounts&lt;InlineRefCountBits&gt; InlineRefCounts; <span class="hljs-comment">//模版类</span><br><span class="hljs-keyword">typedef</span> RefCounts&lt;SideTableRefCountBits&gt; SideTableRefCounts;<br><br><br><span class="hljs-comment">// Barriers</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Strong refcount increment is unordered with respect to other memory locations</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Strong refcount decrement is a release operation with respect to other</span><br><span class="hljs-comment">// memory locations. When an object&#x27;s reference count becomes zero,</span><br><span class="hljs-comment">// an acquire fence is performed before beginning Swift deinit or ObjC</span><br><span class="hljs-comment">// -dealloc code. This ensures that the deinit code sees all modifications</span><br><span class="hljs-comment">// of the object&#x27;s contents that were made before the object was released.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Unowned and weak increment and decrement are all unordered.</span><br><span class="hljs-comment">// There is no deinit equivalent for these counts so no fence is needed.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Accessing the side table requires that refCounts be accessed with</span><br><span class="hljs-comment">// a load-consume. Only code that is guaranteed not to try dereferencing</span><br><span class="hljs-comment">// the side table may perform a load-relaxed of refCounts.</span><br><span class="hljs-comment">// Similarly, storing the new side table pointer into refCounts is a</span><br><span class="hljs-comment">// store-release, but most other stores into refCounts are store-relaxed.</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RefCountBits&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCounts</span> &#123;</span><br>  std::atomic&lt;RefCountBits&gt; refCounts;<br><br>  <span class="hljs-comment">// Out-of-line slow paths.</span><br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  HeapObject *<span class="hljs-title">incrementSlow</span><span class="hljs-params">(RefCountBits oldbits, <span class="hljs-keyword">uint32_t</span> inc)</span></span>;<br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">void</span> <span class="hljs-title">incrementNonAtomicSlow</span><span class="hljs-params">(RefCountBits oldbits, <span class="hljs-keyword">uint32_t</span> inc)</span></span>;<br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">bool</span> <span class="hljs-title">tryIncrementSlow</span><span class="hljs-params">(RefCountBits oldbits)</span></span>;<br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">bool</span> <span class="hljs-title">tryIncrementNonAtomicSlow</span><span class="hljs-params">(RefCountBits oldbits)</span></span>;<br><br>  <span class="hljs-function">SWIFT_NOINLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">void</span> <span class="hljs-title">incrementUnownedSlow</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inc)</span></span>;<br><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Initialized_t</span> &#123;</span> Initialized &#125;;<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Immortal_t</span> &#123;</span> Immortal &#125;;<br><br>  <span class="hljs-comment">// RefCounts must be trivially constructible to avoid ObjC++</span><br>  <span class="hljs-comment">// destruction overhead at runtime. Use RefCounts(Initialized)</span><br>  <span class="hljs-comment">// to produce an initialized instance.</span><br>  <span class="hljs-built_in">RefCounts</span>() = <span class="hljs-keyword">default</span>;<br>  <br>  <span class="hljs-comment">// Refcount of a new object is 1.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">RefCounts</span><span class="hljs-params">(Initialized_t)</span></span><br><span class="hljs-function">    : refCounts(RefCountBits(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;</span>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>RefCounts</code>就是对当前引用计数的包装类，而引用计数的具体类型取决于传递给<code>RefCounts</code>的参数 -&gt; <code>InlineRefCountBits</code>。<code>InlineRefCountBits</code>同样是个模版类。<code>RefCountIsInline</code>传递的是<code>true</code> / <code>false</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> RefCountBitsT&lt;RefCountIsInline&gt; InlineRefCountBits;<br><br><span class="hljs-comment">// RefCountIsInline: refcount stored in an object</span><br><span class="hljs-comment">// RefCountNotInline: refcount stored in an object&#x27;s side table entry</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RefCountInlinedness</span> &#123;</span> RefCountNotInline = <span class="hljs-literal">false</span>, RefCountIsInline = <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PerformDeinit</span> &#123;</span> DontPerformDeinit = <span class="hljs-literal">false</span>, DoPerformDeinit = <span class="hljs-literal">true</span> &#125;;<br></code></pre></td></tr></table></figure></li>
<li>模版类<code>RefCountBitsT</code>,<code>RefCountBitsT</code>就是真实操作引用计数的类，它只有一个属性 <code>bits</code>，它的类型定义是 <code>RefCountBitsInt</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Basic encoding of refcount and flag data into the object&#x27;s header.</span><br><span class="hljs-keyword">template</span> &lt;RefCountInlinedness refcountIsInline&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountBitsT</span> &#123;</span><br><br>  <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountBitsT</span>&lt;</span>RefCountIsInline&gt;;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountBitsT</span>&lt;</span>RefCountNotInline&gt;;<br>  <br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> RefCountInlinedness Inlinedness = refcountIsInline;<br><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> RefCountBitsInt&lt;refcountIsInline, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span>*)&gt;::Type<br>    BitsType;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> RefCountBitsInt&lt;refcountIsInline, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span>*)&gt;::SignedType<br>    SignedBitsType;<br>  <span class="hljs-keyword">typedef</span> RefCountBitOffsets&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BitsType)&gt;<br>    Offsets;<br><br>  BitsType bits;<br>......<br></code></pre></td></tr></table></figure></li>
<li><code>RefCountBitsInt</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 64-bit inline</span><br><span class="hljs-comment">// 64-bit out of line</span><br><span class="hljs-keyword">template</span> &lt;RefCountInlinedness refcountIsInline&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RefCountBitsInt</span>&lt;</span>refcountIsInline, <span class="hljs-number">8</span>&gt; &#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> Type;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int64_t</span> SignedType;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>引用计数的实质： <code>bits</code>其实就是一个<code>uint64</code>位的位域信息，它存储了就是运行周期相关的引用计数。</li>
</ol>
<h2 id="初始引用计数"><a href="#初始引用计数" class="headerlink" title="初始引用计数"></a>初始引用计数</h2><ol>
<li>对象初始化时,默认引用计数传参数<code>InlineRefCounts::Initialized</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Initialize a HeapObject header as appropriate for a newly-allocated object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">HeapObject</span><span class="hljs-params">(HeapMetadata <span class="hljs-keyword">const</span> *newMetadata)</span> </span><br><span class="hljs-function">    : metadata(newMetadata)</span><br><span class="hljs-function">    , refCounts(InlineRefCounts::Initialized)</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>Initialized</code>实际是一个枚举,方法为<code>RefCounts(Initialized_t)</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Initialized_t</span> &#123;</span> Initialized &#125;;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Immortal_t</span> &#123;</span> Immortal &#125;;<br><br>  <span class="hljs-comment">// RefCounts must be trivially constructible to avoid ObjC++</span><br>  <span class="hljs-comment">// destruction overhead at runtime. Use RefCounts(Initialized)</span><br>  <span class="hljs-comment">// to produce an initialized instance.</span><br>  <span class="hljs-built_in">RefCounts</span>() = <span class="hljs-keyword">default</span>;<br>  <br>  <span class="hljs-comment">// Refcount of a new object is 1.</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">RefCounts</span><span class="hljs-params">(Initialized_t)</span></span><br><span class="hljs-function">    : refCounts(RefCountBits(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;</span>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>refCounts(RefCountBits(0, 1))</code>,实际上<code>RefCounts&lt;InlineRefCountBits&gt; InlineRefCounts</code><ol>
<li>其内的类是<code>InlineRefCountBits</code>，其类型实际为<code>RefCountBitsT&lt;RefCountIsInline&gt; InlineRefCountBits</code>,</li>
<li>而<code>RefCountBitsT</code>是模版类 <code>template &lt;RefCountInlinedness refcountIsInline&gt; class RefCountBitsT</code>。</li>
<li>最终<code>RefCountBits</code>实际调用时<code>RefCountBitsT</code></li>
</ol>
</li>
<li><code>RefCountBitsT</code>初始化方法,这里<code>strongExtraCount</code>和<code>unownedCount</code>分别对应<code>RefCountBits(0, 1)</code>中的<code>0</code>,<code>1</code>,这里的<code>1</code>为无主引用<ul>
<li><code>0</code>左移<code>33</code>位还是<code>0</code>，<code>1</code>左移<code>1</code>位是<code>2</code>,<code>BitsType(1)</code>左移<code>0</code>为1,所以<code>refCounts</code>是<code>0x3</code>。(其他偏移见源码<code>RefCount.h</code>)</li>
<li>当声明一个引用对象，该对象没有被引用的时候，<code>refCounts</code>是<code>0x0000000000000003</code>：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">  <span class="hljs-keyword">constexpr</span></span><br><span class="hljs-function">  <span class="hljs-title">RefCountBitsT</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> strongExtraCount, <span class="hljs-keyword">uint32_t</span> unownedCount)</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 33</span></span><br><span class="hljs-function">    : bits((BitsType(strongExtraCount) &lt;&lt; Offsets::StrongExtraRefCountShift) |</span><br><span class="hljs-function">           // <span class="hljs-number">0</span></span><br><span class="hljs-function">           (BitsType(<span class="hljs-number">1</span>)                &lt;&lt; Offsets::PureSwiftDeallocShift) |</span><br><span class="hljs-function">           // <span class="hljs-number">1</span></span><br><span class="hljs-function">           (BitsType(unownedCount)     &lt;&lt; Offsets::UnownedRefCountShift))</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="引用计数如何增加"><a href="#引用计数如何增加" class="headerlink" title="引用计数如何增加"></a>引用计数如何增加</h2><ol>
<li>从<code>swift</code>源码中找到<code>HeapObject.cpp</code>找到<code>_swift_retain_</code>函数实现：<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SWIFT_ALWAYS_INLINE<br><span class="hljs-keyword">static</span> HeapObject *_swift_retain_(HeapObject *object) &#123;<br>  <span class="hljs-built_in">SWIFT_RT_TRACK_INVOCATION</span>(object, swift_retain);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValidPointerForNativeRetain</span>(object)) &#123;<br>    <span class="hljs-comment">// Return the result of increment() to make the eventual call to</span><br>    <span class="hljs-comment">// incrementSlow a tail call, which avoids pushing a stack frame on the fast</span><br>    <span class="hljs-comment">// path on ARM64.</span><br>    <span class="hljs-keyword">return</span> object-&gt;refCounts.<span class="hljs-built_in">increment</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>在<code>RefCount.h</code>中查找<code>increment</code>方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// This returns the enclosing HeapObject so that it the result of this call</span><br>  <span class="hljs-comment">// can be directly returned from swift_retain. This makes the call to</span><br>  <span class="hljs-comment">// incrementSlow() a tail call.</span><br>  <span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">  HeapObject *<span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inc = <span class="hljs-number">1</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>    <br>    <span class="hljs-comment">// constant propagation will remove this in swift_retain, it should only</span><br>    <span class="hljs-comment">// be present in swift_retain_n</span><br>    <span class="hljs-keyword">if</span> (inc != <span class="hljs-number">1</span> &amp;&amp; oldbits.<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">true</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>    &#125;<br>    <br>    RefCountBits newbits;<br>    <span class="hljs-keyword">do</span> &#123;<br>      newbits = oldbits;<br>      <span class="hljs-comment">//引用计数加1</span><br>      <span class="hljs-keyword">bool</span> fast = newbits.<span class="hljs-built_in">incrementStrongExtraRefCount</span>(inc);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SWIFT_UNLIKELY</span>(!fast)) &#123;<br>        <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">false</span>))<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">incrementSlow</span>(oldbits, inc);<br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                              std::memory_order_relaxed));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li>引用计数加<code>1</code>,显然，引用计数是原来的加上<code>1 &lt;&lt; 33</code>,此前引用计数啊加<code>1</code>为<code>0x0000000200000003</code>，实际上就是初始引用<code>0x3 + 1 &lt;&lt; 33</code>,在加<code>1</code>即为<code>0x0000000400000003</code>,引用计数减<code>1</code>,同样如此<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计数加1</span><br><span class="hljs-function">SWIFT_NODISCARD SWIFT_ALWAYS_INLINE <span class="hljs-keyword">bool</span></span><br><span class="hljs-function">  <span class="hljs-title">incrementStrongExtraRefCount</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inc)</span> </span>&#123;<br>    <span class="hljs-comment">// This deliberately overflows into the UseSlowRC field.</span><br>    <span class="hljs-comment">//inc左移33位</span><br>    bits += <span class="hljs-built_in">BitsType</span>(inc) &lt;&lt; Offsets::StrongExtraRefCountShift;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">SignedBitsType</span>(bits) &gt;= <span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">//计数减1</span><br>  <span class="hljs-function">SWIFT_NODISCARD SWIFT_ALWAYS_INLINE <span class="hljs-keyword">bool</span></span><br><span class="hljs-function">  <span class="hljs-title">decrementStrongExtraRefCount</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> dec)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">hasSideTable</span>() &amp;&amp; !<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">false</span>)) &#123;<br>      <span class="hljs-comment">// Can&#x27;t check these assertions with side table present.</span><br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getIsDeiniting</span>())<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">getStrongExtraRefCount</span>() &gt;= dec  &amp;&amp;<br>               <span class="hljs-string">&quot;releasing reference whose refcount is already zero&quot;</span>);<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">getStrongExtraRefCount</span>() + <span class="hljs-number">1</span> &gt;= dec  &amp;&amp;<br>               <span class="hljs-string">&quot;releasing reference whose refcount is already zero&quot;</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">// This deliberately underflows by borrowing from the UseSlowRC field.</span><br>    bits -= <span class="hljs-built_in">BitsType</span>(dec) &lt;&lt; Offsets::StrongExtraRefCountShift;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">SignedBitsType</span>(bits) &gt;= <span class="hljs-number">0</span>);<br>  &#125;PureSwiftDeallocShift<br></code></pre></td></tr></table></figure></li>
<li>其存储<code>64</code>位结构实际为</li>
</ol>
<table>
<thead>
<tr>
<th align="center">位数</th>
<th align="center">0</th>
<th align="center">1——31</th>
<th align="center">32</th>
<th align="center">33——62</th>
<th align="center">63</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">PPureSwiftDeallocShift</td>
<td align="center">UnownedRefCount</td>
<td align="center">IsDeiniting</td>
<td align="center">StrongExtraRefCount</td>
<td align="center">UseSlowRC</td>
</tr>
</tbody></table>
<h2 id="HeapObjectSideTableEntry"><a href="#HeapObjectSideTableEntry" class="headerlink" title="HeapObjectSideTableEntry"></a><span id="jump">HeapObjectSideTableEntry</span></h2><blockquote>
<p><code>Side tables</code>是实现<code>Swift</code>弱引用的核心,大多数情况，对象没有任何“弱”引用，因此为每个对象中的弱引用计数保留存储空间是浪费的。此信息存储在外部的 <code>side table</code>中，只有在确实需要时才会分配。弱引用变量不是直接指向对象，而是指向<code>side table</code>，而<code>side table</code>又指向对象.</p>
<ul>
<li>解决两个问题<ol>
<li>为<code>弱引用</code>计数节省内存，直到对象真正需要它才创建</li>
<li>允许安全地将<code>弱引用</code>归零，因为它不会直接指向对象，而是指向<code>side table</code>,并且不再是<code>竟态条件</code>(当两个<code>线程</code>竞争同一资源时，如果对资源的<code>访问顺序</code>敏感，就称存在<code>竞态</code>条件。)的主体</li>
</ol>
</li>
</ul>
</blockquote>
<ol>
<li>如果结构是<code>sidetable</code>，则会调用<code>incrementNonAtomicSlow</code>方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> fast = newbits.<span class="hljs-built_in">incrementStrongExtraRefCount</span>(inc);<span class="hljs-comment">//一直增加,看63位是否变为1</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SWIFT_UNLIKELY</span>(!fast)) &#123; <span class="hljs-comment">//为false</span><br>   <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">//如果是不可变对象直接返回</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">incrementSlow</span>(oldbits, inc);<br> &#125;<br></code></pre></td></tr></table></figure></li>
<li>首先会判断是否有<code>sidetable</code>通过<code>UseSlowRC</code>是否为1来判断。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RefCountBits&gt;<br>HeapObject *RefCounts&lt;RefCountBits&gt;::<span class="hljs-built_in">incrementSlow</span>(RefCountBits oldbits,<br>                                                   <span class="hljs-keyword">uint32_t</span> n) &#123;<br>  <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">isImmortal</span>(<span class="hljs-literal">false</span>)) &#123;<span class="hljs-comment">//不可变对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123; <span class="hljs-comment">//如果有sidtable</span><br>    <span class="hljs-comment">// Out-of-line slow path.</span><br>    <span class="hljs-keyword">auto</span> side = oldbits.<span class="hljs-built_in">getSideTable</span>();<br>    side-&gt;<span class="hljs-built_in">incrementStrong</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//没有引用越界异常</span><br>    <span class="hljs-comment">// Retain count overflow.</span><br>    swift::<span class="hljs-built_in">swift_abortRetainOverflow</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeapObject</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>sidetable</code>和<code>OC</code>中不不同，并非全局存储，而是同样存储在<code>refCount</code>指针中，通过移位获取真正的地址<ol>
<li><code>getSideTable</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">  HeapObjectSideTableEntry *<span class="hljs-title">getSideTable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">hasSideTable</span>());<br><br>    <span class="hljs-comment">// Stored value is a shifted pointer.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObjectSideTableEntry *&gt;<br>      (<span class="hljs-built_in">uintptr_t</span>(<span class="hljs-built_in">getField</span>(SideTable)) &lt;&lt; Offsets::SideTableUnusedLowBits);<br>      <span class="hljs-comment">// 0-62位，左移动 3位</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>setTable</code>,将<code>side</code>数据指针，右移<code>3</code>位后存储到<code>refCount</code>指针<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">  void setSideTable(HeapObjectSideTableEntry *side) &#123;<br>  assert(hasSideTable());<br>  // Stored value is a shifted pointer.<br>  uintptr_t value = reinterpret_cast&lt;uintptr_t&gt;(side);<br>  uintptr_t storedValue = value &gt;&gt; Offsets::SideTableUnusedLowBits;<br>  assert(storedValue &lt;&lt; Offsets::SideTableUnusedLowBits == value);<br>  setField(SideTable, storedValue);<br>  setField(SideTableMark, 1);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>也就是说，<code>HeapObject</code>的<code>RefCounts</code>实际上存在两种结构，一种是指针<code>RefCount</code>,一种是<code>HeapObjectSideTableEntry</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">HeapObject &#123;<br>    isa<br>    InlineRefCounts &#123;<br>      atomic&lt;InlineRefCountBits&gt; &#123;<br>        strong RC + unowned RC + flags<br>        OR<br>        HeapObjectSideTableEntry* <span class="hljs-comment">//列表</span><br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>HeapObjectSideTableEntry</code>的结构体如下,<code>SideTableRefCountBits</code>也是指针<code>RefCount</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">HeapObjectSideTableEntry &#123;<br>    SideTableRefCounts &#123;<br>      object pointer<br>      atomic&lt;SideTableRefCountBits&gt; &#123;<br>        strong RC + unowned RC + weak RC + flags<br>      &#125;<br>    &#125;   <br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>SideTableRefCountBits</code>是由<code>strong RC + unowned RC + weak RC + flags</code>组成，<code>32位</code> + <code>32位</code> + <code>32位</code> + <code>1位</code>组成<ol>
<li>这里<code>strong RC + unowned RC</code>的初始化和此前一样，和<code>weak</code>做了拆分<code>RefCountBitsT&lt;RefCountNotInline&gt;(strongExtraCount, unownedCount)</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//指针大小的两倍对齐</span><br><span class="hljs-function">class <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span>*) * <span class="hljs-number">2</span>)</span> SideTableRefCountBits : public RefCountBitsT&lt;RefCountNotInline&gt;</span><br><span class="hljs-function">&#123;</span><br>  <span class="hljs-keyword">uint32_t</span> weakBits;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">    <span class="hljs-title">SideTableRefCountBits</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-title">SideTableRefCountBits</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> strongExtraCount,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">uint32_t</span> unownedCount)</span></span><br><span class="hljs-function">        : RefCountBitsT&lt;RefCountNotInline&gt;(strongExtraCount, unownedCount)</span><br><span class="hljs-function">          // weak refcount starts at <span class="hljs-number">1</span> on behalf of the unowned count</span><br><span class="hljs-function">          ,</span><br><span class="hljs-function">          weakBits(<span class="hljs-number">1</span>) &#123;</span>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><code>side-&gt;incrementStrong(n);</code>本质上还是调用了<code>refCount</code>中的方法，也就是说实际上并不会扩展引用计数的大小 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incrementStrong</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inc)</span> </span>&#123;<br>refCounts.<span class="hljs-built_in">increment</span>(inc);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>sidtable</code>中实际强引用大小上是固定的<code>2^32-1</code>，而对象的总引用计数包括强引用计数、无主引用计数、弱引用计数。和<code>OC</code>不同，其主要是为来实现<code>swift</code>弱引用。一旦有弱引用指向对象，才会去创建<code>sidetable</code></li>
<li>对象最初是没有<code>Side Table</code>的，在以下情况下会自动创建：<ul>
<li>对象由弱引用指向时</li>
<li><code>strong</code>或 <code>unowned</code> 计数器溢出（在<code>32</code>位系统上，嵌入式计数器很小）。</li>
</ul>
</li>
<li>“弱”引用现在直接指向<code>Side Table</code>，而“强”和“无主”引用仍然直接指向对象。这样就可以完全释放对象的内存。<ul>
<li>此前类，<code>属性</code>和<code>引用计数器</code>是内联存储的。它比将数据存储在外部内存块中要快一些。但是如果有一个<code>弱引用</code>引用了这个对象，并且一段时间后，<code>强计数器</code>变为了<code>零</code>，而<code>弱计数器</code>仍然不为<code>零</code>。这种情况下，<code>自动引用计数</code>将会把该对象从内存中<code>删除</code>。尽管这样会导致对象<code>销毁</code>，但不会<code>释放</code>其内存(因为还存在<code>弱引用计数</code>)。</li>
<li>当另一个对象通过<code>弱引用</code>访问被销毁的对象时，<code>弱计数器</code>将减少。当<code>弱计数器</code>达到<code>零</code>时，将最终<code>释放内存</code>。这意味着<code>销毁的对象</code>会成为可能长时间占用内存的<strong>僵尸对象</strong>。</li>
</ul>
</li>
</ol>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><blockquote>
<p>用<code>weak</code>直接修饰<code>swift</code>类（如果继承<code>NSObject</code>则还是和<code>OC</code>实现弱引用一样)，则会调用<code>swift_weakInit</code>函数</p>
</blockquote>
<h3 id="弱引用创建"><a href="#弱引用创建" class="headerlink" title="弱引用创建"></a>弱引用创建</h3><ul>
<li><code>swift_weakInit</code>,内实际调用了<code>nativeInit</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">WeakReference *<span class="hljs-title">swift::swift_weakInit</span><span class="hljs-params">(WeakReference *ref, HeapObject *value)</span> </span>&#123;<br>  ref-&gt;<span class="hljs-built_in">nativeInit</span>(value);<br>  <span class="hljs-keyword">return</span> ref;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">(HeapObject *object)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> side = object ? object-&gt;refCounts.formWeakReference() : <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">//存储在弱引用表上</span><br>    nativeValue.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">WeakReferenceBits</span>(side), std::memory_order_relaxed);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>formWeakReference</code>,从<code>sidetable</code>中直接增加弱引用计数和上面强引用一样<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::formWeakReference()<br>&#123;<br>  <span class="hljs-keyword">auto</span> side = <span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (side)<br>    <span class="hljs-keyword">return</span> side-&gt;<span class="hljs-built_in">incrementWeak</span>();<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// Increment the weak reference count.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incrementWeak</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>    RefCountBits newbits;<br>    <span class="hljs-keyword">do</span> &#123;<br>      newbits = oldbits;<br>      <span class="hljs-built_in">assert</span>(newbits.<span class="hljs-built_in">getWeakRefCount</span>() != <span class="hljs-number">0</span>);<br>      newbits.<span class="hljs-built_in">incrementWeakRefCount</span>();<br>      <br>      <span class="hljs-keyword">if</span> (newbits.<span class="hljs-built_in">getWeakRefCount</span>() &lt; oldbits.<span class="hljs-built_in">getWeakRefCount</span>())<br>        <span class="hljs-built_in">swift_abortWeakRetainOverflow</span>();<br>    &#125; <span class="hljs-keyword">while</span> (!refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                              std::memory_order_relaxed));<br>  &#125;<br>  <br>  <span class="hljs-function">SWIFT_ALWAYS_INLINE</span><br><span class="hljs-function">    <span class="hljs-keyword">void</span> <span class="hljs-title">incrementWeakRefCount</span><span class="hljs-params">()</span> </span>&#123; weakBits++; &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>allocateSideTable</code>,如果有<code>sidatable</code>则返回，没有则生成<ol>
<li>拿到原有的<code>64</code>位引用计数</li>
<li>没有则会创建一个<code>sidetable</code>，并保存原有的数据，<code>sidetable</code>中存储的数据即为<a href="#jump">HeapObjectSideTableEntry</a><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::<span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-keyword">bool</span> failIfDeiniting)<br>&#123;<br>    <span class="hljs-comment">//1. 拿到原有的64位引用计数</span><br>  <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>  <br>  <span class="hljs-comment">// Preflight failures before allocating a new side table.</span><br>  <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>    <span class="hljs-comment">// Already have a side table. Return it.</span><br>    <span class="hljs-keyword">return</span> oldbits.<span class="hljs-built_in">getSideTable</span>();<br>  &#125; <br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>    <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Preflight passed. Allocate a side table.</span><br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> custom side table allocator</span><br>  <span class="hljs-number">2.</span> 创建一个sidetable表<br>  <span class="hljs-keyword">auto</span> side = swift_cxx_newObject&lt;HeapObjectSideTableEntry&gt;(<span class="hljs-built_in">getHeapObject</span>());<br>  <br>  <span class="hljs-keyword">auto</span> newbits = <span class="hljs-built_in">InlineRefCountBits</span>(side);<span class="hljs-number">2.</span> 将创建的sidetable的地址进行初始化<br>  <br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>      <span class="hljs-comment">// Already have a side table. Return it and delete ours.</span><br>      <span class="hljs-comment">// Read before delete to streamline barriers.</span><br>      <span class="hljs-keyword">auto</span> result = oldbits.<span class="hljs-built_in">getSideTable</span>();<br>      <span class="hljs-built_in">swift_cxx_deleteObject</span>(side);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>      <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    side-&gt;<span class="hljs-built_in">initRefCounts</span>(oldbits); <span class="hljs-comment">//3. 将原来的sidetable保存</span><br>    <br>  &#125; <span class="hljs-keyword">while</span> (! refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                             std::memory_order_release,<br>                                             std::memory_order_relaxed));<br>  <span class="hljs-keyword">return</span> side;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="弱引用管理"><a href="#弱引用管理" class="headerlink" title="弱引用管理"></a>弱引用管理</h3><ul>
<li><p>获取<code>弱引用对象</code>的方式是通过<code>swift_weakLoadStrong</code>获取的，如果没释放就返回对象，否则返回<code>nil</code>。(并非直接指向原来的对象)<code>弱引用</code>的对象释放，而<code>弱引用</code>还在实际上并非立即设置为<code>nil</code>，完全释放<code>弱引用</code>的<code>sidetable</code>要调用<code>swift_weakDestroy</code>。在调用<code>弱引用</code>的方法，在其<code>get</code>方法中会通过调用<code>swift_weakLoadStrong</code>，返回<code>nil</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HeapObject *<span class="hljs-title">swift::swift_weakLoadStrong</span><span class="hljs-params">(WeakReference *ref)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ref-&gt;<span class="hljs-built_in">nativeLoadStrong</span>();<br>&#125;<br><br><span class="hljs-function">HeapObject *<span class="hljs-title">nativeLoadStrong</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> bits = nativeValue.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">nativeLoadStrongFromBits</span>(bits);<br>&#125;<br>  <br><span class="hljs-function">HeapObject *<span class="hljs-title">nativeLoadStrongFromBits</span><span class="hljs-params">(WeakReferenceBits bits)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> side = bits.<span class="hljs-built_in">getNativeOrNull</span>();<br>    <span class="hljs-keyword">return</span> side ? side-&gt;<span class="hljs-built_in">tryRetain</span>() : <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//已经deinit，则无法retain了，返回nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>完全释放<code>弱引用</code>,则会调用<code>swift_weakDestroy</code>-&gt;<code>nativeDestroy</code>,将<code>nativeValue</code>保存的弱引用<code>sidetable</code>删除（而弱引用实际指向<code>sidetable</code>）,置为<code>nil</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nativeDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> oldBits = nativeValue.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    nativeValue.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>    <span class="hljs-built_in">destroyOldNativeBits</span>(oldBits);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroyOldNativeBits</span><span class="hljs-params">(WeakReferenceBits oldBits)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> oldSide = oldBits.<span class="hljs-built_in">getNativeOrNull</span>();<br>    <span class="hljs-keyword">if</span> (oldSide)<br>      oldSide-&gt;<span class="hljs-built_in">decrementWeak</span>();<span class="hljs-comment">//sidetable销毁，设置为nil</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrementWeak</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> assertions</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> optimize barriers</span><br>    <span class="hljs-keyword">bool</span> cleanup = refCounts.<span class="hljs-built_in">decrementWeakShouldCleanUp</span>();<br>    <span class="hljs-keyword">if</span> (!cleanup)<br>      <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// Weak ref count is now zero. Delete the side table entry.</span><br>    <span class="hljs-comment">// FREED -&gt; DEAD</span><br>    <span class="hljs-built_in">assert</span>(refCounts.<span class="hljs-built_in">getUnownedCount</span>() == <span class="hljs-number">0</span>);<span class="hljs-comment">//存在无主引用则会崩溃</span><br>    <span class="hljs-built_in">swift_cxx_deleteObject</span>(<span class="hljs-keyword">this</span>);<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="lldb调试验证"><a href="#lldb调试验证" class="headerlink" title="lldb调试验证"></a>lldb调试验证</h2><ol>
<li><code>let cir = Circle()</code>初始化<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x0000600000206540</span><br><span class="hljs-number">0x600000206540</span>: <span class="hljs-number">0x0000000100008110</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000206550</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br></code></pre></td></tr></table></figure></li>
<li><code>let t = cir</code>增加强引用<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x0000600000206540</span><br><span class="hljs-number">0x600000206540</span>: <span class="hljs-number">0x0000000100008110</span> <span class="hljs-number">0x0000000200000003</span><br><span class="hljs-number">0x600000206550</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br></code></pre></td></tr></table></figure></li>
<li><code>weak var t1 = cir</code>修饰弱引用,地址变为<code>0xc0000c0000040d5c</code>,这是个内存地址，而非引用计数,需要将其还原<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x0000600000206540</span><br><span class="hljs-number">0x600000206540</span>: <span class="hljs-number">0x0000000100008110</span> <span class="hljs-number">0xc0000c0000040d5c</span><br><span class="hljs-number">0x600000206550</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000012</span><br></code></pre></td></tr></table></figure></li>
<li>得到<code>sidetable</code>地址需要左移动3位,先将最前面的<code>62</code>，<code>63</code>的<code>1</code>设置为<code>0</code>,不然越界无法左移。显然和<code>HeapObjectSideTableEntry</code>数据结构体一致(采用的是2位指针的对齐，即16字节对齐),<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) p/x <span class="hljs-number">0x0000c0000040d5c</span> &lt;&lt; <span class="hljs-number">3</span><br>(Int) $R2 = <span class="hljs-number">0x0000600000206ae0</span><br>(lldb) x/<span class="hljs-number">6</span>xg <span class="hljs-number">0x0000600000206ae0</span><br><span class="hljs-comment">//先存的堆对象</span><br><span class="hljs-number">0x600000206ae0</span>: <span class="hljs-number">0x0000600000206540</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-comment">//强引用，无主引用，弱引用</span><br><span class="hljs-number">0x600000206af0</span>: <span class="hljs-number">0x0000000200000003</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x600000206b00</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br>(lldb) <br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h1><p><img src="1.png"></p>
<ol>
<li>在<code>Live</code>状态时，对象处于活动状态。其引用计数被初始化为 <code>strong：1</code>， <code>unown：1</code>和 <code>weak：1</code>（<code>side table</code>从<code>+1</code>开始）。 一旦有弱引用指向对象，便会创建<code>side table</code>。<strong>弱引用</strong>指向<code>side table</code>而不是对象。</li>
<li>一旦强引用计数达到零，则对象从<code>Live</code>状态进入<code>Deiniting</code>状态。处于<code>Deiniting</code>状态表示<code>deinit</code>正在进行中。在这一点上，强引用操作无效。<ul>
<li>如果存在关联的<code>side table</code>，通过弱引用访问将返回<code>nil</code>。</li>
<li>通过<code>unowned</code>访问将触发断言失败。</li>
<li>通过新的<code>unowned</code>引用仍然可以存储</li>
</ul>
</li>
<li>从此状态开始，可能选择两条分支：<ol>
<li>快速判断如果没有<code>weak</code>，<code>unowned</code>的引用和<code>side table</code>。该对象将转换为<code>Dead</code>状态，并<strong>立即</strong>从内存中删除。</li>
<li>否则对象将变为<code>Deinited</code>状态</li>
</ol>
</li>
<li>在<code>Deinited</code>状态下，<code>deinit</code>已经执行完成，该对象还有未完成的无主引用（至少是初始值：<code>1</code>）,此时，通过强、无主引用以及弱引用进行存储和读取无法发生(强制会崩溃)。通过<code>Unown</code>读取会触发断言错误,但是还留<code>Unown</code>的对象可以访问(代码直接无法访问，<code>lldb</code>可以)（对象还未释放）。如果<code>Unown</code>引用变为<code>0</code>,该对象可以从此处进入两条分支：<ol>
<li>如果无无主引用和弱引用，则可以立即释放该对象。它过渡到<code>Dead</code>状态。</li>
<li>否则，仍然有一个<code>side table</code>要移除，并且对象进入<code>Freed</code>状态,在<code>Freed</code>状态之前，对象已完全释放，但它的 <code>side table</code>仍处于活动状态,此时弱引用变量加载将返回<code>nil</code>,当弱引用计数变为<code>0</code>时，<code>side table</code>会被销毁。对象将转换为<code>DEAD</code></li>
</ol>
</li>
<li>除指向对象的指针外，在<code>Dead</code>状态下对象已被全部销毁。指向<code>HeapObject</code>的指针也从堆中释放出来，在内存中找不到该对象的任何痕迹。</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>SwiftC相关指令</title>
    <url>/2023/05/21/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/SwiftC%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SwiftC相关指令"><a href="#SwiftC相关指令" class="headerlink" title="SwiftC相关指令"></a><code>SwiftC</code>相关指令</h1><ol>
<li><p>语法分析分析输出<code>AST</code>(抽象语法树)</p>
<ul>
<li><code>swiftc main.swift -dump-parse</code></li>
</ul>
</li>
<li><p>语义分析并且检查类型输出<code>AST</code></p>
<ul>
<li><code>swiftc main.swift -dump-ast</code></li>
</ul>
</li>
<li><p>生成<code>swift</code>中间体语言（<code>SIL</code>）未优化</p>
<ul>
<li><code>swiftc main.swift -emit-silgen</code></li>
</ul>
</li>
<li><p>生成<code>swift</code>中间体语言（<code>SIL</code>）已优化</p>
<ul>
<li><code>swiftc main.swift -emit-sil</code></li>
</ul>
</li>
<li><p>生成<code>LLVM</code>中间体语言 （<code>.ll</code>文件）</p>
<ul>
<li><code>swiftc main.swift -emit-ir</code></li>
</ul>
</li>
<li><p>生成<code>LLVM</code>中间体语言 （<code>.bc</code>文件）</p>
<ul>
<li><code>swiftc main.swift -emit-bc</code></li>
</ul>
</li>
<li><p>生成汇编</p>
<ul>
<li><code>swiftc main.swift -emit-assembly</code></li>
</ul>
</li>
<li><p>编译生成可执行<code>.out</code>文件 （<code>x86</code>、<code>arm64</code>….）</p>
<ul>
<li><code>swiftc -o main.o main.swift</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>属性分析</title>
    <url>/2023/05/21/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h1><blockquote>
<p>存储属性是一个作为特定类和结构体实例一部分的常量或变量。存储属性要么是变量存储属性 （由 <code>var</code> 关键字引入）要么是常量存储属性（由 <code>let</code> 关键字引入）</p>
</blockquote>
<h2 id="let-和-var-的区别："><a href="#let-和-var-的区别：" class="headerlink" title="let 和 var 的区别："></a><code>let</code> 和 <code>var</code> 的区别：</h2><ul>
<li>测试验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;断点&quot;</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="从定义上"><a href="#从定义上" class="headerlink" title="从定义上"></a>从定义上</h3><ul>
<li><code>let</code>:用来声明常量，常量的值一旦设置好便不能再被更改；</li>
<li><code>var</code>:用来声明变量，变量的值可以在将来设置为不同的值。</li>
</ul>
<h3 id="汇编角度"><a href="#汇编角度" class="headerlink" title="汇编角度"></a>汇编角度</h3><ul>
<li>汇编查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">SwiftSource</span>`main:<br>    <span class="hljs-number">0x100003df0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:   pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003df1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:   movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003df4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:   subq   <span class="hljs-variable">$0</span>x30, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003df8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:   movq   <span class="hljs-variable">$0</span>xa, <span class="hljs-number">0x41fd</span>(<span class="hljs-operator">%</span>rip)<br>    <span class="hljs-number">0x100003e03</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">19</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-variable">$0</span>x14, <span class="hljs-number">0x41fa</span>(<span class="hljs-operator">%</span>rip)       ; <span class="hljs-type">SwiftSource</span>.age : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">4</span><br>-&gt;  <span class="hljs-number">0x100003e0e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">30</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edi<br></code></pre></td></tr></table></figure></li>
<li>两者并没有任何差别，无非把值赋值给对应的寄存器</li>
</ul>
<h3 id="SIL角度"><a href="#SIL角度" class="headerlink" title="SIL角度"></a><code>SIL</code>角度</h3><ul>
<li><p><code>swiftc xxx.swift -emit-sil // 生成sil（已优化</code></p>
</li>
<li><p>生成的<code>SIL</code></p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//存储型属性  有初始值</span><br><span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br><br><span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">let</span> name: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br><br><span class="hljs-comment">//全局变量声明</span><br><span class="hljs-comment">// age</span><br>sil_global hidden @<span class="hljs-variable">$s4main3ageSivp</span> : <span class="hljs-variable">$Int</span><br><br><span class="hljs-comment">// name</span><br>sil_global hidden [<span class="hljs-keyword">let</span>] @<span class="hljs-variable">$s4main4nameSivp</span> : <span class="hljs-variable">$Int</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>存储属性</code>在编译的时候，编译器默认会合成<code>get</code>/<code>set</code>方式，而我们<code>访问</code>/<code>赋值</code>存储属性的时候，实际上就是调用<code>get</code>/<code>set</code>。</p>
</li>
<li><p><code>let</code>声明的属性默认不会提供<code>setter</code>,无法调用<code>set</code>方法，因此无法赋值</p>
</li>
</ul>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><blockquote>
<p>类、结构体和枚举也能够定义计算属性，计算属性并不存储值，他们提供 <code>getter</code> 和 <code>setter</code> 来修改和获取值。</p>
</blockquote>
<ul>
<li>测试验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> diameter:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> radius <span class="hljs-operator">*</span> <span class="hljs-number">2</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">set</span> &#123;<br>            radius <span class="hljs-operator">=</span> newValue <br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">10</span>)<br>s.diameter <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="汇编角度-1"><a href="#汇编角度-1" class="headerlink" title="汇编角度"></a>汇编角度</h2><ul>
<li>汇编查看,实际会直接调用<code>setter</code>方法，采用<code>直接派发</code>静态调用的方式<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0x100003b94</span> &lt;+<span class="hljs-number">52</span>&gt;:  movl   $<span class="hljs-number">0x1e</span>, %edi<br>    <span class="hljs-number">0x100003b99</span> &lt;+<span class="hljs-number">57</span>&gt;:  leaq   <span class="hljs-number">0x4460</span>(%rip), %r13        ; SwiftSource.s : SwiftSource.Circle<br>    <span class="hljs-number">0x100003ba0</span> &lt;+<span class="hljs-number">64</span>&gt;:  callq  <span class="hljs-number">0x100003d50</span>               ; SwiftSource.Circle.diameter.setter : Swift.Int at main.swift:<span class="hljs-number">18</span><br></code></pre></td></tr></table></figure></li>
<li><code>setter</code>方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SwiftSource`Circle.diameter.setter:<br>-&gt;  <span class="hljs-number">0x100003d50</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  %rbp<br>    <span class="hljs-number">0x100003d51</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   %rsp, %rbp<br>    <span class="hljs-number">0x100003d54</span> &lt;+<span class="hljs-number">4</span>&gt;:  movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003d5c</span> &lt;+<span class="hljs-number">12</span>&gt;: movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x10</span>(%rbp)<br>    <span class="hljs-number">0x100003d64</span> &lt;+<span class="hljs-number">20</span>&gt;: movq   %rdi, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003d68</span> &lt;+<span class="hljs-number">24</span>&gt;: movq   %r13, <span class="hljs-number">-0x10</span>(%rbp)<br>    <span class="hljs-number">0x100003d6c</span> &lt;+<span class="hljs-number">28</span>&gt;: movq   %rdi, (%r13)<br>    <span class="hljs-number">0x100003d70</span> &lt;+<span class="hljs-number">32</span>&gt;: popq   %rbp<br>    <span class="hljs-number">0x100003d71</span> &lt;+<span class="hljs-number">33</span>&gt;: retq   <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="SIL角度-1"><a href="#SIL角度-1" class="headerlink" title="SIL角度"></a>SIL角度</h2><ul>
<li><p><code>swiftc xxx.swift -emit-sil</code></p>
</li>
<li><p>生成的<code>SIL</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> &#123;</span><br>  @_hasStorage var radius: Int &#123; get set &#125;<br>  var diameter: Int &#123; get set &#125;<br>  <span class="hljs-built_in">init</span>(radius: Int)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>计算属性非<code>@_hasStorage</code>属性，但是具有<code>getter</code>和<code>sertter</code>方法，不占用实例的内存</li>
</ul>
<h1 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h1><blockquote>
<ul>
<li>属性观察者会观察用来观察属性值的变化：<ul>
<li><code>willSet</code> 当属性将被改变调用，即使这个值与 原有的值相同；</li>
<li><code>didSet</code> 在属性已经改变之后调用。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>测试验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            radius <span class="hljs-operator">=</span> <span class="hljs-number">15</span><br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            radius <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">10</span>)<br>s.radius <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br><span class="hljs-built_in">print</span>(s.radius) <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="汇编角度-2"><a href="#汇编角度-2" class="headerlink" title="汇编角度"></a>汇编角度</h2><ul>
<li><p>调用初始化方式</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100003bda</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>xa, <span class="hljs-operator">%</span>edi<br>    <span class="hljs-number">0x100003bdf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003ea0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.<span class="hljs-keyword">init</span>(radius: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span> at main.swift:<span class="hljs-number">11</span><br><span class="hljs-operator">.....</span><br><br><br><span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Circle</span>.<span class="hljs-keyword">init</span>(radius:):<br>-&gt;  <span class="hljs-number">0x100003ea0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>: pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003ea1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003ea4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">%</span>rax <span class="hljs-comment">//简单赋值</span><br>    <span class="hljs-number">0x100003ea7</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">7</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003ea8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
<li><p>修改值,调用<code>setter</code>方法</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-number">0x100003c04</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">52</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x1e, <span class="hljs-operator">%</span>edi <span class="hljs-comment">//值存在rdi寄存器中</span><br>    <span class="hljs-number">0x100003c09</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">57</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0x43f0</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>r13        ; <span class="hljs-type">SwiftSource</span>.s : <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span><br>-&gt;  <span class="hljs-number">0x100003c10</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">64</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003c70</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.setter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">12</span><br><span class="hljs-operator">......</span><br><br><br><span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Circle</span>.radius.setter:<br>-&gt;  <span class="hljs-number">0x100003c70</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003c71</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003c74</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003c76</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">6</span><span class="hljs-operator">&gt;</span>:  subq   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003c7a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp) <span class="hljs-comment">//r13是对象s</span><br>    <span class="hljs-number">0x100003c7e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">14</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp) <span class="hljs-comment">//30存放在栈空间</span><br>    <span class="hljs-number">0x100003c82</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c8a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">26</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c92</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">34</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c96</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">38</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c9a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">42</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003cc0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.willset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">13</span><br>    <span class="hljs-number">0x100003c9f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">47</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003ca3</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">51</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi <span class="hljs-comment">//这里取栈空间之前存的30值，因此在willSet中修改为15，这里又会赋值为30</span><br>    <span class="hljs-number">0x100003ca7</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">55</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, (<span class="hljs-operator">%</span>r13) <span class="hljs-comment">//这里将30实际赋值给了对象s的radius</span><br>    <span class="hljs-number">0x100003cab</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">59</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003ce0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.didset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">16</span><br>    <span class="hljs-number">0x100003cb0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">64</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003cb4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">68</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003cb6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">70</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003cb7</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">71</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
<li><p><code>willSet</code>方法,这里再对<code>radius</code>进行修改，不会在触发<code>setter</code>方法(因此也不会触发属性观察器)，是直接赋值</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SwiftSource`Circle.radius.willset:<br>-&gt;  <span class="hljs-number">0x100003c00</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  %rbp<br>    <span class="hljs-number">0x100003c01</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   %rsp, %rbp<br>    <span class="hljs-number">0x100003c04</span> &lt;+<span class="hljs-number">4</span>&gt;:  movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003c0c</span> &lt;+<span class="hljs-number">12</span>&gt;: movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x10</span>(%rbp)<br>    <span class="hljs-number">0x100003c14</span> &lt;+<span class="hljs-number">20</span>&gt;: movq   %rdi, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003c18</span> &lt;+<span class="hljs-number">24</span>&gt;: movq   %r13, <span class="hljs-number">-0x10</span>(%rbp)<br>    <span class="hljs-number">0x100003c1c</span> &lt;+<span class="hljs-number">28</span>&gt;: movq   $<span class="hljs-number">0xf</span>, (%r13) <span class="hljs-comment">//将15赋值给了s的radius</span><br>    <span class="hljs-number">0x100003c24</span> &lt;+<span class="hljs-number">36</span>&gt;: popq   %rbp<br>    <span class="hljs-number">0x100003c25</span> &lt;+<span class="hljs-number">37</span>&gt;: retq       <br></code></pre></td></tr></table></figure></li>
<li><p><code>didSetter</code>方法,这里再对<code>radius</code>进行修改，不会在触发<code>setter</code>方法，是直接赋值</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SwiftSource`Circle.radius.didset:<br>-&gt;  <span class="hljs-number">0x100003ce0</span> &lt;+<span class="hljs-number">0</span>&gt;:  pushq  %rbp<br>    <span class="hljs-number">0x100003ce1</span> &lt;+<span class="hljs-number">1</span>&gt;:  movq   %rsp, %rbp<br>    <span class="hljs-number">0x100003ce4</span> &lt;+<span class="hljs-number">4</span>&gt;:  movq   $<span class="hljs-number">0x0</span>, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003cec</span> &lt;+<span class="hljs-number">12</span>&gt;: movq   %r13, <span class="hljs-number">-0x8</span>(%rbp)<br>    <span class="hljs-number">0x100003cf0</span> &lt;+<span class="hljs-number">16</span>&gt;: movq   $<span class="hljs-number">0x14</span>, (%r13)<br>    <span class="hljs-number">0x100003cf8</span> &lt;+<span class="hljs-number">24</span>&gt;: popq   %rbp <span class="hljs-comment">//将20赋值给了s的radius</span><br>    <span class="hljs-number">0x100003cf9</span> &lt;+<span class="hljs-number">25</span>&gt;: retq   <br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>,<code>willSet</code>、<code>didSetter</code>方法中不会触发，其对于属性的观察器，但是在设置其他属性的，同样会触发属性观察器,下面这种写法会陷入<strong>死循环</strong></p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> diameters:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>  &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            radius <span class="hljs-operator">=</span> <span class="hljs-number">15</span><br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            radius <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            diameters <span class="hljs-operator">=</span> <span class="hljs-number">21</span><br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            diameters <span class="hljs-operator">=</span> <span class="hljs-number">21</span><br>        &#125;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="重写父类观察器"><a href="#重写父类观察器" class="headerlink" title="重写父类观察器"></a>重写父类观察器</h3><blockquote>
<p>和重新方法逻辑一样,其实际调用的<code>getter</code>和<code>setter</code>是父类的方式，只是重写了<code>属性观察器</code></p>
</blockquote>
<ul>
<li>调用顺序是<ol>
<li>子类<code>will set</code></li>
<li>父类<code>will set</code></li>
<li>设置存储值</li>
<li>父类<code>did set</code></li>
<li>子类<code>did set</code></li>
</ol>
</li>
</ul>
<h3 id="汇编查看"><a href="#汇编查看" class="headerlink" title="汇编查看"></a>汇编查看</h3><ul>
<li>验证源码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>           <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>:<span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <br>        &#125;<br>    &#125;<br>   <br>&#125;<br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br>s.radius <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure></li>
<li>汇编查看子类<code>setter</code>，方法中会调用父类的的<code>setter</code>方法，因此会触发父类的设置的属性观察器<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Circle</span>.radius.setter:<br>    <span class="hljs-number">0x100003a90</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003a91</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003a94</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003a96</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">6</span><span class="hljs-operator">&gt;</span>:  subq   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003a9a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003a9e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">14</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003aa2</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003aaa</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">26</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003ab2</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">34</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003ab6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">38</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br>-&gt;  <span class="hljs-number">0x100003aba</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">42</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000039f0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.willset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">22</span><br>    <span class="hljs-number">0x100003abf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">47</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003ac3</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">51</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100003ac6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">54</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003dd4</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_retain<br>    <span class="hljs-number">0x100003acb</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">59</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100003acf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">63</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000037f0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Base</span>.radius.setter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">11</span> <span class="hljs-comment">//这里调用了父类的setter方法，因此会触发父类的属性观察器</span><br>    <span class="hljs-number">0x100003ad4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">68</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003ad8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">72</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100003adb</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">75</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003dce</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_release<br>    <span class="hljs-number">0x100003ae0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">80</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003a10</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Circle</span>.radius.didset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">25</span><br>    <span class="hljs-number">0x100003ae5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">85</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x100003ae9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">89</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100003aeb</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">91</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100003aec</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">92</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h1><ul>
<li><p>必须有初始值</p>
</li>
<li><p>延迟存储属性的初始值是在它第一次被使用时才进行计算</p>
</li>
<li><p>用关键字<code>lazy</code>来标识一个延迟存储属性</p>
</li>
<li><p>测试验证</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>&#125;<br><br><br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br><span class="hljs-keyword">let</span> ds <span class="hljs-operator">=</span> s.radius<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="SIL查看"><a href="#SIL查看" class="headerlink" title="SIL查看"></a>SIL查看</h2><ul>
<li><p><code>swiftc xxx.swift -emit-sil</code></p>
</li>
<li><p>生成的<code>SIL</code></p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">var</span> <span class="hljs-variable">$__lazy_storage_</span><span class="hljs-variable">$_radius</span>: <span class="hljs-type">Int</span>? &#123; <span class="hljs-keyword">get</span>       <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">init</span>()</span><br>  <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>懒加载属性第一次访问前没有值，访问后就有值，其本质就是在编译后生成一个可选型存储属性</p>
</li>
</ul>
<h3 id="getter方法分析"><a href="#getter方法分析" class="headerlink" title="getter方法分析"></a>getter方法分析</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Circle.radius.getter</span><br>sil hidden [lazy_getter] [noinline] @<span class="hljs-variable">$s4main6CircleV6radiusSivg</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-meta">@inout</span> <span class="hljs-type">Circle</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br><span class="hljs-comment">// %0 &quot;self&quot;                                      // users: %2, %12, %1</span><br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Circle</span>): <span class="hljs-comment">//初始化的时候</span><br>  debug_value <span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Circle</span>, <span class="hljs-keyword">var</span>, name <span class="hljs-string">&quot;self&quot;</span>, argno <span class="hljs-number">1</span>, implicit, expr op_deref <span class="hljs-comment">// id: %1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> struct_element_addr <span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Circle</span>, #<span class="hljs-type">Circle</span>.<span class="hljs-variable">$__lazy_storage_</span><span class="hljs-variable">$_radius</span> <span class="hljs-comment">// user: %3</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> load <span class="hljs-operator">%</span><span class="hljs-number">2</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">Int</span>&gt;                  <span class="hljs-comment">// user: %4 //取出内存中可选Int?的值</span><br>  switch_enum <span class="hljs-operator">%</span><span class="hljs-number">3</span> : <span class="hljs-variable">$Optional</span><span class="hljs-operator">&lt;</span><span class="hljs-type">Int</span><span class="hljs-operator">&gt;</span>, <span class="hljs-keyword">case</span> #<span class="hljs-type">Optional</span>.some<span class="hljs-operator">!</span>enumelt: bb1, <span class="hljs-keyword">case</span> #<span class="hljs-type">Optional</span>.none<span class="hljs-operator">!</span>enumelt: bb2 <span class="hljs-comment">// id: %4 //如果有值则走bb1,没有值走bb2</span><br><br><span class="hljs-comment">// %5       有值已经加载过                          // users: %7, %6</span><br>bb1(<span class="hljs-operator">%</span><span class="hljs-number">5</span> : <span class="hljs-variable">$Int</span>):                                   <span class="hljs-comment">// Preds: bb0 </span><br>  debug_value <span class="hljs-operator">%</span><span class="hljs-number">5</span> : <span class="hljs-variable">$Int</span>, <span class="hljs-keyword">let</span>, name <span class="hljs-string">&quot;tmp1&quot;</span>, implicit <span class="hljs-comment">// id: %6</span><br>  br bb3(<span class="hljs-operator">%</span><span class="hljs-number">5</span> : <span class="hljs-variable">$Int</span>)                               <span class="hljs-comment">// id: %7</span><br><br>bb2: 没有值，未加载过                              <span class="hljs-comment">// Preds: bb0</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int64</span>, <span class="hljs-number">9</span>          <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int</span> (%8 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int64</span>)          // <span class="hljs-title">users</span>: %16, %11, %10</span><br><span class="hljs-class">  <span class="hljs-title">debug_value</span> %9 : <span class="hljs-title">$Int</span>, <span class="hljs-title">let</span>, <span class="hljs-title">name</span> &quot;<span class="hljs-title">tmp2</span>&quot;, <span class="hljs-title">implicit</span> // <span class="hljs-title">id</span>: %10</span><br><span class="hljs-class">  %11 = <span class="hljs-title">enum</span> <span class="hljs-title">$Optional</span>&lt;<span class="hljs-title">Int</span>&gt;, #<span class="hljs-title">Optional</span>.some!<span class="hljs-title">enumelt</span>, %9 : <span class="hljs-title">$Int</span> // <span class="hljs-title">user</span>: %14</span><br><span class="hljs-class">  %12 = <span class="hljs-title">begin_access</span> [<span class="hljs-title">modify</span>] [<span class="hljs-title">static</span>] %0 : <span class="hljs-title">$</span>*<span class="hljs-title">Circle</span> // <span class="hljs-title">users</span>: %15, %13</span><br><span class="hljs-class">  %13 = <span class="hljs-title">struct_element_addr</span> %12 : <span class="hljs-title">$</span>*<span class="hljs-title">Circle</span>, #<span class="hljs-title">Circle</span>.<span class="hljs-title">$__lazy_storage_$_radius</span> // <span class="hljs-title">user</span>: %14</span><br><span class="hljs-class">  <span class="hljs-title">store</span> %11 <span class="hljs-title">to</span> %13 : <span class="hljs-title">$</span>*<span class="hljs-title">Optional</span>&lt;<span class="hljs-title">Int</span>&gt;              // <span class="hljs-title">id</span>: %14</span><br><span class="hljs-class">  <span class="hljs-title">end_access</span> %12 : <span class="hljs-title">$</span>*<span class="hljs-title">Circle</span>                       // <span class="hljs-title">id</span>: %15</span><br><span class="hljs-class">  <span class="hljs-title">br</span> <span class="hljs-title">bb3</span>(%9 : <span class="hljs-title">$Int</span>)                               // <span class="hljs-title">id</span>: %16</span><br><span class="hljs-class"></span><br><span class="hljs-class">// %17  统一返回<span class="hljs-title">Int</span>                                // <span class="hljs-title">user</span>: %18</span><br><span class="hljs-class"><span class="hljs-title">bb3</span>(%17 : <span class="hljs-title">$Int</span>):                                  // <span class="hljs-title">Preds</span>: <span class="hljs-title">bb2</span> <span class="hljs-title">bb1</span></span><br><span class="hljs-class">  <span class="hljs-title">return</span> %17 : <span class="hljs-title">$Int</span>                               // <span class="hljs-title">id</span>: %18</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">$s4main6CircleV6radiusSivg</span>&#x27;</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure>
<ol>
<li>在初始化的时候,<code>$__lazy_storage_$_radius</code>设置的<code>nil</code></li>
<li>拿到生成的属性 <code>$__lazy_storage_$_radius</code>的地址，然后去<code>switch</code>：如果有值，走<code>bb1</code>的代码块；如果没有值走<code>bb2</code>代码块</li>
<li><code>bb2</code>没有加载过：去构建初始值，给到变量$<code>$__lazy_storage_$_radius</code></li>
<li><code>bb1</code>已加载过：已经有值了，直接给他返回出去</li>
</ol>
<h1 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h1><blockquote>
<ul>
<li>类型属性本质上就是一个全局变量</li>
<li>类型属性只会被初始化一次,（使用的时候）</li>
</ul>
</blockquote>
<ul>
<li>测试验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>&#125;<br><span class="hljs-type">Circle</span>.radius <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="SIL查看-1"><a href="#SIL查看-1" class="headerlink" title="SIL查看"></a>SIL查看</h2><ul>
<li><code>swiftc xxx.swift -emit-silgen</code></li>
<li>编译后的<code>sil</code>里多了两个全局变量<ul>
<li><code>sil_global private @$s4main6CircleV6radius_Wz</code>,<code>token for radius</code></li>
<li><code>$s4main6CircleV6radiusSivpZ</code>,<code>static Circle.radius</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>  <span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">init</span>()</span><br>&#125;<br><br><span class="hljs-comment">// one-time initialization token for radius</span><br>sil_global <span class="hljs-keyword">private</span> @<span class="hljs-variable">$s4main6CircleV6radius_Wz</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Word</span><br><br><span class="hljs-comment">// static Circle.radius</span><br>sil_global hidden @<span class="hljs-variable">$s4main6CircleV6radiusSivpZ</span> : <span class="hljs-variable">$Int</span> <span class="hljs-operator">=</span> &#123;<br>  <span class="hljs-operator">%</span><span class="hljs-number">0</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int64</span>, <span class="hljs-number">9</span>          <span class="hljs-comment">// user: %1</span><br>  <span class="hljs-operator">%</span>initval <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int</span> (%0 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int64</span>)</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>main</code>函数中，<code>@$s4main6CircleV6radiusSivau</code>函数做了一个全局变量内存地址的转换  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// main</span><br>sil [ossa] <span class="hljs-keyword">@main</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Int32</span>, <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="hljs-type">Int32</span> &#123;<br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$Int32</span>, <span class="hljs-operator">%</span><span class="hljs-number">1</span> : <span class="hljs-variable">$UnsafeMutablePointer</span><span class="hljs-operator">&lt;</span><span class="hljs-type">Optional</span>&lt;<span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;&gt;<span class="hljs-operator">&gt;</span>):<br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">Circle</span>.<span class="hljs-keyword">Type</span><br>  <span class="hljs-comment">// function_ref Circle.radius.unsafeMutableAddressor</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$s4main6CircleV6radiusSivau</span> : $<span class="hljs-meta">@convention</span>(thin) () -&gt; <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span> <span class="hljs-comment">// user: %4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">3</span>() : $<span class="hljs-meta">@convention</span>(thin) () -&gt; <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span> <span class="hljs-comment">// user: %5</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> pointer_to_address <span class="hljs-operator">%</span><span class="hljs-number">4</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span> to [strict] $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// user: %10</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-number">20</span>    <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">7</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>                   <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-comment">// function_ref Int.init(_builtinIntegerLiteral:)</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$sSi22_builtinIntegerLiteralSiBI_tcfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">9</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">8</span>(<span class="hljs-operator">%</span><span class="hljs-number">6</span>, <span class="hljs-operator">%</span><span class="hljs-number">7</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-comment">// user: %11</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> begin_access [modify] [<span class="hljs-keyword">dynamic</span>] <span class="hljs-operator">%</span><span class="hljs-number">5</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// users: %12, %11</span><br>  assign <span class="hljs-operator">%</span><span class="hljs-number">9</span> to <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span>                        <span class="hljs-comment">// id: %11</span><br>  end_access <span class="hljs-operator">%</span><span class="hljs-number">10</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span>                          <span class="hljs-comment">// id: %12</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">13</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int32</span>, <span class="hljs-number">0</span>         <span class="hljs-comment">// user: %14</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">14</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int32</span> (%13 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int32</span>)      // <span class="hljs-title">user</span>: %15</span><br><span class="hljs-class">  <span class="hljs-title">return</span> %14 : <span class="hljs-title">$Int32</span>                             // <span class="hljs-title">id</span>: %15</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">main</span>&#x27;</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure></li>
<li>全局变量内存地址的转换的函数<code>s4main6CircleV6radiusSivau</code>,<code>builtin &quot;once&quot;</code>底层源码调用的是<code>swift_once</code>，其底层实际是<code>dispatch_once</code>，这里的<code>token</code>则是<code>dispatch_once_t</code>,这里返回全局变量的地址  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Circle.radius.unsafeMutableAddressor</span><br>sil hidden [global_init] [ossa] @<span class="hljs-variable">$s4main6CircleV6radiusSivau</span> : $<span class="hljs-meta">@convention</span>(thin) () -&gt; <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span> &#123;<br>bb0:<br>    <span class="hljs-comment">//拿到token的全局变量</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">0</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s4main6CircleV6radius_Wz</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span> <span class="hljs-comment">// user: %1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> address_to_pointer <span class="hljs-operator">%</span><span class="hljs-number">0</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span> to <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span> <span class="hljs-comment">// user: %3</span><br>  <span class="hljs-comment">// function_ref one-time initialization function for radius //</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$s4main6CircleV6radius_WZ</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>) -&gt; () <span class="hljs-comment">// user: %3</span><br>  <span class="hljs-comment">//builtin &quot;once&quot;中执行s4main6CircleV6radius_WZ方法</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> builtin <span class="hljs-string">&quot;once&quot;</span>(<span class="hljs-operator">%</span><span class="hljs-number">1</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span>, <span class="hljs-operator">%</span><span class="hljs-number">2</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>) -&gt; ()) : $()<br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s4main6CircleV6radiusSivpZ</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// user: %5</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> address_to_pointer <span class="hljs-operator">%</span><span class="hljs-number">4</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> to <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span> <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-operator">%</span><span class="hljs-number">5</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span>                 <span class="hljs-comment">// id: %6</span><br>&#125; <span class="hljs-comment">// end sil function &#x27;$s4main6CircleV6radiusSivau&#x27;</span><br><br></code></pre></td></tr></table></figure></li>
<li><code>s4main6CircleV6radius_WZ</code>方法，由<code>builtin &quot;once&quot;</code>保证只执行一次。在该方法中对<code>radius</code>进行了赋值。并且该赋值操作只在使用的时候才会进行操作  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// one-time initialization function for radius</span><br>sil <span class="hljs-keyword">private</span> [global_init_once_fn] [ossa] @<span class="hljs-variable">$s4main6CircleV6radius_WZ</span> : $<span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>) -&gt; () &#123;<br>bb0(<span class="hljs-operator">%</span><span class="hljs-number">0</span> : <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">RawPointer</span>):<br>  alloc_global @<span class="hljs-variable">$s4main6CircleV6radiusSivpZ</span>       <span class="hljs-comment">// id: %1</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s4main6CircleV6radiusSivpZ</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// user: %7</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-number">9</span>     <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> metatype $<span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>                   <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-comment">// function_ref Int.init(_builtinIntegerLiteral:)</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">5</span> <span class="hljs-operator">=</span> function_ref @<span class="hljs-variable">$sSi22_builtinIntegerLiteralSiBI_tcfC</span> : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-comment">// user: %6</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">6</span> <span class="hljs-operator">=</span> apply <span class="hljs-operator">%</span><span class="hljs-number">5</span>(<span class="hljs-operator">%</span><span class="hljs-number">3</span>, <span class="hljs-operator">%</span><span class="hljs-number">4</span>) : $<span class="hljs-meta">@convention</span>(method) (<span class="hljs-type">Builtin</span>.<span class="hljs-type">IntLiteral</span>, <span class="hljs-meta">@thin</span> <span class="hljs-type">Int</span>.<span class="hljs-keyword">Type</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-comment">// user: %7</span><br>  store <span class="hljs-operator">%</span><span class="hljs-number">6</span> to [trivial] <span class="hljs-operator">%</span><span class="hljs-number">2</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span>                <span class="hljs-comment">// id: %7</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">8</span> <span class="hljs-operator">=</span> tuple ()                                   <span class="hljs-comment">// user: %9</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-operator">%</span><span class="hljs-number">8</span> : $()                                 <span class="hljs-comment">// id: %9</span><br>&#125; <span class="hljs-comment">// end sil function &#x27;$s4main6CircleV6radius_WZ&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="属性源码分析"><a href="#属性源码分析" class="headerlink" title="属性源码分析"></a>属性源码分析</h1><blockquote>
<p>在<code>swift类分析</code>中介绍了<code>Metadata</code>的元数据结构，和<code>typeDescriptor</code>类的描述  </p>
</blockquote>
<ol>
<li><code>Metadata</code>的元数据结构 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Metadata</span> </span>&#123; <br>    <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <br>    <span class="hljs-keyword">var</span> superClass: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span> <br>    <span class="hljs-keyword">var</span> cacheData: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) <br>    <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span> <br>    <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <br>    <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <br>    <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <br>    <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <br>    <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutableRawPointer</span> <br>    <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>typeDescriptor</code>是记录类的描述： <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassDescriptor</span></span>&#123; <br><br>     <span class="hljs-comment">//继承至TargetContextDescriptor</span><br>      <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>      <br>      <span class="hljs-comment">//继承至TargetTypeContextDescriptor</span><br>      <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;   <span class="hljs-comment">// class/struct/enum 的名称</span><br>      <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>      <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt; <span class="hljs-comment">//属性描述器</span><br><br>      <span class="hljs-comment">//TargetClassDescriptor具有的</span><br>      <span class="hljs-keyword">var</span> superClassType: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;  <span class="hljs-comment">//父类类型指针</span><br>      <span class="hljs-keyword">var</span> metadataNegativeSizeInWords: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> metadataPositiveSizeInWords: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> numImmediateMembers: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 每一个属性值距离当前实例对象地址的偏移量</span><br>      <span class="hljs-keyword">var</span> <span class="hljs-type">Offset</span>: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-comment">// var size: UInt32 </span><br>      <span class="hljs-comment">// V-Table  (methods) </span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>其中 <code>fieldDescriptor</code> 记录了当前的属性信息，经分析后<code>fieldDescriptor</code> (位于<code>swift-main/include/swift/RemoteInspection/Records.h</code>)在源码中的数据结构，下面对<code>FieldDescriptor</code>属性描述器进行分析</li>
</ol>
<h2 id="FieldDescriptor属性描述器"><a href="#FieldDescriptor属性描述器" class="headerlink" title="FieldDescriptor属性描述器"></a><code>FieldDescriptor属性描述器</code></h2><ul>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Field descriptors contain a collection of field records for a single</span><br><span class="hljs-comment">// class, struct or enum declaration.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldDescriptor</span> &#123;</span><br><span class="hljs-comment">//属性列表紧跟之后，可以认为是连着一起的，认为FieldDescriptor的属性是包含了一个属性列表</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> FieldRecord *<span class="hljs-title">getFieldRecordBuffer</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> FieldRecord *&gt;(<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>);<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">const</span> RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt; MangledTypeName;<br>  <span class="hljs-keyword">const</span> RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt; Superclass;<br><br>  <span class="hljs-built_in">FieldDescriptor</span>() = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-keyword">const</span> FieldDescriptorKind Kind;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> FieldRecordSize;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> NumFields;<br><br>  <span class="hljs-keyword">using</span> const_iterator = FieldRecordIterator;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEnum</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Kind == FieldDescriptorKind::Enum ||<br>            Kind == FieldDescriptorKind::MultiPayloadEnum);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Kind == FieldDescriptorKind::Class ||<br>            Kind == FieldDescriptorKind::ObjCClass);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isProtocol</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Kind == FieldDescriptorKind::Protocol ||<br>            Kind == FieldDescriptorKind::ClassProtocol ||<br>            Kind == FieldDescriptorKind::ObjCProtocol);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStruct</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Kind == FieldDescriptorKind::Struct;<br>  &#125;<br><br>  <span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> Begin = <span class="hljs-built_in">getFieldRecordBuffer</span>();<br>    <span class="hljs-keyword">auto</span> End = Begin + NumFields;<br>    <span class="hljs-keyword">return</span> const_iterator &#123; Begin, End &#125;;<br>  &#125;<br><br>  <span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> Begin = <span class="hljs-built_in">getFieldRecordBuffer</span>();<br>    <span class="hljs-keyword">auto</span> End = Begin + NumFields;<br>    <span class="hljs-keyword">return</span> const_iterator &#123; End, End &#125;;<br>  &#125;<br>    <span class="hljs-comment">//返回属性列表</span><br>  <span class="hljs-function">llvm::ArrayRef&lt;FieldRecord&gt; <span class="hljs-title">getFields</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">getFieldRecordBuffer</span>(), NumFields&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasMangledTypeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> MangledTypeName;<br>  &#125;<br><br>  <span class="hljs-function">StringRef <span class="hljs-title">getMangledTypeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Demangle::<span class="hljs-built_in">makeSymbolicMangledNameStringRef</span>(MangledTypeName.<span class="hljs-built_in">get</span>());<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasSuperclass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Superclass;<br>  &#125;<br><br>  <span class="hljs-function">StringRef <span class="hljs-title">getSuperclass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Demangle::<span class="hljs-built_in">makeSymbolicMangledNameStringRef</span>(Superclass.<span class="hljs-built_in">get</span>());<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>其结构可以还原如下，接下来查看具体属性的结构<code>FieldRecord</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldDescriptor</span> </span>&#123; <br>    <span class="hljs-keyword">var</span> mangledTypeName : <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 混写后的类型名称</span><br>    <span class="hljs-keyword">var</span> superclass : <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span> : uint16 <span class="hljs-comment">// 判断是结构体，类，还是枚举，协议等</span><br>    <span class="hljs-keyword">var</span> fieldRecordSize:uint16 <br>    <span class="hljs-keyword">var</span> numFields:uint32 <span class="hljs-comment">// 属性个数</span><br>    <span class="hljs-keyword">var</span> fields: <span class="hljs-type">FiledRecordBuffer</span>&lt;<span class="hljs-type">FieldRecord</span>&gt;  <span class="hljs-comment">// 记录了每个属性的信息</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FiledRecordBuffer</span>&lt;<span class="hljs-title">Element</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> element: <span class="hljs-type">Element</span><br><br>     <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buffer</span>(<span class="hljs-params">n</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeBufferPointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>             <span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span>.withMemoryRebound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>, capacity:<span class="hljs-number">1</span>) &#123;<span class="hljs-variable">$0</span>&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeBufferPointer</span>(start: ptr, count: n)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span>(<span class="hljs-params">of</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Element</span>&gt; &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating:      <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>).assumingMemoryBound(to: <span class="hljs-type">Element</span>.<span class="hljs-keyword">self</span>).advanced(by: i))<br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="FieldRecord"><a href="#FieldRecord" class="headerlink" title="FieldRecord"></a><code>FieldRecord</code></h3><ul>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldRecord</span> &#123;</span><br>  <span class="hljs-keyword">const</span> FieldRecordFlags Flags;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">const</span> RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt; MangledTypeName;<br>  <span class="hljs-keyword">const</span> RelativeDirectPointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&gt; FieldName;<br><br>  <span class="hljs-built_in">FieldRecord</span>() = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasMangledTypeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> MangledTypeName;<br>  &#125;<br><br>  <span class="hljs-function">StringRef <span class="hljs-title">getMangledTypeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Demangle::<span class="hljs-built_in">makeSymbolicMangledNameStringRef</span>(MangledTypeName.<span class="hljs-built_in">get</span>());<br>  &#125;<br><br>  <span class="hljs-function">StringRef <span class="hljs-title">getFieldName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> FieldName.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIndirectCase</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isIndirectCase</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVar</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Flags.<span class="hljs-built_in">isVar</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>其结构还原的结构体如下,主要这里的类型和名称实际上都是<code>间距指针</code>，而非直接指针  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldRecord</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> flags: <span class="hljs-type">Int32</span><br>    <span class="hljs-keyword">var</span> mangledTypeName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt; <span class="hljs-comment">// 属性的类型</span><br>    <span class="hljs-keyword">var</span> fieldName: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UInt8</span>&gt; <span class="hljs-comment">// 属性的名称</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="验证Mach-o位置"><a href="#验证Mach-o位置" class="headerlink" title="验证Mach-o位置"></a>验证Mach-o位置</h2><ul>
<li>测试代码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-keyword">let</span> diameter:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li><p>在<code>data</code>区找到<code>__TEXT,__swift5_types</code> 这是记录所有的 <code>struct/enum/类</code>的<code>Descriptor</code>的信息,这里查找<code>typeDescriptor</code><br> <img src="1.png"></p>
</li>
<li><p>拿到<code>Circle类</code>的<code>Descriptor</code>在 <code>Mach-O</code> 里的位置:</p>
<pre><code> <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x3F8C</span> <span class="hljs-operator">+</span> <span class="hljs-number">0xFFFFFF2C</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x100003EB8</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>Dscriptor</code>在<code>mach-o</code>的<code>data</code>区的偏移量，需要再减去<code>_pagezero</code>内存地址：</p>
<pre><code> <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100003EB8</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x100000000</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3EB8</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>在<code>data</code>区找到 <code>__TEXT,__const</code>里边，去找<code>0x3EB8</code>的位置：<br><img src="2.png"></p>
<ul>
<li>接下来要找到 <code>fieldDescriptor</code>它的地址，因为<code>fieldDescriptor</code>在<code>TargetClassDescriptor</code>的数据结构前面还有<code>4</code>个<code>UInt32</code>的成员,<code>fieldDescriptor</code>在<code>Mach-O</code>的信息是<pre><code>  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x3EB8</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x10</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x9c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3F64</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>而属性存放<code>data</code>区的<code>__TEXT,__swift5_fieldmd</code>，并在上面找到<code>0x3F64</code><br> <img src="3.png"></p>
</li>
<li><p><code>0x3F64</code>开始是<code>FieldDescriptor</code>属性描述的成员内容</p>
</li>
<li><p><code>FieldRecord</code>的数据结构：</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FieldRecord</span></span>&#123; <br>    <span class="hljs-type">Flags</span>           uint32 <span class="hljs-comment">// 标志位</span><br>    <span class="hljs-type">MangledTypeName</span> int32 <span class="hljs-comment">// 属性的类型名称</span><br>    <span class="hljs-type">FieldName</span>       int32 <span class="hljs-comment">// 属性名称</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>第一个<code>FieldRecord</code> 的<code>FieldName</code>属性名称在<code>Mach-O</code>上的信息<code>0x100003F53</code>减去基地址，<code>0x3F53</code><br> <img src="4.png"></p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x3F74</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x8</span> <span class="hljs-operator">+</span> <span class="hljs-number">0xFFFFFFD7</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x100003F53</span><br></code></pre></td></tr></table></figure></li>
<li><p>在去找<code>data</code>区中的 <code>__TEXT,__swift5_reflstr</code>找到<code>0x3F53</code>,其上字符串正是<code>radius</code><br><img src="5.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>swift类分析</title>
    <url>/2023/05/13/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/swift%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h1><h2 id="纯swift类"><a href="#纯swift类" class="headerlink" title="纯swift类"></a>纯<code>swift</code>类</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Man&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Person</code>是纯<code>swift</code>类，在创建实例的时候，会调用<code>SwiftTest.Person.__allocating_init()</code>；;底层会调用<code>swift_allocObject</code>和<code>SwiftTest.Person.init()</code>。  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Person</span>.__allocating_init():<br>-&gt;  <span class="hljs-number">0x100004580</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004581</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004584</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x100004586</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">6</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x100004587</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">7</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x10000458a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x28, <span class="hljs-operator">%</span>esi<br>    <span class="hljs-number">0x10000458f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x7, <span class="hljs-operator">%</span>edx<br>    <span class="hljs-number">0x100004594</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">20</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000077d8</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_allocObject<br>    <span class="hljs-number">0x100004599</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x10000459c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">28</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000045d0</span>               ; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Person</span>.<span class="hljs-keyword">init</span>() -&gt; <span class="hljs-type">SwiftSource</span>.<span class="hljs-type">Person</span> at main.swift:<span class="hljs-number">11</span><br>    <span class="hljs-number">0x1000045a1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">33</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x8, <span class="hljs-operator">%</span>rsp<br>    <span class="hljs-number">0x1000045a5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">37</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>r13<br>    <span class="hljs-number">0x1000045a7</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">39</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x1000045a8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">40</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="继承NSObject的swift类"><a href="#继承NSObject的swift类" class="headerlink" title="继承NSObject的swift类"></a>继承<code>NSObject</code>的<code>swift</code>类</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:<span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Man&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>Person</code>是继承<code>NSObject</code>的类，在创建实例的时候，会调用<code>SwiftTest.Person.__allocating_init()</code>;底层会调用<code>objc_allocWithZone</code>和<code>objc_msgSend</code> 发送<code>init</code>消息。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">SwiftSource</span>`<span class="hljs-type">Person</span>.__allocating_init():<br>-&gt;  <span class="hljs-number">0x100004420</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004421</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004424</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100004427</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">7</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x1000077a2</span>               ; symbol stub <span class="hljs-keyword">for</span>: objc_allocWithZone<br>    <span class="hljs-number">0x10000442c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">12</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x10000442f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-number">0x7c62</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rsi        ; <span class="hljs-string">&quot;init&quot;</span><br>    <span class="hljs-number">0x100004436</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">22</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x1000077a8</span>               ; symbol stub <span class="hljs-keyword">for</span>: objc_msgSend<br>    <span class="hljs-number">0x10000443b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">27</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x10000443c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">28</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure>

<h1 id="swift源码"><a href="#swift源码" class="headerlink" title="swift源码"></a>swift源码</h1><h2 id="swift-allocObject"><a href="#swift-allocObject" class="headerlink" title="swift_allocObject"></a><code>swift_allocObject</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> HeapObject *_swift_allocObject_(HeapMetadata <span class="hljs-keyword">const</span> *metadata,<br>                                       <span class="hljs-keyword">size_t</span> requiredSize,<br>                                       <span class="hljs-keyword">size_t</span> requiredAlignmentMask) &#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isAlignmentMask</span>(requiredAlignmentMask));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SWIFT_STDLIB_HAS_MALLOC_TYPE</span><br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(<span class="hljs-built_in">swift_slowAllocTyped</span>(<br>      requiredSize, requiredAlignmentMask, <span class="hljs-built_in">getMallocTypeId</span>(metadata)));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(<br>      <span class="hljs-built_in">swift_slowAlloc</span>(requiredSize, requiredAlignmentMask));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this relies on the C++17 guaranteed semantics of no null-pointer</span><br>  <span class="hljs-comment">// check on the placement new allocator which we have observed on Windows,</span><br>  <span class="hljs-comment">// Linux, and macOS.</span><br>  ::<span class="hljs-keyword">new</span> (object) <span class="hljs-built_in">HeapObject</span>(metadata);<br><br>  <span class="hljs-comment">// If leak tracking is enabled, start tracking this object.</span><br>  <span class="hljs-built_in">SWIFT_LEAKS_START_TRACKING_OBJECT</span>(object);<br><br>  <span class="hljs-built_in">SWIFT_RT_TRACK_INVOCATION</span>(object, swift_allocObject);<br><br>  <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><blockquote>
<p><code>swift</code>对象内存分配: <code>__allocating_init</code> -&gt; <code>swift_allocObject</code> -&gt; <code>_swift_allocObject_</code> -&gt; <code>swift_slowAlloc</code> -&gt; <code>malloc</code></p>
</blockquote>
<ul>
<li>调用了<code>swift_slowAlloc</code>函数返回了一个<code>堆对象</code>。这个函数位于<code>Heap.cpp</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">swift::swift_slowAlloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> alignMask)</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> *p;<br>  <span class="hljs-comment">// This check also forces &quot;default&quot; alignment to use AlignedAlloc.</span><br>  <span class="hljs-keyword">if</span> (alignMask &lt;= MALLOC_ALIGN_MASK) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__APPLE__) &amp;&amp; SWIFT_STDLIB_HAS_DARWIN_LIBMALLOC</span><br>    p = <span class="hljs-built_in">malloc_zone_malloc</span>(<span class="hljs-built_in">DEFAULT_ZONE</span>(), size);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    p = <span class="hljs-built_in">malloc</span>(size);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">size_t</span> alignment = <span class="hljs-built_in">computeAlignment</span>(alignMask);<br>    p = <span class="hljs-built_in">AlignedAlloc</span>(size, alignment);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!p) swift::<span class="hljs-built_in">crash</span>(<span class="hljs-string">&quot;Could not allocate memory.&quot;</span>);<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>在<code>p = malloc(size)</code>; 进行了内存分配，最后并返回了<code>p</code></li>
</ul>
<h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><blockquote>
<p>调用了<code>::new (object) HeapObject(metadata);</code>对<code>objc</code>对象进行初始化</p>
</blockquote>
<ul>
<li><code>HeapObject</code>的结构<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">HeapObject</span><span class="hljs-params">(HeapMetadata <span class="hljs-keyword">const</span> *newMetadata)</span> </span><br><span class="hljs-function">    : metadata(newMetadata)</span><br><span class="hljs-function">    , refCounts(InlineRefCounts::Initialized)</span><br><span class="hljs-function">  &#123;</span> &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>swift</code>对象的内存结构： <code>HeapObject</code> ，有两个属性各占<code>8</code>字节： <code>Metadata</code> 和 <code>RefCount</code>，默认占用 <code>16</code> 字节大小。</li>
</ul>
<h2 id="TargetHeapMetadata对象分析"><a href="#TargetHeapMetadata对象分析" class="headerlink" title="TargetHeapMetadata对象分析"></a><code>TargetHeapMetadata</code>对象分析</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> HeapMetadata = TargetHeapMetadata&lt;InProcess&gt;;<br><br><span class="hljs-comment">/// The common structure of all metadata for heap-allocated types.  A</span><br><span class="hljs-comment">/// pointer to one of these can be retrieved by loading the &#x27;isa&#x27;</span><br><span class="hljs-comment">/// field of any heap object, whether it was managed by Swift or by</span><br><span class="hljs-comment">/// Objective-C.  However, when loading from an Objective-C object,</span><br><span class="hljs-comment">/// this metadata may not have the heap-metadata header, and it may</span><br><span class="hljs-comment">/// not be the Swift type metadata for the object&#x27;s dynamic type.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetHeapMetadata</span> :</span> TargetMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> HeaderType = TargetHeapMetadataHeader&lt;Runtime&gt;;<br><br>  <span class="hljs-built_in">TargetHeapMetadata</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetHeapMetadata</span><span class="hljs-params">(MetadataKind kind)</span></span><br><span class="hljs-function">    : TargetMetadata&lt;Runtime&gt;(kind) &#123;</span>&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetHeapMetadata</span><span class="hljs-params">(TargetAnyClassMetadataObjCInterop&lt;Runtime&gt; *isa)</span></span><br><span class="hljs-function">    : TargetMetadata&lt;Runtime&gt;(isa) &#123;</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>swift</code>类的 <code>HeapMetadata / TargetHeapMetadata</code> 是通过 <code>kind</code>进行初始化的。<code>TargetMatedata</code>中只有一个属性<code>Kind</code>,其结构实际为  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span>:<span class="hljs-type">StoredPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>MetadataKind</code>的定义：  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">_MetadataKind</span>: <span class="hljs-title">UInt</span> </span>&#123;<br>  <span class="hljs-comment">// With &quot;flags&quot;:</span><br>  <span class="hljs-comment">// runtimePrivate = 0x100</span><br>  <span class="hljs-comment">// nonHeap = 0x200</span><br>  <span class="hljs-comment">// nonType = 0x400</span><br>  <br>  <span class="hljs-keyword">case</span> `class` <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">case</span> `struct` <span class="hljs-operator">=</span> <span class="hljs-number">0x200</span>     <span class="hljs-comment">// 0 | nonHeap</span><br>  <span class="hljs-keyword">case</span> `enum` <span class="hljs-operator">=</span> <span class="hljs-number">0x201</span>       <span class="hljs-comment">// 1 | nonHeap</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-keyword">optional</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x202</span>     <span class="hljs-comment">// 2 | nonHeap</span><br>  <span class="hljs-keyword">case</span> foreignClass <span class="hljs-operator">=</span> <span class="hljs-number">0x203</span> <span class="hljs-comment">// 3 | nonHeap</span><br>  <span class="hljs-keyword">case</span> opaque <span class="hljs-operator">=</span> <span class="hljs-number">0x300</span>       <span class="hljs-comment">// 0 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> tuple <span class="hljs-operator">=</span> <span class="hljs-number">0x301</span>        <span class="hljs-comment">// 1 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> function <span class="hljs-operator">=</span> <span class="hljs-number">0x302</span>     <span class="hljs-comment">// 2 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> existential <span class="hljs-operator">=</span> <span class="hljs-number">0x303</span>  <span class="hljs-comment">// 3 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> metatype <span class="hljs-operator">=</span> <span class="hljs-number">0x304</span>     <span class="hljs-comment">// 4 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> objcClassWrapper <span class="hljs-operator">=</span> <span class="hljs-number">0x305</span>     <span class="hljs-comment">// 5 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> existentialMetatype <span class="hljs-operator">=</span> <span class="hljs-number">0x306</span>  <span class="hljs-comment">// 6 | runtimePrivate | nonHeap</span><br>  <span class="hljs-keyword">case</span> heapLocalVariable <span class="hljs-operator">=</span> <span class="hljs-number">0x400</span>    <span class="hljs-comment">// 0 | nonType</span><br>  <span class="hljs-keyword">case</span> heapGenericLocalVariable <span class="hljs-operator">=</span> <span class="hljs-number">0x500</span> <span class="hljs-comment">// 0 | nonType | runtimePrivate</span><br>  <span class="hljs-keyword">case</span> errorObject <span class="hljs-operator">=</span> <span class="hljs-number">0x501</span>  <span class="hljs-comment">// 1 | nonType | runtimePrivate</span><br>  <span class="hljs-keyword">case</span> unknown <span class="hljs-operator">=</span> <span class="hljs-number">0xffff</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">type</span>: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> v <span class="hljs-operator">=</span> _metadataKind(type)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> _MetadataKind(rawValue: v) &#123;<br>      <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> result<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> .unknown<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><code>TargetMetadata</code>里面的函数,获取<code>Metadata</code>描述的<code>context</code>,这个函数的作用是根据<code>kind</code>的不同类型，去获取描述器<code>descriptor</code>。所以可以分析出:<ul>
<li>对于<code>class</code>来说它的<code>Metadata</code>是<code>TargetClassMetadata</code>;</li>
<li>对于<code>struct</code>、<code>enum</code>、<code>optional</code>来说它的<code>Metadata</code>是<code>TargetValueMetadata</code>，但是它们都有自己类型的<code>Metadata</code>去继承于<code>TargetValueMetadata</code>。<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">/// Get the nominal type descriptor if this metadata describes a nominal type,</span><br><span class="hljs-comment">/// or return null if it does not.</span><br><span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, TargetTypeContextDescriptor&gt;</span><br><span class="hljs-function"><span class="hljs-title">getTypeContextDescriptor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (<span class="hljs-built_in">getKind</span>()) &#123;<br>  <span class="hljs-keyword">case</span> MetadataKind::Class: &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cls =<br>      <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TargetClassMetadataType&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (!cls-&gt;<span class="hljs-built_in">isTypeMetadata</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (cls-&gt;<span class="hljs-built_in">isArtificialSubclass</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> cls-&gt;<span class="hljs-built_in">getDescription</span>();<br>  &#125;<br>  <span class="hljs-keyword">case</span> MetadataKind::Struct:<br>  <span class="hljs-keyword">case</span> MetadataKind::Enum:<br>  <span class="hljs-keyword">case</span> MetadataKind::Optional:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TargetValueMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>        -&gt;Description;<br>  <span class="hljs-keyword">case</span> MetadataKind::ForeignClass:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TargetForeignClassMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>        -&gt;Description;<br>  <span class="hljs-keyword">case</span> MetadataKind::ForeignReferenceType:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TargetForeignReferenceTypeMetadata&lt;Runtime&gt; *&gt;(<span class="hljs-keyword">this</span>)<br>        -&gt;Description;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="TargetClassMetadata"><a href="#TargetClassMetadata" class="headerlink" title="TargetClassMetadata"></a>TargetClassMetadata</h3><ul>
<li><code>TargetClassMetadataType</code>即<code>TargetClassMetadata</code>是所有<code>swift</code>所有<code>类类型</code>的最终<code>基类</code>，类似于<code>OC</code>中的<code>objc_class</code>。  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The structure of all class metadata.  This structure is embedded</span><br><span class="hljs-comment">/// directly within the class&#x27;s heap metadata structure and therefore</span><br><span class="hljs-comment">/// cannot be extended without an ABI break.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Note that the layout of this type is compatible with the layout of</span><br><span class="hljs-comment">/// an Objective-C class.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// If the Runtime supports Objective-C interoperability, this class inherits</span><br><span class="hljs-comment">/// from TargetAnyClassMetadataObjCInterop, otherwise it inherits from</span><br><span class="hljs-comment">/// TargetAnyClassMetadata.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime, <span class="hljs-keyword">typename</span> TargetAnyClassMetadataVariant&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetAnyClassMetadataVariant &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br><br>  <span class="hljs-built_in">TargetClassMetadata</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-comment">//这里将一个父类的类型传进来了，显然，这里base实际表示元类</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetClassMetadata</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetAnyClassMetadataVariant &amp;base,</span></span><br><span class="hljs-params"><span class="hljs-function">                                ClassFlags flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                                ClassIVarDestroyer *ivarDestroyer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoredPointer size, StoredPointer addressPoint,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoredPointer alignMask,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoredPointer classSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoredPointer classAddressPoint)</span></span><br><span class="hljs-function">      : TargetAnyClassMetadataVariant(base), Flags(flags),</span><br><span class="hljs-function">        InstanceAddressPoint(addressPoint), InstanceSize(size),</span><br><span class="hljs-function">        InstanceAlignMask(alignMask), Reserved(<span class="hljs-number">0</span>), ClassSize(classSize),</span><br><span class="hljs-function">        ClassAddressPoint(classAddressPoint), Description(nullptr),</span><br><span class="hljs-function">        IVarDestroyer(ivarDestroyer) &#123;</span>&#125;<br><br>  <span class="hljs-comment">// The remaining fields are valid only when isTypeMetadata().</span><br>  <span class="hljs-comment">// The Objective-C runtime knows the offsets to some of these fields.</span><br>  <span class="hljs-comment">// Be careful when accessing them.</span><br><br>  <span class="hljs-comment">/// Swift-specific class flags.</span><br>  ClassFlags Flags;<br><br>  <span class="hljs-comment">/// The address point of instances of this type.</span><br>  <span class="hljs-keyword">uint32_t</span> InstanceAddressPoint;<br><br>  <span class="hljs-comment">/// The required size of instances of this type.</span><br>  <span class="hljs-comment">/// &#x27;InstanceAddressPoint&#x27; bytes go before the address point;</span><br>  <span class="hljs-comment">/// &#x27;InstanceSize - InstanceAddressPoint&#x27; bytes go after it.</span><br>  <span class="hljs-keyword">uint32_t</span> InstanceSize;<br><br>  <span class="hljs-comment">/// The alignment mask of the address point of instances of this type.</span><br>  <span class="hljs-keyword">uint16_t</span> InstanceAlignMask;<br><br>  <span class="hljs-comment">/// Reserved for runtime use.</span><br>  <span class="hljs-keyword">uint16_t</span> Reserved;<br><br>  <span class="hljs-comment">/// The total size of the class object, including prefix and suffix</span><br>  <span class="hljs-comment">/// extents.</span><br>  <span class="hljs-keyword">uint32_t</span> ClassSize;<br><br>  <span class="hljs-comment">/// The offset of the address point within the class object.</span><br>  <span class="hljs-keyword">uint32_t</span> ClassAddressPoint;<br><br>  <span class="hljs-comment">// Description is by far the most likely field for a client to try</span><br>  <span class="hljs-comment">// to access directly, so we force access to go through accessors.</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/// An out-of-line Swift-specific description of the type, or null</span><br>  <span class="hljs-comment">/// if this is an artificial subclass.  We currently provide no</span><br>  <span class="hljs-comment">/// supported mechanism for making a non-artificial subclass</span><br>  <span class="hljs-comment">/// dynamically.</span><br>  TargetSignedPointer&lt;Runtime, <span class="hljs-keyword">const</span> TargetClassDescriptor&lt;Runtime&gt; * __ptrauth_swift_type_descriptor&gt; Description;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/// A function for destroying instance variables, used to clean up after an</span><br>  <span class="hljs-comment">/// early return from a constructor. If null, no clean up will be performed</span><br>  <span class="hljs-comment">/// and all ivars must be trivial.</span><br>  TargetSignedPointer&lt;Runtime, ClassIVarDestroyer * __ptrauth_swift_heap_object_destructor&gt; IVarDestroyer;<br><br>  <span class="hljs-comment">// After this come the class members, laid out as follows:</span><br>  <span class="hljs-comment">//   - class members for the superclass (recursively)</span><br>  <span class="hljs-comment">//   - metadata reference for the parent, if applicable</span><br>  <span class="hljs-comment">//   - generic parameters for this class</span><br>  <span class="hljs-comment">//   - class variables (if we choose to support these)</span><br>  <span class="hljs-comment">//   - &quot;tabulated&quot; virtual methods</span><br><br>  <span class="hljs-keyword">using</span> TargetAnyClassMetadataVariant::isTypeMetadata;<br><br>  <span class="hljs-function">ConstTargetMetadataPointer&lt;Runtime, TargetClassDescriptor&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">typename</span> Runtime::StoredSignedPointer</span><br><span class="hljs-function">  <span class="hljs-title">getDescriptionAsSignedPointer</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDescription</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetClassDescriptor&lt;Runtime&gt; *description)</span> </span>&#123;<br>    Description = description;<br>  &#125;<br><br>  <span class="hljs-comment">// [<span class="hljs-doctag">NOTE:</span> Dynamic-subclass-KVO]</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Using Objective-C runtime, KVO can modify object behavior without needing</span><br>  <span class="hljs-comment">// to modify the object&#x27;s code. This is done by dynamically creating an</span><br>  <span class="hljs-comment">// artificial subclass of the object&#x27;s type.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The isa pointer of the observed object is swapped out to point to</span><br>  <span class="hljs-comment">// the artificial subclass, which has the following properties:</span><br>  <span class="hljs-comment">// - Setters for observed keys are overridden to additionally post</span><br>  <span class="hljs-comment">// notifications.</span><br>  <span class="hljs-comment">// - The `-class` method is overridden to return the original class type</span><br>  <span class="hljs-comment">// instead of the artificial subclass type.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// For more details, see:</span><br>  <span class="hljs-comment">// https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html</span><br><br>  <span class="hljs-comment">/// Is this class an artificial subclass, such as one dynamically</span><br>  <span class="hljs-comment">/// created for various dynamic purposes like KVO?</span><br>  <span class="hljs-comment">/// See [<span class="hljs-doctag">NOTE:</span> Dynamic-subclass-KVO]</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isArtificialSubclass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Description == <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setArtificialSubclass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    Description = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-function">ClassFlags <span class="hljs-title">getFlags</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Flags;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFlags</span><span class="hljs-params">(ClassFlags flags)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    Flags = flags;<br>  &#125;<br><br>  <span class="hljs-function">StoredSize <span class="hljs-title">getInstanceSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> InstanceSize;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInstanceSize</span><span class="hljs-params">(StoredSize size)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    InstanceSize = size;<br>  &#125;<br><br>  <span class="hljs-function">StoredPointer <span class="hljs-title">getInstanceAddressPoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> InstanceAddressPoint;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInstanceAddressPoint</span><span class="hljs-params">(StoredSize size)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    InstanceAddressPoint = size;<br>  &#125;<br><br>  <span class="hljs-function">StoredPointer <span class="hljs-title">getInstanceAlignMask</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> InstanceAlignMask;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInstanceAlignMask</span><span class="hljs-params">(StoredSize mask)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    InstanceAlignMask = mask;<br>  &#125;<br><br>  <span class="hljs-function">StoredPointer <span class="hljs-title">getClassSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> ClassSize;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setClassSize</span><span class="hljs-params">(StoredSize size)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    ClassSize = size;<br>  &#125;<br><br>  <span class="hljs-function">StoredPointer <span class="hljs-title">getClassAddressPoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> ClassAddressPoint;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setClassAddressPoint</span><span class="hljs-params">(StoredSize offset)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    ClassAddressPoint = offset;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint16_t</span> <span class="hljs-title">getRuntimeReservedData</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">return</span> Reserved;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRuntimeReservedData</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> data)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    Reserved = data;<br>  &#125;<br><br>  <span class="hljs-comment">/// Get a pointer to the field offset vector, if present, or null.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> StoredPointer *<span class="hljs-title">getFieldOffsets</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">getDescription</span>()-&gt;<span class="hljs-built_in">getFieldOffsetVectorOffset</span>();<br>    <span class="hljs-keyword">if</span> (offset == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> asWords = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span>*&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> StoredPointer *&gt;(asWords + offset);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">getSizeInWords</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>    <span class="hljs-keyword">uint32_t</span> size = <span class="hljs-built_in">getClassSize</span>() - <span class="hljs-built_in">getClassAddressPoint</span>();<br>    <span class="hljs-built_in">assert</span>(size % <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StoredPointer) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> size / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StoredPointer);<br>  &#125;<br><br>  <span class="hljs-comment">/// Given that this class is serving as the superclass of a Swift class,</span><br>  <span class="hljs-comment">/// return its bounds as metadata.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// Note that the ImmediateMembersOffset member will not be meaningful.</span><br>  <span class="hljs-function">TargetClassMetadataBounds&lt;Runtime&gt;</span><br><span class="hljs-function">  <span class="hljs-title">getClassBoundsAsSwiftSuperclass</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> Bounds = TargetClassMetadataBounds&lt;Runtime&gt;;<br><br>    <span class="hljs-keyword">auto</span> rootBounds = Bounds::forSwiftRootClass();<br><br>    <span class="hljs-comment">// If the class is not type metadata, just use the root-class bounds.</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isTypeMetadata</span>())<br>      <span class="hljs-keyword">return</span> rootBounds;<br><br>    <span class="hljs-comment">// Otherwise, pull out the bounds from the metadata.</span><br>    <span class="hljs-keyword">auto</span> bounds = Bounds::forAddressPointAndSize(<span class="hljs-built_in">getClassAddressPoint</span>(),<br>                                                 <span class="hljs-built_in">getClassSize</span>());<br><br>    <span class="hljs-comment">// Round the bounds up to the required dimensions.</span><br>    <span class="hljs-keyword">if</span> (bounds.NegativeSizeInWords &lt; rootBounds.NegativeSizeInWords)<br>      bounds.NegativeSizeInWords = rootBounds.NegativeSizeInWords;<br>    <span class="hljs-keyword">if</span> (bounds.PositiveSizeInWords &lt; rootBounds.PositiveSizeInWords)<br>      bounds.PositiveSizeInWords = rootBounds.PositiveSizeInWords;<br><br>    <span class="hljs-keyword">return</span> bounds;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SWIFT_OBJC_INTEROP</span><br>  <span class="hljs-comment">/// Given a statically-emitted metadata template, this sets the correct</span><br>  <span class="hljs-comment">/// &quot;is Swift&quot; bit for the current runtime. Depending on the deployment</span><br>  <span class="hljs-comment">/// target a binary was compiled for, statically emitted metadata templates</span><br>  <span class="hljs-comment">/// may have a different bit set from the one that this runtime canonically</span><br>  <span class="hljs-comment">/// considers the &quot;is Swift&quot; bit.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAsTypeMetadata</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// If the wrong &quot;is Swift&quot; bit is set, set the correct one.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Note that the only time we should see the &quot;new&quot; bit set while</span><br>    <span class="hljs-comment">// expecting the &quot;old&quot; one is when running a binary built for a</span><br>    <span class="hljs-comment">// new OS on an old OS, which is not supported, however we do</span><br>    <span class="hljs-comment">// have tests that exercise this scenario.</span><br>    <span class="hljs-keyword">auto</span> otherSwiftBit = (<span class="hljs-number">3ULL</span> - SWIFT_CLASS_IS_SWIFT_MASK);<br>    <span class="hljs-built_in">assert</span>(otherSwiftBit == <span class="hljs-number">1ULL</span> || otherSwiftBit == <span class="hljs-number">2ULL</span>);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>-&gt;Data &amp; <span class="hljs-number">3</span>) == otherSwiftBit) &#123;<br>      <span class="hljs-keyword">this</span>-&gt;Data ^= <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Otherwise there should be nothing to do, since only the old &quot;is</span><br>    <span class="hljs-comment">// Swift&quot; bit is used for backward-deployed runtimes.</span><br>    <br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isTypeMetadata</span>());<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Flags &amp; ClassFlags::IsStaticSpecialization;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCanonicalStaticallySpecializedGenericMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> *description = <span class="hljs-built_in">getDescription</span>();<br>    <span class="hljs-keyword">if</span> (!description-&gt;<span class="hljs-built_in">isGeneric</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Flags &amp; ClassFlags::IsCanonicalStaticSpecialization;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetMetadata&lt;Runtime&gt; *metadata)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> metadata-&gt;<span class="hljs-built_in">getKind</span>() == MetadataKind::Class;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> ClassMetadata = TargetClassMetadataType&lt;InProcess&gt;;<br></code></pre></td></tr></table></figure>
</li>
<li><code>template</code>是<code>c++</code>的泛型写法,<code>TargetClassMetadata</code>的父类,如果<code>Runtime</code>支持<code>Objective-C</code>互操作性，则此类继承<code>TargetAnyClassMetadataObjCInterop</code>(实际上该类的父类就是<code>TargetAnyClassMetadata</code>)，否则继承自<code>TargetAnyClassMetadata</code></li>
<li>其中均有<code>assert(isTypeMetadata())</code>断言，显然，这里的属性值是元类才会有的。元类的元类是没有的</li>
<li>其结构实际为 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassMetadata</span></span>&#123;<br>         <span class="hljs-operator">......//</span><span class="hljs-type">TargetAnyClassMetadataObjCInterop或TargetAnyClassMetadata的数据</span><br>       <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <br>       <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <br>       <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <br>       <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <br>       <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <br>       <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <br>       <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <br>       <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutableRawPointer</span> <br>       <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="TargetAnyClassMetadata"><a href="#TargetAnyClassMetadata" class="headerlink" title="TargetAnyClassMetadata"></a>TargetAnyClassMetadata</h3><blockquote>
<p><code>TargetAnyClassMetadata</code>继承了<code>TargetHeapMetadata</code>,即，最开始的基类<br>理解成<code>Swift</code>的<code>元类</code>，<code>isTypeMetadata</code>始终返回<code>true</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// The portion of a class metadata object that is compatible with</span><br><span class="hljs-comment">/// all classes, even non-Swift ones.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetAnyClassMetadata</span> :</span> <span class="hljs-keyword">public</span> TargetHeapMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br>  <span class="hljs-keyword">using</span> TargetClassMetadata = TargetClassMetadataType&lt;Runtime&gt;;<br><br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetAnyClassMetadata</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetAnyClassMetadataObjCInterop&lt;Runtime&gt; *isa,</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetClassMetadata *superclass)</span></span><br><span class="hljs-function">      : TargetHeapMetadata&lt;Runtime&gt;(isa), Superclass(superclass) &#123;</span>&#125;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetAnyClassMetadata</span><span class="hljs-params">(TargetClassMetadata *superclass)</span></span><br><span class="hljs-function">      : TargetHeapMetadata&lt;Runtime&gt;(MetadataKind::Class),</span><br><span class="hljs-function">        Superclass(superclass) &#123;</span>&#125;<br><br>  <span class="hljs-comment">// Note that ObjC classes do not have a metadata header.</span><br><br>  <span class="hljs-comment">/// The metadata for the superclass.  This is null for the root class.</span><br>  TargetSignedPointer&lt;Runtime, <span class="hljs-keyword">const</span> TargetClassMetadata *<br>                                   __ptrauth_swift_objc_superclass&gt;<br>      Superclass;<br><br>  <span class="hljs-comment">/// Is this object a valid swift type metadata?  That is, can it be</span><br>  <span class="hljs-comment">/// safely downcast to ClassMetadata?</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTypeMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">/// A different perspective on the same bit.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPureObjC</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">isTypeMetadata</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>该类中有个<code>superclass</code>属性，并且由于继承<code>TargetHeapMetadata</code>,因此有<code>kind</code>属性，其结构为  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetAnyClassMetadata</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span>:<span class="hljs-type">StoredPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Superclass</span>:<span class="hljs-type">TargetSignedPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="TargetAnyClassMetadataObjCInterop"><a href="#TargetAnyClassMetadataObjCInterop" class="headerlink" title="TargetAnyClassMetadataObjCInterop"></a>TargetAnyClassMetadataObjCInterop</h3><blockquote>
<p><code>TargetAnyClassMetadataObjCInterop</code>继承了<code>TargetAnyClassMetadata</code><br>实际的<code>类数据</code>，其包含了<code>kind</code>（可以和<code>isa</code>转换）、<code>superclass</code>、<code>CacheData</code>、<code>StoredSize Data</code>,和<code>objc_class</code>中的<code>isa</code>、<code>superclass</code>、<code>cache_t cache</code>、<code>class_data_bits_t bits</code>类似。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// This is the class metadata object for all classes (Swift and ObjC) in a</span><br><span class="hljs-comment">/// runtime that has Objective-C interoperability.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetAnyClassMetadataObjCInterop</span></span><br><span class="hljs-class">    :</span> <span class="hljs-keyword">public</span> TargetAnyClassMetadata&lt;Runtime&gt; &#123;<br>  <span class="hljs-keyword">using</span> StoredPointer = <span class="hljs-keyword">typename</span> Runtime::StoredPointer;<br>  <span class="hljs-keyword">using</span> StoredSize = <span class="hljs-keyword">typename</span> Runtime::StoredSize;<br>  <span class="hljs-keyword">using</span> TargetClassMetadataObjCInterop =<br>    <span class="hljs-comment">// swift:: qualifier works around an MSVC quirk</span><br>    swift::TargetClassMetadata&lt;Runtime, TargetAnyClassMetadataObjCInterop&lt;Runtime&gt;&gt;;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetAnyClassMetadataObjCInterop</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetAnyClassMetadataObjCInterop&lt;Runtime&gt; *isa,</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetClassMetadataObjCInterop *superclass)</span></span><br><span class="hljs-function">      : TargetAnyClassMetadata&lt;Runtime&gt;(isa, superclass),</span><br><span class="hljs-function">        CacheData&#123;</span><span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>&#125;,<br>        <span class="hljs-built_in">Data</span>(SWIFT_CLASS_IS_SWIFT_MASK) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">TargetAnyClassMetadataObjCInterop</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      TargetClassMetadataObjCInterop *superclass)</span></span><br><span class="hljs-function">      : TargetAnyClassMetadata&lt;Runtime&gt;(superclass), CacheData&#123;</span><span class="hljs-literal">nullptr</span>,<br>                                                               <span class="hljs-literal">nullptr</span>&#125;,<br>        <span class="hljs-built_in">Data</span>(SWIFT_CLASS_IS_SWIFT_MASK) &#123;&#125;<br><br>  <span class="hljs-comment">// Allow setting the metadata kind to a class ISA on class metadata.</span><br>  <span class="hljs-keyword">using</span> TargetMetadata&lt;Runtime&gt;::getClassISA;<br>  <span class="hljs-keyword">using</span> TargetMetadata&lt;Runtime&gt;::setClassISA;<br><br>  <span class="hljs-comment">/// The cache data is used for certain dynamic lookups; it is owned</span><br>  <span class="hljs-comment">/// by the runtime and generally needs to interoperate with</span><br>  <span class="hljs-comment">/// Objective-C&#x27;s use.</span><br>  TargetPointer&lt;Runtime, <span class="hljs-keyword">void</span>&gt; CacheData[<span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/// The data pointer is used for out-of-line metadata and is</span><br>  <span class="hljs-comment">/// generally opaque, except that the compiler sets the low bit in</span><br>  <span class="hljs-comment">/// order to indicate that this is a Swift metatype and therefore</span><br>  <span class="hljs-comment">/// that the type metadata header is present.</span><br>  StoredSize Data;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> StoredPointer <span class="hljs-title">offsetToData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(TargetAnyClassMetadataObjCInterop, Data);<br>  &#125;<br><br>  <span class="hljs-comment">/// Is this object a valid swift type metadata?  That is, can it be</span><br>  <span class="hljs-comment">/// safely downcast to ClassMetadata?</span><br>  <span class="hljs-comment">//当前对象是有效的Swift类型元数据，并且可以安全地向下转换为ClassMetadata，则该函数应该返回true。否则，如果当前对象无效，则该函数应该返回false。</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTypeMetadata</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Data &amp; SWIFT_CLASS_IS_SWIFT_MASK);<br>  &#125;<br>  <span class="hljs-comment">/// A different perspective on the same bit</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPureObjC</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">isTypeMetadata</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>isa</code>和<code>kind</code>的转换方法<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> TargetAnyClassMetadata&lt;Runtime&gt; *<span class="hljs-title">getClassISA</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> TargetAnyClassMetadata&lt;Runtime&gt; *&gt;(Kind);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setClassISA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TargetAnyClassMetadata&lt;Runtime&gt; *isa)</span> </span>&#123;<br>    Kind = <span class="hljs-keyword">reinterpret_cast</span>&lt;StoredPointer&gt;(isa);<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li>由于<code>TargetAnyClassMetadataObjCInterop</code>继承<code>TargetAnyClassMetadata</code>，其实际数据结构为<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetAnyClassMetadataObjCInterop</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Kind</span>:<span class="hljs-type">StoredPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Superclass</span>:<span class="hljs-type">TargetSignedPointer</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-type">CacheData</span>:(<span class="hljs-type">TargetSignedPointer</span>,<span class="hljs-type">TargetSignedPointer</span>)<br>    <span class="hljs-keyword">var</span> <span class="hljs-type">Data</span>:<span class="hljs-type">StoredSize</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="swift-类的数据结构"><a href="#swift-类的数据结构" class="headerlink" title="swift 类的数据结构"></a>swift 类的数据结构</h3><ul>
<li><p>结合<code>TargetClassMetadata</code>和<code>TargetAnyClassMetadataObjCInterop</code>的数据结构，最终<code>swift</code>类的数据结构为</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Metadata</span> </span>&#123; <br>  <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <br>  <span class="hljs-keyword">var</span> superClass: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span> <br>  <span class="hljs-keyword">var</span> cacheData: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) <span class="hljs-comment">//ObjCInterop 才有的</span><br>  <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span>  <span class="hljs-comment">//ObjCInterop 才有的</span><br>  <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <br>  <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <br>  <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <br>  <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutableRawPointer</span> <br>  <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>其中需要关注<code>typeDescriptor</code>，不管是<code>class</code>/<code>struct</code>/<code>enum</code>都有自己的<code>Descriptor</code>，它就是对类的一个详细描述。</p>
<ul>
<li>而类中主要是<code>TargetClassDescriptor</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">TargetSignedPointer&lt;Runtime, <span class="hljs-keyword">const</span> TargetClassDescriptor&lt;Runtime&gt; *     __ptrauth_swift_type_descriptor&gt; Description;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>下面用图描述，一个对象的内存结构<br>  <img src="7.png"></p>
</li>
</ul>
<h2 id="TargetClassDescriptor"><a href="#TargetClassDescriptor" class="headerlink" title="TargetClassDescriptor"></a><span id="jump"><code>TargetClassDescriptor</code></span></h2><blockquote>
<p><code>TargetClassDescriptor</code>是<code>TargetClassMetadata</code>中主要描述类信息的属性</p>
</blockquote>
<ul>
<li>其数据结构如下，<code>TargetClassDescriptor</code>本身的结构是没有 <code>V-Table</code>和<code>size</code><ul>
<li>整个继承链是<code>TargetClassDescriptor</code> –&gt;<code>TargetTypeContextDescriptor</code> –&gt; <code>TargetContextDescriptor</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetClassDescriptor</span></span>&#123; <br><br>     <span class="hljs-comment">//继承至TargetContextDescriptor</span><br>      <span class="hljs-keyword">var</span> flags: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> parent: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>      <br>      <span class="hljs-comment">//继承至TargetTypeContextDescriptor</span><br>      <span class="hljs-keyword">var</span> name: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;   <span class="hljs-comment">// class/struct/enum 的名称</span><br>      <span class="hljs-keyword">var</span> accessFunctionPointer: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">UnsafeRawPointer</span>&gt;<br>      <span class="hljs-keyword">var</span> fieldDescriptor: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">FieldDescriptor</span>&gt; <span class="hljs-comment">//属性描述器</span><br><br>      <span class="hljs-comment">//TargetClassDescriptor具有的</span><br>      <span class="hljs-keyword">var</span> superClassType: <span class="hljs-type">TargetRelativeDirectPointer</span>&lt;<span class="hljs-type">CChar</span>&gt;  <span class="hljs-comment">//父类类型指针</span><br>      <span class="hljs-keyword">var</span> metadataNegativeSizeInWords: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> metadataPositiveSizeInWords: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> numImmediateMembers: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> numFields: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-keyword">var</span> fieldOffsetVectorOffset: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 每一个属性值距离当前实例对象地址的偏移量</span><br>      <span class="hljs-keyword">var</span> <span class="hljs-type">Offset</span>: <span class="hljs-type">UInt32</span> <br>      <span class="hljs-comment">// var size: UInt32 </span><br>      <span class="hljs-comment">// V-Table  (methods) </span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注意，<code>superClassType</code>的类型是<code>TargetRelativeDirectPointer&lt;Runtime, const char&gt;</code>,它是一个相对地址信息，并且存储的是偏移量。(<code>swift</code>中在数据结构存储数据都是通过<code>偏移量</code>去访问内存地址)</li>
</ul>
<h3 id="TargetRelativeDirectPointer"><a href="#TargetRelativeDirectPointer" class="headerlink" title="TargetRelativeDirectPointer"></a><code>TargetRelativeDirectPointer</code></h3><ul>
<li><p>源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// TargetRelativeDirectPointer其实是RelativeDirectPointer的别名</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime, <span class="hljs-keyword">typename</span> Pointee, <span class="hljs-keyword">bool</span> Nullable = <span class="hljs-literal">true</span>&gt;<br><span class="hljs-keyword">using</span> TargetRelativeDirectPointer<br>  = <span class="hljs-keyword">typename</span> Runtime::<span class="hljs-keyword">template</span> RelativeDirectPointer&lt;Pointee, Nullable&gt;;<br><br><span class="hljs-comment">/// A direct relative reference to an object that is not a function pointer.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">bool</span> Nullable, <span class="hljs-keyword">typename</span> Offset&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RelativeDirectPointer</span>&lt;</span>T, Nullable, Offset,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;!std::is_function&lt;T&gt;::value&gt;::type&gt;<br>    : <span class="hljs-keyword">private</span> RelativeDirectPointerImpl&lt;T, Nullable, Offset&gt;<br>&#123;<br>  <span class="hljs-keyword">using</span> super = RelativeDirectPointerImpl&lt;T, Nullable, Offset&gt;;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> super::get;<br>  <span class="hljs-keyword">using</span> super::super;<br>  <br>  RelativeDirectPointer &amp;<span class="hljs-keyword">operator</span>=(T *absolute) &amp; &#123;<br>    super::<span class="hljs-keyword">operator</span>=(absolute);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-keyword">typename</span> <span class="hljs-title">super::PointerTy</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp; </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> super::ValueTy *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &amp; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> super::ValueTy* <span class="hljs-title">getRelative</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *base)</span> <span class="hljs-keyword">const</span> &amp; </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;super::<span class="hljs-built_in">getRelative</span>(base);<br>  &#125;<br><br>  <span class="hljs-keyword">using</span> super::isNull;<br>  <span class="hljs-keyword">using</span> super::resolve;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>其获取方法是<code>get</code>实际调用了父类<code>RelativeDirectPointerImpl</code>中的方法其源码为</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-function">PointerTy <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp; </span>&#123;<br>  <span class="hljs-comment">// Check for null.</span><br>  <span class="hljs-keyword">if</span> (Nullable &amp;&amp; RelativeOffset == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <br>  <span class="hljs-comment">// The value is addressed relative to `this`.</span><br>  <span class="hljs-comment">//该类的地址加上相对地址</span><br>  <span class="hljs-keyword">uintptr_t</span> absolute = detail::<span class="hljs-built_in">applyRelativeOffset</span>(<span class="hljs-keyword">this</span>, RelativeOffset);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;PointerTy&gt;(absolute);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在<code>swift</code>中引用一个对象有两种情况，</p>
<ul>
<li>一种是<code>地址A</code>上直接存储了对象的<code>地址B</code></li>
<li>另一个就是<code>地址A</code>上存储了<code>相对地址C</code>，该对象的地址<code>B = A + C</code>,这里的<code>TargetRelativeDirectPointer</code>就是相对地址</li>
</ul>
</li>
<li><p><code>TargetRelativeDirectPointer</code>实际等比表示如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 相对地址信息 - 存储的是偏移量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetRelativeDirectPointer</span>&lt;<span class="hljs-title">Pointee</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> offset: <span class="hljs-type">Int32</span><br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getmeasureRelativeOffset</span>()</span> -&gt; <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Pointee</span>&gt;&#123;<br>        <span class="hljs-keyword">let</span> offset <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.offset<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) &#123; p <span class="hljs-keyword">in</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             获得self，变为raw，然后+offset</span><br><span class="hljs-comment">             - UnsafeRawPointer(p) 表示this</span><br><span class="hljs-comment">             - advanced(by: numericCast(offset) 表示移动的步长，即offset</span><br><span class="hljs-comment">             - assumingMemoryBound(to: T.self) 表示假定类型是T，即自己指定的类型</span><br><span class="hljs-comment">             - UnsafeMutablePointer(mutating:) 表示返回的指针类型</span><br><span class="hljs-comment">            */</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeMutablePointer</span>(mutating: <span class="hljs-type">UnsafeRawPointer</span>(p).advanced(by: <span class="hljs-built_in">numericCast</span>(offset)).assumingMemoryBound(to: <span class="hljs-type">Pointee</span>.<span class="hljs-keyword">self</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="ClassContextDescriptorBuilder"><a href="#ClassContextDescriptorBuilder" class="headerlink" title="ClassContextDescriptorBuilder"></a><code>ClassContextDescriptorBuilder</code></h3><blockquote>
<p><code>ClassContextDescriptorBuilder</code>这个类是用来<code>创建</code>当前的<code>Matedata</code>和<code>Descriptor</code>用的,其核心方法是<code>layout</code>函数：</p>
</blockquote>
<ol>
<li><code>ClassContextDescriptorBuilder</code>的<code>layout</code>函数 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">()</span> </span>&#123;<br>      super::<span class="hljs-built_in">layout</span>();<br>      <span class="hljs-built_in">addVTable</span>();<br>      <span class="hljs-built_in">addOverrideTable</span>();<br>      <span class="hljs-built_in">addObjCResilientClassStubInfo</span>();<br>      <span class="hljs-built_in">maybeAddCanonicalMetadataPrespecializations</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>父类是<code>TypeContextDescriptorBuilderBase</code>的<code>layout</code>函数 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">computeIdentity</span>();<br>    <br>  super::<span class="hljs-built_in">layout</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addName</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addAccessFunction</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addReflectionFieldDescriptor</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addLayoutInfo</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addGenericSignature</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">maybeAddResilientSuperclass</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">maybeAddMetadataInitialization</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>最终的基类是<code>ContextDescriptorBuilderBase</code> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addFlags</span>();<br>  <span class="hljs-built_in">asImpl</span>().<span class="hljs-built_in">addParent</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>在构建过程中实际上是<code>TargetClassDescriptor</code>数据的构建，由1可知，实际上构建了<code>addVTable()</code>和<code>addOverrideTable()</code><ul>
<li><code>addVTable()</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addVTable</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">LLVM_DEBUG</span>(<br>    llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;VTable entries for &quot;</span> &lt;&lt; <span class="hljs-built_in">getType</span>()-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry : VTableEntries) &#123;<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>      entry.<span class="hljs-built_in">print</span>(llvm::<span class="hljs-built_in">dbgs</span>());<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>  );<br>    <br>  <span class="hljs-comment">// Only emit a method lookup function if the class is resilient</span><br>  <span class="hljs-comment">// and has a non-empty vtable, as well as no elided methods.</span><br>  <span class="hljs-keyword">if</span> (IGM.<span class="hljs-built_in">hasResilientMetadata</span>(<span class="hljs-built_in">getType</span>(), ResilienceExpansion::Minimal)<br>      &amp;&amp; (HasNonoverriddenMethods || !VTableEntries.<span class="hljs-built_in">empty</span>()))<br>    IGM.<span class="hljs-built_in">emitMethodLookupFunction</span>(<span class="hljs-built_in">getType</span>());<br>    <br>  <span class="hljs-keyword">if</span> (VTableEntries.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br>  <br>  <span class="hljs-keyword">auto</span> offset = MetadataLayout-&gt;<span class="hljs-built_in">hasResilientSuperclass</span>()<br>                  ? MetadataLayout-&gt;<span class="hljs-built_in">getRelativeVTableOffset</span>()<br>                  : MetadataLayout-&gt;<span class="hljs-built_in">getStaticVTableOffset</span>();<br><span class="hljs-comment">//将偏移量添加到B结构体</span><br>  B.<span class="hljs-built_in">addInt32</span>(offset / IGM.<span class="hljs-built_in">getPointerSize</span>());<br>  B.<span class="hljs-built_in">addInt32</span>(VTableEntries.<span class="hljs-built_in">size</span>());<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> fn : VTableEntries)<br>  <span class="hljs-comment">//遍历函数表添加函数指针</span><br>    <span class="hljs-built_in">emitMethodDescriptor</span>(fn);<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">emitMethodDescriptor</span><span class="hljs-params">(SILDeclRef fn)</span> </span>&#123;<br>    <br>  <span class="hljs-comment">// Define the method descriptor to point to the current position in the</span><br>  <span class="hljs-comment">// nominal type descriptor, if it has a well-defined symbol name.</span><br>  IGM.<span class="hljs-built_in">defineMethodDescriptor</span>(<br>      fn, Type, B.<span class="hljs-built_in">getAddrOfCurrentPosition</span>(IGM.MethodDescriptorStructTy),<br>      IGM.MethodDescriptorStructTy);<br>    <br>  <span class="hljs-keyword">if</span> (IGM.<span class="hljs-built_in">getOptions</span>().VirtualFunctionElimination) &#123;<br>    <span class="hljs-keyword">auto</span> offset = B.<span class="hljs-built_in">getNextOffsetFromGlobal</span>() +<br>                  <span class="hljs-comment">// 1st field of MethodDescriptorStructTy</span><br>                  <span class="hljs-built_in">Size</span>(IGM.DataLayout.<span class="hljs-built_in">getTypeAllocSize</span>(IGM.Int32Ty));<br>    VTableEntriesForVFE.<span class="hljs-built_in">push_back</span>(std::pair&lt;Size, SILDeclRef&gt;(offset, fn));<br>  &#125;<br>    <br>  <span class="hljs-comment">// Actually build the descriptor.</span><br>  <span class="hljs-keyword">auto</span> descriptor = B.<span class="hljs-built_in">beginStruct</span>(IGM.MethodDescriptorStructTy);<br>  <span class="hljs-built_in">buildMethodDescriptorFields</span>(IGM, VTable, fn, descriptor);<br>  descriptor.<span class="hljs-built_in">finishAndAddTo</span>(B);<br>    <br>  <span class="hljs-comment">// Emit method dispatch thunk if the class is resilient.</span><br>  <span class="hljs-keyword">auto</span> *func = cast&lt;AbstractFunctionDecl&gt;(fn.<span class="hljs-built_in">getDecl</span>());<br>    <br>  <span class="hljs-keyword">if</span> ((Resilient &amp;&amp; func-&gt;<span class="hljs-built_in">getEffectiveAccess</span>() &gt;= AccessLevel::Public) ||<br>      IGM.<span class="hljs-built_in">getOptions</span>().VirtualFunctionElimination) &#123;<br>    IGM.<span class="hljs-built_in">emitDispatchThunk</span>(fn);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>addOverrideTable()</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addOverrideTable</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">LLVM_DEBUG</span>(<br>    llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;Override Table entries for &quot;</span> &lt;&lt; <span class="hljs-built_in">getType</span>()-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry : OverrideTableEntries) &#123;<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>      entry.first.<span class="hljs-built_in">print</span>(llvm::<span class="hljs-built_in">dbgs</span>());<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>      entry.second.<span class="hljs-built_in">print</span>(llvm::<span class="hljs-built_in">dbgs</span>());<br>      llvm::<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>  );<br>    <br>  <span class="hljs-keyword">if</span> (OverrideTableEntries.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br>    <br>  B.<span class="hljs-built_in">addInt32</span>(OverrideTableEntries.<span class="hljs-built_in">size</span>());<br>    <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair : OverrideTableEntries)<br>    <span class="hljs-built_in">emitMethodOverrideDescriptor</span>(pair.first, pair.second);<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">emitMethodOverrideDescriptor</span><span class="hljs-params">(SILDeclRef baseRef, SILDeclRef declRef)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (IGM.<span class="hljs-built_in">getOptions</span>().VirtualFunctionElimination) &#123;<br>    <span class="hljs-keyword">auto</span> offset =<br>        B.<span class="hljs-built_in">getNextOffsetFromGlobal</span>() +<br>        <span class="hljs-comment">// 1st field of MethodOverrideDescriptorStructTy</span><br>        <span class="hljs-built_in">Size</span>(IGM.DataLayout.<span class="hljs-built_in">getTypeAllocSize</span>(IGM.RelativeAddressTy)) +<br>        <span class="hljs-comment">// 2nd field of MethodOverrideDescriptorStructTy</span><br>        <span class="hljs-built_in">Size</span>(IGM.DataLayout.<span class="hljs-built_in">getTypeAllocSize</span>(IGM.RelativeAddressTy));<br>    VTableEntriesForVFE.<span class="hljs-built_in">push_back</span>(<br>        std::pair&lt;Size, SILDeclRef&gt;(offset, baseRef));<br>  &#125;<br>    <br>  <span class="hljs-keyword">auto</span> descriptor = B.<span class="hljs-built_in">beginStruct</span>(IGM.MethodOverrideDescriptorStructTy);<br>    <br>  <span class="hljs-comment">// The class containing the base method.</span><br>  <span class="hljs-keyword">auto</span> *baseClass = cast&lt;ClassDecl&gt;(baseRef.<span class="hljs-built_in">getDecl</span>()-&gt;<span class="hljs-built_in">getDeclContext</span>());<br>  IGM.IRGen.<span class="hljs-built_in">noteUseOfTypeContextDescriptor</span>(baseClass, DontRequireMetadata);<br>  <span class="hljs-keyword">auto</span> baseClassEntity = LinkEntity::forNominalTypeDescriptor(baseClass);<br>  <span class="hljs-keyword">auto</span> baseClassDescriptor =<br>    IGM.<span class="hljs-built_in">getAddrOfLLVMVariableOrGOTEquivalent</span>(baseClassEntity);<br>  descriptor.<span class="hljs-built_in">addRelativeAddress</span>(baseClassDescriptor);<br>    <br>  <span class="hljs-comment">// The base method.</span><br>  <span class="hljs-keyword">auto</span> baseMethodEntity = LinkEntity::forMethodDescriptor(baseRef);<br>  <span class="hljs-keyword">auto</span> baseMethodDescriptor =<br>    IGM.<span class="hljs-built_in">getAddrOfLLVMVariableOrGOTEquivalent</span>(baseMethodEntity);<br>  descriptor.<span class="hljs-built_in">addRelativeAddress</span>(baseMethodDescriptor);<br>    <br>  <span class="hljs-comment">// The implementation of the override.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> entry = VTable-&gt;<span class="hljs-built_in">getEntry</span>(IGM.<span class="hljs-built_in">getSILModule</span>(), baseRef)) &#123;<br>    <span class="hljs-built_in">assert</span>(entry-&gt;<span class="hljs-built_in">getKind</span>() == SILVTable::Entry::Kind::Override);<br>    <br>    <span class="hljs-keyword">auto</span> *impl = entry-&gt;<span class="hljs-built_in">getImplementation</span>();<br>    <span class="hljs-keyword">if</span> (impl-&gt;<span class="hljs-built_in">isAsync</span>()) &#123;<br>      llvm::Constant *implFn = IGM.<span class="hljs-built_in">getAddrOfAsyncFunctionPointer</span>(impl);<br>      descriptor.<span class="hljs-built_in">addRelativeAddress</span>(implFn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      llvm::Function *implFn = IGM.<span class="hljs-built_in">getAddrOfSILFunction</span>(impl, NotForDefinition);<br>      descriptor.<span class="hljs-built_in">addCompactFunctionReference</span>(implFn);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// The method is removed by dead method elimination.</span><br>    <span class="hljs-comment">// It should be never called. We add a pointer to an error function.</span><br>    descriptor.<span class="hljs-built_in">addRelativeAddressOrNull</span>(<span class="hljs-literal">nullptr</span>);<br>  &#125;<br>    <br>  descriptor.<span class="hljs-built_in">finishAndAddTo</span>(B);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Mach-O方式验证"><a href="#Mach-O方式验证" class="headerlink" title="Mach-O方式验证"></a>Mach-O方式验证</h2><h3 id="mach-O介绍"><a href="#mach-O介绍" class="headerlink" title="mach-O介绍"></a>mach-O介绍</h3><blockquote>
<p><code>Mach-O</code> 其实是<code>Mach Object</code>文件格式的缩写，是 <code>mac</code> 以及 <code>iOS</code> 上可执行文件的格式。常见的 <code>.o</code>,<code>.a</code>,<code>.dylib Framework</code>，<code>dyld .dsym</code></p>
</blockquote>
<p><img src="4.jpg"></p>
<ul>
<li>文件头<code>Header</code>，表明该文件是 <code>Mach-O</code> 格式，指定目标架构，还有一些其他的文件属性信息，文件头信息影响后续的文件结构安排。</li>
<li><code>Load commands</code>是一张包含很多内容的表。内容包括区域的位置、符号表、动态符号表等。</li>
<li><code>Data</code> 区主要就是负责代码和数据记录的。<code>Mach-O</code> 是以 <code>Segment</code> 这种结构来组织数据的，一个 <code>Segment</code> 可以包含 <code>0</code> 个或多个<code>Section</code>。根据 <code>Segment</code> 是映射的哪一个 <code>Load Command</code>，<code>Segment</code> 中 <code>section</code> 就可以被解读为是是代码，常量或者一些其他的数据类型。在装载在内存中时，也是根据 <code>Segment</code> 做内存映射的。</li>
</ul>
<h3 id="编译成sil"><a href="#编译成sil" class="headerlink" title="编译成sil"></a>编译成sil</h3><ul>
<li><code>swiftc ViewController.swift -emit-silgen -o ViewController.sil</code>,编译成<code>sil</code>,在<code>sil</code>中可以看到编译的中间语言中存在函数表  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">sil_vtable Teacher &#123;<br>  #Teacher.teach: (Teacher) -&gt; () -&gt; () : @$s14ViewController7TeacherC5teachyyF	<span class="hljs-comment">// Teacher.teach()</span><br>  #Teacher.teach1: (Teacher) -&gt; () -&gt; () : @$s14ViewController7TeacherC6teach1yyF	<span class="hljs-comment">// Teacher.teach1()</span><br>  #Teacher.teach2: (Teacher) -&gt; () -&gt; () : @$s14ViewController7TeacherC6teach2yyF	<span class="hljs-comment">// Teacher.teach2()</span><br>  #Teacher.init!allocator: (Teacher.Type) -&gt; () -&gt; Teacher : @$s14ViewController7TeacherCACycfC	<span class="hljs-comment">// Teacher.__allocating_init()</span><br>  #Teacher.deinit!deallocator: @$s14ViewController7TeacherCfD	<span class="hljs-comment">// Teacher.__deallocating_deinit</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3></li>
</ul>
<ol>
<li><p>验证的源码，将该源码编译，并用<code>MachOView</code>打开可执行文件</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;teach&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach1</span>()</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;teach1&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach2</span>()</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;teach2&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span>()</span> &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        <span class="hljs-keyword">let</span> t <span class="hljs-operator">=</span> <span class="hljs-type">Teacher</span>()<br>            t.teach()<br>            t.teach1()<br>            t.teach2()<br>             <span class="hljs-comment">//metadata + offset</span><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在<code>Mach-O</code>的<code>data</code>区里的<code>__TEXT</code>,<code>__swift5_types</code>就是存放 所有的<code>struct</code>/<code>enum</code>/<code>类的Descriptor</code>的地址信息；以每<code>4</code>个字节来做区分。第一个<code>4</code>字节就是<code>Teacher</code>的<code>Descriptor</code>:<br> <img src="1.png"></p>
</li>
<li><p><code>Teacher</code>的<code>Descriptor</code>在<code>mach-o</code>上的地址,减去<code>lg_segment_64</code>上虚拟内存的基地址<code>0x100000000</code>得出<code>Descriptor</code>在<code>mach-o</code>的<code>data</code>区的偏移量：</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0xb01C</span> <span class="hljs-operator">+</span> <span class="hljs-number">0xFFFFFBA4</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x10000ABC0</span><br><span class="hljs-number">0x10000ABC0</span> <span class="hljs-operator">-</span> <span class="hljs-number">0x100000000</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xABC0</span><br></code></pre></td></tr></table></figure>
<p> <img src="2.png"><img src="3.png"></p>
</li>
<li><p>在<code>data</code>区域里面<code>__TEXT</code>,<code>__const</code>代码区，查看<code>ABC0</code>,该位置即为<a href="#jump">TargetClassDescriptor</a>,该数据结构已有成员<code>12</code>个,需要往后偏移<code>12</code>个<code>4</code>字节,再往后<code>4</code>字节里面的内容是<code>size</code>。</p>
<ul>
<li><code>size</code>后面的<code>8</code>个就是<code>teach()</code>方法的内容，再往后<code>8</code>个就是<code>teach1()</code>方法的内容，再往后<code>8</code>个就是<code>teach2()</code>的内容：<br><img src="5.png"></li>
<li><code>teach1()</code>的存储地址的偏移地址是<code>ABF4</code>,</li>
</ul>
</li>
<li><p>通过<code>image list</code>指令获取当前偏移基地址<code>0x0000000104ea8000</code>。得出<code>teach1()</code>的地址是<code>0x00000001024ec000 + ABF4 = 0x1024F6BF4</code>,该地址上存放了<code>TargetMethodDescriptor</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">(lldb) image list<br>    [  <span class="hljs-number">0</span>] <span class="hljs-number">471326</span>D4<span class="hljs-number">-83</span>D7<span class="hljs-number">-317F</span>-B08E-DCF8ADCF0875 <span class="hljs-number">0x00000001024ec000</span> /Users/chenjingpo/Library/Developer/Xcode/DerivedData/TextFunc-awqwaeqvhhvlsuhdujvflpzzqipk/Build/Products/Debug-iphoneos/TextFunc.app/TextFunc <br>    [  <span class="hljs-number">1</span>] <span class="hljs-number">41605</span>DC7-F412<span class="hljs-number">-37</span>D1-B51B-FEE1A26701E9 <span class="hljs-number">0x00000001d104f000</span> /Users/chenjingpo/Library/Developer/Xcode/iOS DeviceSupport/<span class="hljs-number">16.4</span><span class="hljs-number">.1</span> (<span class="hljs-number">20E252</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>TargetMethodDescriptor</code>的源码如下，其前<code>4</code>个字节是<code>flags</code>,后<code>4</code>个字节存放的是<code>IMP</code>,(<strong>注意</strong>,<code>imp</code>指针其实是一个相对指针，它存储的其实是<code>offset</code>)<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Runtime&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TargetMethodDescriptor</span> &#123;</span><br>  <span class="hljs-comment">/// Flags describing the method.</span><br>  MethodDescriptorFlags Flags;<br><br>  <span class="hljs-comment">/// The method implementation.</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    TargetCompactFunctionPointer&lt;Runtime, <span class="hljs-keyword">void</span>&gt; Impl;<br>    TargetRelativeDirectPointer&lt;Runtime, <span class="hljs-keyword">void</span>&gt; AsyncImpl;<br>  &#125;;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add method types or anything else needed for reflection.</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">getImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Flags.<span class="hljs-built_in">isAsync</span>()) &#123;<br>      <span class="hljs-keyword">return</span> AsyncImpl.<span class="hljs-built_in">get</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> Impl.<span class="hljs-built_in">get</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li>
<li>结合<code>3</code>，实际<code>offset</code>存储的值是<code>FFFFCD50</code>(该内存上存上的，地址的偏移)，在加上<code>flag</code>的偏移4字节，实际<code>tech</code>方法的地址是  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x1024F6BF4</span> <span class="hljs-operator">+</span> <span class="hljs-number">0x4</span> <span class="hljs-operator">+</span> <span class="hljs-type">FFFFCD50</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x2024F3948</span><br></code></pre></td></tr></table></figure></li>
<li>注意<code>0x2024F3948</code> 还需减去 <code>Mach-O</code>的基地址<code>0x100000000</code>，即<code>0x1024F3948</code>是<code>teach</code>方法的地址<br>  <img src="6.png"></li>
<li>代码查看，运行地址和计算的一样。验证成功，最后两个存放的是<code>size</code>和<code>V-Tabl</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>arm64汇编</title>
    <url>/2023/04/18/iOS%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/arm64%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>汇编主要了解三个方面</p>
<ul>
<li>寄存器</li>
<li>指令</li>
<li>堆栈</li>
</ul>
</blockquote>
<h2 id="arm64汇编"><a href="#arm64汇编" class="headerlink" title="arm64汇编"></a>arm64汇编</h2><ul>
<li><p>生成汇编文件</p>
<ul>
<li><code>xcrun --sdk iphoneos clang -S -arch arm64 main.c -o main.s</code><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3></li>
</ul>
</li>
<li><p>汇编代码,<code>test.s</code>,汇编中<code>;</code>使注解，等于<code>//</code></p>
<figure class="highlight as"><table><tr><td class="code"><pre><code class="hljs as">.text ;函数位置，在代码端<br>.global _test,_add ;使函数函数公有，外界可以访问<br>_test:<br>mov x0,#<span class="hljs-number">0x8</span>  ;将<span class="hljs-number">8</span>赋值给寄存器x0<br>ret   ;函数返回<br><br>;add函数的调用<br>_add:<br>add x0,x0,x1 ;x0 = x0 + x1<br>ret<br></code></pre></td></tr></table></figure></li>
<li><p>调用,汇编中的方法会多个<code>_</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">test();<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">//输出11</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul>
<li><code>64bit</code>的: <code>x0 ~ x28</code></li>
<li><code>32bit</code>的: <code>w0 ~ w28</code>(属于<code>x0 ~ x28</code>的低<code>32bit</code>)</li>
<li><code>x0 ~ x7</code>通常拿来存放<strong>函数的参数</strong>，更多的阐述使用<strong>堆栈</strong>来传递</li>
<li><code>x0</code>通常拿来存放函数的<strong>返回值</strong></li>
</ul>
<h3 id="程序状态寄存器"><a href="#程序状态寄存器" class="headerlink" title="程序状态寄存器"></a>程序状态寄存器</h3><blockquote>
<ul>
<li><code>cpsr</code> <code>(Current Program Status Register)</code></li>
<li><code>spsr(Saved Program Status Register)</code>,异常状态下使用</li>
</ul>
</blockquote>
<h4 id="cpsr寄存器"><a href="#cpsr寄存器" class="headerlink" title="cpsr寄存器"></a><span id="jump"><code>cpsr</code>寄存器</span></h4><p><img src="1.png"></p>
<table>
<thead>
<tr>
<th align="center">标志位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">N</td>
<td align="center">当用两个补码表示的带符 号数进行运算时，N=1 表示运算的结果为负数；N=0 表示运算的结果为正数或零；</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">Z=1 表示运算的结果为零；z=0 表示运算的结果为非零；</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">可以有4种方法设置C的值：1. 加法运算(包括比较指令 CMN）：当运算结果产生了进位时（无符号数溢出），C=1，否则 C=0。2. 减法运算（包括比较指令CMP）：当运算时产生了借位（无符号数溢出），C=0，否则 C=1。3. 对于包含移位操作的非加/减运算指令，C为移出值的最后一位。4. 对于其他的韭加/减运算指令，c的值通常不改变。</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">可以有2种方法设置 V的值：1. 对于加/减法运算指令，当操作数和运算结果为二进制的补码表示的带符号数时，V=1 表示符号位溢出。2. 对于其他的非加/减运算指令，V的值通常不改变。</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center">在 ARM N5 及以上版本的已系列处理器中，用Q标志位指示增强的 DSP 运算指令是否发生了溢出。在其他版本的处理器中，Q标志位无定义。</td>
</tr>
</tbody></table>
<h3 id="零寄存器"><a href="#零寄存器" class="headerlink" title="零寄存器"></a>零寄存器</h3><blockquote>
<p>零寄存器，里面存储的是0。因为无法将立即数0直接赋值给寄存器。要先赋值寄存器后，再赋值，考虑操作比较频繁，因此有专门的寄存器做这个。</p>
</blockquote>
<ul>
<li><code>wzr</code>(<code>32bit,Word Zero Register</code>)</li>
<li><code>xzr</code>(<code>64bit</code>)</li>
<li>注意，该寄存器无法读取(<code>register read wzr</code>无法获取)和写入</li>
</ul>
<h3 id="程序计数器pc-Program-Counter）"><a href="#程序计数器pc-Program-Counter）" class="headerlink" title="程序计数器pc(Program Counter）"></a>程序计数器pc(Program Counter）</h3><blockquote>
<ul>
<li>记录<code>cpu</code>当前指令的是哪一条指令</li>
<li>存储着当前<code>CPU</code>正在执行的指令的地址</li>
<li>类似<code>8086</code>汇编的<code>rip</code>寄存器</li>
</ul>
</blockquote>
<h3 id="链接寄存器"><a href="#链接寄存器" class="headerlink" title="链接寄存器"></a>链接寄存器</h3><ul>
<li><code>lr(Link Register)</code>,也就是<code>x30</code>,但他是特殊寄存器，是没有<code>w30</code>的</li>
<li>存储着函数地址。<code>BL</code>跳转函数地址是，<code>lr</code>会记录当前<code>pc</code>的指令地址，等函数地址返回<code>ret</code>后，会取出<code>lr</code>寄存器中的<code>pc</code>指令，跳转到标记中。因此<code>BL</code>,跳转返回后，能返回到原指令的下一个指令。</li>
</ul>
<h3 id="堆栈寄存器"><a href="#堆栈寄存器" class="headerlink" title="堆栈寄存器"></a>堆栈寄存器</h3><ul>
<li><p><code>sp</code>寄存器,也叫栈顶指针</p>
</li>
<li><p><code>fp</code>寄存器，也是<code>x29</code>,也叫栈低指针。<code>sp</code>和<code>fp</code>之间是可用的。</p>
<h4 id="叶子函数"><a href="#叶子函数" class="headerlink" title="叶子函数"></a>叶子函数</h4><blockquote>
<p>函数内不会再调用其他函数，称为叶子函数</p>
</blockquote>
</li>
<li><p>堆栈平衡示例代码</p>
<ul>
<li>原代码<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>转成汇编<figure class="highlight as"><table><tr><td class="code"><pre><code class="hljs as">sub sp,sp, #<span class="hljs-number">16</span> ; sp = sp - <span class="hljs-number">16</span>,sp寄存器，留出<span class="hljs-number">16</span>字节的空间<br><br>orr w8,wzr,#<span class="hljs-number">0x3</span> ;和<span class="hljs-number">0</span>进行按位或<br>orr w9,wzr,#<span class="hljs-number">0x2</span><br><br>str w9,[sp,#<span class="hljs-number">12</span>] ; 分配到栈空间，在之前分配的内,由高到低分配<br>str w8,[sp, #<span class="hljs-number">8</span>] ;  分配到栈空间，在之前分配的内<br><br>add sp,sp,#<span class="hljs-number">16</span> ; 所谓的回收栈空间实际上是sp寄存器，回到之前分配的位置处，期间已经分配的并不会清零，变成了垃圾数据，等新的值覆盖。<br>ret<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="非叶子函数"><a href="#非叶子函数" class="headerlink" title="非叶子函数"></a>非叶子函数</h4><blockquote>
<p>函数内还会调用其他函数，称为非叶子函数,会先将lr和fp寄存器缓存起来，等函数内其他函数调用完之后，再返回，回到本函数调用的地方</p>
</blockquote>
<ul>
<li>堆栈平衡示例代码<ul>
<li>原代码<code>test2()</code><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br>    test();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>转成汇编<figure class="highlight as"><table><tr><td class="code"><pre><code class="hljs as">sub sp, sp, #<span class="hljs-number">32</span> ; sp寄存器,留出<span class="hljs-number">32</span>字节的空间<br>stp x29, x30, [sp, #<span class="hljs-number">16</span>] ; 将fp寄存器(x29),lr链接寄存器(x30)中存的数据，存放到sp后<span class="hljs-number">16</span>个字节的位置，先进行缓存(因为后续bl调用函数，会用到lr)<br>add x29, sp, #<span class="hljs-number">16</span> ; 将sp+<span class="hljs-number">16</span>的地址赋值给fp<br><br>mov w8, #<span class="hljs-number">5</span> <br>orr w9, wzr, #<span class="hljs-number">0x4</span><br>stur w9, [x29,#<span class="hljs-number">-4</span>] ; a = <span class="hljs-number">4</span>,局部变量赋值,fp比较近，用的fp<br>str w8, [sp, #<span class="hljs-number">8</span>] ; b = <span class="hljs-number">5</span>,sp比较近，用的sp(编译器的优化)<br>bl _test ; 调用test函数，此时lr会存储当前pc的值，等待后需ret返回<br><br>ldp x29, x30, [sp, #<span class="hljs-number">16</span>] ; 将原来存在sp后<span class="hljs-number">16</span>字节的数据取回,fp、lr取出原来的,<br>add sp, sp, #<span class="hljs-number">32</span> ; 收回堆栈空间<br>ret ; 根据lr回到函数调用的地方<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a><span id="jump2">寻址方式</span></h2><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><blockquote>
<p>立即寻址也叫立即数寻址，这是一种特殊的寻址方式，操作数本身就在*指令中给出，只要取出指令也就取到了操作数。这个操作数被称为<strong>立即数</strong>，对应的寻址方式也就叫做<strong>立即寻址</strong>。例如以下</p>
</blockquote>
<ul>
<li>指令：<ul>
<li><code>ADD xO, xO，＃1</code> : <code>xO = xO+1</code></li>
<li><code>ADD xO, x0， #0x3f</code> :  <code>xO = xO+0x3f</code></li>
<li>在以上两条指令中，第二个源操作数即为立即数，要求以<code>＃</code>为前缀，对于以十六进制表示的立即数，还要求在<code>＃</code> 后加上<code>0x</code>或<code>＆</code>。</li>
</ul>
</li>
</ul>
<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><blockquote>
<p>奇存器寻址就是利用寄存器中的数值作为操作数，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式。</p>
</blockquote>
<ul>
<li>以下指令：<ul>
<li><code>ADD xO, x1, x2 </code> : <code>xO = x1+x2</code></li>
<li>该指令的执行效果是将寄存器<code>x1</code>和<code>x2</code>的内容相加，其结果存放在寄存器<code>xO</code>中。</li>
</ul>
</li>
</ul>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><blockquote>
<p>寄存器问接寻址就是以奇存器中的值作为操作数的地址，而操作数本身存放在存储器中.</p>
</blockquote>
<ul>
<li>以下指令：<ul>
<li><code>ADD x0, x1, [x2]</code> : <code>xO = x1+[x2]</code>,以寄存器<code>x2</code>的值作为操作数的地址，在存储器中取得一个操作数后与<code>x1</code>相加，结果存入寄存器<code>xO</code>中。</li>
<li><code>LDR xO, [x1]</code> : <code>xO = [x1]</code>,将以 <code>x1</code> 的值为地址的存储器中的数据传送到<code>xO </code>中</li>
<li><code>STR xO, [x1]</code> : <code>[x1] = xO</code>,将<code>xO</code> 的值传送到以 <code>x1</code> 的值为地址的存储器中。</li>
</ul>
</li>
</ul>
<h3 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h3><blockquote>
<p>基址变址寻址就是将寄存器(该寄存器一般称作基址寄存器）的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。变址寻址方式常用于访问某基地址附近的地址单元。采用变址寻址方式的指令常见有以下几种形式，</p>
</blockquote>
<ul>
<li>如下所示：<ul>
<li><code>LDR xO, [x1，#4]</code> : <code>xO = [x1+4J</code>,将寄存器 <code>x1</code> 的内容加上<code>4</code>形成操作数的<strong>有效地址</strong>，从而取得操作数存入寄存器RO中。</li>
<li><code>LDR xO, [x1, #4]!</code> :<code>xO = [x1+4]</code>、<code>x1 = x1+4</code>,将寄存器 <code>x1</code> 的内容加上 <code>4 </code>形成操作数的<strong>有效地址</strong>，从而取得操作数存入寄存器<code>xO</code> 中，然后，<code>x1</code> 的内容自增<code>4</code>个字节。</li>
<li><code>LDR xO, [x1]，＃4</code> : <code>xO = [x1]、x1 = x1+4</code>,以寄存器<code>x1</code>的内容作为操作数的<strong>有效地址</strong>，从而取得操作数存入寄存器 <code>xO</code>中，然后，<code>x1</code>的内容自增<code>4</code>个字节。</li>
<li><code>LDR xO, [x1, x2]</code> : <code>xO = [x1+x2]</code>,将寄存器 <code>x1</code> 的内容加上寄存器<code>x2</code>的内容形成操作数的<strong>有效地址</strong>，从而取得操作数存入寄存器<code>xO</code>中。</li>
</ul>
</li>
</ul>
<h3 id="多寄存器寻址"><a href="#多寄存器寻址" class="headerlink" title="多寄存器寻址"></a>多寄存器寻址</h3><blockquote>
<p>采用多寄存器寻址方式，一条指令可以完成多个寄存器值的传送。这种寻址方式可以用一条指令完成传送最多16个通用寄存器的值。</p>
</blockquote>
<ul>
<li>以下指令：<ul>
<li><code>LDMIA xO, &#123;x1, x2, x3， x4&#125;</code>: <code>x1 = [x0]</code>、<code>x2 = [x0 + 4]</code>、<code>x3 = [x0 + 8]</code>、<code>x4 = [x0 + 12]</code></li>
<li>该指令的后缀<code>IA</code> 表示在每次执行完加载/存储操作后，<code>xO</code> 按字长度增加，因此，指令可将连续存储单元的值传送到<code>x1</code>~`x4`。</li>
</ul>
</li>
</ul>
<h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><blockquote>
<p>与基址变址寻址方式相类似，相对寻址以程序计数器 PC 的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。</p>
</blockquote>
<ul>
<li>以下程序段完成子程序的调用和返回，跳转指令 <code>BL</code>采用了相对寻址方式：  <figure class="highlight as"><table><tr><td class="code"><pre><code class="hljs as">    BL, NEXT ; 跳转到子程序 `NEXT` 处执行<br>    ......<br>NEXT<br>    ......<br>    MOV PC. LR ; 从子程序返回<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><blockquote>
<ul>
<li>堆栈是一种数据结构，按先进后出 (<code>First In Last Out, FILO</code>）的方式工作，使用一个称作堆栈指针的专用寄存器指示当前的操作位置，堆栈指针总是指向栈顶。</li>
<li>当堆栈指针指向最后压入堆栈的数据时，称为满堆栈 (<code>Full Stack</code>），而当堆栈指针指向下一个将要放入数据的空位置时，称为空堆栈 <code>(Empty Stack</code>)。</li>
<li>同时，根据堆栈的生成方式，又可以分为递增堆栈 (<code>Ascending Stack</code>）和递减堆栈 (<code>DecendingStack</code>），当堆栈由低地址向高地址生成时，称为递增堆栈，当堆栈由高地址向低地址生成时，称为递减堆栈。</li>
</ul>
</blockquote>
<ul>
<li>这样就有四种类型的堆栈工作方式，<code>ARM</code> 微处理器支持这四种类型的堆栈工作方式，即：<ul>
<li>满递增堆栈：堆栈指针指向最后压入的数据，且由低地址向高地址生成。</li>
<li>满递减堆栈：堆栈指针指向最后压入的数据，且由高地址向低地址生成。</li>
<li>空递增堆栈：堆栈指针指向下一个将要放入数据的空位置，且由低地址向高地址生成。</li>
<li>空递减堆栈：堆栈指针指向下一个将要放入数据的空位置，且由高地址向低地址生成。</li>
</ul>
</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="指令的条件域"><a href="#指令的条件域" class="headerlink" title="指令的条件域"></a><span id="jump1">指令的条件域</span></h3><ul>
<li>当处理器工作在<code>ARM</code>状态时，几乎所有的指令均根据<code>CPSR</code>中条件码的状态和指令的条件域有<br>条件的执行。当指令的执行条件满足时，指令被执行，否则指令被忽略。</li>
<li>每一条<code>ARM</code>指令包含<code>4</code>位的条件码(条件码是指令的，而非<code>cpsr</code>寄存器的)，位于指令的最高<code>4</code>位<code>[31:28]</code>。条件码共有<code>16</code>种，每种条件码可用两个字符表示，这两个字符可以添加在<code>指令助记符</code>的后面和指令同时使用。例如，跳转指令<code>B</code>可以加上后缀<code>EQ</code>变为<code>BEQ</code>表示<strong>相等则跳转</strong>，即当<code>CPSR</code>中的<code>Z</code>标志置位时发生跳转。</li>
<li>在<code>16</code>种条件标志码中，只有<code>15</code>种可以使用，如下表所示，第<code>16</code>种（<code>1111</code>）为系统保留，</li>
</ul>
<table>
<thead>
<tr>
<th align="center">条件码</th>
<th align="center">助记符后缀</th>
<th align="center">标 志</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">EQ</td>
<td align="center">Z置位</td>
<td align="center">相等</td>
</tr>
<tr>
<td align="center">0001</td>
<td align="center">NE</td>
<td align="center">Z清零</td>
<td align="center">不相等</td>
</tr>
<tr>
<td align="center">0011</td>
<td align="center">CS</td>
<td align="center">C置位</td>
<td align="center">无符号数大于或等于</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">MI</td>
<td align="center">N置位</td>
<td align="center">负数</td>
</tr>
<tr>
<td align="center">0101</td>
<td align="center">PL</td>
<td align="center">N清零</td>
<td align="center">正数或零</td>
</tr>
<tr>
<td align="center">0110</td>
<td align="center">VS</td>
<td align="center">V置位</td>
<td align="center">溢出</td>
</tr>
<tr>
<td align="center">0111</td>
<td align="center">VC</td>
<td align="center">V清零</td>
<td align="center">未溢出</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">HI</td>
<td align="center">C置位Z清零</td>
<td align="center">无符号数大于</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">LS</td>
<td align="center">C清零Z置位</td>
<td align="center">无符号数小于或等于</td>
</tr>
<tr>
<td align="center">1010</td>
<td align="center">GE</td>
<td align="center">N等于V</td>
<td align="center">带符号数大于或等于</td>
</tr>
<tr>
<td align="center">1011</td>
<td align="center">LT</td>
<td align="center">N 不等于V</td>
<td align="center">带符号数小于</td>
</tr>
<tr>
<td align="center">1100</td>
<td align="center">GT</td>
<td align="center">Z清零且(N等于V)</td>
<td align="center">带符号数大于</td>
</tr>
<tr>
<td align="center">1101</td>
<td align="center">LE</td>
<td align="center">Z置位或(N不等于V)</td>
<td align="center">带符号数小于或等于</td>
</tr>
<tr>
<td align="center">1110</td>
<td align="center">AL</td>
<td align="center">忽略</td>
<td align="center">无条件执行</td>
</tr>
</tbody></table>
<h3 id="move指令"><a href="#move指令" class="headerlink" title="move指令"></a>move指令</h3><ul>
<li><code>MOV</code>指令的格式为：<ul>
<li><code>MOV&#123;条件&#125;&#123;S&#125;目的寄存器，源操作数</code></li>
<li><code>MOV</code> 指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。其中<code>S</code>选项决定指令的操作是否影响 <code>CPSR</code> 中条件标志位的值，当没有<code>S</code>时指令不更新<code>CPSR </code>中条件标志位的值。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>mov x1,x0</code> :将寄存器<code> x0</code> 的值传送到寄存器 <code>x1</code>。</li>
<li><code>mov x1,x0,LSL#0x3</code> : 将寄存器<code>x0</code>的值左移<code>3</code>位后传送到<code>x1</code>。</li>
</ul>
</li>
</ul>
<h3 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h3><ul>
<li><code>ADD</code> 指令的格式为：<ul>
<li><code>ADD&#123;条件&#125;&#123;S&#125; 目的备存器，操作数1，操作数2</code></li>
<li><code>ADD</code> 指令用于把两个操作数相加，并将结果存放到目的寄存器中。<code>操作数1</code>应是一个寄存器，<code>操作数2</code>可以是一个寄存器，被<code>移位的寄存器</code>，或<code>一个立即数</code>。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>ADD xO, x1, x2</code> : <code>xO = x1+x2</code></li>
<li><code>ADD xO, x1, #256</code> : <code>xO = x1+256</code></li>
<li><code>ADD xO, x2, x3, LSL#1</code> : <code>xO = x2 + (x3 &lt;&lt; 1)</code></li>
</ul>
</li>
</ul>
<h3 id="sub-指令"><a href="#sub-指令" class="headerlink" title="sub 指令"></a>sub 指令</h3><ul>
<li><code>SUB</code> 指令的格式为：<ul>
<li><code>SUB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</code></li>
<li><code>SUB</code> 指令用于把<code>操作数1</code>减去<code>操作数2</code>，并将结果存放到<code>目的寄存器</code>中。<code>操作数1</code>应是一个<code>寄存存器</code>，<code>操作数2</code>可以是一个<code>寄存器</code>，<code>被移位的寄存器</code>，或一个<code>立即数</code>。该指令可用于<code>有符号数</code>或<code>无符号数</code>的减法运算。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>sub xO, x1,x2</code> :<code>xO =x1- x2</code>。</li>
<li><code>sub xO, x1,#0x8</code> :<code>xO =x1- 8</code>。</li>
<li><code>sub xO, x2，x3，LSL#1</code> : <code>xO =x2- (x3 &lt;&lt; 1)</code>。</li>
</ul>
</li>
</ul>
<h3 id="CMP-指令"><a href="#CMP-指令" class="headerlink" title="CMP 指令"></a>CMP 指令</h3><ul>
<li><code>CMP 指令的格式为</code><ul>
<li><code>CMP&#123;条件&#125;操作数1，操作数 2</code></li>
<li><code>CMP</code>指令用于把一个<code>寄存器</code>的内容和另一个<code>奇存器</code>的内容或<code>立即数</code>进行比较，同时更新 <a href="#jump">CPSR</a>中条件标志位的值。</li>
<li>该指令进行一次<strong>减法运算</strong>，但不存储结果，只更改条件标志位。标志位表示的是<code>操作数1</code>与<code>操作数2</code>的关系（大、小、相等），例如，当<code>操作数1</code>大于<code>操作数2</code>，则此后的有GT后缀的指令将可以执行。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>cmp x1, xO</code> : 将寄存器 <code>x1</code> 的值与寄存器<code>xO</code> 的值相减，并根据结果设置 <a href="#jump">CPSR</a>的标志位</li>
<li><code>cmp x1, #100</code> :将寄存器 <code>x1</code> 的值与立即数 100相减，并根据结果设置 <a href="#jump">CPSR</a> 的标志位</li>
</ul>
</li>
</ul>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h4 id="B指令"><a href="#B指令" class="headerlink" title="B指令"></a>B指令</h4><ul>
<li><code>B</code>指令的格式为：<ul>
<li><code>B&#123;条件&#125;  目标地址</code></li>
<li><code>B</code>指令是最简单的跳转指令。一旦遇到一个<code>B</code>指令，<code>ARM</code> 处理器将立即跳转到给定的目标地址，从那里继续执行。</li>
<li><strong>注意</strong>,存储在跳转指令中的实际值是相对当前<code>PC</code>值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是<code>24</code>位有符号数，左移两位后有符号扩展为 <code>32</code> 位，表示的有效偏移为 <code>26</code>位(前后 <code>32MB</code> 的地址空间）。以下指令：</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>B Label</code> : 程序无条件跳转到标号 <code>Label</code> 处执行  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">CMP x1，#0<br>b.eq Label<br></code></pre></td></tr></table></figure></li>
<li>上面指令是当 <code>CPSR</code> 寄存器中的<code>z</code>条件码置位时，程序跳转到标号 <code>Label</code> 处执行,见<a href="#jump1">条件</a></li>
</ul>
</li>
</ul>
<h4 id="BL指令"><a href="#BL指令" class="headerlink" title="BL指令"></a>BL指令</h4><ul>
<li><code>BL</code>指令的格式为：<ul>
<li><code>BL&#123;条件&#125;目标地址</code></li>
<li><code>BL</code> 是另一个跳转指令，但跳转之前，会在寄存器<code>lr</code>中保存 <code>PC</code> 的当前内容，因此，可以通过将<code>lr</code> 的内容重新加载到 <code>PC</code> 中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本但常用的手段。</li>
<li><strong>注意</strong>，只有使用<code>BL</code>调用有<code>ret</code>返回的才会回到原来的位置，类似函数调用。<code>B</code>指令是没有这个效果的。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>BL Labe1</code> : 当程序无条件跳转到标号 <code>Label</code> 处执行时，同时将当前的 <code>PC</code>值保存到 <code>lr</code>中</li>
</ul>
</li>
</ul>
<h4 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h4><blockquote>
<p>函数返回，结合<code>BL</code>指令使用</p>
</blockquote>
<ul>
<li>其本质是将<code>lr(x30)</code>寄存器的值赋值给<code>pc</code>,就是原来<code>BL</code>指令调用的下一条指令，调用前会存到<code>lr(x30)</code>中。<code>ret</code>的时候会讲<code>lr(x30)</code>赋值给<code>pc</code>,这样回到了原来<code>BL</code>的调用的指令处</li>
</ul>
<h4 id="内存读操作指令"><a href="#内存读操作指令" class="headerlink" title="内存读操作指令"></a>内存读操作指令</h4><blockquote>
<p>从内存中读取数据</p>
</blockquote>
<h5 id="ldr指令"><a href="#ldr指令" class="headerlink" title="ldr指令"></a>ldr指令</h5><ul>
<li><code>LDR</code> 指令的格式为：<ul>
<li><code>LDR&#123;条件&#125; 日的寄存器，&lt;存储器地址〉</code></li>
<li><code>LDR</code> 指令用于从存储器中将一个<code>32</code>位的字数据传送到目的的寄存器中。该指令通常用于从存储器中读取 <code>32</code> 位的字数据到通用寄存器，然后对数据进行处理。当程序计数器<code>PC</code> 作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。该指令在程序设计中比较常用，且<a href="#jump2">寻址方式</a>灵活多样</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>ldr xO, [x1]</code> : 将存储器地址为 <code>x1</code> 的8字节数据读入寄存器<code>xO</code>。</li>
<li><code>ldr wO, [w1]</code> : 将存储器地址为 <code>w1</code> 的4字节数据读入寄存器<code>wO</code>。//根据寄存器是8字节取值还是4字节</li>
<li><code>ldr xO, [x1, x2]</code> : 将存储器地址为 <code>x1+x2</code> 的字数据读入寄存器<code>xO</code>。</li>
<li><code>ldr xO, [x1, #8]</code> : 将存储器地址为 <code>x1+8</code> 的字数据读入寄存器<code>xO</code>。</li>
<li><code>LDR xO,[x1, x2]!</code> : 将存储器地址为 <code>x1+x2</code> 的字数据读入寄存器<code>xO</code>，并将新地址 <code>x1 + x2</code>写入<code>x1</code></li>
<li><code>LDR xO, [x1. #8]!</code> : 将存储器地址为 <code>x1+8</code> 的字数据读入寄存器<code>xO</code>，并将新地址 <code>x1 + 8</code>写入<code>x1</code></li>
<li><code>LDR xO. [x1],x2</code> : 将存储器地址为 <code>x1</code> 的字数据读入寄存器<code>xO</code>，并将新地址<code>x1+x2</code>写入<code>x1</code></li>
<li><code>LDR xO, [x1，x2，LSL#2]!</code> : 将存储器地址为<code>x1+x2x4</code>字数据读入寄存器<code>xO</code>，并将新地址<code>x1+x2×4</code>写入<code>x1</code>,<code>LSL#2</code>即 <code>&lt;&lt; 2</code>。</li>
<li><code>LDR xO, [x1]，x2，LSL＃2</code> : 将存储器地址为 <code>x1</code> 的字数据读入寄存器<code>xO</code>，并将新地址 <code>x1+x2x4</code>写入<code>x1</code></li>
</ul>
</li>
<li><code>ldur</code>指令，也是内存中读取数据，一般是<code>ldr xO, [x1, #-8]</code>,立即数为负数，具体用法和ldr一样</li>
</ul>
<h5 id="ldp指令"><a href="#ldp指令" class="headerlink" title="ldp指令"></a>ldp指令</h5><blockquote>
<p>将内存中的一对数据赋值给一对寄存器</p>
</blockquote>
<ul>
<li><code>ldp w0,w1,[x2,#10]</code>,将<code>x2,#10</code>上存储的前<code>4</code>个字节数据给<code>w0</code>,后<code>4</code>个字节赋值给<code>w1</code></li>
</ul>
<h4 id="内存写入操作"><a href="#内存写入操作" class="headerlink" title="内存写入操作"></a>内存写入操作</h4><h5 id="STR-指令"><a href="#STR-指令" class="headerlink" title="STR 指令"></a>STR 指令</h5><ul>
<li><code>STR</code> 指令的格式为：<ul>
<li><code>STR&#123;条件&#125;源寄存器，&lt;存储器地址〉</code></li>
<li><code>STR</code> 指令用于从源寄存器中将字节数据传送到存储器中。该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令 <code>LDR</code>。</li>
</ul>
</li>
<li>指令示例：<ul>
<li><code>STR wO, [x1]</code>: 将<code>w0</code>的<code>4</code>个字节数据，写入<code>x1</code>的前<code>4</code>个字节</li>
<li><code>STR wO, [x1]，＃8</code> : 将<code>wO</code> 中的字数据写入以<code>x1</code>为地址的前<code>4</code>个字节存储器中，并将新地址 <code>x1+8</code>写入<code>x1</code>。</li>
<li><code>STR wO, [x1, #8]</code> : 将<code>wO</code> 中的字数据写入以 <code>x1十8</code>为地址的前<code>4</code>个字节存储器中。</li>
</ul>
</li>
<li><code>stur</code>指令和<code>ldur</code>指令一样，<code>stp</code>指令和<code>ldp</code>指令一样</li>
<li><strong>注意</strong>不能用<code>STR #8, [x1]</code>,第一个必须是寄存器,因为寄存器才知道会覆盖多少字节</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>lldb指令</title>
    <url>/2023/04/10/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E5%B8%B8%E7%94%A8lldb%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lldb指令"><a href="#lldb指令" class="headerlink" title="lldb指令"></a>lldb指令</h1><ul>
<li>指令的格式是,<code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...])</code><ul>
<li><code>&lt;command&gt;</code>: 命令</li>
<li><code>&lt;subcommand&gt;</code>: 子命令</li>
<li><code>&lt;action&gt;</code>: 命令操作</li>
<li><code>&lt;options&gt;</code>: 命令选项</li>
<li><code>&lt;argument&gt;</code>: 命令参数</li>
<li>例如给<code>test</code>函数设置断点,<code>breakpoint set -n test</code><ul>
<li><code>breakpoint</code>是<code>&lt;command&gt;</code></li>
<li><code>set</code>是<code>&lt;action&gt;</code></li>
<li><code>-n</code>是<code>&lt;options&gt;</code>,这里是函数名称<code>name</code></li>
<li><code>test</code>是<code>&lt;argument&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="lldb常用指令"><a href="#lldb常用指令" class="headerlink" title="lldb常用指令"></a>lldb常用指令</h2><h3 id="查看指令的用法"><a href="#查看指令的用法" class="headerlink" title="查看指令的用法"></a>查看指令的用法</h3><ul>
<li><code>help &lt;command&gt;</code>,例如:<code>help breakpoint</code>、<code>help breakpoint set</code></li>
</ul>
<h3 id="读取寄存器的值"><a href="#读取寄存器的值" class="headerlink" title="读取寄存器的值"></a>读取寄存器的值</h3><ul>
<li>register read rbp ,读取rbp中的值（lldb可以不用加%）</li>
<li>register read/o rbp,读取值，以8进制显示，默认16进制</li>
<li>register read,获取当前所有的寄存器的值</li>
</ul>
<h3 id="修改寄存器的值"><a href="#修改寄存器的值" class="headerlink" title="修改寄存器的值"></a>修改寄存器的值</h3><ul>
<li>register write 寄存器名称 数值</li>
<li>register write rax O</li>
</ul>
<h3 id="读取内存中的值"><a href="#读取内存中的值" class="headerlink" title="读取内存中的值"></a>读取内存中的值</h3><ul>
<li>x/数量-格式-字节大小 内存地址</li>
<li>x/3xw 0x000010,显示内存中的数据，3组数据，每组4个字节以16进制显示</li>
<li>格式<ul>
<li>x是16进制，</li>
<li>f是浮点，</li>
<li>d是十进制</li>
</ul>
</li>
<li>字节大小<ul>
<li>b-byte 1字节</li>
<li>h-half word 2字节</li>
<li>W-word 4字节</li>
<li>g- giant word 8字节<h3 id="修改内存中的值"><a href="#修改内存中的值" class="headerlink" title="修改内存中的值"></a>修改内存中的值</h3></li>
</ul>
</li>
<li>memory write 内存地址 数值</li>
<li>memory write 0x0000010 10</li>
</ul>
<h3 id="expression-cmd-options-–-expr"><a href="#expression-cmd-options-–-expr" class="headerlink" title="expression [cmd-options] – [expr]"></a>expression [cmd-options] – [expr]</h3><blockquote>
<p>执行一个表达式,调试过程中动态执行代码</p>
</blockquote>
<ul>
<li><code>expression</code>,可以简写：<code>expr</code><ul>
<li><code>cmd-options</code>: 命令选项</li>
<li><code>--</code>: 命令选项结束符，表示所有的命令已经设置完毕，如果没有命令选项，<code>--</code>可以省略</li>
<li><code>expr</code>: 需要执行的表达是 </li>
<li>例如，<code>expression self.view.backgroudColor = [UIColor redColor]</code></li>
</ul>
</li>
<li><code>expression</code>、<code>expression --</code>和指令<code>print</code>、<code>p</code>、<code>call</code>的效果一样，都可以打印对象的内存</li>
<li><code>expression -O --</code>和指令<code>po</code>的效果一样</li>
</ul>
<h3 id="po-表达式"><a href="#po-表达式" class="headerlink" title="po 表达式"></a>po 表达式</h3><ul>
<li>po 表达式<ul>
<li>print 表达式</li>
<li>po/x $rax</li>
<li>po (int)$rax</li>
</ul>
</li>
</ul>
<h3 id="thread-backtrace"><a href="#thread-backtrace" class="headerlink" title="thread backtrace"></a>thread backtrace</h3><ul>
<li>打印线程的堆栈信息</li>
<li>和指令<code>bt</code>的效果一样</li>
</ul>
<h3 id="thread-return-expr"><a href="#thread-return-expr" class="headerlink" title="thread return [expr]"></a>thread return [expr]</h3><ul>
<li>让函数直接返回某个值，不会执行断点后面的方法</li>
</ul>
<h3 id="frame-variable-variable-name"><a href="#frame-variable-variable-name" class="headerlink" title="frame variable[variable-name]"></a>frame variable[variable-name]</h3><ul>
<li>打印当前栈帧的所有变量,<code>frame variable -L p1</code>,打印p1结构体的存储情况</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul>
<li>thread continue、continue、c: 程序继续运行</li>
<li>thread step-over、 next、n（全称和简写）<ul>
<li>单步运行，把子函数当做整体一步执行（源码级别）</li>
</ul>
</li>
<li>thread step-in、 step、s<ul>
<li>单步运行，遇到子函数会进入子函数（源码级别），与si不同，可能会跳过好几句汇编代码</li>
</ul>
</li>
<li>thread step-inst-over、 nexti.ni<ul>
<li>单步运行，把子函数当做整体一步执行（汇编级别）</li>
</ul>
</li>
<li>thread step-inst, stepi. si<ul>
<li>单步运行，遇到子函数会进入子函数（汇编级别）</li>
</ul>
</li>
<li>thread step-out, finish<ul>
<li>直接执行完当前函数的所有代码，返回到上一个函数（遇到断点会卡住）</li>
</ul>
</li>
</ul>
<h3 id="breakpoint-set"><a href="#breakpoint-set" class="headerlink" title="breakpoint set"></a>breakpoint set</h3><blockquote>
<p>设置断点</p>
</blockquote>
<ul>
<li><code>breakpoint set -a 函数地址</code></li>
<li><code>breakpoint set -n 函数名</code><ul>
<li><code>breakpoint set -n test</code></li>
<li><code>breakpoint set -n touchBegan:withEvent:</code></li>
<li><code>breakpoint set -n &quot;-[ViewController touchBegan:withEvent:]&quot;</code></li>
</ul>
</li>
<li><code>breakpoint set -r 正则表达式</code><ul>
<li><code>breakpoint set -r est</code>,对所有函数名包含<code>est</code>的函数打断点</li>
</ul>
</li>
<li><code>breakpoint set -s 动态库 -n 函数名</code></li>
<li><code>breakpoint list</code>,列出所有的断点（每个断点都有自己的编号）<ul>
<li><code>breakpoint disable 断点编号</code>: 禁用断点</li>
<li><code>breakpoint enable 断点编号</code>: 启用断点</li>
<li><code>breakpoint delete 断点编号</code>: 删除断点</li>
</ul>
</li>
</ul>
<h3 id="breakpoint-command"><a href="#breakpoint-command" class="headerlink" title="breakpoint command"></a>breakpoint command</h3><blockquote>
<p>在断点的时候，执行某些命令</p>
</blockquote>
<ul>
<li><code>breakpoint command add 断点编号</code>，执行后需要添加后续要执行的指令<ul>
<li>给断点预先设置需要执行的命令，到触发断点时，就会按顺序执行命令</li>
</ul>
</li>
<li><code>breakpoint command list 断点编号</code><ul>
<li>查看某个断点设置的命令</li>
</ul>
</li>
<li><code>breakpoint command delete 断点编号</code><ul>
<li>删除某个断点设置的命令</li>
</ul>
</li>
</ul>
<h3 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h3><blockquote>
<p>在内存数据发生改变的时候触发</p>
</blockquote>
<ul>
<li><code>watchpoint set variable 变量</code><ul>
<li><code>watchpoint set variable self-&gt;age</code></li>
</ul>
</li>
<li><code>watchpoint set expression 地址</code><ul>
<li><code>watchpoint set expression &amp;(self-&gt;_age)</code></li>
</ul>
</li>
<li><code>watchpoint list</code></li>
<li><code>watchpoint disable 断点编号</code> </li>
<li><code>watchpoint enable 断点编号</code></li>
<li><code>watchpoint delete 断点编号</code></li>
<li> <code>watchpoint command add 断点编号</code></li>
<li> <code>watchpoint command list 断点编号</code> </li>
<li> <code>watchpoint command delete 断点编号</code> </li>
</ul>
<h3 id="模块查找"><a href="#模块查找" class="headerlink" title="模块查找"></a>模块查找</h3><ul>
<li><code>image lookup</code><ul>
<li><code>image lookup -t 类型</code>: 查找某个类型的信息</li>
<li><code>image lookup -a 地址</code>: 根据内存地址查找在模块中的位置,查看在对应源码的哪一行</li>
<li> <code>image lookup -n 符号或者函数名</code>: 查找某个符号或函数的位置</li>
</ul>
</li>
<li><code>image list</code><ul>
<li> 列出所加载的模块信息</li>
<li> <code>image list -o -f</code>,打印出模块的偏移地址、全路径</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>应用技巧</category>
      </categories>
      <tags>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>swift派发机制</title>
    <url>/2023/04/03/iOS%E5%AD%A6%E4%B9%A0/Swift%E8%BF%9B%E9%98%B6/swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="swift派发机制"><a href="#swift派发机制" class="headerlink" title="swift派发机制"></a><code>swift</code>派发机制</h1><blockquote>
<p><code>swift</code>派发机制分：静态派发和动态派发</p>
</blockquote>
<ul>
<li><code>内联</code>（<code>inline</code>）,属于<code>静态派发</code>的一种，最快的派发方式，在函数调用的地方，编译器直接展开函数的代码。</li>
<li><code>静态派发</code>：（又叫：<code>直接调用</code>）<ul>
<li><code>静态派发</code>机制，同时支持<code>值类型</code>和<code>引用类型</code>；<code>静态派发</code>是最快的, 不止是因为需要调用的<code>指令集</code>会更少, 并且编译器还能够有很大的优化空间,<code>静态派发</code>也有人称为<code>直接调用</code>.</li>
<li><code>结构体</code>中以及<code>extension</code>的方法，默认都是<code>直接派发</code></li>
<li>然后，<code>直接调用</code>也是最大的局限, 而且因为缺乏<code>动态性</code>所以没办法支持<strong>继承</strong></li>
</ul>
</li>
<li><code>消息派发</code>：<ul>
<li><code>消息派发</code>是<code>动态派发</code>机制的一种，仅支持<code>引用类型</code>(<code>reference types</code>) 比如：<code>Class</code>，对于<code>动态性</code>或者<code>动态派发</code>，我们需要使用到<code>继承特性</code>，而这是<code>值类型</code>不支持的。</li>
<li><code>消息派发</code>是调用函数最动态的方式. 也是<code>Cocoa</code>的基石, 这样的机制催生了 <code>KVO</code>,<code>消息转发</code> 等功能. </li>
<li>这种运作方式的关键在于开发者可以在运行时改变函数的行为. 不止可以通过<code>swizzling</code>来改变, 甚至可以用<code>isa-swizzling</code>修改对象的继承关系, 可以在面向对象的基础上实现自定义派发.</li>
</ul>
</li>
<li><code>函数表派发</code>：<ul>
<li><code>函数表派发</code>是<code>编译型</code>语言实现<code>动态行为</code>最常见的实现方式. 函数表使用了一个<code>数组</code>来存储类声明的每一个函数的<code>指针</code>. 大部分语言把这个称为 <code>virtual table</code>(<code>虚函数表</code>), <code>Swift</code> 里称为 <code>witness table</code>. 每一个<code>类</code>都会维护一个<code>函数表</code>, 里面记录着<code>类所有的函数</code>, 如果<code>父类函数</code>被 <code>override</code> 的话, 表里面只会保存被 <code>override</code> 之后的函数. 一个子类新添加的函数, 都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数.</li>
<li>查表是一种简单, 易实现, 而且性能可预知的方式. 然而, 这种派发方式比起<code>静态派发</code>还是慢一点. 从字节码角度来看, 多了<code>两次读</code>(读<code>函数表地址</code>，以及<code>函数地址</code>)和<code>一次跳转</code>, 由此带来了性能的损耗. 另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化. (如果函数带有副作用的话)</li>
<li>这种基于数组的实现, 缺陷在于<code>函数表无法拓展</code>。子类会在虚数函数表的最后插入新的函数, 没有位置可以让 <code>extension</code> 安全地<code>插入函数</code>，因此<code>extension</code>中的方法是不会加到<code>函数表内</code>的，属于静态派发</li>
</ul>
</li>
</ul>
<p>这四种派发技术，由编译器来决定使用哪种。</p>
<h1 id="静态派发VS动态派发（Swift-VS-OC）"><a href="#静态派发VS动态派发（Swift-VS-OC）" class="headerlink" title="静态派发VS动态派发（Swift VS OC）"></a>静态派发VS动态派发（<code>Swift</code> VS <code>OC</code>）</h1><ul>
<li><p><code>OC</code>默认支持动态派发，这种派发形式以<code>多态</code>的形式为开发人员提供了灵活性。</p>
<ul>
<li>比如：子类可以重写父类的方法</li>
</ul>
</li>
<li><p><code>动态派发</code>以一定的<code>运行时开销</code>为代价，提供了语言的<code>灵活性</code>。</p>
</li>
<li><p>在<code>动态派发机制</code>下，对于每个方法的调用，编译器必须在<code>方法列表</code>中查找执行方法的实现。</p>
</li>
<li><p><code>编译器</code>需要判断<code>调用方</code>，是选择<code>父类的实现</code>还是<code>子类的实现</code>，而且由于所有对象的内存都是在<code>运行时分配的</code>，因此编译器只能在<code>运行时执行检查</code>。</p>
</li>
<li><p>而<code>静态调用</code>则没有这个问题。在编译期的时候，编译器就知道要为<code>某个方法</code>调用某种实现。因此编译器可以<code>执行某些优化</code>，甚至在可能的情况下，可以将某些代码转换成<code>inline</code>函数，从而使整体执行速度更快</p>
</li>
</ul>
<h2 id="swift中实现动态派发和静态派发"><a href="#swift中实现动态派发和静态派发" class="headerlink" title="swift中实现动态派发和静态派发"></a>swift中实现动态派发和静态派发</h2><h3 id="动态派发"><a href="#动态派发" class="headerlink" title="动态派发"></a>动态派发</h3><ul>
<li><code>函数表派发</code><ul>
<li><code>类</code>中定义的方法默认是<code>函数表派发</code></li>
<li><code>协议</code>中定义的方法，在调用协议时，会去<code>协议的函数表</code>中查询（这种查询过程，也是<code>函数派发</code>)，注意编器可以优化，可能会去除去<code>协议函数表查询</code>的过程。</li>
</ul>
</li>
<li><code>消息派发</code><ul>
<li>方法前加上<code>@objc</code>，<code>OC</code>中的代码调用<code>swift</code>方法，属于消息派发，但是如果是<ul>
<li><code>class</code>内部定义的方法，<code>swift</code>调用还是<strong>函数调用</strong></li>
<li><code>extension</code>内部定义的方法，则是<strong>消息派发</strong></li>
<li>此外，<strong>注意</strong>，一般而言<code>extension</code>中定义的方法，子类是无法重写的，但是由于加了<code>@objc</code>为消息转发机制，和<code>OC</code>类中方法一样，可以在子类中<code>重写</code>(无论是在<code>类中</code>还是<code>extension</code>均可重写)，并且<code>重写</code>后的方法，同样是<code>消息派发机制</code></li>
</ul>
</li>
<li>方法前加上<code>@objc dynamic</code>，<code>swift</code>和<code>OC</code>中调用，均为<code>消息派发</code></li>
</ul>
</li>
</ul>
<h3 id="静态派发"><a href="#静态派发" class="headerlink" title="静态派发"></a>静态派发</h3><ul>
<li><code>内联</code><ul>
<li>编译器会自动将<code>静态派发</code>的某些函数变成<code>内联函数</code><ul>
<li><code>@inline</code>,内联注解， <code>Apple</code> 的文档中是找不到，不建议使用<ul>
<li><code>@inline(__always) func test(i:Int) &#123;  &#125;</code>,开启编译优化后，即使代码很长也会被内联（递归调用,动态派发除外）</li>
<li><code>@inline(never) func test(i:Int) &#123;  &#125;</code>,永远不会被内联，即使开启了编译器优化（有时不起作用,还是会转为内联）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>直接调用</code><ul>
<li>值类型、引用类型以及协议的<code>extension</code>中定义的方法，一般默认是<code>静态派发</code></li>
<li>值类型中定义的方法</li>
<li>引用类型中用<code>final</code>修饰的方法</li>
<li>所有用<code>static</code>修饰的方法</li>
</ul>
</li>
</ul>
<h2 id="派发机制和重写的关系"><a href="#派发机制和重写的关系" class="headerlink" title="派发机制和重写的关系"></a>派发机制和重写的关系</h2><ul>
<li><code>直接派发</code>由于是直接跳到<code>函数地址</code>去执行，因此<code>直接派发</code>的方法是无法进行重写的<ul>
<li>类中<code>extension</code>中的方法，默认是<code>直接派发</code>，因此无法重写</li>
<li><code>extension</code>中的方法，用<code>@objc</code>修饰会变成<code>消息派发</code>，子类可以<code>重写</code></li>
</ul>
</li>
<li>函数派发和消息派发都可以由子类进行重写<ul>
<li>函数派发的重写，只能在子类的<code>非extension</code>中，也就是声明处</li>
<li>消息派发的重写，是可以在子类的<code>extension</code>中进行重写的，类似<code>OC</code>中的分类</li>
</ul>
</li>
</ul>
<h2 id="一些特殊情况"><a href="#一些特殊情况" class="headerlink" title="一些特殊情况"></a>一些特殊情况</h2><ol>
<li><code>LoudPerson</code>实现的函数前面没有 <code>override</code> 修饰, 这是一个提示, 也许代码不会像我们设想的那样运行<ul>
<li><code>LoudPerson</code> 没有在 <code>Greetable</code> 的协议记录表(<code>Protocol Witness Table</code>)里<code>成功注册</code>, 当 <code>sayHi()</code> 通过<code>Greetable</code> 协议派发时, 默认的实现就会被调用</li>
<li>解决的方法就是, 在<code>Person</code>类声明的作用域里<code>就要</code>提供所有协议里定义的函数, 即使已经有默认实现. 或者, 你可以在类的前面加上一个 <code>final</code> 修饰符, 保证这个类不会被继承.<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Greetable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHi</span>()</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Greetable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHi</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Greetable Hello&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greetings</span>(<span class="hljs-params">greeter</span>: <span class="hljs-type">Greetable</span>)</span> &#123;<br>    greeter.sayHi()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>: <span class="hljs-title">Greetable</span> </span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoudPerson</span>: <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHi</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LoudPerson HELLO&quot;</span>)<br>    &#125;<br>&#125;<br><br>greetings(greeter: <span class="hljs-type">LoudPerson</span>())<span class="hljs-comment">//输出Greetable Hello</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>swift进阶</category>
      </categories>
  </entry>
  <entry>
    <title>代码混淆</title>
    <url>/2023/04/02/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<ul>
<li>什么是加固<ul>
<li>加固是为了增加应用的安全性，防止应用被破解、盗版、二次打包、注入、反编译等</li>
</ul>
</li>
<li>常见的加固方式有<ul>
<li>数据加密（字符串、网络数据、敏感数据等）</li>
<li>应用加壳（二进制加密）</li>
<li>代码混淆（类名、方法名、代码逻辑等）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><ul>
<li><p>iOS程序可以通过class-dump、Hopper、IDA等获取类名、方法名、以及分析程序的执行逻辑</p>
<ul>
<li>如果进行代码混淆，可以加大别人的分析难度</li>
</ul>
</li>
<li><p>iOS的代码混淆方案</p>
<ul>
<li><p>源码的混淆</p>
<ul>
<li>类名</li>
<li>方法名</li>
<li>协议名</li>
</ul>
</li>
<li><p>LLVM中间代码<code>IR</code>的混淆（容易产生BUG）</p>
<ul>
<li>自己编写<code>Pass</code></li>
<li><a href="https://github.com/obfuscator-llvm/obfuscator">ollvm</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="源码的混淆-通过宏定义混淆方法名、类名"><a href="#源码的混淆-通过宏定义混淆方法名、类名" class="headerlink" title="源码的混淆 - 通过宏定义混淆方法名、类名"></a>源码的混淆 - 通过宏定义混淆方法名、类名</h3><ul>
<li><p>注意点</p>
<ul>
<li>不能混淆系统方法</li>
<li>不能混淆<code>init</code>开头的等初始化方法</li>
<li>混淆属性时需要额外注意<code>set</code>方法</li>
<li>如果<code>xib</code>、<code>storyboard</code>中用到了混淆的内容，需要手动修正</li>
<li>可以考虑把需要混淆的符号都加上前缀，跟系统自带的符号进行区分</li>
<li>混淆过多可能会被<code>AppStore</code>拒绝上架，需要说明用途</li>
</ul>
</li>
<li><p>建议</p>
<ul>
<li>给需要混淆的符号加上了一个特定的前缀</li>
<li><a href="https://github.com/CoderMJLee/MJCodeObfuscation">工具参考</a></li>
</ul>
</li>
</ul>
<h3 id="ios-class-guard"><a href="#ios-class-guard" class="headerlink" title="ios-class-guard"></a>ios-class-guard</h3><blockquote>
<ul>
<li>它是基于<code>class-dump</code>的扩展</li>
<li>用<code>class-dump</code>扫描出可执行文件中的类名、方法名、属性名等并做替换，会更新<code>xib</code>和<code>storyboard</code>的名字等等<br>会将所有的类进行替换(包括系统的方法)</li>
</ul>
</blockquote>
<ul>
<li><a href="https://github.com/Polidea/ios-class-guard">源码</a></li>
<li>用法<ul>
<li>安装,<code>brew install ios-class-guard</code></li>
<li><code>ios-class-guard [options] &lt;mach-o-file&gt;</code></li>
<li>常用参数<ul>
<li><code>--sdk-root &lt;path&gt;</code>：用于指定SDK路径，如果是模拟器SDK，一般路径就是<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk</li>
<li><code>--sdk-ios</code>：相当于指定<code>SDK</code>路径为<code>真机设备SDK</code></li>
<li> <code>-X &lt;path&gt;</code>：用于指定<code>xib、storyboard</code>所在目录，它会递归搜索</li>
<li><code>-O &lt;path&gt;</code>：生成的混淆头文件路径</li>
<li><code>-m &lt;path&gt;</code>：符号映射表（默认是<code>symbols.json</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h3><ul>
<li>很多时候，可执行文件中的字符串信息，对破解者来说，非常关键，是破解的捷径之一</li>
<li>为了加大破解、逆向难度，可以考虑对字符串进行加密</li>
<li>字符串的加密技术有很多种，可以根据自己的需要自行制定算法<ul>
<li>例如，对每个字符进行异或（^）处理，需要使用字符串时，对异或（^）过的字符再进行一次异或（^），就可以获得原字符</li>
</ul>
</li>
<li><a href="https://github.com/CoderMJLee/MJCodeObfuscation">工具参考</a></li>
</ul>
]]></content>
      <categories>
        <category>应用技巧</category>
      </categories>
      <tags>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title>llvm</title>
    <url>/2023/03/30/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/llvm%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<blockquote>
<p>一般可以将编程语言分为两种，编译语言和直译式语言<br>编译语言: 像<code>C++</code>、<code>OC</code>都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在<code>CPU</code>上执行，所以执行效率较高。<br>解释语言：<code>javaScript</code>、<code>Python</code>都是直译式语言。直译式语言不需要经过编译的过程，而是在执行的时候通过一个中间的解释器将代码解释为<code>CPU</code>可以执行的代码。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活。<br><code>OC</code>和<code>Swift</code>。二者都是编译语言。<code>OC</code>编译都是依赖于<code>Clang+LLVM</code>,<code>Swift</code>赖于<code>Swiftc+LLVM</code>。</p>
</blockquote>
<h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><ul>
<li><a href="https://llvm.org/">官网</a></li>
<li><code>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.</code></li>
<li> <code>LLVM</code>项目是模块化、可重用的编译器以及工具链技术的集合</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="传统的编译器架构"><a href="#传统的编译器架构" class="headerlink" title="传统的编译器架构"></a>传统的编译器架构</h2><p><img src="1.png"></p>
<ul>
<li><code>Frontend</code>:前端<ul>
<li>词法分析、语法分析、语义分析、生成中间代码</li>
</ul>
</li>
<li><code>Optimizer</code>:优化器<ul>
<li>中间代码优化</li>
</ul>
</li>
<li><code>Backend</code>:后端<ul>
<li>生成机器码</li>
</ul>
</li>
</ul>
<h2 id="LLVM架构"><a href="#LLVM架构" class="headerlink" title="LLVM架构"></a>LLVM架构</h2><p><img src="2.png"></p>
<ul>
<li>不同的前端后端使用统一的中间代码<code>LLVM Intermediate Representation (LLVM IR)</code></li>
<li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li>
<li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</li>
<li>优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</li>
<li>相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就 变得特别困难</li>
<li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)</li>
</ul>
<h3 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h3><ul>
<li>什么是<code>Clang</code>?<ul>
<li>LLVM项目的一个子项目</li>
<li>基于LLVM架构的C/C++/Objective-C编译器前端 p <a href=":http://clang.llvm.org/">官网</a></li>
</ul>
</li>
<li>相比于<code>GCC</code>，<code>Clang</code>具有如下优点<ul>
<li>编译速度快:在某些平台上，<code>Clang</code>的编译速度显著的快过<code>GCC</code>(Debug模式下编译OC速度比GGC快3倍)</li>
<li>占用内存小:<code>Clang</code>生成的<code>AST</code>所占用的内存是<code>GCC</code>的五分之一左右</li>
<li>模块化设计:<code>Clang</code>采用基于库的模块化设计，易于<code>IDE</code> 集成及其他用途的重用</li>
<li>诊断信息可读性强:在编译过程中，<code>Clang</code> 创建并保留了大量详细的元数据 (<code>metadata</code>)，有利于调试和错误报告</li>
<li>设计清晰简单，容易理解，易于扩展增强</li>
</ul>
</li>
</ul>
<h2 id="Clang与LLVM"><a href="#Clang与LLVM" class="headerlink" title="Clang与LLVM"></a>Clang与LLVM</h2><p><img src="3.png"></p>
<h1 id="OC源文件的编译过程"><a href="#OC源文件的编译过程" class="headerlink" title="OC源文件的编译过程"></a>OC源文件的编译过程</h1><p><img src="4.jpg"></p>
<ul>
<li>命令行查看编译的过程:<code>$ clang -ccc-print-phases main.m</code>  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">              +- <span class="hljs-number">0</span>: input, <span class="hljs-string">&quot;main.m&quot;</span>, objective-c<br>             +- <span class="hljs-number">1</span>: preprocessor, &#123;<span class="hljs-number">0</span>&#125;, objective-c-cpp-output<br>          +- <span class="hljs-number">2</span>: compiler, &#123;<span class="hljs-number">1</span>&#125;, ir<br>       +- <span class="hljs-number">3</span>: backend, &#123;<span class="hljs-number">2</span>&#125;, assembler<br>    +- <span class="hljs-number">4</span>: assembler, &#123;<span class="hljs-number">3</span>&#125;, object<br> +- <span class="hljs-number">5</span>: linker, &#123;<span class="hljs-number">4</span>&#125;, image<br>+- <span class="hljs-number">6</span>: bind-arch, <span class="hljs-string">&quot;x86_64&quot;</span>, &#123;<span class="hljs-number">5</span>&#125;, image<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ul>
<li>编译代码  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug 0</span><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> debug</span><br>        <span class="hljs-comment">// insert code here...</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Hello, World!&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>        <span class="hljs-comment">// insert code here...</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Hello, debug\n!&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="preprocessor-预处理"><a href="#preprocessor-预处理" class="headerlink" title="preprocessor(预处理)"></a>preprocessor(预处理)</h3><blockquote>
<p>在预处理的时候，注释被删除，条件编译被处理。</p>
</blockquote>
<ul>
<li>执行<code>$ xcrun clang -E main.m</code>  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123; <span class="hljs-keyword">@autoreleasepool</span>  &#123; <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Hello, debug\n!&quot;</span>); &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="词法分析-lexical-anaysis"><a href="#词法分析-lexical-anaysis" class="headerlink" title="词法分析(lexical anaysis)"></a>词法分析(lexical anaysis)</h3><blockquote>
<p>词法分析器读入源文件的字符流，将他们组织成有意义的词素（<code>lexeme</code>）序列，对于每个词素，词法分析器产生的词法单元（<code>token</code>）作为输出。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>Clang</code>会对代码进行词法分析，将代码切分成<code>Token</code>，显示每个 <code>Token</code> 的类型、值，以及位置, <a href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def">clang定义了所有的token类型</a>，这些<code>token</code>类型分为以下四类：</p>
<ol>
<li>关键字：语法中的关键字，比如<code>if</code>、<code>else</code>、<code>while</code>、<code>for</code>等；</li>
<li>标识符：变量名；</li>
<li>字面量：值、数字、字符串；</li>
<li>特殊符号：加减乘除等符号。</li>
</ol>
</li>
<li><p>执行<code>$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</code></p>
<ul>
<li>其中<code>loc=main.m:1:1</code>表示这个<code>token</code>位于源文件<code>main.c</code>的第1行，从第1个字符开始。保存<code>token</code>在源文件中的位置，是方便后续<code>clang</code>分析的时候能够找到出错的原始位置  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c"><span class="hljs-string">&#x27;#import &lt;Foundation/Foundation.h&gt;</span><br><span class="hljs-string">#&#x27;</span>		Loc=&lt;main.m:<span class="hljs-number">1</span>:<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">int</span> <span class="hljs-string">&#x27;int&#x27;</span>	 [StartOfLine]	Loc=&lt;main.m:<span class="hljs-number">3</span>:<span class="hljs-number">1</span>&gt;<br>identifier <span class="hljs-string">&#x27;main&#x27;</span>	 [LeadingSpace]	      Loc=&lt;main.m:<span class="hljs-number">3</span>:<span class="hljs-number">5</span>&gt;<br>l_paren <span class="hljs-string">&#x27;(&#x27;</span>		Loc=&lt;main.m:<span class="hljs-number">3</span>:<span class="hljs-number">9</span>&gt;<br><span class="hljs-keyword">int</span> <span class="hljs-string">&#x27;int&#x27;</span>		Loc=&lt;main.m:<span class="hljs-number">3</span>:<span class="hljs-number">10</span>&gt;<br>....<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="语法分析-semantic-analysis"><a href="#语法分析-semantic-analysis" class="headerlink" title="语法分析(semantic analysis)"></a>语法分析(semantic analysis)</h3><blockquote>
<p>语法分析的<code>token</code>流会被解析成一颗抽象的语法树(先按语法组合成语义，生成类似 VarDecl 这样的节点，然后将这些节点按照层级关系构成抽象语法树（AST）)（<code>abstract syntax tree - AST</code>）</p>
</blockquote>
<ul>
<li>执行<code>$ xcrun clang -cc1 -ast-dump JBPerson.m</code>  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">.....<br>|-ObjCImplementationDecl <span class="hljs-number">0x7fa731c6b500</span> &lt;MJPerson.m:<span class="hljs-number">10</span>:<span class="hljs-number">1</span>, line:<span class="hljs-number">32</span>:<span class="hljs-number">1</span>&gt;    line:<span class="hljs-number">10</span>:<span class="hljs-number">17</span> JBPerson<br>| |-ObjCInterface <span class="hljs-number">0x7fa731c69d70</span> <span class="hljs-string">&#x27;JBPerson&#x27;</span><br>| |-ObjCMethodDecl <span class="hljs-number">0x7fa731c6b5d0</span> &lt;line:<span class="hljs-number">11</span>:<span class="hljs-number">1</span>, line:<span class="hljs-number">17</span>:<span class="hljs-number">1</span>&gt; line:<span class="hljs-number">11</span>:<span class="hljs-number">1</span> - initWithAge:name: <span class="hljs-string">&#x27;instancetype&#x27;</span>:<span class="hljs-string">&#x27;id&#x27;</span><br>| | |-ImplicitParamDecl <span class="hljs-number">0x7fa731c6c9c0</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit used <span class="hljs-keyword">self</span> <span class="hljs-string">&#x27;JBPerson *&#x27;</span><br>| | |-ImplicitParamDecl <span class="hljs-number">0x7fa731c6ca28</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit _cmd <span class="hljs-string">&#x27;SEL&#x27;</span>:<span class="hljs-string">&#x27;SEL *&#x27;</span><br>| | |-ParmVarDecl <span class="hljs-number">0x7fa731c6b660</span> &lt;col:<span class="hljs-number">31</span>, col:<span class="hljs-number">42</span>&gt; col:<span class="hljs-number">42</span> used age <span class="hljs-string">&#x27;NSInteger&#x27;</span>:<span class="hljs-string">&#x27;long&#x27;</span><br>| | |-ParmVarDecl <span class="hljs-number">0x7fa731c6b6c8</span> &lt;col:<span class="hljs-number">53</span>, col:<span class="hljs-number">65</span>&gt; col:<span class="hljs-number">65</span> used name <span class="hljs-string">&#x27;NSString *&#x27;</span><br>| | `-CompoundStmt <span class="hljs-number">0x7fa731c6cef0</span> &lt;col:<span class="hljs-number">70</span>, line:<span class="hljs-number">17</span>:<span class="hljs-number">1</span>&gt;<br>| |   |-IfStmt <span class="hljs-number">0x7fa731c6ce70</span> &lt;line:<span class="hljs-number">12</span>:<span class="hljs-number">5</span>, line:<span class="hljs-number">15</span>:<span class="hljs-number">5</span>&gt;<br>| |   | |-BinaryOperator <span class="hljs-number">0x7fa731c6cae0</span> &lt;line:<span class="hljs-number">12</span>:<span class="hljs-number">9</span>, col:<span class="hljs-number">27</span>&gt; <span class="hljs-string">&#x27;JBPerson *&#x27;</span> <span class="hljs-string">&#x27;=&#x27;</span><br>| |   | | |-DeclRefExpr <span class="hljs-number">0x7fa731c6ca90</span> &lt;col:<span class="hljs-number">9</span>&gt; <span class="hljs-string">&#x27;JBPerson *&#x27;</span> lvalue ImplicitParam <span class="hljs-number">0x7fa731c6c9c0</span> <span class="hljs-string">&#x27;self&#x27;</span> <span class="hljs-string">&#x27;JBPerson *&#x27;</span><br>| |   | | `-ObjCMessageExpr <span class="hljs-number">0x7fa731c6cab0</span> &lt;col:<span class="hljs-number">16</span>, col:<span class="hljs-number">27</span>&gt; <span class="hljs-string">&#x27;JBPerson *&#x27;</span> selector=init <span class="hljs-keyword">super</span> (instance)<br>| |   | `-CompoundStmt <span class="hljs-number">0x7fa731c6ce50</span> &lt;col:<span class="hljs-number">30</span>, line:<span class="hljs-number">15</span>:<span class="hljs-number">5</span>&gt;<br>| |   |   |-PseudoObjectExpr <span class="hljs-number">0x7fa731c6cc70</span> &lt;line:<span class="hljs-number">13</span>:<span class="hljs-number">9</span>, col:<span class="hljs-number">20</span>&gt; <span class="hljs-string">&#x27;NSInteger&#x27;</span>:<span class="hljs-string">&#x27;long&#x27;</span><br>| |   |   | |-BinaryOperator <span class="hljs-number">0x7fa731c6cbe8</span> &lt;col:<span class="hljs-number">9</span>, col:<span class="hljs-number">20</span>&gt; <span class="hljs-string">&#x27;NSInteger&#x27;</span>:<span class="hljs-string">&#x27;long&#x27;</span> lvalue <span class="hljs-string">&#x27;=&#x27;</span><br>| |   |   | | |-ObjCPropertyRefExpr <span class="hljs-number">0x7fa731c6cba0</span> &lt;col:<span class="hljs-number">9</span>, col:<span class="hljs-number">14</span>&gt; <span class="hljs-string">&#x27;&lt;pseudo-object type&gt;&#x27;</span> lvalue objcproperty Kind=PropertyRef Property=<span class="hljs-string">&quot;age&quot;</span> Messaging=Setter<br>| |   |   | | | `-OpaqueValueExpr <span class="hljs-number">0x7fa731c6cb88</span> &lt;col:<span class="hljs-number">9</span>&gt; <span class="hljs-string">&#x27;JBPerson *&#x27;</span><br>.....<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="CodeGen"><a href="#CodeGen" class="headerlink" title="CodeGen"></a>CodeGen</h3><blockquote>
<p>codeGen遍历语法树，生成<code>LLVM IR</code>代码。<code>LLVM IR</code>是前端的输出，后端的输入</p>
</blockquote>
<ul>
<li>遍历语法树生成<code>LLVM IR</code>,<code>LLVM IR</code>有3种表示形式,但本质是等价的<ol>
<li><code>text</code>:便于阅读的文本格式，类似于汇编语言，拓展名.ll， <code>$ clang -S -emit-llvm main.m</code></li>
<li><code>bitcode</code>:二进制格式，拓展名.bc， <code>$ clang -c -emit-llvm main.m</code></li>
<li><code>memory</code>:内存格式</li>
</ol>
</li>
<li>执行<code>$ xcrun clang -S -emit-llvm main.m -o main.ll</code>  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">.....<br>define i32 @main(i32 %<span class="hljs-number">0</span>, i8** %<span class="hljs-number">1</span>) #<span class="hljs-number">1</span> &#123;<br>  %<span class="hljs-number">3</span> = alloca i32, align <span class="hljs-number">4</span><br>  %<span class="hljs-number">4</span> = alloca i32, align <span class="hljs-number">4</span><br>  %<span class="hljs-number">5</span> = alloca i8**, align <span class="hljs-number">8</span><br>  store i32 <span class="hljs-number">0</span>, i32* %<span class="hljs-number">3</span>, align <span class="hljs-number">4</span><br>  store i32 %<span class="hljs-number">0</span>, i32* %<span class="hljs-number">4</span>, align <span class="hljs-number">4</span><br>  store i8** %<span class="hljs-number">1</span>, i8*** %<span class="hljs-number">5</span>, align <span class="hljs-number">8</span><br>  %<span class="hljs-number">6</span> = call i8* @llvm.objc.autoreleasePoolPush() #<span class="hljs-number">2</span><br>  notail call <span class="hljs-keyword">void</span> (i8*, ...) @<span class="hljs-built_in">NSLog</span>(i8* bitcast (%<span class="hljs-keyword">struct</span>.__NSConstantString_tag* @_unnamed_cfstring_ to i8*))<br>  call <span class="hljs-keyword">void</span> @llvm.objc.autoreleasePoolPop(i8* %<span class="hljs-number">6</span>)<br>  ret i32 <span class="hljs-number">0</span><br>&#125;<br>.....<br></code></pre></td></tr></table></figure></li>
<li><code>objective-C</code>代码在这一步会进行<code>runtime</code>的桥接：<code>property</code>合成，<code>ARC</code>处理等。</li>
<li><code>LLVM</code>会对生成的<code>IR</code>进行优化，优化会调用相应的<code>Pass</code>进行处理。<code>Pass</code>由多个节点组成，都是<code>Pass</code>类的子类，每个节点负责做特定的优化，具体细节见，</li>
</ul>
<h3 id="生成汇编代码"><a href="#生成汇编代码" class="headerlink" title="生成汇编代码"></a>生成汇编代码</h3><blockquote>
<p><code>LLVM</code>对<code>IR</code>进行优化后，会针对不同架构形成不同的目标代码，最后以汇编代码的格式输出.</p>
</blockquote>
<ul>
<li><p>执行<code>$ xcrun clang -S main.m -o main.s</code></p>
  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">_main:                                  ## @main<br>	.cfi_startproc<br>## %bb<span class="hljs-number">.0</span>:<br>	pushq	%rbp<br>	.cfi_def_cfa_offset <span class="hljs-number">16</span><br>	.cfi_offset %rbp, <span class="hljs-number">-16</span><br>	movq	%rsp, %rbp<br>	.cfi_def_cfa_register %rbp<br>	subq	$<span class="hljs-number">32</span>, %rsp<br>	movl	$<span class="hljs-number">0</span>, <span class="hljs-number">-4</span>(%rbp)<br>	movl	%edi, <span class="hljs-number">-8</span>(%rbp)<br>	movq	%rsi, <span class="hljs-number">-16</span>(%rbp)<br></code></pre></td></tr></table></figure>
<h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><blockquote>
<p>汇编器,以汇编代码作为输入，将汇编代码转换为机器码</p>
</blockquote>
</li>
<li><p>执行<code>$ xcrun clang -fmodules -c main.m -o main.o</code></p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">.....<br>(undefined) external _NSLog<br>                   (undefined) external ___CFConstantStringClassReference<br>                   (undefined) external _objc_autoreleasePoolPop<br>                   (undefined) external _objc_autoreleasePoolPush<br><span class="hljs-number">0000000000000000</span> (__TEXT,__text) external _main<br>.....<br></code></pre></td></tr></table></figure></li>
<li><p><code>_NSLog</code>是一个<code>undefined external</code>的。<code>undefined</code>表示在当前文件找不到符号<code>_NSLog</code>,而<code>external</code>表示这个符号是外部可以访问的，对应文件私有符号是<code>non-exrernal</code></p>
</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote>
<p>链接器把编译产生的.o文件和（dylib，a，tbd）文件(动态库文件)，生成一个mach-0文件(a.out文件的替代) </p>
</blockquote>
<ul>
<li><p>执行<code>$ xcrun clang main.o -o main</code></p>
<ul>
<li><code>_NSLog</code>仍然是<code>undefined</code>,但是后面多了一些信息，<code>from Foundation</code>,表示这个符号来自于<code>libSystem</code>，会在运行时动态绑定<figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">$ nm -nm main<br>                 (undefined) external _NSLog (from Foundation)<br>                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)<br>                 (undefined) external _objc_autoreleasePoolPop (from libobjc)<br>                 (undefined) external _objc_autoreleasePoolPush (from libobjc)<br>                 (undefined) external dyld_stub_binder (from libSystem)<br><span class="hljs-number">0000000100000000</span> (__TEXT,__text) [referenced dynamically] external __mh_execute_header<br><span class="hljs-number">0000000100003</span>f20 (__TEXT,__text) external _main<br><span class="hljs-number">0000000100008018</span> (__DATA,__data) non-external __dyld_private<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>就得到了一个<code>mach-o</code>格式的可执行文件</p>
  <figure class="highlight obj-c"><table><tr><td class="code"><pre><code class="hljs obj-c">$ file main<br>main: Mach-O <span class="hljs-number">64</span>-bit executable x86_64<br>$ ./main <br>hello debug<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul>
<li>下载<code>LLVM</code>,<code>git clone https://github.com/llvm/llvm-project.git</code></li>
<li>将<code>llvm-project</code>工程下的<code>clang</code>，移动到<code>llvm-project/llvm/tools</code></li>
</ul>
<h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><ul>
<li><p>安装<code>cmake</code>和<code>ninja</code>(先安装<a href="https://brew.sh/">brew</a>)</p>
<ul>
<li><code>brew install cmake</code></li>
<li><code>brew install ninja</code></li>
</ul>
</li>
<li><p>在LLVM源码同级目录下新建一个【<code>llvm_build</code>】目录(最终会在【<code>llvm_build</code>】目录下生成【<code>build.ninja</code>】</p>
<ul>
<li><code>cd llvm_build</code></li>
<li><code>cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=生成的目录 -DLLVM_ENABLE_PROJECTS=&quot;clang;clang-tools-extra&quot; -G Ninja ../llvm</code></li>
<li><code>ninja</code>,依次执行编译、安装指令</li>
<li> <code>ninja install</code>,安装完成，出现在生成的目录</li>
</ul>
</li>
<li><p>也可以生成<code>Xcode</code>项目再进行编译，但是速度很慢</p>
<ul>
<li>在<code>llvm-project</code>同级目录下新建一个【<code>llvm_xcode</code>】目录</li>
<li><code>cd llvm_xcode</code></li>
<li><code>cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang;clang-tools-extra&quot; -G Xcode ../llvm-project/llvm</code></li>
</ul>
</li>
</ul>
<h1 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h1><ul>
<li><code>libclang</code>、<code>libTooling</code><ul>
<li><a href="https://clang.llvm.org/docs/Tooling.html">官方参考</a> </li>
<li>应用:语法树分析、语言转换等</li>
</ul>
</li>
<li><code>Clang</code>插件开发<ul>
<li>官方参考<ul>
<li><a href="https://clang.llvm.org/docs/ClangPlugins.html">https://clang.llvm.org/docs/ClangPlugins.html</a></li>
<li><a href="https://clang.llvm.org/docs/ExternalClangExamples.html">https://clang.llvm.org/docs/ExternalClangExamples.html</a></li>
<li><a href="https://clang.llvm.org/docs/RAVFrontendAction.html">https://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
</ul>
</li>
<li>应用:代码检查(命名规范、代码规范)等</li>
</ul>
</li>
<li><code>Pass</code>开发<ul>
<li><a href="https://llvm.org/docs/WritingAnLLVMPass.html">官方参考</a></li>
<li>应用:代码优化、代码混淆等</li>
</ul>
</li>
<li>开发新的编程语言<ul>
<li><a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html">https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html</a></li>
<li><a href="https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/">https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/</a></li>
</ul>
</li>
</ul>
<h2 id="Clang插件开发"><a href="#Clang插件开发" class="headerlink" title="Clang插件开发"></a><code>Clang</code>插件开发</h2><ol>
<li>在【<code>clang/tools</code>】源码目录下新建一个插件目录，例如<code>jb-plugin</code></li>
</ol>
<p><img src="5.png"></p>
<ol start="2">
<li><p>在<code>clang/tools/CMakeLists.txt</code>最后加入内容: <code>add_clang_subdirectory(jb-plugin)</code>，小括号里是插件目录名</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">add_clang_subdirectory(amdgpu-arch)<br>add_clang_subdirectory(nvptx-arch)<br>add_clang_subdirectory(jb-plugin)<br></code></pre></td></tr></table></figure></li>
<li><p>在<code>jb-plugin</code>目录下新建一个<code>CMakeLists.txt</code>，文件内容是</p>
<ul>
<li><code>JBPlugin</code>是插件名，<code>JBPlugin.cpp</code>是源代码文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">add_llvm_library(JBPlugin MODULE BUILDTREE_ONLY<br>JBPlugin.cpp)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>JBPlugin.cpp</code>的源码</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">    <br>    <br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/AST.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> llvm;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;<br><br><span class="hljs-keyword">namespace</span>  JBPlugin &#123;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JBHandler</span>:</span> <span class="hljs-keyword">public</span> MatchFinder::MatchCallback &#123;<br><span class="hljs-keyword">private</span>:<br>    CompilerInstance &amp;ci;<br>    <span class="hljs-keyword">bool</span> isClass;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUserSourceCode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string filename)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (filename.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 非Xcode中的源码都认为是用户源码</span><br>        <span class="hljs-keyword">if</span> (filename.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;/Applications/Xcode.app/&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isShouldUseCopy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string typeStr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (typeStr.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;NSString&quot;</span>) != string::npos ||<br>            typeStr.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;NSArray&quot;</span>) != string::npos ||<br>            typeStr.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;NSDictionary&quot;</span>) != string::npos) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//检查类名</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkClassName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> ObjCInterfaceDecl *decl = Result.Nodes.getNodeAs&lt;ObjCInterfaceDecl&gt;(<span class="hljs-string">&quot;objcInterfaceDecl&quot;</span>);<br>        string filename = ci.<span class="hljs-built_in">getSourceManager</span>().<span class="hljs-built_in">getFilename</span>(decl-&gt;<span class="hljs-built_in">getSourceRange</span>().<span class="hljs-built_in">getBegin</span>()).<span class="hljs-built_in">str</span>();<br><br>        <span class="hljs-keyword">if</span> (decl &amp;&amp; <span class="hljs-built_in">isUserSourceCode</span>(filename))&#123;<br>            <span class="hljs-keyword">size_t</span> pos = decl-&gt;<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;_&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (pos != StringRef::npos) &#123;<br>                DiagnosticsEngine &amp;D = ci.<span class="hljs-built_in">getDiagnostics</span>();<br>                <span class="hljs-comment">//找到报错的位置</span><br>                SourceLocation loc = decl -&gt;<span class="hljs-built_in">getLocation</span>().<span class="hljs-built_in">getLocWithOffset</span>(pos);<br>                D.<span class="hljs-built_in">Report</span>(loc, D.<span class="hljs-built_in">getCustomDiagID</span>(DiagnosticsEngine::Error, <span class="hljs-string">&quot;类名不允许下划线&quot;</span>));<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkProperty</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchFinder::MatchResult &amp;Result)</span></span>&#123;<br>        <span class="hljs-keyword">const</span> ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs&lt;ObjCPropertyDecl&gt;(<span class="hljs-string">&quot;objcPropertyDecl&quot;</span>);<br>        string filename = ci.<span class="hljs-built_in">getSourceManager</span>().<span class="hljs-built_in">getFilename</span>(propertyDecl-&gt;<span class="hljs-built_in">getSourceRange</span>().<span class="hljs-built_in">getBegin</span>()).<span class="hljs-built_in">str</span>();<br>        string typeStr = propertyDecl-&gt;<span class="hljs-built_in">getType</span>().<span class="hljs-built_in">getAsString</span>(); <span class="hljs-comment">// 拿到属性的类型</span><br>        ObjCPropertyAttribute::Kind attrKind = propertyDecl-&gt;<span class="hljs-built_in">getPropertyAttributes</span>();<span class="hljs-comment">// 拿到节点的描述信息</span><br>        <span class="hljs-keyword">if</span> (propertyDecl &amp;&amp; <span class="hljs-built_in">isUserSourceCode</span>(filename))&#123;<br>            <span class="hljs-comment">// 如果应该使用copy但是却没有使用，那么就报出警告</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isShouldUseCopy</span>(typeStr) &amp;&amp; !(attrKind &amp; ObjCPropertyDecl::SetterKind::Copy)) &#123;<br>                DiagnosticsEngine &amp;diag = ci.<span class="hljs-built_in">getDiagnostics</span>(); <span class="hljs-comment">// 诊断引擎</span><br>                diag.<span class="hljs-built_in">Report</span>(propertyDecl-&gt;<span class="hljs-built_in">getBeginLoc</span>(), diag.<span class="hljs-built_in">getCustomDiagID</span>(DiagnosticsEngine::Warning, <span class="hljs-string">&quot;%0这个地方推荐用Copy&quot;</span>))&lt;&lt;typeStr;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">JBHandler</span>(CompilerInstance &amp;ci,<span class="hljs-keyword">bool</span> isclass):<span class="hljs-built_in">ci</span>(ci),<span class="hljs-built_in">isClass</span>(isclass)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;<br>        <span class="hljs-comment">//根据标识符号</span><br>        <span class="hljs-comment">//从声明中找到之前标识符号的声名</span><br>        <span class="hljs-keyword">if</span>(isClass) &#123;<br>            <span class="hljs-built_in">checkClassName</span>(Result);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">checkProperty</span>(Result);<br>        &#125;<br>        <br>        <br>    &#125;<br>&#125;;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JBASTConsumer</span>:</span> <span class="hljs-keyword">public</span> ASTConsumer &#123;<br>    <span class="hljs-keyword">private</span>:<br>        MatchFinder matcher;<br>        JBHandler handler;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">JBASTConsumer</span>(CompilerInstance &amp;ci,<span class="hljs-keyword">bool</span> isClass) :<span class="hljs-built_in">handler</span>(ci,isClass)&#123;<br>            <span class="hljs-comment">//告诉 matcher去语法树找什么东西，并传入handler（调用其中的run方法）</span><br>            <span class="hljs-keyword">if</span> (isClass) &#123;<br>                matcher.<span class="hljs-built_in">addMatcher</span>(<span class="hljs-built_in">objcInterfaceDecl</span>().<span class="hljs-built_in">bind</span>(<span class="hljs-string">&quot;objcInterfaceDecl&quot;</span>), &amp;handler);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                matcher.<span class="hljs-built_in">addMatcher</span>(<span class="hljs-built_in">objcPropertyDecl</span>().<span class="hljs-built_in">bind</span>(<span class="hljs-string">&quot;objcPropertyDecl&quot;</span>), &amp;handler);<br>            &#125;<br>            <br>        &#125;<br>        <br>        <span class="hljs-comment">//在整个文件都解析完后被调用</span><br>        <span class="hljs-comment">//当clang遍历解析完一次语法树之后，就会调用,ctx包含语法树的信息</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(ASTContext &amp;ctx)</span> </span>&#123;<br>            <span class="hljs-comment">//matcher会去语法树查找东西</span><br>            matcher.<span class="hljs-built_in">matchAST</span>(ctx);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//将来加载插件的时候执行的动作</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JBClassAction</span>:</span> <span class="hljs-keyword">public</span> PluginASTAction &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//2.指定action后，会创建一个Consumer对象</span><br>    <span class="hljs-function">unique_ptr&lt;ASTConsumer&gt; <span class="hljs-title">CreateASTConsumer</span><span class="hljs-params">(CompilerInstance &amp;ci, StringRef iFile)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> unique_ptr&lt;JBASTConsumer&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">JBASTConsumer</span>(ci,<span class="hljs-literal">true</span>));<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParseArgs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CompilerInstance &amp;ci, <span class="hljs-keyword">const</span> vector&lt;string&gt; &amp;args)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JBPropertyAction</span>:</span> <span class="hljs-keyword">public</span> PluginASTAction &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//2.指定action后，会创建一个Consumer对象</span><br>    <span class="hljs-function">unique_ptr&lt;ASTConsumer&gt; <span class="hljs-title">CreateASTConsumer</span><span class="hljs-params">(CompilerInstance &amp;ci, StringRef iFile)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> unique_ptr&lt;JBASTConsumer&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">JBASTConsumer</span>(ci,<span class="hljs-literal">false</span>));<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParseArgs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CompilerInstance &amp;ci, <span class="hljs-keyword">const</span> vector&lt;string&gt; &amp;args)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">//1.注册插件，指定action</span><br><span class="hljs-keyword">static</span> clang::<span class="hljs-function">FrontendPluginRegistry::Add&lt;JBPlugin::JBClassAction&gt; <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-string">&quot;JBPlugin&quot;</span>, <span class="hljs-string">&quot;The JBPlugin is my Class clang-plugin.&quot;</span>)</span></span>;<br><span class="hljs-keyword">static</span> clang::<span class="hljs-function">FrontendPluginRegistry::Add&lt;JBPlugin::JBPropertyAction&gt; <span class="hljs-title">Y</span><span class="hljs-params">(<span class="hljs-string">&quot;JBPlugin&quot;</span>, <span class="hljs-string">&quot;The JBPlugin is my Property clang-plugin.&quot;</span>)</span></span>;<br><br></code></pre></td></tr></table></figure></li>
<li><p>利用<code>cmake</code>生成的<code>Xcode</code>项目来编译插件(第一次编写完插件，需要利用<code>cmake</code>重新生成一下<code>Xcode</code>项目) </p>
<ul>
<li>插件源代码在<code>Sources/Loadable modules</code>目录下可以找到，这样就可以直接在Xcode里编写插件代码<br><img src="6.png"></li>
<li>选择<code>JBPlugin</code>这个<code>target</code>进行编译，编译完会生成一个动态库文件</li>
</ul>
</li>
<li><p>加载插件,在Xcode项目中指定加载插件动态库:<code>BuildSettings</code> &gt; <code>OTHER_CFLAGS</code></p>
<ul>
<li><code>-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称</code></li>
<li>-Xclang -load -Xclang /Users/chenjingpo/Desktop/源码/LLVVM/llvm_xcode/Debug/lib/JBPlugin.dylib -Xclang -add-plugin -Xclang JBPlugin</li>
<li></li>
</ul>
</li>
</ol>
<p><img src="7.png"></p>
<ol start="7">
<li>在<code>xcode</code>中使用编译好的<code>clang</code>,<code>xcode</code>自带的是不允许的</li>
</ol>
<ul>
<li>增加2个<code>User-Defined</code>，为<code>CC</code>和<code>CCX</code>，指定编译好的<code>clang</code>指令</li>
</ul>
<p><img src="8.png"></p>
<ul>
<li>将<code>Enable Index-While-Building Functionality</code>设置为<code>NO</code></li>
</ul>
<p><img src="9.png"></p>
<ol start="8">
<li>编译项目</li>
</ol>
<p><img src="10.png"></p>
]]></content>
      <categories>
        <category>应用技巧</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2023/03/26/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><blockquote>
<ul>
<li>函数式编程 ( <code>Funtional Programming</code>，简称<code>FP</code>）是一种编程范式，也就是如何编写程序的方法论<ul>
<li>主要思想：把计算过程尽量分解成一系列可复用函数的调用</li>
<li>主要特征：函数是“第一等公民〞<ul>
<li>函数与其他数据类型一样的地位，可以赋值给其他变量，也可以作为函数参数、函数返回值</li>
</ul>
</li>
</ul>
</li>
<li>函数式编程最早出现在<code>LISP</code>语言 ，绝大部分的现代编程语言也对函数式编程做了不同程度的支持，比如<ul>
<li><code>Haskell</code>. <code>Javascript</code>. <code>Python</code>. <code>Swift</code>、<code>Kotlin</code>、<code>Scala</code>等</li>
</ul>
</li>
<li>函数式编程中几个常用的概念<ul>
<li><code>Higher-Order Function</code>, <code>Function Currying</code></li>
<li><code>Functor.</code> <code>Applicative Functor</code>,<code>Monad</code></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li>传统写法，实现假设要实现：<code>var num = 1; [(num + 3）*5-1] % 10 / 2</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">+</span> v2 &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">V2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">-</span> v2 &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiple</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-params">_v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">*</span> v2 &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">/</span> v2 &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mod</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">%</span> v2&#125;<br><br>divide (mod (sub (mult iple(add (num, <span class="hljs-number">3</span>)， <span class="hljs-number">5</span>)， <span class="hljs-number">1</span>)， <span class="hljs-number">10</span>）， <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
</li>
<li>函数式写法<ul>
<li>将函数拆分成只接受一个参数   <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> -&gt; (<span class="hljs-type">Int</span>) 一<span class="hljs-operator">&gt;</span><span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">+</span> v &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">-</span> v &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiple</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> 一<span class="hljs-operator">&gt;</span>（<span class="hljs-type">Int）</span> 一<span class="hljs-operator">&gt;</span><span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">*</span> v &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> -&gt;（<span class="hljs-type">Int）</span> 一<span class="hljs-operator">&gt;</span> <span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">/</span> v &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mod</span>( <span class="hljs-params">v</span>: <span class="hljs-type">Int</span>)</span> -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">%</span> v &#125; &#125;<br></code></pre></td></tr></table></figure></li>
<li>定义一个合并函数运算符 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">infix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">&gt;&gt;&gt;</span> : <span class="hljs-type">AdditionPrecedence</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">&gt;&gt;&gt;&lt;</span></span><span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span><span class="hljs-operator">&gt;</span>(<br><span class="hljs-keyword">_</span> f1:<span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>) -&gt; <span class="hljs-type">B</span>,<br><span class="hljs-keyword">_</span> f2:<span class="hljs-keyword">@escaping</span> (<span class="hljs-type">B</span>)-&gt;<span class="hljs-type">C</span>) -&gt;(<span class="hljs-type">A</span>)-&gt; <span class="hljs-type">C</span> &#123; &#123; f2(f1(<span class="hljs-variable">$0</span>)) &#125; &#125;<br></code></pre></td></tr></table></figure></li>
<li>写法 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> fn <span class="hljs-operator">=</span> add(<span class="hljs-number">3</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> multiple(<span class="hljs-number">5</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> sub (<span class="hljs-number">1</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> mod (<span class="hljs-number">10</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> divide (<span class="hljs-number">2</span>)<br>fn(num)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="高阶函数-Higher-Order-Function"><a href="#高阶函数-Higher-Order-Function" class="headerlink" title="高阶函数 ( Higher-Order Function )"></a>高阶函数 ( <code>Higher-Order Function</code> )</h2><blockquote>
<ul>
<li>高阶函数是至少满足下列一个条件的函数：</li>
<li>接受一个或多个函数作为输入 （<code>map</code>、<code>filter</code>、<code>reduce</code>等）</li>
<li>返回一个函数</li>
</ul>
</blockquote>
<h2 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化 (Currying)"></a>柯里化 (<code>Currying</code>)</h2><blockquote>
<p>什么是柯里化？</p>
<ul>
<li>将一个接受多参数的函数变换为一系列只接受单个参数的函数</li>
<li><code>Array</code>、<code>Optional</code>的<code>ma</code>p方法接收的参数就是一个柯里化函数</li>
</ul>
</blockquote>
<ul>
<li>柯里化转换的方法,和方法合并的实践，上面的例子可以改写成<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">+</span> v2 &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">V2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">-</span> v2 &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiple</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-params">_v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">*</span> v2 &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">/</span> v2 &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mod</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123; v1 <span class="hljs-operator">%</span> v2&#125;<br><br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&lt;</span></span><span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span><span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">_</span> fn: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) -&gt; <span class="hljs-type">C</span>)<br>-&gt; (<span class="hljs-type">B</span>) -&gt; (<span class="hljs-type">A</span>) -&gt; <span class="hljs-type">C</span> &#123; &#123; b <span class="hljs-keyword">in</span> &#123; a <span class="hljs-keyword">in</span> fn(a, b) &#125; &#125; &#125;<br>    <br><span class="hljs-keyword">infix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">&gt;&gt;&gt;</span> : <span class="hljs-type">AdditionPrecedence</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">&gt;&gt;&gt;&lt;</span></span><span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span><span class="hljs-operator">&gt;</span>(<br><span class="hljs-keyword">_</span> f1: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>) -&gt; <span class="hljs-type">B</span>,<br><span class="hljs-keyword">_</span> f2: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">B</span>) -&gt;<span class="hljs-type">C</span>) -&gt;（<span class="hljs-type">A</span>)-&gt;<span class="hljs-type">C</span> &#123; &#123; f2(f1(<span class="hljs-variable">$0</span>)) &#125; &#125;<br><br><br><span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> fn <span class="hljs-operator">=</span> (<span class="hljs-operator">~</span>add) (<span class="hljs-number">3</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> (<span class="hljs-operator">~</span>multiple) (<span class="hljs-number">5</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> (<span class="hljs-operator">~</span>sub) (<span class="hljs-number">1</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> (<span class="hljs-operator">~</span>mod) (<span class="hljs-number">10</span>) <span class="hljs-operator">&gt;&gt;&gt;</span> (<span class="hljs-operator">~</span>divide)(<span class="hljs-number">2</span>)<br>fn (num)<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="函子-（Functor"><a href="#函子-（Functor" class="headerlink" title="函子 （Functor)"></a>函子 （<code>Functor</code>)</h2><blockquote>
<ul>
<li> 像<code>Array</code>、<code>Optional</code>这样支持<code>map</code>运算的类型，称为函子 ( Functor)</li>
<li><code>public func mapsT&gt;(_ transform: (Element) -&gt; T) -&gt; Array&lt;T&gt;</code></li>
<li><code>public func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; Optional&lt;U&gt;</code></li>
</ul>
</blockquote>
<h2 id="适用函子-Applicative-Functor"><a href="#适用函子-Applicative-Functor" class="headerlink" title="适用函子 ( Applicative Functor)"></a>适用函子 ( <code>Applicative Functor</code>)</h2><blockquote>
<ul>
<li>对任意一个函子F，如果能支持以下运算，该函子就是一个适用函子</li>
<li><code>func puresA&gt;( value: A) -&gt;F&lt;A&gt;</code></li>
<li><code>func &lt;*&gt;&lt;A, B&gt;(fn: F&lt;(A) -&gt;B&gt;, value: F&lt;A&gt;)一＞F&lt;B&gt;</code></li>
</ul>
</blockquote>
<h4 id="单子（Monad"><a href="#单子（Monad" class="headerlink" title="单子（Monad)"></a>单子（<code>Monad</code>)</h4><blockquote>
<ul>
<li>对任意一个类型F，如果能支持以下运算，那么就可以称为是一个单子(<code>Monad</code>)<ul>
<li><code>func pure&lt;A&gt;(_ value: A) -&gt; F&lt;A&gt;</code></li>
<li><code>func flatMap&lt;A, B&gt;(_ value: F&lt;A&gt;,_ fn:(A) -&gt; F&lt;B&gt;) -&gt; F&lt;B&gt;</code></li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>swift和OC</title>
    <url>/2023/03/19/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E5%92%8COC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h1><ul>
<li><code>@_silgen_name</code>可以对<code>c</code>函数进行重命名<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-meta">@_silgen_name</span>(<span class="hljs-string">&quot;sum&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swift_sum</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int32</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-type">Int32</span>)</span> -&gt; <span class="hljs-type">Int32</span><br></code></pre></td></tr></table></figure></li>
<li>此外，还可以类似<code>extern</code>，声明系统内部函数，并进行使用。如果该函数不存在，则无法编译通过<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-meta">@_silgen_name</span>(<span class="hljs-string">&quot;swift_retainCount&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swift_elk_retainCount</span>(<span class="hljs-operator">...</span>)</span><span class="hljs-comment">//这里要具体的函数</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h1><ul>
<li><code>@objc dynamic</code>修饰的内容会具有动态性，比如,在<code>swift</code>中调用方法会走<code>runtime</code>那一套流程<ul>
<li>只通过<code>@objc</code>修饰的，在<code>OC</code>调用，是<code>objc_msg</code>,在<code>swift</code>中调用还是<code>虚表</code>的方式</li>
<li>要让<code>swift</code>中调用还是<code>objc_msg</code>，需要加上<code>dynamic</code></li>
</ul>
</li>
</ul>
<h1 id="KVC-KVO"><a href="#KVC-KVO" class="headerlink" title="KVC/KVO"></a>KVC/KVO</h1><ul>
<li><code>Swift</code>支持 <code>KVC\KVO</code> 的条件<ul>
<li>属性所在的类、监听器最终继承自 <code>NSObject</code></li>
<li>用 <code>@objc dynamic</code> 修饰对应的厲性</li>
</ul>
</li>
<li>示例<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> ob:<span class="hljs-type">NSKeyValueObservation</span>?<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">init</span>()</span> &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        ob <span class="hljs-operator">=</span> observe(\.age,options: [.new,.old]) &#123; <span class="hljs-keyword">_</span>, change <span class="hljs-keyword">in</span><br>            <span class="hljs-built_in">print</span>(change.newValue,change.oldValue)<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Array中lazy优化"><a href="#Array中lazy优化" class="headerlink" title="Array中lazy优化"></a><code>Array</code>中<code>lazy</code>优化</h2><ul>
<li>下面<code>map</code>操作，会在使用的时候在<code>map</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].lazy.map &#123; num <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mapping <span class="hljs-subst">\(num)</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> num<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br><span class="hljs-comment">// 输出</span><br><span class="hljs-operator">----</span><br>mapping <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>mapping <span class="hljs-number">2</span><br><span class="hljs-number">4</span><br>mapping <span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-operator">----</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>自定义模式匹配，条件编译</title>
    <url>/2023/03/19/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自定义模式匹配"><a href="#自定义模式匹配" class="headerlink" title="自定义模式匹配"></a>自定义模式匹配</h1><blockquote>
<p>在<code>switch</code>的<code>case</code>中，较为复杂的表达式模式匹配，实际上实现了<code>～=</code> 方法，因此，可以通过重载运算符，自定义表达是模式的匹配规则</p>
</blockquote>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> score <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:<span class="hljs-type">Int</span>,<span class="hljs-params">value</span>:<span class="hljs-type">Student</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; value.score <span class="hljs-operator">&gt;=</span> pattern &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:<span class="hljs-type">ClosedRange</span>&lt;<span class="hljs-type">Int</span>&gt;,<span class="hljs-params">value</span>:<span class="hljs-type">Student</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; pattern.contains(value.score) &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:<span class="hljs-type">Range</span>&lt;<span class="hljs-type">Int</span>&gt;,<span class="hljs-params">value</span>:<span class="hljs-type">Student</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; pattern.contains(value.score) &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> stu <span class="hljs-operator">=</span> <span class="hljs-type">Student</span>(score: <span class="hljs-number">80</span>)<br><span class="hljs-keyword">switch</span> stu &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">90</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=90&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">80</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">90</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[80,90)&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">60</span><span class="hljs-operator">...</span><span class="hljs-number">79</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[60,79]&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=0&quot;</span>)<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> <span class="hljs-number">60</span> <span class="hljs-operator">=</span> stu &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=60&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">String</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:(<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span>,<span class="hljs-params">value</span>:<span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; pattern(value) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPrefix</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">prefix</span>:<span class="hljs-type">String</span>)</span> -&gt; ((<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span>.hasPrefix(<span class="hljs-keyword">prefix</span>) &#125; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasSuffix</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">suffix</span>:<span class="hljs-type">String</span>)</span> -&gt; ((<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span>.hasSuffix(suffix) &#125; &#125;<br><br><span class="hljs-keyword">var</span> str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jack&quot;</span><br><span class="hljs-keyword">switch</span> str &#123;<br><span class="hljs-keyword">case</span> hasPrefix(<span class="hljs-string">&quot;j&quot;</span>),hasSuffix(<span class="hljs-string">&quot;k&quot;</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;以j开头，以k结尾&quot;</span>)<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Int</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~=</span> (<span class="hljs-params">pattern</span>:(<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Bool</span>,<span class="hljs-params">value</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; pattern(value) &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEven</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; i<span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isOdd</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Bool</span> &#123; i<span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>&#125;<br><span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br><span class="hljs-keyword">switch</span> age &#123;<br><span class="hljs-keyword">case</span> isEven:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;偶数&quot;</span>)<br><span class="hljs-keyword">case</span> isOdd:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;奇数&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;其他&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">~&gt;</span><br><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">~&gt;=</span><br><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">~&lt;</span><br><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">~&lt;=</span><br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&gt;</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; ((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;</span> i &#125;  &#125;<br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&gt;=</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; ((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;=</span> i &#125;  &#125;<br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&lt;</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; ((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&lt;</span> i &#125;  &#125;<br><span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">~&lt;=</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; ((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Bool</span>) &#123; &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&lt;=</span> i &#125;  &#125;<br><br><span class="hljs-keyword">switch</span> age &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-operator">~&gt;=</span><span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=0&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-operator">~&gt;=</span><span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;=10&quot;</span>)<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h1><blockquote>
<p><code>swift中</code>是没有宏定义的，但是有相关的条件编译</p>
</blockquote>
<ul>
<li><p><code>swift</code>中以下条件编译</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><span class="hljs-comment">//操作系统：macos\iositvosiwatchos\Linux\And roidiWindows\FreeBsD</span><br><span class="hljs-keyword">#if</span> os (macos) 1l os(ios)<br><span class="hljs-number">1</span><span class="hljs-operator">/</span> <span class="hljs-type">CPU架构：13861x86_64</span>\armlarm64<br><span class="hljs-keyword">#elseif</span> arch(<span class="hljs-operator">×</span><span class="hljs-number">86_64</span>) <span class="hljs-operator">||</span> arch (arm64)<br><span class="hljs-comment">// swift版本</span><br><span class="hljs-keyword">#elseif</span> swift(<span class="hljs-operator">&lt;</span><span class="hljs-number">5</span>) <span class="hljs-operator">&amp;&amp;</span> swift(<span class="hljs-operator">&gt;=</span><span class="hljs-number">3</span>)<br><span class="hljs-comment">//模拟器</span><br><span class="hljs-keyword">#elseif</span> targetEnvironment (simulator)<br><span class="hljs-number">1</span><span class="hljs-operator">/</span>可以导入某模块<br><span class="hljs-keyword">#elseif</span> canImport (<span class="hljs-type">Foundat</span> ion)<br><span class="hljs-keyword">#else</span> <span class="hljs-keyword">#endif</span><br></code></pre></td></tr></table></figure></li>
<li><p>条件编译，通过下面的配置标记，可以实现条件编译</p>
</li>
</ul>
<p><img src="1.png"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">#if</span> <span class="hljs-type">TEST</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-keyword">#endif</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>字面量</title>
    <url>/2023/03/19/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%AD%97%E9%9D%A2%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><ul>
<li><code>iOS</code>中字面量默认类型是由于下面定义决定的，下面常见类型<ul>
<li><code>public typealias IntegerLiteralType = Int</code></li>
<li><code>public typealias FloatLiteralType = Double</code></li>
<li><code>public typealias BooleanLiteralType = Bool</code></li>
<li><code>Opublic typealias StringLiteralType = String</code></li>
</ul>
</li>
<li>可以通过<code>typealias</code>修改字面量的默认类型,<code>typealias FloatLiteralType = Float</code>、<code>typealias IntegerLiteralType = UInt8</code></li>
</ul>
<h2 id="字面量协议"><a href="#字面量协议" class="headerlink" title="字面量协议"></a>字面量协议</h2><ul>
<li><code>Swif</code>自带类型之所以能够通过字面量初始化，是因为它们遵守了对应的协议<ul>
<li><code>Bool: ExpressibleByBooleanLiteral</code></li>
<li><code>Int : ExpressibleByIntegerLiteral</code></li>
<li><code>Float. Double : ExpressibleByIntegerLiteral. ExpressibleByFloatLiteral</code></li>
<li><code>Dictionary : ExpressibleByDictionaryLiteral</code></li>
<li><code>String: ExpressibleByStringLiteral</code></li>
<li><code>Array. Set: ExpressibleByArrayLiteral</code></li>
<li><code>Optional: ExpressibleByNilLiteral</code></li>
</ul>
</li>
</ul>
<h2 id="字面量协议的应用"><a href="#字面量协议的应用" class="headerlink" title="字面量协议的应用"></a>字面量协议的应用</h2><ul>
<li>字面量<code>bool</code>给<code>Int</code>赋值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Int</span>: <span class="hljs-title">ExpressibleByBooleanLiteral</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">booleanLiteral</span> <span class="hljs-params">value</span>: <span class="hljs-type">Bool</span>)</span> &#123;<br>        <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> value <span class="hljs-operator">?</span> <span class="hljs-number">1</span>:<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> num:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br><span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure></li>
<li>字面量给对象赋值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:<span class="hljs-title">ExpressibleByIntegerLiteral</span>,<span class="hljs-title">ExpressibleByStringLiteral</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Chen&quot;</span><br>    <span class="hljs-comment">//协议要求的，必须required</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">integerLiteral</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int</span>)</span> &#123; <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> value&#125;<br>    <span class="hljs-keyword">required</span> <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">stringLiteral</span> <span class="hljs-params">value</span>: <span class="hljs-type">String</span>)</span> &#123; <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> value &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> student:<span class="hljs-type">Student</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(student.name,student.age) <span class="hljs-comment">//Chen 20</span><br>student <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Jack&quot;</span><br><span class="hljs-built_in">print</span>(student.name,student.age) <span class="hljs-comment">// Jack 0</span><br></code></pre></td></tr></table></figure></li>
<li>用数组/字典，字面量给结构体/类赋值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Point</span>: <span class="hljs-title">ExpressibleByArrayLiteral</span>,<span class="hljs-title">ExpressibleByDictionaryLiteral</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">arrayLiteral</span> <span class="hljs-params">elements</span>: <span class="hljs-type">Int</span>...)</span> &#123;<br>        <span class="hljs-keyword">for</span> (i,value) <span class="hljs-keyword">in</span> elements.enumerated() &#123;<br>            <span class="hljs-keyword">if</span> i <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123; x <span class="hljs-operator">=</span> value &#125;<br>            <span class="hljs-keyword">if</span> i <span class="hljs-operator">==</span> <span class="hljs-number">1</span> &#123; y <span class="hljs-operator">=</span> value &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">init</span>(<span class="hljs-params">dictionaryLiteral</span> <span class="hljs-params">elements</span>: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)<span class="hljs-operator">...</span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (k,value) <span class="hljs-keyword">in</span> elements &#123;<br>            <span class="hljs-keyword">switch</span> k &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;x&quot;</span>: x <span class="hljs-operator">=</span> value<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;y&quot;</span>:y <span class="hljs-operator">=</span> value<br>                <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> p:<span class="hljs-type">Point</span> <span class="hljs-operator">=</span> [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(p) <span class="hljs-comment">//Point(x: 10, y: 20)</span><br>p <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;x&quot;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&quot;y&quot;</span>:<span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(p) <span class="hljs-comment">//Point(x: 11, y: 20)</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理、作用域、指针</title>
    <url>/2023/03/15/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul>
<li>跟<code>OC</code>一样，<code>Swift</code>也是采取基于引用计数的<code>ARC</code>内存管理方案(针对堆空间）</li>
<li><code>Swift</code>的<code>ARC</code>中有<code>3</code>种引用<ul>
<li>强引用 (<code>strong reference</code> ）：默认情况下，引用都是强引用</li>
<li>弱引用(<code>weak reference</code>）：通过<code>weak</code>定义弱引用<ul>
<li>必须是可选类型的<code>var</code>，因为实例销毁后，<code>ARC</code>会自动将弱引用设置为<code>nil</code></li>
<li><code>ARC</code>自动给弱引用设置<code>nil</code>时，不会<code>触发</code><strong>属性观察器</strong></li>
</ul>
</li>
<li>无主引用 (<code>unowned reference</code>）：通过<code>unowned</code>定义无主引用<ul>
<li>不会产生强引用，实例销毁后仍然存储着实例的内存地址（类似于OC中的<code>unsafe_unretained</code>）</li>
<li>试图在实例销毀后访问无主引用，会产生运行时错误（野指针）</li>
</ul>
</li>
</ul>
</li>
<li><code>weak</code>、<code>unowned</code>只能用在类实例上面</li>
</ul>
<h2 id="内存访问冲突"><a href="#内存访问冲突" class="headerlink" title="内存访问冲突"></a>内存访问冲突</h2><ul>
<li>内存访问冲突会在两个访问满足下列条件时发生：<ol>
<li>至少一个是写入操作</li>
<li>它们访问的是同一块内存</li>
<li>它们的访问时间重叠（比如在同一个函数内）</li>
</ol>
</li>
<li>例子<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> ad <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-comment">//出现内存访问冲突</span><br><span class="hljs-comment">//Thread 1: Simultaneous accesses to 0x10000c870, but modification requires exclusive access</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>(<span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">+=</span> ad<br>&#125;<br>test1(num: <span class="hljs-operator">&amp;</span>ad)<br></code></pre></td></tr></table></figure></li>
<li>解决方式,用一个临时变量取值，这样同一个函数中，就有两个地址了<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> temp <span class="hljs-operator">=</span> ad<br>test1(num: <span class="hljs-operator">&amp;</span>temp)<br>ad <span class="hljs-operator">=</span> temp<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="结构体和元祖的特殊情况"><a href="#结构体和元祖的特殊情况" class="headerlink" title="结构体和元祖的特殊情况"></a>结构体和元祖的特殊情况</h2><ul>
<li><strong>注意</strong>,元组和结构体的内存地址均在一块， 如果在全局区，苹果设计，不能同时访问其成员内存<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>(<span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>,<span class="hljs-params">num2</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">+=</span> num2<br>&#125;<br><br><span class="hljs-comment">//出现内存访问冲突</span><br><span class="hljs-keyword">var</span> temp <span class="hljs-operator">=</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>test1(num: <span class="hljs-operator">&amp;</span>temp.<span class="hljs-number">0</span>, num2: <span class="hljs-operator">&amp;</span>temp.<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//出现内存访问冲突</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Num</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> num2:<span class="hljs-type">Int</span><br>&#125;<br><span class="hljs-keyword">var</span> temp <span class="hljs-operator">=</span> <span class="hljs-type">Num</span>(num1: <span class="hljs-number">1</span>, num2: <span class="hljs-number">2</span>)<br>test1(num: <span class="hljs-operator">&amp;</span>temp.num1, num2: <span class="hljs-operator">&amp;</span>temp.num2)<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,如果满足下面的条件，则可以同时访问。（在<code>swift</code>的安全限制中，因为是局部变量，只在函数作用域，不像全局变量一样，存在被其他函数访问的风险）<ul>
<li>你只访问实例存储属性，不是计算属性(是实例属性的话，也是可以的)或者类属性</li>
<li>结构体是<code>局部变量</code>而<code>非全局变量</code></li>
<li>结构体要么没有被闭包捕获要么只被非逃逸闭包捕获<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> temp <span class="hljs-operator">=</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>    test1(num: <span class="hljs-operator">&amp;</span>temp.<span class="hljs-number">0</span>, num2: <span class="hljs-operator">&amp;</span>temp.<span class="hljs-number">1</span>)<br><br>    <br>    <span class="hljs-keyword">var</span> temp2 <span class="hljs-operator">=</span> <span class="hljs-type">Num</span>(num1: <span class="hljs-number">1</span>, num2: <span class="hljs-number">2</span>)<br>    test1(num: <span class="hljs-operator">&amp;</span>temp2.num1, num2: <span class="hljs-operator">&amp;</span>temp2.num2)<br>&#125;<br>test()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><blockquote>
<p><code>do</code>不仅可以和<code>catch</code>一起用，还可以单独使用，作为局部作用域，和<code>OC</code>不同不能用单纯的<code>&#123;&#125;</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="子类重写父类成员需要注意的是"><a href="#子类重写父类成员需要注意的是" class="headerlink" title="子类重写父类成员需要注意的是"></a>子类重写父类成员需要注意的是</h2><ul>
<li>子类重写成员的访问级别必须 <code>≥</code>子类的访问级别，或者<code>≥</code>父类被重写成员的访问级别<ul>
<li>这里<code>TestH</code>定义为<code>private</code>但是和<code>Test</code>在同一文件，实际可以认为是<code>fileprivate</code></li>
<li>子类重写父类，其访问基本必须大于等于子类，或者父类的，因此显示添加<code>private</code>无法编译，因为<code>TestH</code>实际是<code>fileprivate</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestH</span>: <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>父类的成员不能被成员作用域外定义的子类重写<ul>
<li>子类无法访问到父类成员，不会重写<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-operator">----</span> 不会重写<span class="hljs-operator">----</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestH</span>: <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-operator">----</span> 会重写<span class="hljs-operator">----</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestH</span>: <span class="hljs-title">Test</span> </span>&#123;<br>         <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="不安全的指针"><a href="#不安全的指针" class="headerlink" title="不安全的指针"></a>不安全的指针</h2><ul>
<li>为什么说指针不安全？<ol>
<li>⽐如我们在创建⼀个对象的时候，是需要在堆分配内存空间的。但是这个内存空间的声明周期是有限的，也就意味着如果我们使⽤指针指向这块内容空间，如果当前内存空间的⽣命周期啊到了（引⽤计数为<code>0</code>），那么我们当前的指针是不是就变成了未定义的⾏为了（野指针）</li>
<li>我们创建的内存空间是有边界的，⽐如我们创建⼀个⼤⼩为<code>10</code>的数组，这个时候我们通过指针访问 到了 <code>index = 11</code> 的位置，这个时候是不是就越界了，访问了⼀个未知的内存空间。</li>
<li>指针类型与内存的值类型不⼀致，也是不安全的。（<code>Int *</code> 和 <code>Int8 *</code>类型容易造成精度缺失）</li>
</ol>
</li>
</ul>
<h2 id="指针的类别"><a href="#指针的类别" class="headerlink" title="指针的类别"></a>指针的类别</h2><ul>
<li><code>Swift</code>中也有专门的指针类型，这些都被定性为“<code>Unsafe</code>”（不安全的），常见的有以下<code>4</code>种类型<ul>
<li><code>UnsafePointer&lt;Pointee&gt;</code>类似于 <code>const Pointee *</code></li>
<li><code>UnsafeMutablePointercPointee&gt;</code>类似于 <code>Pointee *</code></li>
<li><code>UnsafeRawPointer</code> 类似于 <code>const void *</code></li>
<li><code>UnsafeMutableRawPointer</code> 类似于 <code>void *</code></li>
</ul>
</li>
<li>一些指针的方法,类型指针，不需要管理内存<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 值类型</span><br><span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-comment">//创建一个指针</span><br><span class="hljs-keyword">var</span> ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafeMutablePointer</span>(to: <span class="hljs-operator">&amp;</span>age) &#123;<span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>)&#125;<br><br><span class="hljs-comment">// 引用类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br><br><span class="hljs-comment">//拿到的是person指针变量的地址</span><br><span class="hljs-keyword">var</span> ptr2 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>person) &#123; <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>) &#125;<br><br><span class="hljs-comment">//获取地址上存储的数据</span><br><span class="hljs-keyword">let</span> bitPattern <span class="hljs-operator">=</span> ptr2.load(as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<br><span class="hljs-comment">//根据传入的值，生成地址，这里ptr3 == person，和person指针相同，都指向堆地址</span><br><span class="hljs-keyword">var</span> ptr3 <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(bitPattern: bitPattern)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建原生指针"><a href="#创建原生指针" class="headerlink" title="创建原生指针"></a>创建原生指针</h3><blockquote>
<ul>
<li>对于原生指针的内存管理是需要手动管理</li>
<li>原生指针在使用完需要手动释放</li>
</ul>
</blockquote>
<h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> ptr4 <span class="hljs-operator">=</span> malloc(<span class="hljs-number">16</span>)<br><br><span class="hljs-comment">//存</span><br>ptr4<span class="hljs-operator">?</span>.storeBytes(of: <span class="hljs-number">11</span>, as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>) <br>ptr4<span class="hljs-operator">?</span>.storeBytes(of: <span class="hljs-number">22</span>, toByteOffset: <span class="hljs-number">8</span>,as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<br><br><span class="hljs-comment">//取</span><br><span class="hljs-built_in">print</span>(ptr4<span class="hljs-operator">?</span>.load(as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<span class="hljs-operator">!</span>) <span class="hljs-comment">// 11</span><br><span class="hljs-comment">//偏移8字节存储</span><br><span class="hljs-built_in">print</span>(ptr4<span class="hljs-operator">?</span>.load(fromByteOffset: <span class="hljs-number">8</span>, as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<span class="hljs-operator">!</span>) <span class="hljs-comment">// 22</span><br><span class="hljs-comment">//销毁</span><br>free(ptr4)<br></code></pre></td></tr></table></figure>
</code></pre>
<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> ptr5 <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="hljs-number">16</span>, alignment: <span class="hljs-number">1</span>)<br>ptr5.storeBytes(of: <span class="hljs-number">11</span>, as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<br>ptr5.advanced(by: <span class="hljs-number">8</span>).storeBytes(of: <span class="hljs-number">22</span>, as: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>)<br>ptr5.deallocate()<br></code></pre></td></tr></table></figure>
</code></pre>
<h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> ptr6 <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Int</span>&gt;.allocate(capacity: <span class="hljs-number">2</span>)<br><span class="hljs-comment">//对两个int重复赋予 11</span><br><span class="hljs-comment">//ptr6.initialize(repeating: 11, count: 2)</span><br>ptr6.initialize(to: <span class="hljs-number">11</span>)<br><span class="hljs-comment">//下一个存储的int</span><br>ptr6.successor().initialize(to: <span class="hljs-number">20</span>)<br><span class="hljs-comment">// (ptr6 + 1).initialize(to: 20)</span><br><span class="hljs-comment">// ptr6[1].initialize(to: 20)</span><br><br><span class="hljs-comment">//已经确定是int的，所以1就是8字节</span><br><span class="hljs-built_in">print</span>(ptr6.pointee) <span class="hljs-comment">// 11</span><br><span class="hljs-built_in">print</span>((ptr6 <span class="hljs-operator">+</span> <span class="hljs-number">1</span>).pointee) <span class="hljs-comment">// 20</span><br><span class="hljs-built_in">print</span>(ptr6[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 11</span><br><span class="hljs-built_in">print</span>(ptr6[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 20</span><br><br><span class="hljs-comment">//和第二种相比，要反初始化,否则会存在内存泄漏</span><br>ptr6.deinitialize(count: <span class="hljs-number">2</span>)<br>ptr6.deallocate() <br></code></pre></td></tr></table></figure>
  
</code></pre>
<h3 id="指针转换"><a href="#指针转换" class="headerlink" title="指针转换"></a>指针转换</h3><ul>
<li><code>unsafeBitcast</code>是忽略数据类型的强制转换，不会因为数据类型的变化而改变原来的内存数据<ul>
<li>例如<code>var age:Int = 10, age2:Double = Double(age)</code>,<code>Int</code>转换成<code>Double</code>时，其存储的数据是会发生改变的。但是用<code>unsafeBitcast</code>转换是不会的，也就是<code>10</code>转换成<code>Double</code>后，其<code>Double</code>上的数据是<code>0xa</code>，但并不一定是10</li>
<li><code>var ptr8 = unsafeBitCast(person, to: UnsafeRawPointer.self)</code>,<code>ptr8</code>和<code>person</code>指针一样，指向堆地址<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> ptr7 <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="hljs-number">16</span>, alignment: <span class="hljs-number">1</span>)<br><br>ptr7.assumingMemoryBound(to: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>).pointee <span class="hljs-operator">=</span> <span class="hljs-number">11</span><br><span class="hljs-comment">//这里因为不知到什么类型，+8，实际是偏移8字节</span><br>(ptr7 <span class="hljs-operator">+</span> <span class="hljs-number">8</span>).assumingMemoryBound(to: <span class="hljs-type">Double</span>.<span class="hljs-keyword">self</span>).pointee <span class="hljs-operator">=</span> <span class="hljs-number">22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">unsafeBitCast</span>(ptr7, to: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt;.<span class="hljs-keyword">self</span>).pointee) <span class="hljs-comment">//11</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">unsafeBitCast</span>(ptr7 <span class="hljs-operator">+</span> <span class="hljs-number">8</span>, to: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt;.<span class="hljs-keyword">self</span>).pointee) <span class="hljs-comment">// 4626885667169763328</span><br><br>ptr7.deallocate()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="内存绑定"><a href="#内存绑定" class="headerlink" title="内存绑定"></a>内存绑定</h2><blockquote>
<ul>
<li><code>swift</code> 提供了三种不同的 <code>API</code> 来绑定/重新绑定指针：<ol>
<li><code>assumingMemoryBound(to:)</code></li>
<li><code>bindMemory(to: capacity:)</code></li>
<li><code>withMemoryRebound(to: capacity: body:)</code></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="assumingMemoryBound-to"><a href="#assumingMemoryBound-to" class="headerlink" title="assumingMemoryBound(to:)"></a><code>assumingMemoryBound(to:)</code></h3><blockquote>
<p>只是让编译器绕过类型检查，并没有发⽣实际类型的转换,一种假定绑定的状态，实际绑定要用<code>bindMemory(to: capacity:)</code></p>
</blockquote>
<ol>
<li>有些时候我们处理代码的过程中，只有<code>原始指针</code>（没有保留<code>指针类型</code>），但此刻对于处理代码的我们来 说明确知道指针的类型，我们就可以使⽤ <code>assumingMemoryBound(to:)</code> 来告诉编译器预期的类型。 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tuple <span class="hljs-operator">=</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>tuple) &#123; tuplePtr <span class="hljs-keyword">in</span><br>    testPointer(tuplePtr)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testPointer</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">p</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt;)</span> &#123;<br>    <span class="hljs-built_in">print</span>(p[<span class="hljs-number">0</span>])<br>    <span class="hljs-built_in">print</span>(p[<span class="hljs-number">1</span>])<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>此时在调用<code>testPointer</code>会报编译器错误 <code>Cannot convert value of type &#39;UnsafePointer&lt;(Int, Int)&gt;&#39; to expected argument type &#39;UnsafePointer&lt;Int&gt;&#39;</code>,修改如下: <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tuple <span class="hljs-operator">=</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>tuple) &#123; tuplePtr <span class="hljs-keyword">in</span><br>    testPointer(<span class="hljs-type">UnsafeRawPointer</span>(tuplePtr).assumingMemoryBound(to: <span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testPointer</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">p</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt;)</span> &#123;<br>    <span class="hljs-built_in">print</span>(p[<span class="hljs-number">0</span>])<br>    <span class="hljs-built_in">print</span>(p[<span class="hljs-number">1</span>])<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>元组是值类型，在本质上这块内存空间是连续的，存放Int类型数据。先把元组转化成指针指向元组的首地址<code>tuple[0]</code>，通过<code>assumingMemoryBound(to:)</code>告诉编译器，当前元组的内存已经绑定过<code>Int</code>了，这时就能骗过编译器检查。</li>
</ol>
<h3 id="bindMemory-to-capacity"><a href="#bindMemory-to-capacity" class="headerlink" title="bindMemory(to: capacity:)"></a><code>bindMemory(to: capacity:)</code></h3><blockquote>
<p>⽤于更改内存绑定的类型，如果当前内存还没有类型绑定，则将⾸次绑定为该类型；否则重新绑定该类型，并且内存中所有的值都会变成该类型。</p>
</blockquote>
<h4 id="class实例绑定成class的底层数据结构"><a href="#class实例绑定成class的底层数据结构" class="headerlink" title="class实例绑定成class的底层数据结构"></a><code>class</code>实例绑定成<code>class</code>的底层数据结构</h4><ol>
<li><code>swift</code>源码可知<code>clas</code>的底层结构是<code>HeapObject</code> <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapObject</span> </span>&#123;<br><span class="hljs-keyword">var</span> metadata: <span class="hljs-type">UnsafeRawPointer</span> <span class="hljs-comment">// 定义一个未知类型的指针</span><br><span class="hljs-keyword">var</span> refCounts: <span class="hljs-type">UInt32</span> <span class="hljs-comment">// 引用计数</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>metadata</code>其实也是一个结构体 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Metadata</span> </span>&#123; <br>  <span class="hljs-keyword">var</span> kind: <span class="hljs-type">Int</span> <br>  <span class="hljs-keyword">var</span> superClass: <span class="hljs-keyword">Any</span>.<span class="hljs-keyword">Type</span> <br>  <span class="hljs-keyword">var</span> cacheData: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) <br>  <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span> <br>  <span class="hljs-keyword">var</span> classFlags: <span class="hljs-type">Int32</span> <br>  <span class="hljs-keyword">var</span> instanceAddressPoint: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> instanceSize: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> instanceAlignmentMask: <span class="hljs-type">UInt16</span> <br>  <span class="hljs-keyword">var</span> reserved: <span class="hljs-type">UInt16</span> <br>  <span class="hljs-keyword">var</span> classSize: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> classAddressPoint: <span class="hljs-type">UInt32</span> <br>  <span class="hljs-keyword">var</span> typeDescriptor: <span class="hljs-type">UnsafeMutableRawPointer</span> <br>  <span class="hljs-keyword">var</span> iVarDestroyer: <span class="hljs-type">UnsafeRawPointer</span><br> &#125;<br></code></pre></td></tr></table></figure></li>
<li>将<code>Circle</code>绑定到结构体内存中: <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-keyword">let</span> diameter:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>通过<code>Unmanaged</code>指定内存管理,类似于<code>OC</code>与<code>CF</code>的桥接交互方式,通过<code>bindMemory</code>进行内存绑定<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br><span class="hljs-comment">// 通过Unmanaged指定内存管理，类似于OC与CF的交互方式（所有权的转换 __bridge）</span><br><span class="hljs-comment">// passUnretained 不增加引用计数，即不需要获取所有权</span><br><span class="hljs-comment">// passRetained 增加引用技术，即需要获取所有权</span><br><span class="hljs-comment">// toOpaque 不透明的指针</span><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passUnretained(circle).toOpaque()<br><span class="hljs-comment">// bindMemory更改当前UnsafeMutableRawPointer的指针类型，绑定到具体类型值</span><br><span class="hljs-comment">// - 如果没有绑定，则绑定</span><br><span class="hljs-comment">// - 如果已经绑定，则重定向到 HeapObject类型上</span><br><span class="hljs-keyword">let</span> heapObject <span class="hljs-operator">=</span> ptr.bindMemory(to: <span class="hljs-type">HeapObject</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(heapObject.pointee.metadata) <span class="hljs-comment">// 0x0000000100008110</span><br><span class="hljs-built_in">print</span>(heapObject.pointee.refCounts) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">let</span> metadataPtr <span class="hljs-operator">=</span> heapObject.pointee.metadata.bindMemory(to: <span class="hljs-type">Metadata</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(metadataPtr.pointee) <span class="hljs-comment">// Metadata(kind: 4295000280, superClass: _TtCs12_SwiftObject, cacheData: (140703243243968, -9212113037786349568), data: -9223266483736374430, classFlags: 2, instanceAddressPoint: 0, instanceSize: 32, instanceAlignmentMask: 7, reserved: 0, classSize: 144, classAddressPoint: 16, typeDescriptor: 0x0000000100003cb8, iVarDestroyer: 0x0000000000000000)</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="withMemoryRebound-to-capacity-body"><a href="#withMemoryRebound-to-capacity-body" class="headerlink" title="withMemoryRebound(to: capacity: body:)"></a><code>withMemoryRebound(to: capacity: body:)</code></h3><ol>
<li>当我们在给外部函数传递参数时，不免会有⼀些数据类型上的差距。如果我们进⾏类型转换，必然要来回复制数据；这个时候我们就可以使⽤ <code>withMemoryRebound(to: capacity: body:)</code> 来临时更 改内存绑定类型，<code>block</code>中临时绑定完后返回原来的状态。 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>num) &#123; ptr: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int</span>&gt; <span class="hljs-keyword">in</span><br>    testPointer2(ptr)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testPointer2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">p</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;)</span> &#123;<br>    <span class="hljs-built_in">print</span>(p)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>此时编译器报错因为类型不匹配。使用<code>withMemoryRebound(to: capacity: body:)</code>修改后： <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> ptr1 <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>num) &#123;<span class="hljs-variable">$0</span>&#125;<br>ptr1.withMemoryRebound(to: <span class="hljs-type">Int8</span>.<span class="hljs-keyword">self</span>, capacity: <span class="hljs-number">1</span>) &#123; (ptr: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;)  <span class="hljs-keyword">in</span><br>    testPointer2(ptr)<br>    <span class="hljs-comment">// 超过了闭包作用域，则不是UnsafePointer&lt;Int8&gt;类型</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testPointer2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">p</span>: <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;)</span> &#123;<br>    <span class="hljs-built_in">print</span>(p)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>高级运算符和扩展</title>
    <url>/2023/03/14/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h1><ul>
<li>在全局作用域使用<code>operator</code>进行声明<ul>
<li><code>prefix operator</code> 前缀运算符</li>
<li><code>suffix operator</code> 后缀运算符</li>
<li><code>infix operator</code> 中缀运算符：优先级组</li>
</ul>
</li>
<li>自定义优先组<ul>
<li><code>associativity</code>,结合性，指多个运算符能否一起用，类似<code>1 + 1 + 1</code>,<code>left</code>和<code>right</code>指多个运算符，从哪个方向开始算</li>
<li><code>higherThan</code>和<code>1owerThan</code>,比系统的优先级高或低，<a href="https://developer.apple.com/documentation/swift/operator-declarations">系统运算符参考</a></li>
<li><code>assignment</code>支持出现可选链出现<code>nil</code>的情况，例如<code>p1?.point +- Point(x: 1, y: 3)</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift">precedenceqroup 优先级组&#123;<br>    associativity：结合性(left\rightinone)<br>    higherThan：比谁的优先级高<br>    1owerThan：比谁的优先級低<br>    assignment：<span class="hljs-literal">true</span> 代表在可选链操作中拥有跟赋值运算符一样的优先級<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><blockquote>
<p><code>Swif</code>中的扩展，有点类似于<code>OC</code>中的分类 (<code>Category</code>)</p>
</blockquote>
<ul>
<li><p>扩展可以为枚举、结构体、类、协议添加新功能</p>
<ul>
<li>可以添加方法、计算属性、下标、（便捷）初始化器、嵌套类型、协议等等</li>
</ul>
</li>
<li><p>扩展不能办到的事情</p>
<ul>
<li>不能覆盖原有的功能</li>
<li>不能重写父类中的方法</li>
<li>不能添加存储属性 ，不能向已有的属性添加属性观察器</li>
<li>不能添加父类</li>
<li>不能添加指定初始化器，不能添加反初始化器</li>
</ul>
</li>
<li><p>注意，扩展中的方法的调用是采用<code>静态派发</code>的方式（类似<code>结构体</code>中的<code>方法</code>），扩展中的方法是不会加到<code>类的虚表</code>中的（因此在扩展中不能重写<code>父类的方法</code>）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Array</title>
    <url>/2023/03/13/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/Array/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Array的内存"><a href="#Array的内存" class="headerlink" title="Array的内存"></a>Array的内存</h1><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.stride(ofValue: arr)) <span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure>
<ul>
<li>数组是结构体，但其内存占用是<code>8</code>字节，而并非，其数组内<code>int</code>存储的总和，<ul>
<li>实际上数组生成在堆空间，其<code>8</code>字节是堆空间</li>
<li>汇编查看,显然在数组初始化的时候，调用了<code>alloc</code>，在堆空间中创建了内存<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">  <span class="hljs-operator">*</span> thread #<span class="hljs-number">1</span>, queue <span class="hljs-operator">=</span> &#x27;com.apple.main<span class="hljs-operator">-</span>thread&#x27;, stop reason <span class="hljs-operator">=</span> breakpoint <span class="hljs-number">4.1</span><br><span class="hljs-operator">*</span> frame #<span class="hljs-number">0</span>: <span class="hljs-number">0x00007ff81a193e62</span> libswiftCore.dylib`swift_allocObject <span class="hljs-operator">+</span> <span class="hljs-number">34</span><br>  frame #<span class="hljs-number">1</span>: <span class="hljs-number">0x00007ff819e9e533</span> libswiftCore.dylib`<span class="hljs-type">Swift</span>._allocateUninitializedArray<span class="hljs-operator">&lt;</span>τ_0_0<span class="hljs-operator">&gt;</span>(<span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>) -&gt; (<span class="hljs-type">Swift</span>.<span class="hljs-type">Array</span>&lt;τ_0_0&gt;, <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>) <span class="hljs-operator">+</span> <span class="hljs-number">83</span><br>  frame #<span class="hljs-number">2</span>: <span class="hljs-number">0x0000000100004275</span> <span class="hljs-type">SwiftDText</span>`main at main.swift:<span class="hljs-number">26</span>:<span class="hljs-number">7</span><br>  frame #<span class="hljs-number">3</span>: <span class="hljs-number">0x00007ff80b6fd310</span> dyld`start <span class="hljs-operator">+</span> <span class="hljs-number">2432</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数组在堆中的内存数据查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-comment">//&amp;arr</span><br>x<span class="hljs-operator">/</span>4xg <span class="hljs-number">0x10000C3A0</span><br><span class="hljs-number">0x10000c3a0</span>: <span class="hljs-number">0x0000600002104000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x10000c3b0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-comment">// 数组上内存的情况</span><br>x<span class="hljs-operator">/</span>10xg <span class="hljs-number">0x0000600002104000</span><br><span class="hljs-number">0x600002104000</span>: <span class="hljs-number">0x00007ff84e38f7b0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600002104010</span>: <span class="hljs-number">0x0000000000000005</span> <span class="hljs-number">0x000000000000000a</span><br><span class="hljs-number">0x600002104020</span>: <span class="hljs-number">0x0000000000000001</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x600002104030</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600002104040</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li>显然，数组和引用类型相似，其真正存储的值在堆空间，该堆空间，<ul>
<li>第一个<code>8</code>字节是<code>metaData</code>,</li>
<li>第二个<code>8</code>字节存放是引用计数</li>
<li>第三个<code>8</code>字节存放是数组长度，第四个<code>8</code>字节是数组的容量，（<code>长度</code>大于容量的<code>一半</code>，则容量会进行倍数扩容）</li>
<li>往后字节存放数组中存放的值，上面介绍的是整型，下面介绍其他类型的<ul>
<li>注意如果是<code>Any</code>，则除数据本身外，还会有介绍数据类型相关的字节，每个内容占<code>4</code><strong>字节</strong><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//字符串</span><br><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]<br><span class="hljs-number">0x60000260c000</span>: <span class="hljs-number">0x00007ff84e38eaa0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x60000260c010</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000008</span><br><span class="hljs-number">0x60000260c020</span>: <span class="hljs-number">0x0000000000000031</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x60000260c030</span>: <span class="hljs-number">0x0000000000000032</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x60000260c040</span>: <span class="hljs-number">0x0000000000000033</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x60000260c050</span>: <span class="hljs-number">0x0000000000000034</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-comment">// Any  var arr = [&quot;1&quot;,2,3,&quot;4&quot;]</span><br><span class="hljs-number">0x6000033080a0</span>: <span class="hljs-number">0x00007ff84e38eb70</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x6000033080b0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000000000008</span><br><span class="hljs-number">0x6000033080c0</span>: <span class="hljs-number">0x0000000000000031</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x6000033080d0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x00007ff84ef72ad8</span><br><span class="hljs-number">0x6000033080e0</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000033080f0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x00007ff84ef74a40</span><br><span class="hljs-number">0x600003308100</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x600003308110</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x00007ff84ef74a40</span><br><span class="hljs-number">0x600003308120</span>: <span class="hljs-number">0x0000000000000034</span> <span class="hljs-number">0xe100000000000000</span><br><span class="hljs-number">0x600003308130</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x00007ff84ef72ad8</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>扩容方式查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> arr <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>]()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">3</span> &#123;<br>    arr.append(i)<br>&#125;<br><span class="hljs-comment">// 数组地址 0x000000010000c260</span><br><span class="hljs-comment">// [0]</span><br>x<span class="hljs-operator">/</span>xg <span class="hljs-number">0x000000010000c260</span><br><span class="hljs-number">0x10000c260</span>: <span class="hljs-number">0x0000600000c00bd0</span><br>x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x0000600000c00bd0</span><br><span class="hljs-number">0x600000c00bd0</span>: <span class="hljs-number">0x00007ff84e38f7b0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000c00be0</span>: <span class="hljs-number">0x0000000000000001</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600000c00bf0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><br><span class="hljs-comment">// [0,1]</span><br>x<span class="hljs-operator">/</span>xg <span class="hljs-number">0x000000010000c260</span><br><span class="hljs-number">0x10000c260</span>: <span class="hljs-number">0x0000600000c00bd0</span><br>x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x0000600000c00bd0</span><br><span class="hljs-number">0x600000c14000</span>: <span class="hljs-number">0x00007ff84e38f7b0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000c14010</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x0000000000000004</span><br><span class="hljs-number">0x600000c14020</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000001</span><br><br><span class="hljs-comment">// [0,1,2]</span><br>x<span class="hljs-operator">/</span>xg <span class="hljs-number">0x000000010000c260</span><br><span class="hljs-number">0x10000c260</span>: <span class="hljs-number">0x0000600001700600</span><br>x<span class="hljs-operator">/</span>8xg <span class="hljs-number">0x0000600001700600</span><br><span class="hljs-number">0x600001700600</span>: <span class="hljs-number">0x00007ff84e38f7b0</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600001700610</span>: <span class="hljs-number">0x0000000000000003</span> <span class="hljs-number">0x0000000000000008</span><br><span class="hljs-number">0x600001700620</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000001</span><br><span class="hljs-number">0x600001700630</span>: <span class="hljs-number">0x0000000000000002</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li>显然扩容在数组实际长度达到容量值的<code>一半以上</code>之后，就会进行扩容，此时会重新申请堆空间构建数组</li>
<li><strong>注意</strong>,<code>Array</code>在<code>swift</code>中是值类型，但其本质实际上是<code>引用类型</code>，其内存存储在<code>堆空间</code>中，在<code>swift</code>中设置为<code>struct</code>只是表明<code>Array</code>在<code>swift</code>中使用的<code>行为</code>是按结构体的方式来编写代码的,其本质仍是引用类型。</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2023/03/12/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个字符串变量占用多少内存"><a href="#一个字符串变量占用多少内存" class="headerlink" title="一个字符串变量占用多少内存"></a>一个字符串变量占用多少内存</h1><blockquote>
<p>显然一个字符串占有<code>16</code>个字节</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789&quot;</span><br><span class="hljs-keyword">var</span> str2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789ABCDEFGHIGK&quot;</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">String</span>&gt;.stride. <span class="hljs-comment">//16</span><br><span class="hljs-type">MemoryLayout</span>.stride(ofValue: str1) <span class="hljs-comment">//16</span><br><span class="hljs-type">MemoryLayout</span>.stride(ofValue: str2) <span class="hljs-comment">//16</span><br></code></pre></td></tr></table></figure>

<h1 id="字符串的底层存储"><a href="#字符串的底层存储" class="headerlink" title="字符串的底层存储"></a>字符串的底层存储</h1><h2 id="小于长度0xF的字符串"><a href="#小于长度0xF的字符串" class="headerlink" title="小于长度0xF的字符串"></a>小于长度<code>0xF</code>的字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>汇编查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x10000dfd9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000e1c2</span>               ; symbol stub <span class="hljs-keyword">for</span>: <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(_builtinStringLiteral: <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, utf8CodeUnitCount: <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, isASCII: <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span><br>    <span class="hljs-number">0x10000dfde</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">30</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0x71fb</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.str1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span><br>    <span class="hljs-number">0x10000dfe5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">37</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rdx, <span class="hljs-number">0x71fc</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.str1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li>
<li>分析，这里将<code>rax</code>和<code>rdx</code>的分别赋值给了<code>str1</code>(地址是<code>0x1000151E0</code>)的前8个字节和后8个字节，<code>register read rax</code>查看<ul>
<li><code>x 0x1000151E0</code> -&gt; <code>30 31 32 33 34 35 36 37 38 39 00 00 00 00 00 ea</code>,查看<code>str1</code>地址内存,小端模式（低低高高）</li>
<li><code>rax = 0x3736353433323130</code>，<code>rdx = 0xea00000000003938</code>,根据<a href="https://www.ascii-code.com/">ASCII码表</a>可知<code>30-39</code>是<code>0-9</code>。<strong>显然</strong>,字符串直接存储在<code>str1</code>地址的内存上</li>
<li><code>0xea</code>,存储的实际是字符串的<code>tag</code>和长度，其中<code>e</code>是<code>tag</code>,而<code>a</code>是<code>10</code>即字符串的长度<ul>
<li><code>&quot;0123456789ABCDE&quot;</code>的内存<code>30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 ef</code>,显然最后的长度变成了<code>f</code>即<code>15</code>,<code>e</code>是<code>tag</code></li>
<li><code>&quot;0123456789ABCDEF&quot;</code>上<code>10 00 00 00 00 00 00 d0 f0 f5 00 00 01 00 00 80</code>,<code>0xd000000000000010</code> + <code>0x800000010000f5f0</code>,显然和前面的不同。其存储的方式发生了改变</li>
</ul>
</li>
<li><strong>总结</strong>，如果字符串长度小于<code>0xF</code>，其字符串直接存储在地址的内存上，其第<code>16</code>个字节上，存储者字符串的<code>tag</code>和<code>长度</code>。而字符串长度大于<code>0xF</code>，其存储方式发生了改变</li>
</ul>
</li>
</ul>
<h2 id="大于长度0xF的字符串"><a href="#大于长度0xF的字符串" class="headerlink" title="大于长度0xF的字符串"></a>大于长度<code>0xF</code>的字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>根据其内存，其内存地址是 <code>0xd000000000000010</code> + <code>0x8000000100003f50</code></li>
<li>汇编查看<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x10000dfb8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:   leaq   <span class="hljs-number">0x1651</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span><br>    <span class="hljs-number">0x10000dfbf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x10, <span class="hljs-operator">%</span>esi<br>    <span class="hljs-number">0x10000dfc4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">20</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edx<br>-&gt;  <span class="hljs-number">0x10000dfc9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000e1b2</span>               ; symbol stub <span class="hljs-keyword">for</span>: <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(_builtinStringLiteral: <span class="hljs-type">Builtin</span>.<span class="hljs-type">RawPointer</span>, utf8CodeUnitCount: <span class="hljs-type">Builtin</span>.<span class="hljs-type">Word</span>, isASCII: <span class="hljs-type">Builtin</span>.<span class="hljs-type">Int1</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span><br>    <span class="hljs-number">0x10000dfce</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">30</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0x720b</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.str1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span><br>    <span class="hljs-number">0x10000dfd5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">37</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rdx, <span class="hljs-number">0x720c</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.str1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br>    <br><span class="hljs-operator">-------</span><br>libswiftCore.dylib`<span class="hljs-type">Swift</span>.<span class="hljs-type">String</span>.<span class="hljs-keyword">init</span><br>    <span class="hljs-number">0x7ff819e87ae0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">32</span><span class="hljs-operator">&gt;</span>:  cmpq   <span class="hljs-variable">$0</span>xf, <span class="hljs-operator">%</span>rsi<br>    <span class="hljs-number">0x7ff819e87ae4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">36</span><span class="hljs-operator">&gt;</span>:  jle    <span class="hljs-number">0x7ff819e87b26</span>            ; <span class="hljs-operator">&lt;+</span><span class="hljs-number">102</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-number">0x7ff819e87ae6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">38</span><span class="hljs-operator">&gt;</span>:  movabsq $<span class="hljs-operator">-</span><span class="hljs-number">0x4000000000000000</span>, <span class="hljs-operator">%</span>rcx ; imm <span class="hljs-operator">=</span> <span class="hljs-number">0xC000000000000000</span> <br>    <span class="hljs-number">0x7ff819e87af0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">48</span><span class="hljs-operator">&gt;</span>:  orq    <span class="hljs-operator">%</span>rsi, <span class="hljs-operator">%</span>rcx<br>    <span class="hljs-number">0x7ff819e87af3</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">51</span><span class="hljs-operator">&gt;</span>:  testb  <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>al<br>    <span class="hljs-number">0x7ff819e87af5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">53</span><span class="hljs-operator">&gt;</span>:  cmoveq <span class="hljs-operator">%</span>rsi, <span class="hljs-operator">%</span>rcx<br>    <span class="hljs-number">0x7ff819e87af9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">57</span><span class="hljs-operator">&gt;</span>:  movabsq <span class="hljs-variable">$0</span>x1000000000000000, <span class="hljs-operator">%</span>rax ; imm <span class="hljs-operator">=</span> <span class="hljs-number">0x1000000000000000</span> <br>    <span class="hljs-number">0x7ff819e87b03</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">67</span><span class="hljs-operator">&gt;</span>:  orq    <span class="hljs-operator">%</span>rcx, <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x7ff819e87b06</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">70</span><span class="hljs-operator">&gt;</span>:  movabsq <span class="hljs-variable">$0</span>x7fffffffffffffe0, <span class="hljs-operator">%</span>rdx ; imm <span class="hljs-operator">=</span> <span class="hljs-number">0x7FFFFFFFFFFFFFE0</span> <br>    <span class="hljs-number">0x7ff819e87b10</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">80</span><span class="hljs-operator">&gt;</span>:  addq   <span class="hljs-operator">%</span>rdx, <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x7ff819e87b13</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">83</span><span class="hljs-operator">&gt;</span>:  addq   <span class="hljs-variable">$0</span>x20, <span class="hljs-operator">%</span>rdx<br>-&gt;  <span class="hljs-number">0x7ff819e87b17</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">87</span><span class="hljs-operator">&gt;</span>:  orq    <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">%</span>rdx<br></code></pre></td></tr></table></figure></li>
<li>分析,这里字符串<code>&quot;0123456789ABCDEF&quot;</code>的地址赋值给了<code>rdi = 0x0000000100003f70  &quot;0123456789ABCDEF&quot;</code>,将字符串的长度<code>0x10</code>传给了<code>esi</code>（即<code>rsi</code>）</li>
<li>在<code>Swift.String.init</code>方法中会<code>cmpq   $0xf, %rsi</code>会对字符串的长度，进行判断然后处理，这里<code>addq   %rdx, %rdi</code>,这里将<code>rdx</code>和<code>rdi</code>中的值相加，然后赋值给<code>rdi</code>(最终复制给了<code>rdx</code>),这里<code>rdi</code>是<code>0x7fffffffffffffe0</code> + <code>0x0000000100003f70</code> = <code>0x8000000100003f50</code>,即字符串<code>后8字节</code>存储的内容,显然字符串后8字节减去<code>0x7fffffffffffffe0</code>存储着字符串的内存地址。</li>
<li>其<code>前8字节</code>存储的实际是字符串的<code>tag</code>和<code>长度</code><ul>
<li><code>&quot;0123456789ABCDEFGH&quot;</code>的内存地址<code>0xd000000000000012</code> + <code>0x8000000100003f70</code></li>
<li>显然，其高位<code>d</code>代表大于<code>oxF</code>的字符串存储方法，低位开始代表字符串的长度</li>
</ul>
</li>
<li>大于<code>oxF</code>的字符串存储的字符串真实地址位置实际在<code>__TEXT.cstring</code>常量区,<code>&quot;0123456789ABCDEF&quot;</code>的真实内存地址是<code>0x0000000100003f70</code><ul>
<li><code>swiftc -o main.o main.swift</code>,编译成<code>.o</code>文件，用<code>machOview</code>查看</li>
<li>显然<code>3f70</code>是在<code>__TEXT.cstring</code>常量区，且小于<code>oxF</code>存在内存上的字符串，在常量区，仍有备份<br><img src="1.png"></li>
</ul>
</li>
</ul>
<h2 id="字符串拼接后的内存放在那里"><a href="#字符串拼接后的内存放在那里" class="headerlink" title="字符串拼接后的内存放在那里"></a>字符串拼接后的内存放在那里</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789ABCD&quot;</span><br>str1.append(<span class="hljs-string">&quot;E&quot;</span>)<br>str1.append(<span class="hljs-string">&quot;G&quot;</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>添加长度小于<code>0xF</code>，直接查看内存<code>str1</code>的地址是<code>0x1000151E0</code>,<ul>
<li><code>x 0x1000151E0</code> -&gt; <code>30 31 32 33 34 35 36 37 38 39 41 42 43 44 00 ee</code></li>
<li><code>str1.append(&quot;E&quot;)</code>后<code>x 0x1000151E0</code> -&gt; <code>30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 ef</code></li>
<li>显然，当添加后长度低于<code>0xF</code>后，其内存仍然存储在地址内存上</li>
</ul>
</li>
<li>当添加后大于<code>0xF</code>，<code>str1.append(&quot;G&quot;)</code> -&gt; <code>0xf000000000000010 0x000060000170c000</code>，此时<code>tag</code>和此前不同为<code>f</code>,其长度为<code>16</code>,查看其存储地址<code>0x000060000170c000</code>,显然其地址+<code>0x20</code>之后开始存储字符串的真实内容。实际上字符串拼接长度大于<code>oxF</code>后，会存储在堆中，其内存存储在地址后<code>0x20</code>（前<code>16</code>个字节，类似对象，<code>metaDat</code>和引用计数）后 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">x<span class="hljs-operator">/</span>50xb <span class="hljs-number">0x000060000170c000</span><br> <span class="hljs-number">0x60000170c000</span>: <span class="hljs-number">0xa8</span> <span class="hljs-number">0xe9</span> <span class="hljs-number">0x3f</span> <span class="hljs-number">0x4f</span> <span class="hljs-number">0xf8</span> <span class="hljs-number">0x7f</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span><br> <span class="hljs-number">0x60000170c008</span>: <span class="hljs-number">0x03</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span><br> <span class="hljs-number">0x60000170c010</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span><br> <span class="hljs-number">0x60000170c018</span>: <span class="hljs-number">0x10</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0xf0</span><br> <span class="hljs-number">0x60000170c020</span>: <span class="hljs-number">0x30</span> <span class="hljs-number">0x31</span> <span class="hljs-number">0x32</span> <span class="hljs-number">0x33</span> <span class="hljs-number">0x34</span> <span class="hljs-number">0x35</span> <span class="hljs-number">0x36</span> <span class="hljs-number">0x37</span><br> <span class="hljs-number">0x60000170c028</span>: <span class="hljs-number">0x38</span> <span class="hljs-number">0x39</span> <span class="hljs-number">0x41</span> <span class="hljs-number">0x42</span> <span class="hljs-number">0x43</span> <span class="hljs-number">0x44</span> <span class="hljs-number">0x45</span> <span class="hljs-number">0x47</span><br> <span class="hljs-number">0x60000170c030</span>: <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span><br></code></pre></td></tr></table></figure>
<ul>
<li>判断为何在堆中，断点查看<code>malloc</code>方法，查看<code>append</code>是否有分配堆空间，显然拦截成功，分配了堆空间<ul>
<li>查看<code>malloc</code>生成的堆空间地址<code>rax = 0x000060000170c000</code>,即最后字符串的后<code>8</code>字节地址<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">  bt<br>  <span class="hljs-operator">*</span> thread #<span class="hljs-number">1</span>, queue <span class="hljs-operator">=</span> &#x27;com.apple.main<span class="hljs-operator">-</span>thread&#x27;, stop reason <span class="hljs-operator">=</span> breakpoint <span class="hljs-number">2.1</span><br><span class="hljs-operator">*</span> frame #<span class="hljs-number">0</span>: <span class="hljs-number">0x00007ff80b89ec19</span> libsystem_malloc.dylib`_malloc_zone_malloc <span class="hljs-operator">+</span> <span class="hljs-number">10</span><br>  frame #<span class="hljs-number">1</span>: <span class="hljs-number">0x00007ff81a1a2b96</span> libswiftCore.dylib`std::__1::pair<span class="hljs-operator">&lt;</span>(anonymous namespace)::<span class="hljs-type">TupleCacheEntry</span><span class="hljs-operator">*</span>, swift::<span class="hljs-type">MetadataResponse</span><span class="hljs-operator">&gt;</span> swift::<span class="hljs-type">LockingConcurrentMap</span>&lt;(anonymous namespace)::<span class="hljs-type">TupleCacheEntry</span>, (anonymous namespace)::<span class="hljs-type">TupleCacheStorage</span>&gt;::getOrInsert<span class="hljs-operator">&lt;</span>(anonymous namespace)::<span class="hljs-type">TupleCacheEntry</span>::<span class="hljs-type">Key</span>, swift::<span class="hljs-type">MetadataRequest</span><span class="hljs-operator">&amp;</span>, swift::<span class="hljs-type">TargetValueWitnessTable</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*&amp;&gt;</span>((anonymous namespace)::TupleCacheEntry::<span class="hljs-type">Key</span>, swift::<span class="hljs-type">MetadataRequest</span><span class="hljs-operator">&amp;</span>, swift::<span class="hljs-type">TargetValueWitnessTable</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*&amp;</span>) <span class="hljs-operator">+</span> <span class="hljs-number">4038</span><br>  frame #<span class="hljs-number">2</span>: <span class="hljs-number">0x00007ff81a1a19b4</span> libswiftCore.dylib`swift_getTupleTypeMetadata <span class="hljs-operator">+</span> <span class="hljs-number">116</span><br>  frame #<span class="hljs-number">3</span>: <span class="hljs-number">0x00007ff81a1c41ce</span> libswiftCore.dylib`swift::<span class="hljs-type">Demangle</span>::__runtime::<span class="hljs-type">TypeDecoder</span>&lt;(anonymous namespace)::<span class="hljs-type">DecodedMetadataBuilder</span>&gt;::decodeMangledType(swift::Demangle::__runtime::<span class="hljs-type">Node</span><span class="hljs-operator">*</span>, unsigned int, bool) <span class="hljs-operator">+</span> <span class="hljs-number">9342</span><br>  frame #<span class="hljs-number">4</span>: <span class="hljs-number">0x00007ff81a1c149d</span> libswiftCore.dylib`swift_getTypeByMangledNodeImpl(swift::<span class="hljs-type">MetadataRequest</span>, swift::Demangle::__runtime::<span class="hljs-type">Demangler</span><span class="hljs-operator">&amp;</span>, swift::Demangle::__runtime::<span class="hljs-type">Node</span><span class="hljs-operator">*</span>, void const<span class="hljs-operator">*</span> const<span class="hljs-operator">*</span>, std::__1::function<span class="hljs-operator">&lt;</span>swift::<span class="hljs-type">TargetMetadata</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span> (unsigned int, unsigned int)<span class="hljs-operator">&gt;</span>, std::__1::function<span class="hljs-operator">&lt;</span>swift::<span class="hljs-type">TargetWitnessTable</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span> (swift::<span class="hljs-type">TargetMetadata</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span>, unsigned int)<span class="hljs-operator">&gt;</span>) <span class="hljs-operator">+</span> <span class="hljs-number">493</span><br>  frame #<span class="hljs-number">5</span>: <span class="hljs-number">0x00007ff81a1c126d</span> libswiftCore.dylib`swift_getTypeByMangledNode <span class="hljs-operator">+</span> <span class="hljs-number">477</span><br>  frame #<span class="hljs-number">6</span>: <span class="hljs-number">0x00007ff81a1c1980</span> libswiftCore.dylib`swift_getTypeByMangledNameImpl(swift::<span class="hljs-type">MetadataRequest</span>, __swift::__runtime::llvm::<span class="hljs-type">StringRef</span>, void const<span class="hljs-operator">*</span> const<span class="hljs-operator">*</span>, std::__1::function<span class="hljs-operator">&lt;</span>swift::<span class="hljs-type">TargetMetadata</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span> (unsigned int, unsigned int)<span class="hljs-operator">&gt;</span>, std::__1::function<span class="hljs-operator">&lt;</span>swift::<span class="hljs-type">TargetWitnessTable</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span> (swift::<span class="hljs-type">TargetMetadata</span>&lt;swift::<span class="hljs-type">InProcess</span>&gt; const<span class="hljs-operator">*</span>, unsigned int)<span class="hljs-operator">&gt;</span>) <span class="hljs-operator">+</span> <span class="hljs-number">992</span><br>  frame #<span class="hljs-number">7</span>: <span class="hljs-number">0x00007ff81a1bdc4d</span> libswiftCore.dylib`swift_getTypeByMangledName <span class="hljs-operator">+</span> <span class="hljs-number">477</span><br>  frame #<span class="hljs-number">8</span>: <span class="hljs-number">0x00007ff81a1bde7e</span> libswiftCore.dylib`swift_getTypeByMangledNameInContext <span class="hljs-operator">+</span> <span class="hljs-number">174</span><br>  frame #<span class="hljs-number">9</span>: <span class="hljs-number">0x00007ff81a133c47</span> libswiftCore.dylib`__swift_instantiateConcreteTypeFromMangledName <span class="hljs-operator">+</span> <span class="hljs-number">39</span><br>  frame #<span class="hljs-number">10</span>: <span class="hljs-number">0x00007ff81a01f961</span> libswiftCore.dylib`<span class="hljs-type">Swift</span>._StringGuts.prepareForAppendInPlace(totalCount: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>, otherUTF8Count: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () <span class="hljs-operator">+</span> <span class="hljs-number">385</span><br>  frame #<span class="hljs-number">11</span>: <span class="hljs-number">0x00007ff81a01fc16</span> libswiftCore.dylib`<span class="hljs-type">Swift</span>._StringGuts.append(<span class="hljs-type">Swift</span>._StringGutsSlice) -&gt; () <span class="hljs-operator">+</span> <span class="hljs-number">390</span><br>  frame #<span class="hljs-number">12</span>: <span class="hljs-number">0x000000010000e041</span> <span class="hljs-type">SwiftDText</span>`main at main.swift:<span class="hljs-number">69</span>:<span class="hljs-number">6</span><br>  frame #<span class="hljs-number">13</span>: <span class="hljs-number">0x00007ff80b6fd310</span> dyld`start <span class="hljs-operator">+</span> <span class="hljs-number">2432</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong>，一开始大于<code>oxF</code>的字符串(此前存在<code>常量区</code>)拼接后一样的存储在<code>堆</code>中，因为<code>常量区</code>是无法更改的</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="空字符串的存储"><a href="#空字符串的存储" class="headerlink" title="空字符串的存储"></a><span id="jump">空字符串的存储</span></h2><blockquote>
<p>先分析下，空字符串在内存中是如何保存的</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> empty <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">let</span> ptr <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>empty) &#123; <span class="hljs-variable">$0</span>&#125;<br><span class="hljs-built_in">print</span>(ptr) <span class="hljs-comment">// 0x00007ff7bfefead0</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>lldb</code>查看,其前<code>16</code>个字节存储的大小是<code>0x0000000000000000</code> + <code>0xe000000000000000</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">lldb) x<span class="hljs-operator">/</span>4xg <span class="hljs-number">0x00007ff7bfefead0</span><br><span class="hljs-number">0x7ff7bfefead0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0xe000000000000000</span><br><span class="hljs-number">0x7ff7bfefeae0</span>: <span class="hljs-number">0x0000000000000004</span> <span class="hljs-number">0x0000000100015330</span><br></code></pre></td></tr></table></figure></li>
<li><p>这里并不能看出<code>string</code>的内存结构，下面根据源码进行具体分析</p>
</li>
</ul>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="String-Swift"><a href="#String-Swift" class="headerlink" title="String.Swift"></a><code>String.Swift</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">@frozen<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">String</span> &#123;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-comment">// @SPI(Foundation)</span><br>  var _guts: _StringGuts<br><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-function">internal <span class="hljs-title">init</span><span class="hljs-params">(_ _guts: _StringGuts)</span> </span>&#123;<br>    self._guts = _guts<br>    _invariantCheck()<br>  &#125;<br><br>  <span class="hljs-comment">// This is intentionally a static function and not an initializer, because</span><br>  <span class="hljs-comment">// an initializer would conflict with the Int-parsing initializer, when used</span><br>  <span class="hljs-comment">// as function name, e.g.</span><br>  <span class="hljs-comment">//   [1, 2, 3].map(String.init)</span><br>  @_alwaysEmitIntoClient<br>  @_semantics(<span class="hljs-string">&quot;string.init_empty_with_capacity&quot;</span>)<br>  @_semantics(<span class="hljs-string">&quot;inline_late&quot;</span>)<br>  @inlinable<br>  internal <span class="hljs-keyword">static</span> func _createEmpty(withInitialCapacity: Int) -&gt; String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(_StringGuts(_initialCapacity: withInitialCapacity))<br>  &#125;<br><br>  <span class="hljs-comment">/// Creates an empty string.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// Using this initializer is equivalent to initializing a string with an</span><br>  <span class="hljs-comment">/// empty string literal.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">///     let empty = &quot;&quot;</span><br>  <span class="hljs-comment">///     let alsoEmpty = String()</span><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  @_semantics(<span class="hljs-string">&quot;string.init_empty&quot;</span>)<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">init</span>() &#123; self.<span class="hljs-built_in">init</span>(_StringGuts()) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>最直观地可以看到<code>String</code>是一个结构体，就是我们所说的值类型；它有一个成员变量<code>_StringGuts</code>,其中最后有一个创建空字符串初始化方式<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(_StringGuts())<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="StringGuts"><a href="#StringGuts" class="headerlink" title="_StringGuts"></a><code>_StringGuts</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">/<br><span class="hljs-comment">// StringGuts is a parameterization over String&#x27;s representations. It provides</span><br><span class="hljs-comment">// functionality and guidance for efficiently working with Strings.</span><br><span class="hljs-comment">//</span><br>@frozen<br><span class="hljs-keyword">public</span> <span class="hljs-comment">// SPI(corelibs-foundation)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">StringGuts</span>:</span> @unchecked Sendable &#123;<br>  @usableFromInline<br>  internal var _object: _StringObject<br><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-function">internal <span class="hljs-title">init</span><span class="hljs-params">(_ object: _StringObject)</span> </span>&#123;<br>    self._object = object<br>    _invariantCheck()<br>  &#125;<br><br>  <span class="hljs-comment">// Empty string</span><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-built_in">init</span>() &#123;<br>    self.<span class="hljs-built_in">init</span>(_StringObject(empty: ()))<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Raw</span><br>extension _StringGuts &#123;<br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  internal var rawBits: _StringObject.RawBitPattern &#123;<br>    <span class="hljs-keyword">return</span> _object.rawBits<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>_StringGuts</code>也是一个结构体，它有一个成员变量是<code>_StringObject</code>类型的实例;并且在最后是通过初始化出一个<code>_StringObject</code>类型的实例来初始化<code>_StringGuts</code>的。因此真正<code>swift</code>的实质就是<code>_StringObject</code></li>
</ul>
<h3 id="StringObject"><a href="#StringObject" class="headerlink" title="_StringObject"></a><code>_StringObject</code></h3><ul>
<li><p>创建空字符串的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">@inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-function">internal <span class="hljs-title">init</span><span class="hljs-params">(empty:())</span> </span>&#123;<br>    <span class="hljs-comment">// Canonical empty pattern: small zero-length string</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> arch(i386) || arch(arm) || arch(arm64_32) || arch(wasm32)</span><br>    self.<span class="hljs-built_in">init</span>(<br>      count: <span class="hljs-number">0</span>,<br>      variant: .<span class="hljs-built_in">immortal</span>(<span class="hljs-number">0</span>),<br>      discriminator: Nibbles.emptyString,<br>      flags: <span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    self._countAndFlagsBits = <span class="hljs-number">0</span><br>    self._object = Builtin.<span class="hljs-built_in">valueToBridgeObject</span>(Nibbles.emptyString._value)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    _internalInvariant(self.smallCount == <span class="hljs-number">0</span>)<br>    _invariantCheck()<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>初始化方法,其内有成员变量<code>_count</code>,<code>_variant</code>,<code>_discriminator</code>,<code>_flags</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">@usableFromInline<br>  internal var _count: Int <span class="hljs-comment">// 字符串大小</span><br><br>  @usableFromInline<br>  internal var _variant: Variant <span class="hljs-comment">// 枚举值 默认0</span><br><br>  @usableFromInline<br>  internal var _discriminator: UInt8 <span class="hljs-comment">// 空字符串在初始化的时候传递了一个Nibbles.emptyString</span><br><br>  @usableFromInline<br>  internal var _flags: UInt16<br><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  <span class="hljs-built_in">init</span>(count: Int, variant: Variant, discriminator: UInt64, flags: UInt16) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> os(Android) &amp;&amp; arch(arm64)</span><br>    _internalInvariant(discriminator &amp; <span class="hljs-number">0x00FF</span>_0000_0000_0000 == discriminator,<br>      <span class="hljs-string">&quot;only the second byte can carry the discriminator and small count on Android AArch64&quot;</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    _internalInvariant(discriminator &amp; <span class="hljs-number">0xFF00</span>_0000_0000_0000 == discriminator,<br>      <span class="hljs-string">&quot;only the top byte can carry the discriminator and small count&quot;</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    self._count = count<br>    self._variant = variant<br>    self._discriminator = <span class="hljs-built_in">UInt8</span>(truncatingIfNeeded: discriminator &amp;&gt;&gt; <span class="hljs-number">56</span>)<br>    self._flags = flags<br>    self._invariantCheck()<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>Variant</code>是一个枚举值，默认是<code>immortal 0</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">internal <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Variant</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">immortal</span><span class="hljs-params">(UInt)</span> <span class="hljs-comment">// 原始字符串</span></span><br><span class="hljs-function">    <span class="hljs-keyword">case</span> <span class="hljs-title">native</span><span class="hljs-params">(AnyObject)</span> <span class="hljs-comment">// AnyObject</span></span><br><span class="hljs-function">    <span class="hljs-keyword">case</span> <span class="hljs-title">bridged</span><span class="hljs-params">(_CocoaString)</span> <span class="hljs-comment">// NSString</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    @inlinable @<span class="hljs-title">inline</span><span class="hljs-params">(__always)</span></span><br><span class="hljs-function">    internal <span class="hljs-keyword">static</span> func <span class="hljs-title">immortal</span><span class="hljs-params">(start: UnsafePointer&lt;UInt8&gt;)</span> -&gt; Variant </span>&#123;<br>      let biased = <span class="hljs-built_in">UInt</span>(bitPattern: start) &amp;- _StringObject.nativeBias<br>      <span class="hljs-keyword">return</span> .<span class="hljs-built_in">immortal</span>(biased)<br>    &#125;<br><br>    @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>    internal var isImmortal: Bool &#123;<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .immortal = self &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>internal var _discriminator: UInt8</code> 在初始化的时候传递了一个<code>Nibbles.emptyString</code>（<code>Nibbles</code>是一个枚举类型）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Encoding is optimized for common fast creation. The canonical empty string,</span><br><span class="hljs-comment"> ASCII small strings, as well as most literals, have all consecutive 1s in their</span><br><span class="hljs-comment"> high nibble mask, and thus can all be encoded as a logical immediate operand</span><br><span class="hljs-comment"> on arm64.</span><br><span class="hljs-comment">*/</span><br>extension _StringObject.Nibbles &#123;<br>  <span class="hljs-comment">// The canonical empty string is an empty small string</span><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  internal <span class="hljs-keyword">static</span> var emptyString: UInt64 &#123;<br>    <span class="hljs-keyword">return</span> _StringObject.Nibbles.<span class="hljs-built_in">small</span>(isASCII: <span class="hljs-literal">true</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Discriminator for small strings</span><br>  @inlinable @<span class="hljs-built_in"><span class="hljs-keyword">inline</span></span>(__always)<br>  internal <span class="hljs-keyword">static</span> func <span class="hljs-built_in">small</span>(isASCII: Bool) -&gt; UInt64 &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> os(Android) &amp;&amp; arch(arm64)</span><br>    <span class="hljs-keyword">return</span> isASCII ? <span class="hljs-number">0x00E0</span>_0000_0000_0000 : <span class="hljs-number">0x00A0</span>_0000_0000_0000<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">return</span> isASCII ? <span class="hljs-number">0xE000</span>_0000_0000_0000 : <span class="hljs-number">0xA000</span>_0000_0000_0000<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>0x00E0_0000_0000_0000</code>和<a href="#jump">空字符串的存储</a>中空字符串的内存一致</p>
</li>
</ul>
<h2 id="小于长度0xF的字符串-1"><a href="#小于长度0xF的字符串-1" class="headerlink" title="小于长度0xF的字符串"></a>小于长度<code>0xF</code>的字符串</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789&quot;</span><br><span class="hljs-comment">//内存：0x3736353433323130  0xea00000000003938</span><br><span class="hljs-keyword">var</span> str2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中&quot;</span><br><span class="hljs-comment">//内存：0x0000000000adb8e4 0xa300000000000000</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>small strings</code>的<code>Discriminator</code>,<ul>
<li>中文字符不是<code>ASCII</code>编码，一个中文字符占据<code>3</code>个字节（<code>24</code>位),其<code>Discriminator</code>为<code>0xa000000000000000</code>,这里的长度<code>3</code>并非真实长度，而是其字节数。</li>
<li><code>&quot;0123456789&quot;</code>,是<code>ASCII</code>编码,并且一个字符占<code>1</code>哥字节，其<code>Discriminator</code>为<code>0xe000000000000000</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-comment">// Discriminator for small strings</span><br>  <span class="hljs-keyword">@inlinable</span> <span class="hljs-meta">@inline</span>(__always)<br>  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">small</span>(<span class="hljs-params">isASCII</span>: <span class="hljs-type">Bool</span>)</span> -&gt; <span class="hljs-type">UInt64</span> &#123;<br><span class="hljs-keyword">#if</span> os(<span class="hljs-type">Android</span>) <span class="hljs-operator">&amp;&amp;</span> arch(arm64)<br>    <span class="hljs-keyword">return</span> isASCII <span class="hljs-operator">?</span> <span class="hljs-number">0x00E0_0000_0000_0000</span> : <span class="hljs-number">0x00A0_0000_0000_0000</span><br><span class="hljs-keyword">#else</span><br>    <span class="hljs-keyword">return</span> isASCII <span class="hljs-operator">?</span> <span class="hljs-number">0xE000_0000_0000_0000</span> : <span class="hljs-number">0xA000_0000_0000_0000</span><br><span class="hljs-keyword">#endif</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="大于长度0xF的字符串-1"><a href="#大于长度0xF的字符串-1" class="headerlink" title="大于长度0xF的字符串"></a>大于长度<code>0xF</code>的字符串</h2><blockquote>
<p>对于大字符串(大于<code>15</code>个字符串)来说，原本的小字符串占据的<code>15</code>个字节已经不足以存储字符串了，那就会发生改变</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str1 <span class="hljs-operator">=</span> `<span class="hljs-string">&quot;0123456789ABCDEFGH&quot;</span><br><span class="hljs-comment">//内存地址:0xd000000000000012.  0x8000000100003f70</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>largeImmortal</code>的<code>Discriminator</code></p>
<ul>
<li>这里<code> 0x0080_0000_0000_0000</code>，是<code>Discriminator</code>，剩下的<code>0x100003f70</code>实际上关联了实际存储的字符串<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Discriminator for large, immortal, swift-native strings</span><br>  <span class="hljs-keyword">@inlinable</span> <span class="hljs-meta">@inline</span>(__always)<br>  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largeImmortal</span>()</span> -&gt; <span class="hljs-type">UInt64</span> &#123;<br><span class="hljs-keyword">#if</span> os(<span class="hljs-type">Android</span>) <span class="hljs-operator">&amp;&amp;</span> arch(arm64)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x0080_0000_0000_0000</span><br><span class="hljs-keyword">#else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x8000_0000_0000_0000</span><br><span class="hljs-keyword">#endif</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>源码意思是实际的字符串需要加上偏移量<code>nativeBias</code>即<code>32</code>，<code>32</code>的<code>16</code>进制是<code>0x20</code>实际字符串存储的位置是<code>0x100003f70 + 20</code> = <code>0x100003f90</code>,</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Large</span> strings can either be <span class="hljs-string">&quot;native&quot;</span>, <span class="hljs-string">&quot;shared&quot;</span>, or <span class="hljs-string">&quot;foreign&quot;</span>.<br><br> <span class="hljs-type">Native</span> strings have tail<span class="hljs-operator">-</span>allocated storage, which begins at an offset of<br> `nativeBias` from the storage object&#x27;s address. <span class="hljs-type">String</span> literals, which reside<br> <span class="hljs-keyword">in</span> the constant section, are encoded <span class="hljs-keyword">as</span> their start address minus `nativeBias`,<br> unifying code paths <span class="hljs-keyword">for</span> both literals (<span class="hljs-string">&quot;immortal native&quot;</span>) and native strings.<br> <span class="hljs-type">Native</span> <span class="hljs-type">Strings</span> are always managed by the <span class="hljs-type">Swift</span> runtime.<br><br> <span class="hljs-type">Shared</span> strings <span class="hljs-keyword">do</span> not have tail<span class="hljs-operator">-</span>allocated storage, but can provide access<br> upon query to contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> code units. <span class="hljs-type">Lazily</span><span class="hljs-operator">-</span>bridged <span class="hljs-type">NSStrings</span> capable of<br> providing access to contiguous <span class="hljs-type">ASCII</span><span class="hljs-operator">/</span><span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> <span class="hljs-keyword">set</span> the <span class="hljs-type">ObjC</span> bit. <span class="hljs-type">Accessing</span> shared<br> string&#x27;s pointer should always be behind a resilience barrier, permitting<br> future evolution.<br><br> <span class="hljs-type">Foreign</span> strings cannot provide access to contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span>. <span class="hljs-type">Currently</span>, this only<br> encompasses lazily<span class="hljs-operator">-</span>bridged <span class="hljs-type">NSStrings</span> that cannot be treated <span class="hljs-keyword">as</span> <span class="hljs-string">&quot;shared&quot;</span>. <span class="hljs-type">Such</span><br> strings may provide access to contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">16</span>, or may be discontiguous <span class="hljs-keyword">in</span><br> storage. <span class="hljs-type">Accessing</span> foreign strings should remain behind a resilience barrier<br> <span class="hljs-keyword">for</span> future evolution. <span class="hljs-type">Other</span> foreign forms are reserved <span class="hljs-keyword">for</span> the future.<br><br> <span class="hljs-type">Shared</span> and foreign strings are always created and accessed behind a resilience<br> barrier, providing flexibility <span class="hljs-keyword">for</span> the future.<br><br> <span class="hljs-operator">┌────────────┐</span><br> <span class="hljs-operator">│</span> nativeBias <span class="hljs-operator">│</span><br> <span class="hljs-operator">├────────────┤</span><br> <span class="hljs-operator">│</span>     <span class="hljs-number">32</span>     <span class="hljs-operator">│</span><br> <span class="hljs-operator">└────────────┘</span><br><br> <span class="hljs-operator">┌───────────────┬────────────┐</span><br> <span class="hljs-operator">│</span>    b63:b60    <span class="hljs-operator">│</span>   b60:b0   <span class="hljs-operator">│</span><br> <span class="hljs-operator">├───────────────┼────────────┤</span><br> <span class="hljs-operator">│</span> discriminator <span class="hljs-operator">│</span> objectAddr <span class="hljs-operator">│</span><br> <span class="hljs-operator">└───────────────┴────────────┘</span><br><br> discriminator: <span class="hljs-type">See</span> comment <span class="hljs-keyword">for</span> _StringObject.<span class="hljs-type">Discriminator</span><br> objectAddr: <span class="hljs-type">The</span> address of the beginning of the potentially<span class="hljs-operator">-</span>managed object.<br><br> <span class="hljs-type">TODO</span>(<span class="hljs-type">Future</span>): <span class="hljs-type">For</span> <span class="hljs-type">Foreign</span> strings, consider allocating a bit <span class="hljs-keyword">for</span> whether they<br> can provide contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">16</span> code units, which would allow us to avoid doing<br> the full call <span class="hljs-keyword">for</span> non<span class="hljs-operator">-</span>contiguous <span class="hljs-type">NSString</span>.<br><br></code></pre></td></tr></table></figure></li>
<li><p>而大字符串前面的标识位<code>0xd000000000000012</code></p>
<ul>
<li><code>0-47</code>位是长度，这里是<code>0x12</code>即长度为18<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">All</span> non<span class="hljs-operator">-</span>small forms share the same structure <span class="hljs-keyword">for</span> the other half of the bits<br> (i.e. non<span class="hljs-operator">-</span>object bits) <span class="hljs-keyword">as</span> a word containing code unit count and various<br> performance flags. <span class="hljs-type">The</span> top <span class="hljs-number">16</span> bits are nonessential flags; these aren&#x27;t<br> critical <span class="hljs-keyword">for</span> correct operation, but they may provide additional guarantees that<br> allow more efficient operation or more reliable detection of runtime errors.<br> <span class="hljs-type">The</span> lower <span class="hljs-number">48</span> bits contain the code unit count (aka endIndex).<br><br><span class="hljs-operator">┌──────┬──────┬──────┬──────┬──────┬──────────┬───────────────────────────────┐</span><br><span class="hljs-operator">│</span> b63  <span class="hljs-operator">│</span> b62  <span class="hljs-operator">│</span> b61  <span class="hljs-operator">│</span> b60  <span class="hljs-operator">│</span> b59  <span class="hljs-operator">│</span>  b58:<span class="hljs-number">48</span>  <span class="hljs-operator">│</span>             b47:<span class="hljs-number">0</span>             <span class="hljs-operator">│</span><br><span class="hljs-operator">├──────┼──────┼──────┼──────┼──────┼──────────┼───────────────────────────────┤</span><br><span class="hljs-operator">│</span> <span class="hljs-type">ASCII</span><span class="hljs-operator">│</span> <span class="hljs-type">NFC</span>  <span class="hljs-operator">│</span>native<span class="hljs-operator">│</span> tail <span class="hljs-operator">│</span> <span class="hljs-type">UTF8</span> <span class="hljs-operator">│</span> reserved <span class="hljs-operator">│</span>             count             <span class="hljs-operator">│</span><br><span class="hljs-operator">└──────┴──────┴──────┴──────┴──────┴──────────┴───────────────────────────────┘</span><br><br> b63: isASCII. <span class="hljs-keyword">set</span> when all code units are known to be <span class="hljs-type">ASCII</span>, enabling:<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Trivial</span> <span class="hljs-type">Unicode</span> scalars, they&#x27;re just the code units<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Trivial</span> <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">16</span> transcoding (just bit<span class="hljs-operator">-</span>extend)<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Also</span>, isASCII always implies isNFC<br><br> b62: isNFC. <span class="hljs-keyword">set</span> when the contents are <span class="hljs-keyword">in</span> normal form <span class="hljs-type">C</span><br>   <span class="hljs-operator">-</span> <span class="hljs-type">Enables</span> trivial lexicographical comparisons: just memcmp<br>   <span class="hljs-operator">-</span> `isASCII` always implies `isNFC`, but not vice versa<br><br> b61: isNativelyStored. <span class="hljs-keyword">set</span> <span class="hljs-keyword">for</span> native stored strings<br>   <span class="hljs-operator">-</span> `largeAddressBits` holds an instance of `_StringStorage`.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">I</span>.e. the start of the code units <span class="hljs-keyword">is</span> at the stored address <span class="hljs-operator">+</span> `nativeBias`<br>   <span class="hljs-operator">-</span> <span class="hljs-type">NOTE</span>: isNativelyStored <span class="hljs-keyword">is</span> <span class="hljs-operator">*</span>specifically<span class="hljs-operator">*</span> allocated to b61 to align with the<br>     bit<span class="hljs-operator">-</span>position of isSmall on the <span class="hljs-type">BridgeObject</span>. <span class="hljs-type">This</span> allows us to check <span class="hljs-keyword">for</span><br>     native storage without an extra branch guarding against smallness. <span class="hljs-type">See</span><br>     `_StringObject.hasNativeStorage` <span class="hljs-keyword">for</span> this usage.<br><br> b60: isTailAllocated. contiguous <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> code units starts at address <span class="hljs-operator">+</span> `nativeBias`<br>   <span class="hljs-operator">-</span> `isNativelyStored` always implies `isTailAllocated`, but not vice versa<br>      (e.g. literals)<br>   <span class="hljs-operator">-</span> `isTailAllocated` always implies `isFastUTF8`<br><br> b59: isForeignUTF8. <span class="hljs-type">This</span> bit <span class="hljs-keyword">is</span> to be <span class="hljs-keyword">set</span> on future <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> encoded string<br>      variants, i.e. on strings whose index positions are measured <span class="hljs-keyword">in</span> <span class="hljs-type">UTF</span><span class="hljs-operator">-</span><span class="hljs-number">8</span> code<br>      units, even though their storage isn&#x27;t continuous. <span class="hljs-type">As</span> of <span class="hljs-type">Swift</span> <span class="hljs-number">5.7</span>, we<br>      don&#x27;t have any such foreign forms, but inlinable index validation methods<br>      need to prepare <span class="hljs-keyword">for</span> the possibility of their introduction, so we need to<br>      assign this bit <span class="hljs-keyword">in</span> preparation.<br><br>      <span class="hljs-type">If</span> we decide to never introduce such forms, we can stop checking this bit<br>      at any time, but we cannot reuse it <span class="hljs-keyword">for</span> something <span class="hljs-keyword">else</span> <span class="hljs-operator">--</span> we need to<br>      preserve its current meaning to keep inlined index validation code<br>      working.<br><br> b48<span class="hljs-operator">-</span><span class="hljs-number">58</span>: <span class="hljs-type">Reserved</span> <span class="hljs-keyword">for</span> future usage.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Because</span> <span class="hljs-type">Swift</span> <span class="hljs-keyword">is</span> <span class="hljs-type">ABI</span> stable (on <span class="hljs-keyword">some</span> platforms at least), these bits can<br>     only be assigned semantics that don&#x27;t affect interoperability with code<br>     built with previous releases of the <span class="hljs-type">Standard</span> <span class="hljs-type">Library</span>, from <span class="hljs-number">5.0</span> onward.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Older</span> binaries will not look at newly assigned bits, and they will not<br>     <span class="hljs-keyword">set</span> them, either (unless by side effect of calling into newly built code).<br>     <span class="hljs-type">Such</span> code must <span class="hljs-keyword">continue</span> working.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">Code</span> <span class="hljs-keyword">in</span> new versions of the stdlib must <span class="hljs-keyword">continue</span> to work correctly even <span class="hljs-keyword">if</span><br>     <span class="hljs-keyword">some</span> of these newly assigned bits are never <span class="hljs-keyword">set</span> <span class="hljs-operator">--</span> <span class="hljs-keyword">as</span> may be the <span class="hljs-keyword">case</span> when<br>     the initialization of a string was emitted entirely into an older client<br>     binary.<br>   <span class="hljs-operator">-</span> <span class="hljs-type">This</span> typically means that these bits can only be used <span class="hljs-keyword">as</span> <span class="hljs-keyword">optional</span><br>     performance shortcuts, e.g. to signal the availability of a potential fast<br>     path. (<span class="hljs-type">However</span>, it <span class="hljs-keyword">is</span> also possible to store information here that allows<br>     more reliable detection <span class="hljs-operator">&amp;</span> handling of runtime errors, like the<br>     `isForeignUTF8` bit above.)<br><br> b0<span class="hljs-operator">-</span><span class="hljs-number">47</span>: count. <span class="hljs-type">Stores</span> the number of code units. <span class="hljs-type">Corresponds</span> to the position of<br>     the `endIndex`.<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>类的初始化</title>
    <url>/2023/03/06/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h1><ul>
<li>类、结构体、枚举都可以定义初始化器</li>
<li>类有<code>2</code>种初始化器：指定初始化器 (<code>designated initializer</code>）、便捷初始化器 (<code>convenience initializer</code>)</li>
<li>每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器</li>
<li>默认初始化器总是类的指定初始化器</li>
<li>类偏向于少量指定初始化器，一个类通常只有一个指定初始化器</li>
<li>初始化器的相互调用规则<ul>
<li>指定初始化器必须从它的直系父类调用指定初始化器</li>
<li>便捷初始化器必须从相同的类里调用另一个初始化器</li>
<li>便捷初始化器最终必须调用一个<strong>指定初始化器</strong></li>
</ul>
</li>
</ul>
<h2 id="两段式初始化"><a href="#两段式初始化" class="headerlink" title="两段式初始化"></a>两段式初始化</h2><ul>
<li><code>swift</code>在编码安全方面是煞费苦心，为了保证初始化过程的安全，设定了两段式初始化、 安全检查</li>
<li>两段式初始化<ul>
<li>第1阶段：初始化所有存储属性<ol>
<li>外层调用指定\便捷初始化器</li>
<li>分配内存给实例，但未初始化</li>
<li>指定初始化器确保当前类定义的存储属性都初始化</li>
<li>指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链</li>
</ol>
</li>
<li>第2阶段：设置新的存储属性值<ol>
<li>从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例</li>
<li>初始化器现在能够使用<code>self</code>（访问、修改它的属性 ，调用它的实例方法等等）</li>
<li>最终，链中任何便捷初始化器都有机会定制实例以及使用<code>self</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h2><ul>
<li>指定初始化器必须保证在调用父类初始化器之前，其所在类定义的所有存储属性都要初始化完成</li>
<li>指定初始化器必须先调用父类初始化器，然后才能为继承的属性设置新值</li>
<li>便捷初始化器必须先调用同类中的其它初始化器(指定初始化器，或者其他调用了指定初始化器的便携初始化)，然后再为任意属性设置新值</li>
<li>初始化器在第1阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用<code>se1f</code></li>
<li>直到第1阶段结束，实例才算完全合法</li>
</ul>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><ul>
<li>当重写父类的指定初始化器时 ，必须加上<code>override</code>（即使子类的实现是便捷初始化器）</li>
<li>如果子类写了一个匹配父类便捷初始化器的初始化器，不用加上<code>override</code><ul>
<li>因为父类的便捷初始化器永远不会通过子类<code>直接调用</code>，因此，严格来说，子类<strong>无法重写</strong>父类的便捷初始化器</li>
</ul>
</li>
</ul>
<h2 id="自动继承"><a href="#自动继承" class="headerlink" title="自动继承"></a>自动继承</h2><ol>
<li>如果子类没有自定义任何<code>指定初始化器</code>，它会自动继承父类所有的指定初始化器<ul>
<li>如果子类有自己的初始化器，且不满足<code>2</code>，则不会继承父类的任何初始化器</li>
</ul>
</li>
<li>如果子类提供了父类所有<code>指定初始化器</code>的实现（要么通过<code>方式1</code>继承，要么重写）<ul>
<li>子类自动继承所有的父类便捷初始化器</li>
</ul>
</li>
<li>就算子类添加了更多的便捷初始化器，这些规则仍然适用</li>
<li>子类以<code>便捷初始化器的形式</code><strong>重写</strong>父类的指定初始化器，也可以作为满足规则<code>2</code>的一部分</li>
</ol>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>方法调用,多态</title>
    <url>/2023/03/05/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>查看swift方法调用、以及多态实现的原理</p>
</blockquote>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul>
<li>例子<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">speak</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sleep</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> animal <span class="hljs-operator">=</span> <span class="hljs-type">Animal</span>()<br>animal.sleep()<br>animal.speak() <br></code></pre></td></tr></table></figure></li>
<li>汇编查看，结构体的方法调用，直接调用<code>函数地址</code>执行方法,结构体没有多态的逻辑<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x10000df71</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>-&gt;  <span class="hljs-number">0x10000df74</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000e130</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span>.<span class="hljs-keyword">init</span>() -&gt; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span> at main.swift:<span class="hljs-number">10</span><br>    <span class="hljs-number">0x10000df79</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">9</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000e060</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span>.sleep() -&gt; () at main.swift:<span class="hljs-number">15</span><br>    <span class="hljs-number">0x10000df7e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">14</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x10000df90</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span>.speak() -&gt; () at main.swift:<span class="hljs-number">11</span><br>    <span class="hljs-number">0x10000df83</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">19</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">speak</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sleep</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:<span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">speak</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sleep</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>,#function)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> animal <span class="hljs-operator">=</span> <span class="hljs-type">Animal</span>()<br>animal.sleep() <span class="hljs-comment">//0x58(%rax)</span><br>animal.speak() <span class="hljs-comment">//0x50(%rax)</span><br>animal <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span>()<br>animal.speak() <span class="hljs-comment">//0x50(%rax)</span><br>animal.sleep()<br></code></pre></td></tr></table></figure>
<ul>
<li>汇编查看<ol>
<li><code>register read r13</code> -&gt; <code>r13 = 0x0000600000014000</code>,和<code>animal</code>的地址一致,<code>movq   (%r13), %rax</code>将<code>aniaml</code>地址上的头8字节存的信息（即<code>metaData</code>-<code>0x0000000100014cd0</code>）赋值给<code>rax</code>。</li>
<li><code>callq  *0x58(%rax)</code>,<code>si</code>查看,其实际为<code>sleep</code>方法调用，现在，在<code>metaData</code>偏移<code>0x58</code>的内存上存有函数的地址</li>
<li><code>speak</code>方法同样在<code>0x50(%rax)</code>位置处，同样存有地址，且，类方法存储的地址相距<code>8</code>字节</li>
<li>将<code>Dog</code>初始化后赋值给<code>animal</code>，其<code>metaData</code>和<code>Animal</code>不同，地址为<code>0x0000000100014d70</code>，和原来的<code>animal</code>没有关系。但其实际上调用的函数地址是仍然是偏移<code>0x50</code>和<code>0x58</code>处的函数地址。</li>
<li>将<code>Dog</code>中重新的方法去掉，发现情况一致，<code>Dog</code>和<code>Animal</code>头<code>8</code>字节的<code>metaData</code>不同，但是方法同样偏移相同的位置<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//调用sleep方法</span><br><span class="hljs-number">0x10000d98d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">93</span><span class="hljs-operator">&gt;</span>:  movq   (<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x10000d991</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">97</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-operator">*</span><span class="hljs-number">0x58</span>(<span class="hljs-operator">%</span>rax)<br>-&gt;  <span class="hljs-number">0x10000d994</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">100</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0xa8</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><br><span class="hljs-comment">// 调用speak方法</span><br><span class="hljs-number">0x10000d9d8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">168</span><span class="hljs-operator">&gt;</span>: movq   (<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br>-&gt;  <span class="hljs-number">0x10000d9dc</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">172</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-operator">*</span><span class="hljs-number">0x50</span>(<span class="hljs-operator">%</span>rax)<br><br><span class="hljs-comment">//将Dog()赋值给animal</span><br> ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Dog</span>.__allocating_init() -&gt; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Dog</span> at main.swift:<span class="hljs-number">20</span><br>    <span class="hljs-number">0x10000d9fc</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">204</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x98</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x10000da03</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">211</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0x7a36</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.animal : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span><br>    <span class="hljs-number">0x10000da0a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">218</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x50</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rsi<br>    <span class="hljs-number">0x10000da0e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">222</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x21, <span class="hljs-operator">%</span>edx<br>    <span class="hljs-number">0x10000da13</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">227</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br>    <span class="hljs-number">0x10000da15</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">229</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>ecx<br>    <span class="hljs-number">0x10000da17</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">231</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x10000e14c</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_beginAccess<br>    <span class="hljs-number">0x10000da1c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">236</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x98</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x10000da23</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">243</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-number">0x7a16</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.animal : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span><br>    <span class="hljs-number">0x10000da2a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">250</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0x7a0f</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.animal : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Animal</span><br>    <br><span class="hljs-comment">//调用dog的speak方法</span><br><span class="hljs-number">0x10000da77</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">327</span><span class="hljs-operator">&gt;</span>: movq   (<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br>-&gt;  <span class="hljs-number">0x10000da7b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">331</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-operator">*</span><span class="hljs-number">0x50</span>(<span class="hljs-operator">%</span>rax)<br><span class="hljs-comment">//调用dog的sleep方法</span><br><span class="hljs-number">0x10000dac2</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">402</span><span class="hljs-operator">&gt;</span>: movq   (<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br>    <span class="hljs-number">0x10000dac6</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">406</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-operator">*</span><span class="hljs-number">0x58</span>(<span class="hljs-operator">%</span>rax)<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="总结，"><a href="#总结，" class="headerlink" title="总结，"></a><strong>总结</strong>，</h2><ul>
<li>实际上<code>swift</code>中方法的确认，由<code>虚表</code>来决定。其前<code>8字节</code>存放了类型信息，其后面<code>0x50</code>之后存放地址，重写了父类的方法，则会存储重写后的方法地址，未重写父类的方法，会保存父类的方法，此外还有本类中添加的方法。</li>
<li>代码在编译完，由编译器将函数地址放到<code>metaData</code>中，</li>
<li>在赋值时，由于<code>Dog</code>,和<code>Animal</code>的类型信息不同，会寻找到对应的方法实现。</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>下标、重写</title>
    <url>/2023/03/05/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="subscript下标"><a href="#subscript下标" class="headerlink" title="subscript下标"></a><code>subscript</code>下标</h1><ul>
<li>结构体,对结构体设置，必须要有<code>set</code>方法，才能改结构体内的值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>,y <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br>    <span class="hljs-function"><span class="hljs-keyword">subscript</span>(<span class="hljs-params">index</span>:<span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Point</span> &#123;<br>        <span class="hljs-keyword">set</span> &#123; point <span class="hljs-operator">=</span> newValue &#125;<br><br>        <span class="hljs-keyword">get</span> &#123; point &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> p <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br>p[<span class="hljs-string">&quot;0&quot;</span>].x <span class="hljs-operator">=</span> <span class="hljs-number">11</span> <span class="hljs-comment">//本质上是 p[&quot;0&quot;].x = Point(11,p[&quot;0&quot;].y)</span><br>p[<span class="hljs-string">&quot;0&quot;</span>].y <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li>
<li>类，返回的是引用类型，因此不需要<code>set</code>也能设置<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>,y <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br>    <span class="hljs-function"><span class="hljs-keyword">subscript</span>(<span class="hljs-params">index</span>:<span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Point</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; point &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> p <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br>p[<span class="hljs-string">&quot;0&quot;</span>].x <span class="hljs-operator">=</span> <span class="hljs-number">11</span> <br>p[<span class="hljs-string">&quot;0&quot;</span>].y <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><h2 id="重写类型方法、下标"><a href="#重写类型方法、下标" class="headerlink" title="重写类型方法、下标"></a>重写类型方法、下标</h2><ul>
<li>被<code>class</code>修饰的类型方法、下标，允许被子类重写<ul>
<li>父类如果是<code>class</code>修饰方法，则可以重写，并且新的方法写出<code>static</code>可以防止当前类的子类，继续重写</li>
</ul>
</li>
<li>被<code>static</code>修饰的类型方法、下标，不允许被子类重写</li>
</ul>
<h2 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h2><ul>
<li>重写实例属性<ul>
<li>子类可以将父类的属性（存储、计算） 重写为计算属性</li>
<li>子类不可以将父类属性性重写为存储属性</li>
<li>只能重写<code>var</code>属性，不能重写<code>let</code>属性</li>
<li>重写时，属性名、类型要一致</li>
<li>子类重写后的属性权限 不能小于 父类属性的权限<ul>
<li>如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的</li>
<li>如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的</li>
</ul>
</li>
</ul>
</li>
<li>重写类型属性<ul>
<li>被<code>class</code>修饰的计算类型属性，可以被子类重写,存储属性不能用<code>class</code>修饰，只能被<code>static</code></li>
<li>被<code>static</code>修饰的类型属性（存储、计算），不可以被子类重写</li>
</ul>
</li>
</ul>
<h2 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h2><blockquote>
<p>重写属性观察器，实际上并不会覆盖父类的属性观察器，只是再添加了一次观察器。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Animal:willSet&quot;</span>,newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Animal:didSet&quot;</span>,oldValue)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:<span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dog:willSet&quot;</span>,newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dog:didSet&quot;</span>,oldValue)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> dog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span> ()<br>dog.age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-comment">/*打印结果：</span><br><span class="hljs-comment">Dog:willSet 10</span><br><span class="hljs-comment">Animal:willSet 10</span><br><span class="hljs-comment">Animal:didSet 0</span><br><span class="hljs-comment">Dog:didSet 0</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>重写属性观察器，会先是子类的<code>willSet</code>-&gt;父类的<code>willSet</code>方法，最后是在父类中进行实际的设置，然后父类的<code>didSet</code>方法-&gt;子类的<code>didSet</code>方法</li>
</ul>
<h2 id="通过重写为计算属性增加属性观察器"><a href="#通过重写为计算属性增加属性观察器" class="headerlink" title="通过重写为计算属性增加属性观察器"></a>通过重写为计算属性增加属性观察器</h2><blockquote>
<p>在同一个类中计算属性不能同时有<code>set</code>/<code>get</code>和<code>willset</code>/<code>didSet</code>，但是可以通过重写的方式，使其子类中可以拥有属性观察器。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> num:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num get&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">20</span><br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num set&quot;</span>)<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:<span class="hljs-title">Animal</span> </span>&#123; <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> num: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num:willSet&quot;</span>,newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num:didSet&quot;</span>,oldValue)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> dog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span> ()<br>dog.num <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br><span class="hljs-comment">/*打印结果：</span><br><span class="hljs-comment">num get</span><br><span class="hljs-comment">num:willSet 12</span><br><span class="hljs-comment">num set</span><br><span class="hljs-comment">num:didSet 20</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>重写计算属性，可以为其添加属性观察器，会先调用<code>get</code>方法，给<code>oldValue</code>赋值,再调用<code>willSet</code>、<code>set</code>、<code>didSet</code>方法</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>属性</title>
    <url>/2023/03/01/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h3><ul>
<li><code>lazy</code>属性必须是<code>var</code>，不能是<code>let</code><ul>
<li>必须在实例的初始化方法完成之前就拥有值</li>
</ul>
</li>
<li>如果多条线程同时第一次访问<code>lazy</code>属性<ul>
<li>无法保证属性只被初始化<code>1</code>次</li>
</ul>
</li>
<li>当结构体包含一个延迟存储属性时，只有<code>var</code>才能访问延迟存储属性<ul>
<li>因为延迟属性初始化时需要改变结构体的内存</li>
</ul>
</li>
</ul>
<h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><ul>
<li><code>wil1set</code>会传递新值，默认叫<code>newValue</code></li>
<li><code>didset</code>会传递旧值，默认叫<code>oldValue</code></li>
<li>在初始化器中设置属性值不会触发<code>wil1Set</code>和<code>didset</code></li>
<li>在属性定义时设置初始值也不会触发<code>wi11Set</code>和<code>didset</code><ul>
<li>属性定义是设置，和初始化器中设置，其源码实际是一样的</li>
</ul>
</li>
<li>属性观察器，计算属性的功能，同样可以应用在全局变量、局部变量身上</li>
</ul>
<h3 id="inout探究"><a href="#inout探究" class="headerlink" title="inout探究"></a>inout探究</h3><blockquote>
<p>此前对函数inout进行探究，其值传入的是地址。但和属性值关联起来使用，会有所不同</p>
</blockquote>
<ul>
<li>例子,用<code>Int</code>类型，能在内存中直观看到传的值<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> width:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br>    <span class="hljs-keyword">var</span> side:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;willSet&quot;</span>,newValue)<br>        &#125;<br><br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;didSet&quot;</span>,oldValue,side)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> area:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>           <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;getArea&quot;</span>)<br>           <span class="hljs-keyword">return</span> width <span class="hljs-operator">*</span> side<br>        &#125;<br>        <br>        <span class="hljs-keyword">set</span> &#123;<br>            width <span class="hljs-operator">=</span> newValue <span class="hljs-operator">/</span> side<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;setArea&quot;</span>)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">init</span>()</span> &#123;<br>        <span class="hljs-keyword">self</span>.side  <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;设置Num&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> s <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="单纯存储属性调用"><a href="#单纯存储属性调用" class="headerlink" title="单纯存储属性调用"></a>单纯存储属性调用</h4><ul>
<li>纯属性调用,<code>test(&amp;s.width)</code>,很显然是拿到数据地址(<code>width</code>是第一个，它的地址，即函数地址，第一个存的<code>8</code>，第二个是<code>2</code>)，作为<code>rdi</code>参数，之后进行函数调用。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-number">0x1000054c4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">52</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-number">0xb745</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span><br>-&gt;  <span class="hljs-number">0x1000054cb</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">59</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008620</span>               ; <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-keyword">inout</span> <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">240</span><br><span class="hljs-comment">//内存情况</span><br>x<span class="hljs-operator">/</span>4xg <span class="hljs-number">0x0000000100010c10</span><br><span class="hljs-number">0x100010c10</span>: <span class="hljs-number">0x0000000000000008</span> <span class="hljs-number">0x0000000000000002</span><br><span class="hljs-number">0x100010c20</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="计算属性调用"><a href="#计算属性调用" class="headerlink" title="计算属性调用"></a>计算属性调用</h4><ul>
<li>计算属性调用,<code>test(&amp;s.area)</code>，输出<code>getArea</code>、<code>设置Num</code>、<code>setArea</code>。首先计算属性会通过<code>get</code>取值拿到局部变量之后，将局部变量地址传进<code>test</code>函数去设置，设置完毕之后，再调用<code>set</code>方法。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100005266</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">54</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0xb9a3</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span><br>    <span class="hljs-number">0x10000526d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">61</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0xb9a4</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rsi        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br>-&gt;  <span class="hljs-number">0x100005274</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">68</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008120</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.area.getter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">226</span><br>    <span class="hljs-number">0x100005279</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">73</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x10000527d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">77</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100005281</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">81</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008550</span>               ; <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-keyword">inout</span> <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">242</span><br>    <span class="hljs-number">0x100005286</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">86</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x10000528a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">90</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-number">0xb97f</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>r13        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span><br>    <span class="hljs-number">0x100005291</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">97</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008290</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.area.setter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">231</span><br></code></pre></td></tr></table></figure></li>
<li>汇编验证<ol>
<li><code>movq   0xb9a3(%rip) , %rdi</code>、<code>movq   0xb9a4(%rip), %rsi</code>,<code>rdi</code>和<code>rsi</code>作为参数，这里将<code>width</code>和<code>side</code>地址上的存<code>8</code>和<code>2</code>分别进行赋值；作为后续调用<code>area.getter</code>的参数</li>
<li><code>rax</code>作为返回值，这里将get返回的结果赋值给，<code>-0x28(%rbp)</code>地址空间上,<code>rbp</code>是局部变量，代码在main函数中，是main函数的局部变量</li>
<li><code>leaq   -0x28(%rbp), %rdi</code>,将局部变量的地址赋予<code>rdi</code>作为函数参数，调用<code>test(inout Swift.Int)</code>方法</li>
<li><code> movq   -0x28(%rbp), %rdi</code>,<code>leaq   0xb97f(%rip), %r13</code>,将3中生成的局部变量的值赋值<code>rdi</code>作为参数,即<code>s</code>地址也作为参数，调用<code>area.setter</code>进行赋值</li>
</ol>
</li>
</ul>
<h4 id="带属性观察器的存储属性调用"><a href="#带属性观察器的存储属性调用" class="headerlink" title="带属性观察器的存储属性调用"></a>带属性观察器的存储属性调用</h4><ul>
<li>存储属性调用,<code>test(&amp;s.side)</code>，输出<code>设置Num</code>、<code>willSet 20</code>、<code>didSet 2 20</code>。先设置值，方法执行完毕后，才调用<code>willSet</code>和<code>didSet</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100005326</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">54</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0xb8eb</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rax        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br>-&gt;  <span class="hljs-number">0x10000532d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">61</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100005331</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">65</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x100005335</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">69</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100008610</span>               ; <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-keyword">inout</span> <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">242</span><br>    <span class="hljs-number">0x10000533a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">74</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <span class="hljs-number">0x10000533e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">78</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-number">0xb8cb</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>r13        ; <span class="hljs-type">SwiftDText</span>.s : <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span><br>    <span class="hljs-number">0x100005345</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">85</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x100007f30</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.side.setter : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">215</span><br>    <span class="hljs-number">0x10000534a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">90</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br></code></pre></td></tr></table></figure></li>
<li>汇编验证<ol>
<li><code>movq 0xb8eb(%rip), %rax</code>,<code>movq   %rax, -0x28(%rbp)</code>,这里取出<code>sid</code>的值，取出来，将他赋值给局部变量<code> -0x28(%rbp)</code></li>
<li><code>leaq   -0x28(%rbp), %rdi</code>,这里将局部变量的地址取出作为参数，传递给<code>test</code>函数</li>
<li><code>movq   -0x28(%rbp), %rdi</code>,<code>leaq   0xb8cb(%rip), %r13</code>,这里将修改后的局部变量，以及<code>s</code>作为参数，调用<code>side.setter</code></li>
<li><code>side.setter</code>方法<ol>
<li>这里<code>r13</code>，<code>rdi</code>的值始终保持不变，一个是<code>s</code>，一个是新值，也作为<code>willSet</code>方法和<code>didiSet</code>方法的参数调用</li>
<li>在<code>%rax, 0x8(%r13)</code>,<code>didiSet</code>方法之前，将<code>rax</code>的值。即<code>-0x30(%rbp)</code>内存中的值(最开始<code>rdi</code>赋值的)，进行了新值的替换，<code>r13</code>是<code>s</code>，其后8字节即<code>side</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100007f34</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>r13<br><span class="hljs-number">0x100007f36</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">6</span><span class="hljs-operator">&gt;</span>:  subq   <span class="hljs-variable">$0</span>x38, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100007f3a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">10</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x38</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f3e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">14</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x30</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f42</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f4a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">26</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f52</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">34</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f5a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">42</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f5e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">46</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f62</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">50</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-number">0x8</span>(<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rax<br><span class="hljs-number">0x100007f66</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">54</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f6a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">58</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100007f6e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">62</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100007f90</span>               ;       <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.side.willset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">216</span><br><span class="hljs-number">0x100007f73</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">67</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x38</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>r13<br><span class="hljs-number">0x100007f77</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">71</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x30</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rax<br><span class="hljs-number">0x100007f7b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">75</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x28</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100007f7f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">79</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0x8</span>(<span class="hljs-operator">%</span>r13)<br><span class="hljs-number">0x100007f83</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">83</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100008080</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Circle</span>.side.didset : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">220</span><br><span class="hljs-number">0x100007f88</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">88</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x38, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100007f8c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">92</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>r13<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>有属性观察器的存储属性，实现和计算属性一样，采用<code>拷入拷出</code>或者<code>值结果调用</code>的方式，目的是为了设置完属性后，可以触发属性观察器。本质上<code>test</code>函数内部，是不会触发属性观察器的。</li>
</ul>
<h4 id="inout总结"><a href="#inout总结" class="headerlink" title="inout总结"></a>inout总结</h4><ul>
<li>如果实参有物理内存地址，且没有设置属性观察器<ul>
<li>直接将实参的内存地址传入函数（实参进行引用传递）</li>
</ul>
</li>
<li>如果实参是计算属性 或者 设置了属性观察器<ul>
<li>采取了<code>Copy In Copy Out</code>(<code>拷入拷出</code>)的做法<ul>
<li>调用该函数时 ，先复制实参的值，产生副本(局部变量),调用<code>get</code>（存储属性是直接取值，计算属性是<code>get</code>）</li>
<li>将副本的内存地址传入函数（副本进行引1用传递），在函数内部可以修改副本的值</li>
<li>函数返回后，再将副本的值覆盖实参的值,调用(<code>set</code>)</li>
</ul>
</li>
</ul>
</li>
<li>总结：<code>inout</code>的本质就是引用传递（地址传递）</li>
</ul>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><ul>
<li>严格来说，属性可以分为<ul>
<li>实例属性 ( Instance Property)：只能通过实例去访问<ul>
<li>存储实例属性 ( Stored Instance Property）：存储在实例的内存中，每个实例都有1份，</li>
<li>计算实例属性 ( Computed Instance Property )</li>
</ul>
</li>
<li>类型属性( Type Property ）：只能通过类型去访问<ul>
<li>存储类型属性 ( Stored Type Property)：整个程序运行过程中，就只有1份内存（类似于<strong>全局变量</strong>)</li>
<li>计算类型属性 ( Computed Type Property )</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="类型属性细节"><a href="#类型属性细节" class="headerlink" title="类型属性细节"></a>类型属性细节</h4><ul>
<li>不同于存储实例属性，你必须给存储类型属性设定初始值<ul>
<li>因为类型没有像实例那样的<code>init</code>初始化器来初始化存储属性</li>
</ul>
</li>
<li>存储类型属性默认就是<code>lazy</code>，会在第一次使用的时候才初始化<ul>
<li>就算被多个线程同时访问，保证只会初始化一次,会使用<code>dispatch_once</code>技术</li>
</ul>
</li>
<li>枚举类型也可以定义<strong>类型属性</strong>（存储类型属性、计算类型属性）<ul>
<li>枚举类型中不可以定义存储实例属性，但是可以定义类型属性</li>
<li>这是因为类型属性，不在实例中，属于全局变量</li>
</ul>
</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ol>
<li><code>private</code>保证外界不会调用初始化方法</li>
<li>使用类型属性，是<code>lazy</code>，会在第一次使用的时候才初始化，并且保证只会初始化一次，线程安全的,和OC中<code>dispatch_once</code>一致<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileManager</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">FileManager</span> ()<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">init</span>( &#123; &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="汇编查看"><a href="#汇编查看" class="headerlink" title="汇编查看"></a>汇编查看</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> count  <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">var</span> num1 <span class="hljs-operator">=</span> <span class="hljs-number">11</span> <br><span class="hljs-type">Car</span>.count <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br><span class="hljs-keyword">var</span> num3 <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<ul>
<li>汇编代码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//num1的赋值</span><br> <span class="hljs-number">0x100003c18</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-variable">$0</span>xb, <span class="hljs-number">0x453d</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-keyword">static</span> <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Car</span>.count : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">4</span><br>    <span class="hljs-number">0x100003c23</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">19</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003c90</span>               ; <span class="hljs-type">SwiftDText</span>.<span class="hljs-type">Car</span>.count.unsafeMutableAddressor : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift<br>    <span class="hljs-number">0x100003c28</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">24</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">%</span>rdi<br>-&gt;  <span class="hljs-number">0x100003c2b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">27</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rdi, <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp)<br>    <span class="hljs-number">0x100003c2f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">31</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rsi<br>    <span class="hljs-number">0x100003c33</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">35</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x21, <span class="hljs-operator">%</span>edx<br>    <span class="hljs-number">0x100003c38</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">40</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br>    <span class="hljs-number">0x100003c3a</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">42</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>ecx<br>    <span class="hljs-number">0x100003c3c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">44</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003e6e</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_beginAccess<br>    <span class="hljs-number">0x100003c41</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">49</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rax<br>    <span class="hljs-comment">//这里对count赋值</span><br>    <span class="hljs-number">0x100003c45</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">53</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>xc, (<span class="hljs-operator">%</span>rax)<br>    <span class="hljs-number">0x100003c4c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">60</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br>    <br><span class="hljs-comment">//num3的赋值</span><br><span class="hljs-number">0x100003c55</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">69</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x9, <span class="hljs-number">0x4508</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.num1 : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">4</span><br>    <span class="hljs-number">0x100003c60</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">80</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br></code></pre></td></tr></table></figure></li>
<li>分析汇编<ol>
<li><code>num1</code>的地址<code>0x100008160</code>、count的地址<code>0x0000000100008158</code>,num3的地址<code>0x100008168</code>，显然<code>count</code>和<code>num1</code>以及<code>num3</code>的地址是连续的，而num1和num3是全局变量，显然<code>count</code>和<code>num1</code>和<code>num3</code>一样，均是全局变量</li>
<li>类属性本质就是全局变量，相比一般的全局变量，类属性可以增加访问权限控制。</li>
</ol>
</li>
<li>类属性的<code>lazy</code>加载分析,通过<code>SIL</code>源码编译查看<ol>
<li>指令<code>swiftc -emit-sil main.swift -o main.sil</code>生成<code>SIL</code></li>
<li><code>count</code>加了<code>static</code>是全局变量，其初始化方法调用了<code>global_init_once_fn</code>（类似<code>dispatch_once</code>,保证只会初始化一次）,其内部载第一次加载的时候初始化，并赋值2，<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>  <span class="hljs-meta">@_hasStorage</span> <span class="hljs-meta">@_hasInitialValue</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> count: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>  <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">deinit</span><br>  <span class="hljs-function"><span class="hljs-keyword">init</span>()</span><br>&#125;<br><br><br><span class="hljs-comment">// one-time initialization function for count</span><br>sil <span class="hljs-keyword">private</span> [global_init_once_fn] @<span class="hljs-variable">$s4main3CarC5count_WZ</span> : $<span class="hljs-keyword">@convention(c)</span> () -&gt; () &#123;<br>bb0:<br>  alloc_global @<span class="hljs-variable">$s4main3CarC5countSivpZ</span>           <span class="hljs-comment">// id: %0</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> global_addr @<span class="hljs-variable">$s4main3CarC5countSivpZ</span> : $<span class="hljs-operator">*</span><span class="hljs-type">Int</span> <span class="hljs-comment">// user: %4</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> integer_literal <span class="hljs-variable">$Builtin</span>.<span class="hljs-type">Int64</span>, <span class="hljs-number">2</span>          <span class="hljs-comment">// user: %3</span><br>  <span class="hljs-operator">%</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">$Int</span> (%2 : <span class="hljs-title">$Builtin</span>.<span class="hljs-title">Int64</span>)          // <span class="hljs-title">user</span>: %4</span><br><span class="hljs-class">  <span class="hljs-title">store</span> %3 <span class="hljs-title">to</span> %1 : <span class="hljs-title">$</span>*<span class="hljs-title">Int</span>                          // <span class="hljs-title">id</span>: %4</span><br><span class="hljs-class">  %5 = <span class="hljs-title">tuple</span> ()                                   // <span class="hljs-title">user</span>: %6</span><br><span class="hljs-class">  <span class="hljs-title">return</span> %5 : <span class="hljs-title">$</span>()                                 // <span class="hljs-title">id</span>: %6</span><br><span class="hljs-class">&#125; // <span class="hljs-title">end</span> <span class="hljs-title">sil</span> <span class="hljs-title">function</span> &#x27;<span class="hljs-title">$s4main3CarC5count_WZ</span>&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2023/02/27/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote>
<p>一个函数和它所捕获的变量\常量环境组合起来，称为闭包</p>
<ul>
<li>一般指定义在函数内部的函数</li>
<li>一般它捕获的是外层的局部变量\常量</li>
</ul>
</blockquote>
<h2 id="闭包本质查看"><a href="#闭包本质查看" class="headerlink" title="闭包本质查看"></a>闭包本质查看</h2><h3 id="不捕获变量"><a href="#不捕获变量" class="headerlink" title="不捕获变量"></a>不捕获变量</h3><ul>
<li>源码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> i<br>    &#125;<br>    <span class="hljs-keyword">return</span> plus(i:)<br>&#125;<br><span class="hljs-keyword">var</span> fu <span class="hljs-operator">=</span> getFun()<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.stride(ofValue: fu)) <span class="hljs-comment">//16</span><br></code></pre></td></tr></table></figure></li>
<li>汇编查看<ul>
<li><code>rax</code>一般为返回值，很明显将<code>0xe5(%rip)</code>的地址存放在计算器<code>rax</code>中，返回<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">SwiftDText</span>`getFun():<br>-&gt;  <span class="hljs-number">0x100004e10</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004e11</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004e14</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-number">0xe5</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rax          ; plus(i: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">195</span><br>    <span class="hljs-number">0x100004e1b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">11</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>ecx, <span class="hljs-operator">%</span>ecx<br>    <span class="hljs-number">0x100004e1d</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">13</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-operator">%</span>ecx, <span class="hljs-operator">%</span>edx<br>    <span class="hljs-number">0x100004e1f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">15</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br>    <span class="hljs-number">0x100004e20</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">16</span><span class="hljs-operator">&gt;</span>: retq   <br></code></pre></td></tr></table></figure></li>
<li>查看<code>rax</code>地址,很明显存放的是函数地址，显然不捕获变量的闭包，直接返回了函数的地址。并且和<code>fu</code>的指针一致。  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">register read rax<br>rax <span class="hljs-operator">=</span> <span class="hljs-number">0x0000000100004f00</span>  <span class="hljs-type">SwiftDText</span>`plus(i: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">195</span><br>p fu<br>() <span class="hljs-variable">$R0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0000000100004f00</span> <br></code></pre></td></tr></table></figure></li>
<li>此外将<code>xorl   %ecx, %ecx</code>进行异或,其值为<code>0</code>，并将结果赋值给<code>edx</code>（<code>edx</code>与<code>rdx</code>共寄存器，只是一个<code>4</code>字节，一个<code>8</code>字节),也可理解为赋值给了<code>rdx</code></li>
<li><code>fn</code>指针变量是<code>16</code>字节空间，<ul>
<li>其中赋值的地址为<code>0x100002299 + 0xe337 = 0x1000105D0</code>,<code>0x1000022a0 + 0xe338 = 0x1000105D8</code>,并且为<code>movq</code>(占<code>8</code>字节)数据移动赋值</li>
<li>因此，很显然这里将<code>rax</code>中的函数地址地址赋予<code>fu</code>，同时<code>rdx</code>也赋值给了<code>fu</code>，<code>rdx</code>和后续捕获变量有关系<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100002292</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0xe337</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span><br><span class="hljs-number">0x100002299</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rdx, <span class="hljs-number">0xe338</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br><span class="hljs-number">0x1000022a0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">32</span><span class="hljs-operator">&gt;</span>:  movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edi<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h3><ul>
<li>源码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span>,num2 <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>    <span class="hljs-keyword">return</span> plus(i:)<br>&#125;<br><span class="hljs-keyword">var</span> fu <span class="hljs-operator">=</span> getFun()<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>.stride(ofValue: fu)) <span class="hljs-comment">//16</span><br></code></pre></td></tr></table></figure></li>
<li>汇编查看<ul>
<li>汇编源码<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-number">0x100008870</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x100008871</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x100008874</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  subq   <span class="hljs-variable">$0</span>x10, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100008878</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x8</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100008880</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">16</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x0, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100008888</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">24</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x9, <span class="hljs-operator">-</span><span class="hljs-number">0x8</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100008890</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">32</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x3, <span class="hljs-operator">-</span><span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100008898</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">40</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0x3b79</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; _swift_FORCE_LOAD_<span class="hljs-variable">$_swiftIOKit_</span><span class="hljs-variable">$_SwiftDText</span> <span class="hljs-operator">+</span> <span class="hljs-number">24</span><br><span class="hljs-number">0x10000889f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">47</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x20, <span class="hljs-operator">%</span>esi<br><span class="hljs-number">0x1000088a4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">52</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x7, <span class="hljs-operator">%</span>edx<br><span class="hljs-number">0x1000088a9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">57</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x10000ab86</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_allocObject<br><span class="hljs-number">0x1000088ae</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">62</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">%</span>rax, <span class="hljs-operator">%</span>rdx <span class="hljs-comment">//堆生成的对象，给了rdx</span><br><span class="hljs-number">0x1000088b1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">65</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x9, <span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>rdx)  <span class="hljs-comment">//9赋值给了rdx后16字节</span><br><span class="hljs-number">0x1000088b9</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">73</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-variable">$0</span>x3, <span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rdx) <span class="hljs-comment">//3赋值给了rdx后24字节</span><br><span class="hljs-number">0x1000088c1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">81</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0xf8</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rax          ; partial apply forwarder <span class="hljs-keyword">for</span> function signature specialization <span class="hljs-operator">&lt;</span><span class="hljs-type">Arg</span>[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Value</span> <span class="hljs-type">Promoted</span> from <span class="hljs-type">Box</span>, <span class="hljs-type">Arg</span>[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Value</span> <span class="hljs-type">Promoted</span> from <span class="hljs-type">Box</span><span class="hljs-operator">&gt;</span> of plus(i: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at <span class="hljs-operator">&lt;</span>compiler<span class="hljs-operator">-</span>generated<span class="hljs-operator">&gt;</span> <span class="hljs-comment">//注意这里和之前未捕获的不同</span><br><span class="hljs-number">0x1000088c8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">88</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x10, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x1000088cc</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">92</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x1000088cd</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">93</span><span class="hljs-operator">&gt;</span>: retq <br></code></pre></td></tr></table></figure></li>
<li>可以看出调用了<code>swift_allocObject</code>，在堆空间生成了对象。并且该对象的地址返回在<code>rax</code>中,打印出地址，以及存储的<code>num</code>,<code>num2</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">register read rax<br>    rax <span class="hljs-operator">=</span> <span class="hljs-number">0x0000600000208000</span><br><span class="hljs-comment">//显示地址的内存，6组，每组8字节，按16进制显示</span><br>x<span class="hljs-operator">/</span>6xg <span class="hljs-number">0x0000600000208000</span><br><span class="hljs-number">0x600000208000</span>: <span class="hljs-number">0x000000010000c418</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000208010</span>: <span class="hljs-number">0x0000000000000009</span> <span class="hljs-number">0x0000000000000003</span><br><span class="hljs-number">0x600000208020</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure></li>
<li><code>leaq    0xf8(%rip), %rax</code>，<code>movq   $0x9, 0x10(%rdx)、movq   $0x3, 0x18(%rdx)</code>,函数地址传给了<code>rax</code>,生成的包装<code>num</code> 的对象传给了<code>rdx</code>,<code>rdx</code>和<code>rax</code>一般用做函数返回值。实际返回结果后，将<code>rax</code>和<code>rdx</code>上的值，赋值给了<code>fn对象</code>（由于在全局区执行，所以是<code>rip</code>，全局变量）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-number">0x100005f62</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">18</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rax, <span class="hljs-number">0xaca7</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span><br><span class="hljs-number">0x100005f69</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">25</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rdx, <span class="hljs-number">0xaca8</span>(<span class="hljs-operator">%</span>rip)        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span><br><span class="hljs-comment">//此时rip的的地址是0x100010C10，将rax和rdx存在该地址的内存上，一个为函数地址，一个为存储的变量地址</span><br>x<span class="hljs-operator">/</span>2g <span class="hljs-number">0x100010C10</span><br><span class="hljs-number">0x100010c10</span>: <span class="hljs-number">0x00000001000089c0</span> <span class="hljs-number">0x0000600000208000</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，和未捕获的闭包表达式不同，捕获了变量的闭包，其赋值给<code>rdx</code>的函数地址，和实际的不同.(xcode旁边的注解和捕获变量的赋值，是不一样的)，实际上，该函数地址进行了一次包装<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//实际调用函数的地方</span><br><span class="hljs-number">0x100005f97</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">71</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0xac7a</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>r13        ; <span class="hljs-type">SwiftDText</span>.fu : (<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span> <span class="hljs-comment">//这里实际将，num包装的堆地址传给了r13</span><br><span class="hljs-number">0x100005f9e</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">78</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">-</span><span class="hljs-number">0x80</span>(<span class="hljs-operator">%</span>rbp)<br><span class="hljs-number">0x100005fa2</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">82</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>r13, <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100005fa5</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">85</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000abf2</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_retain<br><span class="hljs-number">0x100005faa</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">90</span><span class="hljs-operator">&gt;</span>:  leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100005fae</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">94</span><span class="hljs-operator">&gt;</span>:  callq  <span class="hljs-number">0x10000abb6</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_endAccess<br><span class="hljs-number">0x100005fb3</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">99</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">-</span><span class="hljs-number">0x88</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rax<br><span class="hljs-number">0x100005fba</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">106</span><span class="hljs-operator">&gt;</span>: movl   <span class="hljs-variable">$0</span>x1, <span class="hljs-operator">%</span>edi<br><span class="hljs-number">0x100005fbf</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">111</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-operator">*%</span>rax<br><span class="hljs-comment">//函数内部</span><br><span class="hljs-number">0x1000089c0</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">0</span><span class="hljs-operator">&gt;</span>:  pushq  <span class="hljs-operator">%</span>rbp  <span class="hljs-comment">//即上面rax中存放的地址</span><br><span class="hljs-number">0x1000089c1</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-operator">%</span>rsp, <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x1000089c4</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">4</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0x10</span>(<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rsi <span class="hljs-comment">//将r13中的num包装对象偏移16字节（即num）取出，偏移24字节num2，传给rsi作为函数参数</span><br><span class="hljs-number">0x1000089c8</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">8</span><span class="hljs-operator">&gt;</span>:  movq   <span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>r13), <span class="hljs-operator">%</span>rdx<br><span class="hljs-number">0x1000089cc</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">12</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x1000089cd</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">13</span><span class="hljs-operator">&gt;</span>: jmp    <span class="hljs-number">0x100008920</span>               ; function signature specialization <span class="hljs-operator">&lt;</span><span class="hljs-type">Arg</span>[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Value</span> <span class="hljs-type">Promoted</span> from <span class="hljs-type">Box</span>, <span class="hljs-type">Arg</span>[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Value</span> <span class="hljs-type">Promoted</span> from <span class="hljs-type">Box</span><span class="hljs-operator">&gt;</span> of plus(i: <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span> at main.swift:<span class="hljs-number">197</span> <span class="hljs-comment">//最终实际地址是0x100008920  </span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="捕获的时机"><a href="#捕获的时机" class="headerlink" title="捕获的时机"></a>捕获的时机</h3><ul>
<li><strong>注意</strong>，捕获只会在使用的时候进行捕获，这里捕获的是<code>20</code>，而非<code>9</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> i<br>    &#125;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> plus(i:)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,如果没有执行，则不会捕获，和此前未捕获变量一致<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> i<br>    &#125;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-variable">$0</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,如果是全局变量，也不会进行捕获</li>
<li><strong>注意</strong>,上面的函数中未对<code>num</code>和<code>num2</code>进行修改，最终这两个数(3个以上也是这样)，会包装成一个堆对象</li>
<li><strong>注意</strong>,下面的函数对<code>num</code>和<code>num2</code>进行修改，最终这<code>两</code>个数，会<code>分别</code>包装成一个堆对象，汇编查看会生成两个堆对象<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>,(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>) &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span>,num2 <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        num <span class="hljs-operator">+=</span> i<br>        num2 <span class="hljs-operator">+=</span> i<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,下面会生成两个堆对象，每个堆对象包装了<code>num</code>和<code>num2</code>（由于未修改）。如果<code>num</code>和<code>num2</code>修改了，也只会分别生成一个，不会因为两次闭包捕获，各自生成一次。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFun</span>()</span> -&gt;((<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>,(<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>) &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">9</span>,num2 <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minus</span>(<span class="hljs-params">i</span>:<span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">+</span> num2 <span class="hljs-operator">+</span> i<br>    &#125;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> (plus(i:),minus(i:))<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>可以把闭包想象成是一个类的实例对象<ul>
<li>内存在堆空间</li>
<li>捕获的局部变量\常量就是对象的成员（存储属性）</li>
<li>组成闭包的函数就是类内部定义的方法</li>
</ul>
</li>
</ul>
<h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><blockquote>
<p>自动闭包的参数会延迟执行，甚至不执行</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getfirstPositive</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">v1</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">v2</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span>? &#123;<br><span class="hljs-keyword">return</span> v1 <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">?</span> v1 : v2 ()<br>&#125;<br>getFirstPositive(<span class="hljs-operator">-</span><span class="hljs-number">4</span>, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>@autoclosure</code> 会自动将<code>20</code> 封装成闭包<code>&#123; 20 &#125;</code></li>
<li><code>@autoclosure</code> 只支持<code>()一＞T</code>格式的参数</li>
<li>空合并运算符<code>??</code>使用了<code>@autoclosure</code> 技术<ul>
<li><code>func ?? &lt;T&gt;(optional:T?,defaultValue:@autoclosure() throws -&gt; T?) rethrows -&gt; T?</code></li>
</ul>
</li>
<li>有<code>@autoclosure</code>、无<code>@autoclosure</code>，构成了函数重载</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>结构体与类</title>
    <url>/2023/02/26/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="结构体是值类型（枚举也是值类型），类是引用类型（指针类型）"><a href="#结构体是值类型（枚举也是值类型），类是引用类型（指针类型）" class="headerlink" title="结构体是值类型（枚举也是值类型），类是引用类型（指针类型）"></a>结构体是值类型（枚举也是值类型），类是引用类型（指针类型）</h1><ul>
<li>例子<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> width <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> height <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>    <span class="hljs-keyword">var</span> y <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> size <span class="hljs-operator">=</span> <span class="hljs-type">Size</span>()<br>    <span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>执行<code>test()</code>方法时的内存地址,(<code>64</code>位)<br><img src="1.png"><ul>
<li>内存地址由<code>高</code>到<code>低</code>在栈中赋值，结构体直接存储在<code>栈</code>上，类在<code>栈</code>上存的是<code>8</code>字节的<code>指针地址</code></li>
<li>堆空间的<code>Size</code>对象占<code>32</code>位，其中<code>16</code>位存<code>width</code>，<code>height</code>数据，<code>8</code>位存<code>引用计数</code>，<code>8</code>位<code>类型信息</code>的地址</li>
</ul>
</li>
<li>注意，类的指针和结构体存的地方不一定在栈，<ul>
<li>如果在全局区生成，则类的指针和结构体在全局区，</li>
<li>如果结构体变量为类的属性，则会和该类一起在堆区生成</li>
<li>如果在函数内生成，则类的指针和结构体在栈区</li>
</ul>
</li>
</ul>
<h1 id="类和结构体的大小"><a href="#类和结构体的大小" class="headerlink" title="类和结构体的大小"></a>类和结构体的大小</h1><ul>
<li>类中用<code>MemoryLayout</code>获取的大小，实际是指针大小始终位<code>8</code><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Size</span>&gt;.stride) <span class="hljs-comment">// 8,Size指针变量因此是8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Point</span>&gt;.stride) <span class="hljs-comment">// 16，</span><br></code></pre></td></tr></table></figure></li>
<li>获取类内存中的指针数据<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> size <span class="hljs-operator">=</span> <span class="hljs-type">Size</span>()<br><span class="hljs-keyword">let</span> sizePoint <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeRawPointer</span>(bitPattern: <span class="hljs-built_in">unsafeBitCast</span>(size, to: <span class="hljs-type">UInt</span>.<span class="hljs-keyword">self</span>))<span class="hljs-operator">!</span> <span class="hljs-comment">//存放在堆中的引用地址</span><br>malloc_size(sizePoint) <span class="hljs-comment">//32 获取堆中的内存数据大小</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="值类型赋值"><a href="#值类型赋值" class="headerlink" title="值类型赋值"></a>值类型赋值</h1><ul>
<li>值类型赋值给<code>var</code>、<code>let</code>或者给函数传参，是直接将所有内容拷贝一份</li>
<li>类似于对文件进行<code>copy</code>、<code>paste</code>操作，产生了全新的文件副本。属于深拷贝 ( <code>deep copy</code> )</li>
</ul>
<h2 id="结构体的Copy-on-Write"><a href="#结构体的Copy-on-Write" class="headerlink" title="结构体的Copy on Write"></a>结构体的Copy on Write</h2><ul>
<li>在<code>swift</code>标准库中，为了提升性能，<code>String</code>、<code>Array</code>、<code>Dictionary</code>、<code>set</code>采取了<code>Copy On Write</code>的技术<ul>
<li>比如仅当有<code>“写</code>〞操作时 ，才会真正执行拷贝操作</li>
<li>对于标准库值类型的赋值操作 ，<code>Swift</code> 能确保最佳性能，所有没必要为了<code>保证最佳性能来避免赋值</code><ul>
<li>如果是非标准库的结构体，是不会有写时拷贝的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="引用类型赋值"><a href="#引用类型赋值" class="headerlink" title="引用类型赋值"></a>引用类型赋值</h2><ul>
<li>引用赋值给<code>var</code>、 <code>let</code>或者给函数传参，是将内存地址拷贝一份</li>
<li>类似于制作一个文件的替身（快捷方式、链接），指向的是同一个文件。属于浅拷贝 (<code>shallow copy</code>)</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>汇编基本认识，x86汇编</title>
    <url>/2023/02/25/iOS%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>软件、程序的执行过程<br><img src="1.png"></li>
<li>通常，cpu会将内存中的数据存储到寄存器中，然后再对寄存器中的数据进行计算</li>
<li>假设内存中有块<code>红色内存空间</code>的值是3，现在想把它的值加1，并将结果存储到<code>蓝色内存空间</code><ul>
<li>CPU首先会将<code>红色内存空间</code>的值放到<code>rax寄存器</code>中: <code>movq</code> <code>红色内存空间</code>, <code>%rax</code></li>
<li>然后让rax寄存器与1相加，送回到rax中：<code>addq</code> <code>$0x1</code>,<code>%rax</code>,</li>
<li>最后将值赋值给内存空间：<code>movq</code> <code>%rax</code>，<code>蓝色内存空间</code></li>
</ul>
</li>
<li>CPU不支持内存之间的改变，因此要通过寄存器，并且寄存器内操作，速度要快些<h3 id="语言发展"><a href="#语言发展" class="headerlink" title="语言发展"></a>语言发展</h3></li>
</ul>
<ol>
<li>机器语言<ul>
<li>由0和1组成</li>
</ul>
</li>
<li>汇编语言( Assembly Language )<ul>
<li>用符号代替了O和1，比机器语言便于阅读和记忆</li>
</ul>
</li>
<li>高级语言<ul>
<li>C\C++\java\javaScript\Python等，更接近人类自然语言</li>
</ul>
</li>
</ol>
<ul>
<li>例如，将寄存器BX的内容送入奇存器AX<ul>
<li>机器语言：1000100111011000</li>
<li>汇编语言：movw %bx, %ax</li>
<li>高级语言：ax = bx;</li>
</ul>
</li>
<li>汇编语言与机器语言一一对应，但是高级语言和汇编语言不是一一对应的</li>
<li>汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言</li>
<li>高级语言可以通过编译得到;汇编语言\机器语言 ，但汇编语言\机器语言几乎不可能还原成高级语言</li>
<li>iOS中，主要的汇编语言是<ul>
<li>AT&amp;T汇编 -＞ ioS模拟器</li>
<li>ARM汇编 -＞ ioS真机设备</li>
</ul>
</li>
</ul>
<h3 id="常见的x86汇编指令"><a href="#常见的x86汇编指令" class="headerlink" title="常见的x86汇编指令"></a>常见的x86汇编指令</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="left">AT&amp;T</th>
<th>Intel</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器命名</td>
<td align="left">%rax</td>
<td>rax</td>
<td align="left"></td>
</tr>
<tr>
<td>操作数顺序</td>
<td align="left">movq %rax, %rdx</td>
<td>mov rdx, rax</td>
<td align="left">将rax的值赋值给rdx</td>
</tr>
<tr>
<td>常数\立即数</td>
<td align="left">movq <code>$3</code>, <code>%rax</code> ;movq <code>$0x10</code>, %rax</td>
<td>mov rax, 3   ;  mov rax, 0x10</td>
<td align="left">将3赋值给rax;  将Ox10赋值给rax,(带$符号的都是立即数，即常数)</td>
</tr>
<tr>
<td>内存赋值</td>
<td align="left">movq $0xa, 0x1ff7(%rip)</td>
<td>mov qword ptr [rip+0x1ff7],     0xa</td>
<td align="left">将0xa赋值给地址为rip +0x1ff7的内存空间（注意执行指令，<code>rip</code>中存放了下一条指令的地址,因此此时相加的是与下一条指令相加的地址）</td>
</tr>
<tr>
<td>取内存地址</td>
<td align="left">leaq -0x18(%rbp), %rax</td>
<td>lea rax, [rbp - 0x181]</td>
<td align="left">将rbp-0x18这个地址值赋值给rax</td>
</tr>
<tr>
<td>jmp指令</td>
<td align="left">jmp *%rdx; jmp 0×4001002; jmp *(%rax)</td>
<td>jmp rdx ;jmp 0×4001002;jmp [rax]</td>
<td align="left">jmp 0×4001002 ，跳到指定内存地址，去执行代码。  jmp *%rdx  间接跳转rdx的地址</td>
</tr>
<tr>
<td>call 指令</td>
<td align="left">call 0x19001632               call *%rdx</td>
<td>callq 0x19001632              call   %rdx</td>
<td align="left">跳转到函数地址进行执行，会和retq(会返回当初callq调用的下一个指令)配和使用，和jmp不同</td>
</tr>
<tr>
<td>操作数长度</td>
<td align="left">movl %eax, %edx; movb $0x10, %al; leaw 0x10(%d×), %ax</td>
<td>mov edx, eax;mov al, 0x10;lea ax, [dx + 0x10]</td>
<td align="left">b = byte (8-bit) ;s = short (16-bit integer or 32-bit floating point) ;W = word (16-bit);I = long (32-bit integer or 64-bit floating point);q = quad (64 bit);t = ten bytes (80-bit floating point)</td>
</tr>
</tbody></table>
<ul>
<li>操作数长度，代表要覆盖的长度，列如<code>movq 0xa, (0x110)</code>,将0xa存放在0x110地址中(考虑大小端存放)，占8字节（q为64位），而<code>movw 0xa, (0x110)</code>,表示占2字节（w为16位）</li>
<li><strong>注意</strong>，带括号的指地址上的内存，<ul>
<li><code>movq $0xa, 0x1ff7(%rip)</code>,将<code>$0xa</code>赋值给<code>0x1ff7(%rip)</code>地址上的内存空间</li>
<li> <code>movq %rax, %rdx</code>，将<code>rax</code>赋值给<code>rdx</code></li>
</ul>
</li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul>
<li>寄存器命名特点<ul>
<li>r开头：64bit,8字节</li>
<li>e开头: 32bit,4字节</li>
<li>ax,bx,cx: 2字节</li>
<li>ah al:8bit 1字节</li>
</ul>
</li>
<li>iOS中为64位寄存器，但是也有其他低位寄存器，会拿出一半来做4字节及一下的寄存器，其内存是共用的</li>
</ul>
<p><img src="2.png"></p>
<ul>
<li>寄存器只能存储8个字节的，像对象都是存在堆中的 </li>
<li>常用有16个常用寄存器<ul>
<li>rax、rbx rex、rdx、rsi、rdi、rbp、 rsp</li>
<li>r8.r9. r10.r11、 r12、r13、rl4、r15</li>
</ul>
</li>
<li>寄存器的具体用途<ol>
<li><code>rax</code>、<code>rdx</code>常作为函数返回值使用</li>
<li><code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>等奇存器常用于存放函数参数，参数过多，寄存器不够，则会放到栈中</li>
<li><code>rsp</code>、<code>rbp</code>用于栈操作,用来存在栈空间的地址值<ul>
<li>函数中，一般<code>rbp</code>和<code>rsp</code>之间用来存局部变量的，其他地方（<code>rbp</code>上方x或<code>rsp</code>下方）存放函数参数(在2中寄存器不够了，就会放到栈中)</li>
</ul>
</li>
<li><code>rip</code>作为指令指针<ul>
<li>存储着<code>CPU</code>下一条要执行的指令的地址</li>
<li>，一旦<code>CPU</code>读取一条指令，<code>rip</code>会自动指向下一条指令（存储下一条指令的地址）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h4><ul>
<li>内存地址格式为：<code>0x4bdc(%rip)</code>，一般是全局变量 ，全局区（数据段）</li>
<li>内存地址格式为：<code>-0x78（%rbp</code>），一般是局部变量，栈空间</li>
<li>内存地址格式为：<code>0x10（%rax)</code>，一般是堆空间</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举内存分析</title>
    <url>/2023/02/25/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内存查看"><a href="#内存查看" class="headerlink" title="内存查看"></a>内存查看</h1><blockquote>
<p><code>view Memory</code>功能，查看地址中存放的内存</p>
</blockquote>
<ul>
<li><p>查看效果<br><img src="1.png"></p>
</li>
<li><p>地址内存查看方式，<code>iOS</code>是小端模式，高高低低，高地址存高位，低地址存地位</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">上面<span class="hljs-number">8</span>个字节实际上是<br><span class="hljs-number">0x00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span><br></code></pre></td></tr></table></figure></li>
<li><p>获取枚举的地址方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1 <br><span class="hljs-keyword">let</span> nums <span class="hljs-operator">=</span> <span class="hljs-built_in">withUnsafePointer</span>(to: <span class="hljs-operator">&amp;</span>t) &#123; <span class="hljs-type">UnsafeRawPointer</span>(<span class="hljs-variable">$0</span>) &#125; <span class="hljs-comment">//内存地址 0x000000010000c0b0</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="普通枚举"><a href="#普通枚举" class="headerlink" title="普通枚举"></a>普通枚举</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum</span> </span>&#123; <br>    <span class="hljs-keyword">case</span> test1,test2,test3,test4,test5,test6<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.size) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.stride) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.alignment) <span class="hljs-comment">// 1</span><br><br><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1<br>t <span class="hljs-operator">=</span> .test5<br>t <span class="hljs-operator">=</span> .test6<br></code></pre></td></tr></table></figure>
<ul>
<li>内存情况,占用<code>1</code>字节内存,第一个枚举是<code>00</code>,后面依次增加，其内存最大是<code>0xFF</code>预计最大可以有枚举数<code>256</code>个（这么大的数量无需用枚举了）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1 <span class="hljs-comment">// 0x00</span><br>t <span class="hljs-operator">=</span> .test5  <span class="hljs-comment">// 0x04</span><br>t <span class="hljs-operator">=</span> .test6  <span class="hljs-comment">// 0x05</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="带原始值的枚举"><a href="#带原始值的枚举" class="headerlink" title="带原始值的枚举"></a>带原始值的枚举</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum</span>:<span class="hljs-title">Int</span> </span>&#123; <br>    <span class="hljs-keyword">case</span> test1 <span class="hljs-operator">=</span> <span class="hljs-number">10</span>,test2,test3,test4,test5,test6<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.size) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.stride) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.alignment) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<ul>
<li>内存情况,占用<code>1</code>字节内存。其内存情况和普通枚举类型一样的，其原始值不占有内存空间，类似计算属性<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1 <span class="hljs-comment">// 0x00</span><br>t <span class="hljs-operator">=</span> .test5  <span class="hljs-comment">// 0x04</span><br>t <span class="hljs-operator">=</span> .test6  <span class="hljs-comment">// 0x05</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="带关联值的枚举"><a href="#带关联值的枚举" class="headerlink" title="带关联值的枚举"></a>带关联值的枚举</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum</span> </span>&#123; <br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>),test2(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>),test3(<span class="hljs-type">Int</span>),test4(<span class="hljs-type">Bool</span>),test5,test6<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.size) <span class="hljs-comment">// 25</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.stride) <span class="hljs-comment">// 32</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNum</span>&gt;.alignment) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>内存情况,实际占用<code>25</code>个字节，内存对齐是<code>32</code>个字节。对于存储情况，以最大存储<code>3</code>个<code>Int</code>，为<code>24</code>字节，前面的<code>24</code>个字节均用来存储关联值的（不管当前实际关联值大小是<code>1</code>个字节，还是<code>16</code>个字节），最高位用来存储枚举的类型（普通枚举不一样）。</p>
<ul>
<li>内存从左到右，从上到下，内存地址增加</li>
<li>关联值和非关联值，枚举的标志位存放的位置是不一样的，类似共用体<ul>
<li>非关联值排在前面，普通枚举排在后面<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//占用内存情况</span><br><span class="hljs-comment">//10 00 00 00 00 00 00 00  //实际为 0x10</span><br><span class="hljs-comment">//02 00 00 00 00 00 00 00  //实际为 0x02</span><br><span class="hljs-comment">//03 00 00 00 00 00 00 00  //实际为 0x03</span><br><span class="hljs-comment">//00 </span><br><span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>.test1(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <br><span class="hljs-comment">//占用内存情况</span><br><span class="hljs-comment">//04 00 00 00 00 00 00 00  //实际为 0x04</span><br><span class="hljs-comment">//05 00 00 00 00 00 00 00  //实际为 0x05</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00  </span><br><span class="hljs-comment">//01                       //实际为 0x01</span><br>t <span class="hljs-operator">=</span> .test2(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <br> <span class="hljs-comment">//占用内存情况</span><br><span class="hljs-comment">//01 00 00 00 00 00 00 00  //实际为 0x01</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00  </span><br><span class="hljs-comment">//03                       //实际为 0x03</span><br>t <span class="hljs-operator">=</span> .test4(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">//占用内存情况</span><br><span class="hljs-comment">//10 00 00 00 00 00 00 00  //第一位标识位是1，表明第二个普通的枚举</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00</span><br><span class="hljs-comment">//00 00 00 00 00 00 00 00  </span><br><span class="hljs-comment">//04                      //实际为 0x04而非按顺序的0x05, 这表明总共有4个关联枚举？</span><br>t <span class="hljs-operator">=</span> .test6<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>最后一个值为<code>bool</code>类型，则实际尺寸仍然是<code>25</code>字节，<code>bool</code>和<code>枚举的标识位</code>混用，并且有关联类型的标识符和普通的标识符号顺序不同。但是中间有<code>bool</code>，实际占用是<code>32</code>字节。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//实际占用25字节</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum2</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> test4(<span class="hljs-type">Bool</span>) <br>    <span class="hljs-keyword">case</span> test5 <br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Bool</span>)<br>    <span class="hljs-keyword">case</span> test2(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> test3(<span class="hljs-type">Int</span>)<br>&#125;<br><br><span class="hljs-comment">//实际占用32字节</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum2</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> test4(<span class="hljs-type">Bool</span>) <br>    <span class="hljs-keyword">case</span> test5 <br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Bool</span>,<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> test2(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> test3(<span class="hljs-type">Int</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>注意如果只有一个项的关联值，其内存不会算上枚举自身的<code>1</code>字节<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNUm</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNUm</span>&gt;.size) <span class="hljs-comment">//24</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNUm</span>&gt;.stride) <span class="hljs-comment">//24</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">TestNUm</span>&gt;.alignment) <span class="hljs-comment">//24</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="switch匹配"><a href="#switch匹配" class="headerlink" title="switch匹配"></a>switch匹配</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestNum</span> </span>&#123; <br>    <span class="hljs-keyword">case</span> test1(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>),test2(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>),test3(<span class="hljs-type">Int</span>),test4(<span class="hljs-type">Bool</span>),test5,test6<br>&#125;<br><br><span class="hljs-comment">//实际大小是25</span><br><span class="hljs-keyword">var</span> e <span class="hljs-operator">=</span> <span class="hljs-type">TestEnum</span>.test1(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)<br><span class="hljs-comment">//取出标识位去判断，这里是第25位</span><br><span class="hljs-keyword">switch</span> e &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .test1(v1,v2,v3): <span class="hljs-comment">//判断25位是0，取出前24个字节进行赋值</span><br>        <span class="hljs-built_in">print</span>(v1,v2,v3)<br>     <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .test2(v1,v2): <span class="hljs-comment">//判断25位是1，取出前16个字节进行赋值</span><br>        <span class="hljs-built_in">print</span>(v1,v2,v3)<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>swift的枚举、可选项</title>
    <url>/2023/02/23/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E6%9E%9A%E4%B8%BE%E3%80%81%E5%8F%AF%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h1><ul>
<li>递归枚举，必须用<code>indirect</code>修饰<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ArithExpr</span></span>&#123;<br>    <span class="hljs-keyword">case</span> number(<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">indirect</span> <span class="hljs-keyword">case</span> sum(<span class="hljs-type">ArithExpr</span>,<span class="hljs-type">ArithExpr</span>)<br>    <span class="hljs-keyword">indirect</span> <span class="hljs-keyword">case</span> difference(<span class="hljs-type">ArithExpr</span>,<span class="hljs-type">ArithExpr</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="关联值和原始值的内存"><a href="#关联值和原始值的内存" class="headerlink" title="关联值和原始值的内存"></a>关联值和原始值的内存</h1><ul>
<li><p>原始值所分配的空间只有<code>1</code>个字节，不管他有无原始值。原始值一开始是决定好的，无法更改，因此没必要存储到内存中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Season1</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> spring,summer,autumn,winter<br>&#125;<br><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season1</span>&gt;.stride <span class="hljs-comment">//1  分配占用的空间大小</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season1</span>&gt;.size   <span class="hljs-comment">// 1 实际用到的空间大小</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season1</span>&gt;.alignment  <span class="hljs-comment">// 1 对齐的参数</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Season</span>:<span class="hljs-title">Int</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> spring <span class="hljs-operator">=</span> <span class="hljs-number">100</span>,summer <span class="hljs-operator">=</span> <span class="hljs-number">200</span>,autumn <span class="hljs-operator">=</span> <span class="hljs-number">300</span>,winter <span class="hljs-operator">=</span> <span class="hljs-number">400</span><br>&#125;<br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season</span>&gt;.stride <span class="hljs-comment">//1  分配占用的空间大小</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season</span>&gt;.size   <span class="hljs-comment">// 1 实际用到的空间大小</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Season</span>&gt;.alignment  <span class="hljs-comment">// 1 对齐的参数</span><br></code></pre></td></tr></table></figure></li>
<li><p>关联值中，以所占最大的关联值的内存为准。由于将来需要将关联值存储到枚举的<code>内存</code>内，因此需要分配内存。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Password</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> number(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) <span class="hljs-comment">// Int 4字节，加上枚举1个字节，实际33</span><br>    <span class="hljs-keyword">case</span> other<br>    <span class="hljs-keyword">case</span> bigNumer(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)<br>&#125;<br><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Password</span>&gt;.size <span class="hljs-comment">// 33</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Password</span>&gt;.alignment <span class="hljs-comment">// 8</span><br><span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Password</span>&gt;.stride <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="多重可选项"><a href="#多重可选项" class="headerlink" title="多重可选项"></a>多重可选项</h1><ul>
<li><span id="jump1">示意图1</span><br><img src="1.png"><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> num2: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> num1<br><span class="hljs-keyword">var</span> num3: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(num2 <span class="hljs-operator">==</span> num3) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">print</span>(num1 <span class="hljs-operator">==</span> num2) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">print</span>(num2 <span class="hljs-operator">==</span> <span class="hljs-number">10</span>) <span class="hljs-comment">//true </span><br><span class="hljs-comment">//双重强制解包</span><br>num3<span class="hljs-operator">!!</span> <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></li>
<li><span id="jump2">示意图2</span><br><img src="2.png"><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span> <br><span class="hljs-keyword">var</span> num2: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> num1<br><span class="hljs-keyword">var</span> num3: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-built_in">print</span>(num2 <span class="hljs-operator">==</span> num3) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">print</span>(num1 <span class="hljs-operator">==</span> num2) <span class="hljs-comment">//true </span><br><span class="hljs-built_in">print</span>(num1 <span class="hljs-operator">==</span> num3) <span class="hljs-comment">//false </span><br>(num2 <span class="hljs-operator">??</span> <span class="hljs-number">1</span>) <span class="hljs-operator">??</span> <span class="hljs-number">2</span> <span class="hljs-comment">//2  num2解出来不为nil，是num1;num1解出来为nil，赋值2</span><br>(num3 <span class="hljs-operator">??</span> <span class="hljs-number">1</span>) <span class="hljs-operator">??</span> <span class="hljs-number">2</span> <span class="hljs-comment">//1  num3解出来为nil，则赋值1</span><br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="可选-的源码，"><a href="#可选-的源码，" class="headerlink" title="可选==的源码，"></a>可选<code>==</code>的源码，</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Optional</span> <span class="hljs-title">where</span> <span class="hljs-title">Wrapped</span>:<span class="hljs-title">Equatable</span> </span>&#123;<br>    <span class="hljs-comment">//这里在求等于时会保证两个类型一致</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">==</span>(<span class="hljs-params">lhs</span>: <span class="hljs-type">Wrapped</span>?, <span class="hljs-params">rhs</span>: <span class="hljs-type">Wrapped</span>?)</span> -&gt; <span class="hljs-type">Bool</span> &#123;<br>      <span class="hljs-keyword">switch</span> (lhs, rhs) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (l<span class="hljs-operator">?</span>, r<span class="hljs-operator">?</span>):<br>        <span class="hljs-keyword">return</span> l <span class="hljs-operator">==</span> r<br>      <span class="hljs-keyword">case</span> (<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在<a href="#jump1">示意1</a>中。<code>num1</code>会再包装一次，变成<code>Int??</code>,类比<code>Optional(Optional(10))</code>,两者的包装程度一致。像非<code>nil</code>参数再比较时，由于都会进行包装时其相等，因此只要满足参数相等，其可选就会相等。   <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> num2: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> num1<br></code></pre></td></tr></table></figure>
</li>
<li>在<a href="#jump2">示意2</a>中。<code>num3</code>会再包装一次，变成<code>Int??</code>，类比<code>Optional(nil)</code>,但是<code>num1</code>的值是<code>nil</code>已经满足了<code>Int??</code>类型的要求，因此是不一样的。而<code>num1</code>的值赋予给<code>num2</code>是，同样包装了一次，因此<code>num2</code>和<code>num3</code>是相等的都为<code>Optional(nil)</code>。  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span> <br><span class="hljs-keyword">var</span> num2: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> num1<br><span class="hljs-keyword">var</span> num3: <span class="hljs-type">Int</span>?? <span class="hljs-operator">=</span> num1<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="可选-的源码，-1"><a href="#可选-的源码，-1" class="headerlink" title="可选??的源码，"></a>可选<code>??</code>的源码，</h2>   <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">??</span> &lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-params">optional</span>: <span class="hljs-type">T</span>?, <span class="hljs-params">defaultValue</span>: <span class="hljs-keyword">@autoclosure</span> () <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">T</span>)</span><br>    <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-type">T</span> &#123;<br>  <span class="hljs-keyword">switch</span> <span class="hljs-keyword">optional</span> &#123;<br>  <span class="hljs-keyword">case</span> .some(<span class="hljs-keyword">let</span> value):<br>    <span class="hljs-keyword">return</span> value<br>  <span class="hljs-keyword">case</span> .none:<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> defaultValue()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>下列例子中，同样，在使用<code>??</code>时，会返回传入参数解包一次的值,并且只会解包一次。</p>
<ul>
<li>由于<code>Int?</code> -&gt; <code>Int????</code>,类型是可以直接赋值的，因此可以这么判断</li>
<li>而<code>Int????</code> -&gt; <code>Int?</code>,是没办法赋值的，在编译器中会按<code>Any</code>处理<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> num:<span class="hljs-type">Int</span>??? <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> num1:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-comment">//传入参数是Int???，最后返回是Int??</span><br><span class="hljs-comment">// num1 = num // 无法赋值</span><br><span class="hljs-built_in">print</span>(num <span class="hljs-operator">??</span> num1) <span class="hljs-comment">// Optional(Optional(1))</span><br><br>num <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-comment">//传入参数是Int???，最后返回是Int??，这会对num1进行包装</span><br><span class="hljs-built_in">print</span>(num <span class="hljs-operator">??</span> num1) <span class="hljs-comment">// Optional(Optional(2))</span><br><span class="hljs-comment">// </span><br><br>num <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> num3:<span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>num3 <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br> <span class="hljs-built_in">print</span>(num3 <span class="hljs-operator">??</span> num) <span class="hljs-comment">//Optional(Optional(Optional(1)))</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可以使用<code>lldb</code>指令<code>frame variable -R</code>或者<code>fr v -R</code>查看结构</p>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>枚举、可选项</tag>
      </tags>
  </entry>
  <entry>
    <title>swift的函数</title>
    <url>/2023/02/22/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="inout"><a href="#inout" class="headerlink" title="inout"></a><code>inout</code></h1><h2 id="inout的函数，是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）"><a href="#inout的函数，是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）" class="headerlink" title="inout的函数，是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）"></a><code>inout</code>的函数，是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）</h2><ul>
<li>汇编验证<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-type">Int</span>)</span> &#123;<br> <br> &#125;<br> <span class="hljs-comment">// movq 值传递 %rbp - 0x20的地址中取值,传给方法</span><br><span class="hljs-number">0x100003f70</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">64</span><span class="hljs-operator">&gt;</span>: movq   <span class="hljs-operator">-</span><span class="hljs-number">0x20</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100003f74</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">68</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003f90</span>               ;  <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">11</span><br><span class="hljs-number">0x100003f79</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">73</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br><span class="hljs-number">0x100003f7b</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">75</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x20, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100003f7f</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">79</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x100003f80</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">80</span><span class="hljs-operator">&gt;</span>: retq <br> <br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br> <br> &#125;<br> <br> <span class="hljs-comment">// leaq 地址传递 %rbp - 0x20的地址传到 %rdi,且在callq后面，并没有movq赋值操作</span><br><span class="hljs-number">0x100003f6c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">44</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-number">0x408d</span>(<span class="hljs-operator">%</span>rip), <span class="hljs-operator">%</span>rdi        ; <span class="hljs-type">SwiftDText</span>.num : <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span><br><span class="hljs-number">0x100003f73</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">51</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003f90</span>               ; <span class="hljs-type">SwiftDText</span>.test(<span class="hljs-keyword">inout</span> <span class="hljs-type">Swift</span>.<span class="hljs-type">Int</span>) -&gt; () at main.swift:<span class="hljs-number">11</span><br><span class="hljs-number">0x100003f78</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">56</span><span class="hljs-operator">&gt;</span>: leaq   <span class="hljs-operator">-</span><span class="hljs-number">0x18</span>(<span class="hljs-operator">%</span>rbp), <span class="hljs-operator">%</span>rdi<br><span class="hljs-number">0x100003f7c</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">60</span><span class="hljs-operator">&gt;</span>: callq  <span class="hljs-number">0x100003fa8</span>               ; symbol stub <span class="hljs-keyword">for</span>: swift_endAccess<br><span class="hljs-number">0x100003f81</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">65</span><span class="hljs-operator">&gt;</span>: xorl   <span class="hljs-operator">%</span>eax, <span class="hljs-operator">%</span>eax<br><span class="hljs-number">0x100003f83</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">67</span><span class="hljs-operator">&gt;</span>: addq   <span class="hljs-variable">$0</span>x20, <span class="hljs-operator">%</span>rsp<br><span class="hljs-number">0x100003f87</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">71</span><span class="hljs-operator">&gt;</span>: popq   <span class="hljs-operator">%</span>rbp<br><span class="hljs-number">0x100003f88</span> <span class="hljs-operator">&lt;+</span><span class="hljs-number">72</span><span class="hljs-operator">&gt;</span>: retq  <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="inout-函数存在的独占访问权限"><a href="#inout-函数存在的独占访问权限" class="headerlink" title="inout 函数存在的独占访问权限"></a><code>inout</code> 函数存在的独占访问权限</h2><ul>
<li>下面均会出现<code>imultaneous accesses to 0x100008178, but modification requires exclusive access</code>崩溃异常<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&lt;!--</span>第一种<span class="hljs-operator">--&gt;</span><br><span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-params">nu</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    nu <span class="hljs-operator">+=</span> <span class="hljs-number">3</span><br>    <span class="hljs-built_in">print</span>(num) <span class="hljs-comment">// 读同一个地址的num会崩溃</span><br>    <span class="hljs-comment">//num += 10 // 写同一个地址的num也会崩溃</span><br>&#125;<br>test(nu: <span class="hljs-operator">&amp;</span>num)<br><span class="hljs-operator">&lt;!--</span>第二种<span class="hljs-operator">--&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNum</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> i:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <br>&#125;<br><br><span class="hljs-keyword">let</span> testNum <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-params">i</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123; <br>    i <span class="hljs-operator">+=</span> <span class="hljs-number">3</span><br>    <span class="hljs-built_in">print</span>(testNum.i) <span class="hljs-comment">// 读同一个地址的num会崩溃</span><br>    <span class="hljs-comment">//testNum.i += 10 // 写同一个地址的num也会崩溃</span><br>&#125;<br>test(i: <span class="hljs-operator">&amp;</span>testNum.i)<br></code></pre></td></tr></table></figure></li>
<li>当一个变量访问同一块内存时，会产生独占内存访问权限冲突</li>
</ul>
<h2 id="计算型属性或者一个具有属性观察器的属性调用inout时"><a href="#计算型属性或者一个具有属性观察器的属性调用inout时" class="headerlink" title="计算型属性或者一个具有属性观察器的属性调用inout时"></a>计算型属性或者一个具有属性观察器的属性调用inout时</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNum</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> j:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> i:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;get&quot;</span>)<br>            <span class="hljs-keyword">return</span> j<br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set&quot;</span>)<br>            j <span class="hljs-operator">=</span> newValue<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">let</span> actNum <span class="hljs-operator">=</span> <span class="hljs-type">TestNum</span>()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-params">i</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始&quot;</span>)<br>    i <span class="hljs-operator">+=</span> <span class="hljs-number">3</span><br>    actNum.i <span class="hljs-operator">+=</span> <span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(actNum.i)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束&quot;</span>)<br>&#125;<br>test(i: <span class="hljs-operator">&amp;</span>actNum.i)<br><span class="hljs-built_in">print</span>(actNum.i)<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">get</span><br><span class="hljs-comment">开始</span><br><span class="hljs-comment">get</span><br><span class="hljs-comment">set</span><br><span class="hljs-comment">get</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">结束</span><br><span class="hljs-comment">set</span><br><span class="hljs-comment">get</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>在<code>test</code>方法内部同时使用<code>&amp;actNum.i</code>和<code>actNum.i</code>并未出现<code>独占内存访问权限冲突</code>,造成这种情况出现的原始实际上和设置了属性观察器有关,并且在方法内部设置的值<code>10</code>，最后输出的时候，仍为<code>3</code>。<ul>
<li>表明方法内部的<code>i</code>,和<code>actNum.i</code>并非同一个，因此没有出现独占内存。并且在方法结束后，会重新赋值给<code>actNum.i</code>这种行为叫做<code>拷入拷出</code>或者<code>值结果调用</code>。具体见<code>属性那章</code></li>
<li><code>拷入拷出</code>遵循如下规则：<ol>
<li>函数调用时，参数的值被拷贝。</li>
<li>函数体内部，拷贝后的值被修改。</li>
<li>函数返回后，拷贝后的值被赋值给原参数。</li>
</ol>
</li>
<li>可以认为在调用函数前，先创建了一个值<code>x</code>，并将调用<code>get</code>方法将<code>actNum.i</code>赋值给<code>x</code>，这是在函数中进行的<code>inout</code>操作是<code>x</code>，在函数结束后，调用<code>set</code>方法，将<code>x</code>的值赋予给<code>actNum.i</code></li>
</ul>
</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote>
<ul>
<li>规则<ul>
<li>函数名相同</li>
<li>参数个数不同 或者 参数类型不同 或者 参数标签不同</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>注意</strong>,重载和返回值类型无关<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">40</span><br>    <span class="hljs-keyword">return</span> num<br>&#125;<br><span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span><span class="hljs-operator">=</span> test(<span class="hljs-operator">&amp;</span>num) <span class="hljs-comment">//会报错,无法分清</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，默认参数和函数重载一起使用产生二义性时，编译器不会报错（在<code>C++</code>中会报错）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>,<span class="hljs-params">type</span>:<span class="hljs-type">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>)</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>)</span> &#123;<br>    num <span class="hljs-operator">=</span> <span class="hljs-number">40</span><br>&#125;<br><span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-comment">//会调用test(_ num: inout Int)</span><br>test(<span class="hljs-operator">&amp;</span>num) <span class="hljs-comment">// num = 40</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,可变参数、省略参数标签、函数重载一起使用参数二义性时，编译器有可能会报错（避免这种情况）<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//第一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-type">Int</span>,<span class="hljs-params">num2</span>:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>)</span> &#123;<br>    <br>&#125;<br><span class="hljs-comment">//第二</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>: <span class="hljs-type">Int</span>,<span class="hljs-keyword">_</span> <span class="hljs-params">num2</span>:<span class="hljs-type">Int</span>)</span> &#123;<br>   <br>&#125;<br><span class="hljs-comment">//第三</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">num</span>:<span class="hljs-type">Int</span>...)</span> &#123;<br>    <br>&#125;<br><span class="hljs-comment">//编译起报错，但是屏蔽第一个代码，就不会报错了</span><br>test(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul>
<li>如果开启了编译器优化（<code>Release</code>模式默认会开启优化）(<code>buildSetting</code>中的<code>optimization</code>)，编译器会自动将某些函数变成内联函数<ul>
<li>将函数调用展开成函数体</li>
</ul>
</li>
<li>哪些函数不会被自动内联<ul>
<li>函数体比较长</li>
<li>包含递归调用</li>
<li>包含动态派发（无法在编译的时候确定是谁调用的）</li>
</ul>
</li>
<li><code>@inline</code>,内联注解， <code>Apple</code> 的文档中是找不到，不建议使用<ul>
<li><code>@inline(__always) func test(i:Int) &#123;  &#125;</code>,开启编译优化后，即使代码很长也会被内联（递归调用,动态派发除外）</li>
<li><code>@inline(never) func test(i:Int) &#123;  &#125;</code>,永远不会被内联，即使开启了编译器优化（有时不起作用,还是会转为内联）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>swift的基础语法</title>
    <url>/2023/02/20/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>记录下<code>swfit</code>的基础不同的语法</p>
</blockquote>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>只能赋值<code>1</code>次</li>
<li>它的值不要求在编泽时期确定，但使用之前必须赋值<code>1</code>次</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>标识符（比如常量名、变量名、函数名）几乎可以使用任何字符</li>
<li>标识符不能以数字开头，不能包含空白字符、制表符、節头等特殊字符</li>
</ul>
<h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><blockquote>
<p>只有<strong>值类型</strong>和<strong>引用类型</strong>，以前语言中的<code>Int</code>，<code>Bool</code>均为<strong>结构体</strong>，而非<strong>基础数据类型</strong></p>
</blockquote>
<p><img src="1.png"></p>
<ul>
<li>整数类型：<code>Int8</code>、 <code>Int16</code>、 <code>Int32</code>、<code>Int64</code>、<code>UInt8</code>、 <code>UInt16</code>、 <code>UInt32</code>、<code>UInt64</code></li>
<li>在<code>32bit</code>平台，<code>Int</code>等价于<code>Int32</code>；在<code>64bit</code>平台，<code>Int</code>等价于<code>Int64</code></li>
<li>整数的最值：<code>UInt8.max</code>、 <code>Int16. min</code></li>
<li>目一般情况下，都是直接使用<code>Int</code>即可</li>
<li>浮点类型：<code>Float</code> ，<code>32位</code>，精度只有<code>6位</code>；<code>Double</code>，<code>64位</code>，精度至少<code>15位</code></li>
</ul>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ul>
<li>字面量<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//整数</span><br><span class="hljs-keyword">let</span> intDecimal <span class="hljs-operator">=</span> <span class="hljs-number">17</span><span class="hljs-comment">//十进制</span><br><span class="hljs-keyword">let</span> intBinary <span class="hljs-operator">=</span> <span class="hljs-number">0b10001</span> <span class="hljs-comment">// 二进制</span><br><span class="hljs-keyword">let</span> intoctal <span class="hljs-operator">=</span> <span class="hljs-number">0o21</span> <span class="hljs-comment">//八进制</span><br>llet intHexadecimal <span class="hljs-operator">=</span> <span class="hljs-number">0x11</span><span class="hljs-comment">//十六进制</span><br><br><span class="hljs-comment">//浮点数</span><br><span class="hljs-keyword">let</span> doubleDecimal <span class="hljs-operator">=</span> <span class="hljs-number">125.0</span> <span class="hljs-comment">//十进制，等价于1.25e2，日.0125等价于1.25e-2</span><br><span class="hljs-comment">//只有十六进制可以这么写</span><br><span class="hljs-keyword">let</span> doubleHexadecimal1<span class="hljs-operator">=</span> <span class="hljs-number">0xFp2</span> <span class="hljs-comment">//十六进制，意味着15x2^2，相当于十进制的68.0</span><br><span class="hljs-keyword">let</span> doubleHe xadecima12 <span class="hljs-operator">=</span><span class="hljs-number">0xFp-2</span> <span class="hljs-comment">// 十六进制，意味着15x2^-2，相当于十进制的3.75</span><br></code></pre></td></tr></table></figure></li>
<li>类型转换<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//字面量可以直接相加，因为数字字面量本身没有明确的类型</span><br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-operator">+</span> <span class="hljs-number">0.14156</span> <span class="hljs-comment">//不会报错</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul>
<li><code>for</code>遍历值作为变量 <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//i默认是let，有需要时可以声明为var，但是该变量只能单个for中变化,下一次又会重新赋值</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">3</span> &#123;<br>    <span class="hljs-built_in">print</span>(i)<br>    i <span class="hljs-operator">+=</span> <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-comment">//输出 1、2、3</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="区间运算"><a href="#区间运算" class="headerlink" title="区间运算"></a>区间运算</h2><ul>
<li>区间运算  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> names <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> names[<span class="hljs-number">2</span><span class="hljs-operator">...</span><span class="hljs-number">3</span>] &#123;<br>    <span class="hljs-built_in">print</span>(n)<br>&#125;<br><span class="hljs-comment">//输出 c d</span><br></code></pre></td></tr></table></figure></li>
<li>单侧区间:让区间朝一个方向尽可能远  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> names[<span class="hljs-number">1</span><span class="hljs-operator">...</span>] &#123;<br>    <span class="hljs-built_in">print</span>(n)<br>&#125;<br><span class="hljs-comment">//输出 b c d</span><br><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> names[<span class="hljs-operator">..&lt;</span><span class="hljs-number">2</span>] &#123;<br>    <span class="hljs-built_in">print</span>(n)<br>&#125;<br><span class="hljs-comment">//输出 a b</span><br><span class="hljs-comment">//3到正无穷，但是...3不能用for</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">3</span><span class="hljs-operator">...</span> &#123;<br>    <span class="hljs-built_in">print</span>(i)<br>&#125;<br><br><span class="hljs-keyword">let</span> rang:<span class="hljs-type">PartialRangeThrough</span>&lt;<span class="hljs-type">Int</span>&gt; <span class="hljs-operator">=</span> <span class="hljs-operator">...</span><span class="hljs-number">3</span> <span class="hljs-comment">//负无穷到3，不能用于for</span><br></code></pre></td></tr></table></figure></li>
<li>字符串、字符也能包含区间，但是不能用于<code>for</code>  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> stringRang <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cc&quot;</span><span class="hljs-operator">...</span><span class="hljs-string">&quot;ff&quot;</span><br>stringRang.contains(<span class="hljs-string">&quot;dz&quot;</span>) <span class="hljs-comment">//true</span><br>str.contains(<span class="hljs-string">&quot;fg&quot;</span>) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li>
<li>带间隔的区间值  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//从4开始，累加2，&lt;=12</span><br><span class="hljs-keyword">for</span> tickMark <span class="hljs-keyword">in</span> <span class="hljs-built_in">stride</span>(from: <span class="hljs-number">4</span>, through: <span class="hljs-number">12</span>, by: <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>,tickMark)<br>&#125;<br><span class="hljs-comment">//输出 4 6 8 10 12</span><br><span class="hljs-comment">//从4开始，累加2，&lt;12</span><br><span class="hljs-keyword">for</span> tickMark <span class="hljs-keyword">in</span> <span class="hljs-built_in">stride</span>(from: <span class="hljs-number">4</span>, to: <span class="hljs-number">12</span>, by: <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>,tickMark)<br>&#125;<br><span class="hljs-comment">//输出 4 6 8 10</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>swift的编译</title>
    <url>/2023/02/20/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="swift的编译"><a href="#swift的编译" class="headerlink" title="swift的编译"></a>swift的编译</h3><p><img src="2.png"><br><img src="1.png"></p>
<ul>
<li>OC前端采用<code>Clang</code>，<code>swift</code>的前端采用的是<code>swiftc</code>,swift编译时会生成swift的中间代码<code>SIL</code>，对代码进行优化之后，在转换成<code>IR</code>,它们的后端均为<code>LLVM</code></li>
</ul>
<h3 id="swift语法"><a href="#swift语法" class="headerlink" title="swift语法"></a>swift语法</h3><ul>
<li>一些操作<ul>
<li>生成语法树：<code>swiftc -dump-ast main.swift</code></li>
<li>生成最简洁的SIL代码：<code>swiftc -emit-sil main.swift</code></li>
<li>生成LLVM IR代码：<code>swiftc -emit-ir main.swift -o main.ll</code></li>
<li>口生成汇编代码：<code>swiftc -emit-assembly main.swift -o main.s</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>安装包瘦身</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>安装包（IPA）主要由可执行文件、资源组成</p>
</blockquote>
<ul>
<li>资源（图片、音频、视频等）<ul>
<li>采取无损压缩</li>
<li>去除没有用到的资源： <a href="https://github.com/tinymind/LSUnusedResources">地址</a></li>
</ul>
</li>
<li>可执行文件瘦身<ul>
<li><code>Strip Linked Product</code>、<code>Make Strings Read-Only</code>、<code>Symbols Hidden by Default</code>设置为<code>YES</code></li>
<li>去掉异常支持，<code>Enable C++ Exceptions</code>、<code>Enable Objective-C Exceptions</code>设置为<code>NO</code>， <code>Other C Flags</code>添加<code>-fno-exceptions</code></li>
</ul>
</li>
<li>利用<a href="https://www.jetbrains.com/objc/">AppCode</a>检测未使用的代码：<code>菜单栏 -&gt; Code -&gt; Inspect Code</code></li>
<li>编写<code>LLVM插件</code>检测出重复代码、未被调用的代码</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>启动优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="APP的启动"><a href="#APP的启动" class="headerlink" title="APP的启动"></a>APP的启动</h2><ul>
<li><code>APP</code>的启动可以分为2种<ul>
<li>冷启动（<code>Cold Launch</code>）：从零开始启动<code>APP</code></li>
<li>热启动（<code>Warm Launch</code>）：<code>APP</code>已经在内存中，在后台存活着，再次点击图标启动<code>APP</code></li>
<li><code>APP</code>启动时间的优化，主要是针对冷启动进行优化</li>
</ul>
</li>
<li><code>APP</code>的冷启动可以概括为<code>3</code>大阶段<ul>
<li><code>dyld</code></li>
<li><code>runtime</code></li>
<li><code>main</code><br><img src="1.png"></li>
</ul>
</li>
</ul>
<h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3><ul>
<li><code>dyld（dynamic link editor）</code>，<code>Apple</code>的动态链接器，可以用来装载<code>Mach-O</code>文件（可执行文件、动态库等）</li>
<li>启动<code>APP</code>时，<code>dyld</code>所做的事情有<ul>
<li>装载<code>APP</code>的可执行文件，同时会递归加载所有依赖的动态库</li>
<li>当<code>dyld</code>把可执行文件、动态库都装载完毕后，会通知<code>Runtime</code>进行下一步的处理</li>
</ul>
</li>
</ul>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><ul>
<li>启动<code>APP</code>时，<code>runtime</code>所做的事情有<ul>
<li>调用<code>map_images</code>进行可执行文件内容的解析和处理<ul>
<li>例如类的解析<code>realizeClassWithoutSwift</code>（重新解析<code>Class</code>，初始化一些<code>flags</code>,初始化<code>class_rw_t</code>(一开始<code>data</code>中存的是<code>class_ro_t</code>,取出存入<code>class_rw_t</code>)并设置<code>data</code>）</li>
</ul>
</li>
<li>在<code>load_images</code>中调用<code>call_load_methods</code>，调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法<ul>
<li>还有<code>attachCategories</code>，将分类中的方法、属性、协议，加到<code>class_rw_t</code>中</li>
</ul>
</li>
<li>进行各种<code>objc</code>结构的初始化（注册<code>Objc</code>类 、初始化类对象等等）</li>
<li>调用<code>C++</code>静态初始化器(结构体的初始化)和<code>__attribute__((constructor))</code>修饰的函数（类似<code>+load</code>，由系统调用）</li>
</ul>
</li>
<li>到此为止，可执行文件和动态库中所有的符号<code>(Class，Protocol，Selector，IMP，…)</code>都已经按格式成功加载到内存中，被<code>runtime</code>所管理</li>
</ul>
<h3 id="APP的启动-main"><a href="#APP的启动-main" class="headerlink" title="APP的启动 - main"></a>APP的启动 - main</h3><ul>
<li>对<code>application:didFinishLaunchingWithOptions:</code>方法耗时优化</li>
<li>总的来说<ul>
<li><code>APP</code>的启动由<code>dyld</code>主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li>
<li>并由<code>runtime</code>负责加载成<code>objc</code>定义的结构</li>
<li>所有初始化工作结束后，<code>dyld</code>就会调用<code>main</code>函数</li>
<li>接下来就是<code>UIApplicationMain</code>函数，<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions:</code>方法</li>
</ul>
</li>
</ul>
<h2 id="APP的启动优化"><a href="#APP的启动优化" class="headerlink" title="APP的启动优化"></a>APP的启动优化</h2><ul>
<li><p>按照不同的阶段</p>
<ul>
<li><p><code>dyld</code></p>
<ol>
<li>减少动态库、合并一些动态库（定期清理不必要的动态库）</li>
<li>减少<code>Objc</code>类、分类的数量、减少<code>Selector</code>数量（定期清理不必要的类、分类）</li>
<li>减少<code>C++虚函数</code>数量</li>
<li><code>Swift</code>尽量使用<code>struct</code></li>
</ol>
</li>
<li><p><code>runtime</code></p>
<ul>
<li>用<code>+initialize</code>方法和<code>dispatch_once</code>取代所有的<code>__attribute__((constructor))</code>、<code>C++静态构造器</code>、<code>ObjC的+load</code></li>
</ul>
</li>
<li><p><code>main</code></p>
<ul>
<li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunching</code>方法中按需加载</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>耗电优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><ul>
<li>尽可能降低<code>CPU</code>、<code>GPU</code>功耗</li>
<li>少用定时器</li>
<li>优化<code>I/O</code>操作<ul>
<li>尽量不要频繁写入小数据，最好批量一次性写入</li>
<li>读写大量重要数据时，考虑用<code>dispatch_io</code>，其提供了基于<code>GCD</code>的异步操作文件<code>I/O</code>的<code>API</code>。用<code>dispatch_io</code>系统会优化磁盘访问</li>
<li>数据量比较大的，建议使用数据库（比如<code>SQLite</code>、<code>CoreData</code>）</li>
</ul>
</li>
<li>网络优化<ul>
<li>减少、压缩网络数据</li>
<li>如果多次请求的结果是相同的，尽量使用缓存</li>
<li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li>
<li><strong>网络不可用</strong>时，不要尝试执行网络请求</li>
<li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li>
<li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载</li>
</ul>
</li>
<li>定位优化<ul>
<li>如果只是需要快速确定用户位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法。定位完成后，会自动让定位硬件断电</li>
<li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li>
<li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li>
<li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为<code>YES</code>，如果用户不太可能移动的时候系统会自动暂停位置更新</li>
<li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion</code></li>
</ul>
</li>
<li>硬件检测优化<ul>
<li>用户移动、摇晃、倾斜设备时，会产生动作(<code>motion</code>)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>卡顿优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a><code>CPU</code>和<code>GPU</code></h2><blockquote>
<p>在屏幕成像的过程中，<code>CPU</code>和<code>GPU</code>起着至关重要的作用</p>
</blockquote>
<ul>
<li><p><code>CPU</code>（<code>Central Processing Unit</code>，中央处理器）</p>
<ul>
<li>对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（<code>Core Graphics</code>）</li>
</ul>
</li>
<li><p><code>GPU</code>（<code>Graphics Processing Unit</code>，图形处理器）</p>
<ul>
<li>纹理的渲染<br><img src="1.png"></li>
</ul>
</li>
<li><p>在<code>iOS</code>中是双缓冲机制，有<code>前帧缓存</code>、<code>后帧缓存</code></p>
</li>
</ul>
<h3 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因"></a>卡顿产生的原因</h3><p><img src="2.png"></p>
<ul>
<li>卡顿解决的主要思路<ul>
<li>尽可能减少<code>CPU</code>、<code>GPU</code>资源消耗</li>
<li>按照<code>60FPS</code>的刷帧率，每隔<code>16ms</code>就会有一次<code>VSync</code>信号</li>
</ul>
</li>
</ul>
<h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li><p>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用<code>CALayer</code>取代<code>UIView</code></p>
</li>
<li><p>不要频繁地调用<code>UIView</code>的相关属性，比如<code>frame</code>、<code>bounds</code>、<code>transform</code>等属性，尽量减少不必要的修改</p>
</li>
<li><p>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</p>
</li>
<li><p><code>Autolayout</code>会比直接设置<code>frame</code>消耗更多的CPU资源</p>
</li>
<li><p>图片的<code>size</code>最好刚好跟<code>UIImageView</code>的<code>size</code>保持一致</p>
</li>
<li><p>控制一下线程的最大并发数量</p>
</li>
<li><p>尽量把耗时的操作放到子线程</p>
<ul>
<li>文本处理（尺寸计算、绘制）</li>
<li>图片处理（解码、绘制）</li>
<li><code>iOS10</code>以上支持,解码<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">UIGraphicsImageRendererFormat</span> *uiformat = [[<span class="hljs-built_in">UIGraphicsImageRenderer</span> alloc] init];<br>uiformat.scale = image.scale;<br>uiformat.opaque = !hasAlpha;<br><span class="hljs-built_in">UIGraphicsImageRenderer</span> *uirenderer = [[<span class="hljs-built_in">UIGraphicsImageRenderer</span> alloc] initWithSize:imageSize format:uiformat];<br><span class="hljs-built_in">UIGraphicsImageDrawingActions</span> uiactions = ^(<span class="hljs-built_in">UIGraphicsImageRendererContext</span> *rendererContext) &#123;<br>    [image drawInRect:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, imageSize.width, imageSize.height)];<br>&#125;;<br><span class="hljs-built_in">UIImage</span> *decodedImage = [uirenderer imageWithActions:uiactions];<br></code></pre></td></tr></table></figure></li>
<li><code>iOS10以</code>下支持，解码<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//redraw image using device context</span><br>    <span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span>(imageView.bounds.size, <span class="hljs-literal">YES</span>, <span class="hljs-number">0</span>);<br>    [image drawInRect:imageView.bounds];<br>    image = <span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span>();<br>    <span class="hljs-built_in">UIGraphicsEndImageContext</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><ul>
<li><p>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</p>
</li>
<li><p><code>GPU</code>能处理的最大纹理尺寸是<code>4096x4096</code>，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</p>
</li>
<li><p>尽量减少视图数量和层次</p>
</li>
<li><p>减少透明的视图（<code>alpha&lt;1</code>），不透明的就设置<code>opaque</code>为<code>YES</code></p>
</li>
<li><p>尽量避免出现离屏渲染</p>
</li>
</ul>
<h4 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h4><ul>
<li><p>在<code>OpenGL</code>中，<code>GPU</code>有<code>2</code>种渲染方式</p>
<ol>
<li><code>On-Screen Rendering</code>：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作</li>
<li><code>Off-Screen Rendering</code>：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
</ol>
</li>
<li><p>离屏渲染消耗性能的原因</p>
<ul>
<li>需要创建新的缓冲区</li>
<li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（<code>On-Screen</code>）切换到离屏（<code>Off-Screen</code>）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕</li>
</ul>
</li>
<li><p>哪些操作会触发离屏渲染？</p>
<ul>
<li><p>光栅化，<code>layer.shouldRasterize = YES</code></p>
</li>
<li><p>遮罩，<code>layer.mask</code></p>
</li>
<li><p>圆角，同时设置<code>layer.masksToBounds = YES</code>、<code>layer.cornerRadius大于0</code></p>
<ul>
<li>考虑通过<code>CoreGraphics</code>绘制裁剪圆角，或者提供圆角图片</li>
</ul>
</li>
</ul>
</li>
<li><p>阴影，<code>layer.shadowXXX</code></p>
<ul>
<li>如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染</li>
</ul>
</li>
</ul>
<h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3><ul>
<li><p>平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作</p>
</li>
<li><p>可以添加<code>Observer</code>到主线程<code>RunLoop</code>中，通过监听<code>RunLoop</code>状态切换的耗时，以达到监控卡顿的目的</p>
<ul>
<li>绘制操作基本都在<code>source0</code>和<code>source1</code>中处理,主要监听</li>
<li><code>kCFRunLoopBeforeWaiting</code>,开始休眠之前，处理的事件卡顿</li>
<li><code>kCFRunLoopBeforeSources</code>,处理<code>source0</code>，<code>kCFRunLoopAfterWaiting</code>，被<code>source1</code>唤醒处理的耗时<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)startMonitoring &#123;<br>    <span class="hljs-keyword">if</span> (_isMonitoring) &#123; <span class="hljs-keyword">return</span>; &#125;<br>    _isMonitoring = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<br>        <span class="hljs-number">0</span>,<br>        (__bridge <span class="hljs-keyword">void</span> *)<span class="hljs-keyword">self</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span><br>    &#125;;<br>    _observer = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="hljs-literal">YES</span>, <span class="hljs-number">0</span>, &amp;lxdRunLoopObserverCallback, &amp;context);<br>    <span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(lxd_event_monitor_queue(), ^&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">self</span>.isMonitoring) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.currentActivity == kCFRunLoopBeforeWaiting) &#123;<br>                __block <span class="hljs-built_in">BOOL</span> timeOut = <span class="hljs-literal">YES</span>;<br>                <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                    timeOut = <span class="hljs-literal">NO</span>;<br>                    dispatch_semaphore_signal(<span class="hljs-keyword">self</span>.eventSemphore);<br>                &#125;);<br>                <span class="hljs-comment">//等待1s,看添加到主队列的block是否执行完</span><br>                [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval: <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (timeOut) &#123;<br>                    [LXDBacktraceLogger lxd_logMain];<span class="hljs-comment">//打印堆栈信息</span><br>                &#125;<br>                dispatch_wait(<span class="hljs-keyword">self</span>.eventSemphore, DISPATCH_TIME_FOREVER);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(lxd_fluecy_monitor_queue(), ^&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">self</span>.isMonitoring) &#123;<br>        <span class="hljs-comment">//监听信号量解锁，并进行等待</span><br>            <span class="hljs-keyword">long</span> waitTime = dispatch_semaphore_wait(<span class="hljs-keyword">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">200</span> * <span class="hljs-built_in">NSEC_PER_MSEC</span>));<span class="hljs-comment">//解锁成功返回0</span><br>            <span class="hljs-keyword">if</span> (waitTime != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.observer) &#123;<br>                    <span class="hljs-keyword">self</span>.timeOut = <span class="hljs-number">0</span>;<br>                    [<span class="hljs-keyword">self</span> stopMonitoring];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//是否当前状态一直卡处理source0和休眠唤醒状态，超过5次，就打印</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.currentActivity == kCFRunLoopBeforeSources || <span class="hljs-keyword">self</span>.currentActivity == kCFRunLoopAfterWaiting) &#123;<br>                    <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">self</span>.timeOut &lt; <span class="hljs-number">5</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    [LXDBacktraceLogger lxd_logMain];<br>                    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval: <span class="hljs-number">5</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">self</span>.timeOut = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)stopMonitoring &#123;<br>    <span class="hljs-keyword">if</span> (!_isMonitoring) &#123; <span class="hljs-keyword">return</span>; &#125;<br>    _isMonitoring = <span class="hljs-literal">NO</span>;<br>    <br>    <span class="hljs-built_in">CFRunLoopRemoveObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);<br>    <span class="hljs-built_in">CFRelease</span>(_observer);<br>    _observer = <span class="hljs-literal">nil</span>;<br>&#125;<br><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lxdRunLoopObserverCallback(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity, <span class="hljs-keyword">void</span> * info) &#123;<br>    [LXDAppFluecyMonitor sharedMonitor].currentActivity = activity;<br>    <span class="hljs-comment">//每次变化进行信号量的增加，在监听的队列进行减少</span><br>    dispatch_semaphore_signal([LXDAppFluecyMonitor sharedMonitor].semphore);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>自动释放池</title>
    <url>/2023/02/18/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><ul>
<li><p>编译,<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@autoreleasepool</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>发现实际上是一个<code>__AtAutoreleasePool</code>的结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>    <span class="hljs-comment">//创建的时候调用构造函数，即 objc_autoreleasePoolPush();</span><br>    &#125;<br>    <span class="hljs-comment">//代码块结束的时候析构函数,即 objc_autoreleasePoolPop(atautoreleasepoolobj)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">AtAutoreleasePool</span> &#123;</span><br>    <span class="hljs-comment">//构造函数，在创建结构体的时候调用</span><br>  __AtAutoreleasePool() &#123; <br>  atautoreleasepoolobj = <span class="hljs-built_in">objc_autoreleasePoolPush</span>();<br>  &#125;<br>    <span class="hljs-comment">//析构函数，在结构体销毁的时候调用</span><br>  ~__AtAutoreleasePool() &#123;<br>  <span class="hljs-built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);<br>  &#125;<br>  <span class="hljs-keyword">void</span> * atautoreleasepoolobj;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">objc_autoreleasePoolPush</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::<span class="hljs-built_in">push</span>();<br>&#125;<br><br><span class="hljs-function">NEVER_INLINE</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">objc_autoreleasePoolPop</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ctxt)</span></span><br><span class="hljs-function"></span>&#123;<br>    AutoreleasePoolPage::<span class="hljs-built_in">pop</span>(ctxt);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>自动释放池的主要底层数据结构是：<code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code></li>
<li>用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管理的</li>
</ul>
<h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a><code>AutoreleasePoolPage</code></h3><ul>
<li>主要结构<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoreleasePoolPage</span> :</span> <span class="hljs-keyword">private</span> AutoreleasePoolPageData &#123; .... &#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AutoreleasePoolPageData</span> &#123;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">const</span> SIZE =<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span><br>		PAGE_MAX_SIZE;  <span class="hljs-comment">// must be multiple of vm page size</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>		PAGE_MIN_SIZE;  <span class="hljs-comment">// size and alignment, power of 2</span><br>		<span class="hljs-comment">//(1 &lt;&lt; 12) //4096</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><br>    <span class="hljs-keyword">magic_t</span> <span class="hljs-keyword">const</span> magic;<br>	__unsafe_unretained id *next;<br>	<span class="hljs-keyword">objc_thread_t</span> <span class="hljs-keyword">const</span> thread;<br>	AutoreleasePoolPage * <span class="hljs-keyword">const</span> parent;<br>	AutoreleasePoolPage *child;<br>	<span class="hljs-keyword">uint32_t</span> <span class="hljs-keyword">const</span> depth;<br>	<span class="hljs-keyword">uint32_t</span> hiwat;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>每个<code>AutoreleasePoolPage</code>对象占用<code>4096</code>字节内存，除了用来存放它内部的<code>成员变量</code>(主要成员大概占用<code>56</code>字节)，剩下的空间用来存放<code>autorelease</code>对象的地址<ul>
<li>剩下空间不够了，则会创建一个新的</li>
</ul>
</li>
<li>所有的<code>AutoreleasePoolPage</code>对象通过<code>双向链表</code>的形式连接在一起</li>
</ul>
<h3 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a><code>objc_autoreleasePoolPush</code></h3><ul>
<li>所有的<code>AutoreleasePoolPage</code>对象通过双向链表的形式连接在一起</li>
</ul>
<ol>
<li><code>objc_autoreleasePoolPush</code>调用<code>push</code>方法会将一个<code>POOL_BOUNDARY</code>(实际是个<code>nil</code>)入栈，并且返回其存放的内存地址<ul>
<li>后续调用<code>autorelease</code>加入释放值,也是调用<code>autoreleaseFast</code>方法添加到释放池，page不够，则创建新的，此时新的不用加<code>POOL_BOUNDARY</code>标记<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">push</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ReturnAutoreleaseInfo info = <span class="hljs-built_in">getReturnAutoreleaseInfo</span>();<br>        <span class="hljs-built_in">moveTLSAutoreleaseToPool</span>(info);<br><br>        id *dest;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(DebugPoolAllocation)) &#123;<br>            <span class="hljs-comment">// Each autorelease pool starts on a new pool page.</span><br>            dest = <span class="hljs-built_in">autoreleaseNewPage</span>(POOL_BOUNDARY);<span class="hljs-comment">//新建的页，第一个地址假上一个POOL_BOUNDARY</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dest = <span class="hljs-built_in">autoreleaseFast</span>(POOL_BOUNDARY);<br>        &#125;<br>        <span class="hljs-built_in">ASSERT</span>(dest == (id *)EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);<br>        <span class="hljs-keyword">return</span> dest;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h3><ol>
<li><code>objc_autoreleasePoolPop(atautoreleasepoolobj)</code>,调用<code>pop</code>时，则会对所有添加的值调用<code>release</code>方法，直到遇到<code>POOL_BOUNDARY</code>为止,<code>holdPage</code>为当前页面<br><img src="1.png"></li>
<li>存放的类型是<code>AutoreleasePoolEntry</code>,<code>ptr</code>是对象地址，<code>count</code>则是释放池内，该对象调用<code>autorelease</code>的次数<ul>
<li>当前页面没了，则会调整到父页，并设置父页面为当前页面，继续<code>release</code>，直到碰到<code>POOL_BOUNDARY</code></li>
<li><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域<br><img src="2.png"></li>
</ul>
</li>
</ol>
<h3 id="autoreleaseFast"><a href="#autoreleaseFast" class="headerlink" title="autoreleaseFast"></a>autoreleaseFast</h3><ol>
<li><code>autorelease</code>方法实际内部调用的是<code>autoreleaseFast</code>，其传入的值是对象<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> id *<span class="hljs-title">autoreleaseFast</span><span class="hljs-params">(id obj)</span></span><br><span class="hljs-function">    </span>&#123;<br>        AutoreleasePoolPage *page = <span class="hljs-built_in">hotPage</span>();<br>        <span class="hljs-keyword">if</span> (page &amp;&amp; !page-&gt;<span class="hljs-built_in">full</span>()) &#123;<br>            <span class="hljs-keyword">return</span> page-&gt;<span class="hljs-built_in">add</span>(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">autoreleaseFullPage</span>(obj, page);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">autoreleaseNoPage</span>(obj);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>add</code>添加到释放值，如果已经存在则增加次数，否则增加一个<code>AutoreleasePoolEntry</code><ul>
<li>这里增加次数只会在<code>4</code>个偏移内，如果超过了这个偏移，则当新的</li>
<li>在找到新存在的后，会将其移动到存储的最后一个<br><img src="3.png"></li>
</ul>
</li>
</ul>
<h3 id="查看释放值信息"><a href="#查看释放值信息" class="headerlink" title="查看释放值信息"></a>查看释放值信息</h3><ul>
<li><code>_objc_autoreleasePoolPrint</code>,该方法是一个私有方法,<code>MRC</code>环境下</li>
<li><code>p1</code>在距离上一个<code>p1</code>在<code>4</code>的范围内，则数量增加<code>1</code>，并且移动到最后<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> _objc_autoreleasePoolPrint(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">@autoreleasepool</span> &#123;  <br>    CJPerson *p1 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p2 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p3 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p4 = [[[CJPerson alloc] init] autorelease];<br>    [p1 <span class="hljs-keyword">retain</span>];<br>    [p1 autorelease];<br>    CJPerson *p5 = [[[CJPerson alloc] init] autorelease];<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123; <br>            CJPerson *p6 = [[[CJPerson alloc] init] autorelease];<br>             _objc_autoreleasePoolPrint();<br>    &#125;<br>   <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">objc[5867]: ##############</span><br><span class="hljs-comment">objc[5867]: AUTORELEASE POOLS for thread 0x7ff856aee640</span><br><span class="hljs-comment">objc[5867]: 10 releases pending.</span><br><span class="hljs-comment">objc[5867]: [0x10080b000]  ................  PAGE  (hot) (cold)</span><br><span class="hljs-comment">objc[5867]: [0x10080b038]  ################  POOL 0x10080b038</span><br><span class="hljs-comment">//每个AutoreleasePoolEntry`指针占8位</span><br><span class="hljs-comment">objc[5867]: [0x10080b040]    0x600000004060  CJPerson</span><br><span class="hljs-comment">objc[5867]: [0x10080b048]    0x600000004070  CJPerson</span><br><span class="hljs-comment">objc[5867]: [0x10080b050]    0x600000004080  CJPerson</span><br><span class="hljs-comment">//移动到最后，并且会打印数量</span><br><span class="hljs-comment">objc[5867]: [0x10080b058]    0x600000004050  CJPerson  autorelease count 2 </span><br><span class="hljs-comment">objc[5867]: [0x10080b060]    0x600000004090  CJPerson</span><br><span class="hljs-comment">objc[5867]: [0x10080b068]  ################  POOL 0x10080b068</span><br><span class="hljs-comment">objc[5867]: [0x10080b070]    0x6000000040a0  CJPerson</span><br><span class="hljs-comment">objc[5867]: ##############</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
<li><code>p1</code>在距离上一个<code>p1</code>在<code>4</code>的范围之外，则会另新增一个，尽管他们存的内存地址是一样的<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> _objc_autoreleasePoolPrint(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">@autoreleasepool</span> &#123;  <br>    CJPerson *p1 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p2 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p3 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p4 = [[[CJPerson alloc] init] autorelease];<br>    CJPerson *p5 = [[[CJPerson alloc] init] autorelease];<br>    [p1 <span class="hljs-keyword">retain</span>];<br>    [p1 autorelease];<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123; <br>            CJPerson *p6 = [[[CJPerson alloc] init] autorelease];<br>             _objc_autoreleasePoolPrint();<br>    &#125;<br>   <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">objc[6090]: ##############</span><br><span class="hljs-comment">objc[6090]: AUTORELEASE POOLS for thread 0x7ff856aee640</span><br><span class="hljs-comment">objc[6090]: 11 releases pending.</span><br><span class="hljs-comment">objc[6090]: [0x102009000]  ................  PAGE  (hot) (cold)</span><br><span class="hljs-comment">objc[6090]: [0x102009038]  ################  POOL 0x102009038</span><br><span class="hljs-comment">objc[6090]: [0x102009040]    0x60000000c020  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009048]    0x60000000c030  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009050]    0x60000000c040  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009058]    0x60000000c050  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009060]    0x60000000c060  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009068]    0x60000000c020  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009070]  ################  POOL 0x102009070</span><br><span class="hljs-comment">objc[6090]: [0x102009078]    0x60000000c070  CJPerson</span><br><span class="hljs-comment">objc[6090]: [0x102009080]  ################  POOL 0x102009080</span><br><span class="hljs-comment">objc[6090]: [0x102009088]    0x60000000c080  CJPerson</span><br><span class="hljs-comment">objc[6090]: ##############</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="autorelease时机"><a href="#autorelease时机" class="headerlink" title="autorelease时机"></a>autorelease时机</h3><ul>
<li><code>iOS</code>在主线程的<code>Runloop</code>中注册了<code>2</code>个<code>Observer</code><ul>
<li>第1个<code>Observer</code>监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li>
<li>第2个<code>Observer</code>监听了<code>kCFRunLoopBeforeWaiting</code>事件，会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code></li>
<li>  监听了<code>kCFRunLoopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>dealloc</title>
    <url>/2023/02/18/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dealloc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引用计数存储"><a href="#引用计数存储" class="headerlink" title="引用计数存储"></a>引用计数存储</h2><blockquote>
<ul>
<li>在<code>iOS</code>中，使用引用计数来管理<code>OC</code>对象的内存</li>
<li>一个新创建的<code>OC</code>对象引用计数默认是<code>1</code>，当引用计数减为<code>0</code>，<code>OC</code>对象就会销毁，释放其占用的内存空间</li>
<li>调用<code>retain</code>会让<code>OC</code>对象的引用计数<code>+1</code>，调用<code>release</code>会让<code>OC</code>对象的引用计数<code>-1</code></li>
<li>内存管理的经验总结<ul>
<li>当调用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法返回了一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它</li>
<li>想拥有某个对象，就让它的引用计数<code>+1</code>；不想再拥有某个对象，就让它的引用计数<code>-1</code></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>从<code>arm64</code>架构开始，对<code>isa</code>进行了优化，变成了一个共用体（<code>union</code>）结构，还使用位域来存储更多的信息<ul>
<li>其中<code>has_sidetable_rc</code>为<code>1</code>引用计数器是否过大无法存储在<code>isa</code>中<ul>
<li>如果为<code>1</code>，那么引用计数会存储在一个叫<code>SideTable</code>的类的属性中</li>
</ul>
</li>
<li><code>extra_rc</code>里面里面存储的值是引用<code>计数器减1</code>,<code>818</code>源码之前是减<code>1</code>，之后则是其本来的值了，见<a href="#jump">retainCount</a></li>
</ul>
</li>
</ul>
<p><img src="1.png"></p>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a><code>SideTable</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SideTable</span> &#123;</span><br>    <span class="hljs-keyword">spinlock_t</span> slock;<br>    RefcountMap refcnts; <span class="hljs-comment">//refcnts是一个存放着对象引用计数的散列表</span><br>    <span class="hljs-keyword">weak_table_t</span> weak_table;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a><span id="jump"><code>retainCount</code></span></h3><ul>
<li><p><code>818</code>源码,<code>extra_rc</code>上存的引用计数，不用做加1的操作，其上存的并非引用计数减一<br> <img src="2.png"></p>
<ul>
<li>并新增了方法，判断<code>isDeallocating</code><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(ISA_BITFIELD)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        ISA_BITFIELD;  <span class="hljs-comment">// defined in isa.h</span><br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeallocating</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> extra_rc == <span class="hljs-number">0</span> &amp;&amp; has_sidetable_rc == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDeallocating</span><span class="hljs-params">()</span> </span>&#123;<br>        extra_rc = <span class="hljs-number">0</span>;<br>        has_sidetable_rc = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>781</code>源码，<code>extra_rc</code>上存的是引用计数啊减<code>1</code>，计算时需要加1<br> <img src="3.png"></p>
</li>
<li><p>根据<code>key</code>从<code>SideTables</code>中获取<code>sidetable</code>，再从<code>refcnts</code>获取迭代器，从中取出引用计数<br>  <img src="4.png"></p>
</li>
</ul>
<h3 id="relese"><a href="#relese" class="headerlink" title="relese"></a>relese</h3><blockquote>
<p><code>relese</code>实际调用<code>rootrelease</code>，核心方法是<code>sidetable_release</code></p>
</blockquote>
<ul>
<li><code>sidetable_release</code><br>  <img src="5.png"><ul>
<li><code>refcnts</code>，在每次引用计数增减，是一个<code>SIDE_TABLE_RC_ONE</code></li>
<li><code>relese</code>，引用计数释放完了，则会调用<code>delloc</code>方法</li>
</ul>
</li>
</ul>
<h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p><img src="6.png"></p>
<h3 id="SIDE-TABLE-RC-ONE"><a href="#SIDE-TABLE-RC-ONE" class="headerlink" title="SIDE_TABLE_RC_ONE"></a>SIDE_TABLE_RC_ONE</h3><ul>
<li>每次引用计数改变的值<code>0B100</code>，后两位分别判断是否有弱引用，是否正在释放<br>  <img src="7.png"></li>
</ul>
<h2 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h2><ul>
<li>当一个对象要释放时，会自动调用<code>dealloc</code>，接下的调用轨迹是<ol>
<li><code>dealloc</code></li>
<li><code>_objc_rootDealloc</code></li>
<li><code>rootDealloc</code></li>
<li><code>object_dispose</code></li>
<li><code>objc_destructInstance</code>、<code>free</code></li>
</ol>
</li>
</ul>
<ol>
<li>会判断是否是<code>弱引用</code>、<code>关联对象</code>、<code>c++析构函数</code>、<code>引用计数表</code>，都没有的话直接<code>free释放</code><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">objc_object::<span class="hljs-built_in">rootDealloc</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTaggedPointer</span>()) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// fixme necessary?</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(<span class="hljs-built_in">isa</span>().nonpointer                     &amp;&amp;<br>                 !<span class="hljs-built_in">isa</span>().weakly_referenced             &amp;&amp;<br>                 !<span class="hljs-built_in">isa</span>().has_assoc                     &amp;&amp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ISA_HAS_CXX_DTOR_BIT</span><br>                 !<span class="hljs-built_in">isa</span>().has_cxx_dtor                  &amp;&amp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>                 !<span class="hljs-built_in">isa</span>().<span class="hljs-built_in">getClass</span>(<span class="hljs-literal">false</span>)-&gt;<span class="hljs-built_in">hasCxxDtor</span>() &amp;&amp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>                 !<span class="hljs-built_in">isa</span>().has_sidetable_rc))<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">sidetable_present</span>());<br>        <span class="hljs-built_in">free</span>(<span class="hljs-keyword">this</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">object_dispose</span>((id)<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>按顺序先处理后，再去释放<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">objc_destructInstance</span><span class="hljs-params">(id obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (obj) &#123;<br>        <span class="hljs-comment">// Read all of the flags at once for performance.</span><br>        <span class="hljs-keyword">bool</span> cxx = obj-&gt;<span class="hljs-built_in">hasCxxDtor</span>();<br>        <span class="hljs-keyword">bool</span> assoc = obj-&gt;<span class="hljs-built_in">hasAssociatedObjects</span>();<br><br>        <span class="hljs-comment">// This order is important.</span><br>        <span class="hljs-keyword">if</span> (cxx) <span class="hljs-built_in">object_cxxDestruct</span>(obj);<span class="hljs-comment">//调用c++析构函数</span><br>        <span class="hljs-keyword">if</span> (assoc) _object_remove_associations(obj, <span class="hljs-comment">/*deallocating*/</span><span class="hljs-literal">true</span>);<span class="hljs-comment">//删删除关联对象</span><br>        obj-&gt;<span class="hljs-built_in">clearDeallocating</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-comment">//清除弱引用和sidetable</span><br>objc_object::<span class="hljs-built_in">clearDeallocating</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!<span class="hljs-built_in">isa</span>().nonpointer)) &#123;<br>        <span class="hljs-comment">// Slow path for raw pointer isa.</span><br>        <span class="hljs-built_in">sidetable_clearDeallocating</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">isa</span>().weakly_referenced  ||  <span class="hljs-built_in">isa</span>().has_sidetable_rc)) &#123;<br>        <span class="hljs-comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span><br>        <span class="hljs-built_in">clearDeallocating_slow</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">sidetable_present</span>());<br>&#125;<br><br>objc_object::<span class="hljs-built_in">clearDeallocating_slow</span>()<br>&#123;<br>    <span class="hljs-built_in">ASSERT</span>(<span class="hljs-built_in">isa</span>().nonpointer  &amp;&amp;  (<span class="hljs-built_in">isa</span>().weakly_referenced || <span class="hljs-built_in">isa</span>().has_sidetable_rc));<br><br>    SideTable&amp; table = <span class="hljs-built_in">SideTables</span>()[<span class="hljs-keyword">this</span>];<br>    table.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isa</span>().weakly_referenced) &#123;<br>        <span class="hljs-built_in">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class="hljs-keyword">this</span>); <span class="hljs-comment">//清楚弱引用</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isa</span>().has_sidetable_rc) &#123;<br>        table.refcnts.<span class="hljs-built_in">erase</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//清楚sidetable</span><br>    &#125;<br>    table.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="weak指针释放"><a href="#weak指针释放" class="headerlink" title="weak指针释放"></a>weak指针释放</h3><ol>
<li>获取到<code>weak_entry_t</code>，从中获取存放的弱引用指针，将其置为<code>nil</code><br><img src="8.png"><ol start="2">
<li>从<code>weak_table_t</code>，查找的方式，是通过<code>hash</code>表，线性查找的方式<br><img src="9.png"></li>
<li><code>weak_entry_t</code>的结构，会根据数组长度的不同，结构有所不同<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">weak_table_t</span> &#123;</span><br><span class="hljs-keyword">weak_entry_t</span> *weak_entries;<br><span class="hljs-keyword">size_t</span>    num_entries;<br><span class="hljs-keyword">uintptr_t</span> mask;<br><span class="hljs-keyword">uintptr_t</span> max_hash_displacement;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">weak_entry_t</span> &#123;</span><br>    DisguisedPtr&lt;objc_object&gt; referent;<br> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>          <span class="hljs-keyword">weak_referrer_t</span> *referrers;<br>          <span class="hljs-keyword">uintptr_t</span>        out_of_line_ness : <span class="hljs-number">2</span>;<br>          <span class="hljs-keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;<br>          <span class="hljs-keyword">uintptr_t</span>        mask;<br>         <span class="hljs-keyword">uintptr_t</span>        max_hash_displacement;<br>      &#125;;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-comment">// out_of_line_ness field is low bits of inline_referrers[1]</span><br>        <span class="hljs-keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];<br>    &#125;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>js的基础学习（二）</title>
    <url>/2023/02/18/js%E7%9A%84%E5%AD%A6%E4%B9%A0/js%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><blockquote>
<p>Math中的方法，都会隐式转换成Number</p>
</blockquote>
<h4 id="max"><a href="#max" class="headerlink" title="max"></a>max</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ar numArr = [1,2,3,4,1]<br>console.log(Math.max(...numArr)); // 4<br>console.log(Math.max(0,1,&#x27;张三&#x27;)); // NaN<br>console.log(Math.max(0,1,&#x27;张三&#x27;)); // -Infinity<br></code></pre></td></tr></table></figure>
<h4 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">console.log(Math.abs(-0.13));   // 0.13<br>console.log(Math.abs(&#x27;-0.13&#x27;)); // -0.13隐式转换<br>console.log(Math.abs(&#x27;数字&#x27;)); // NaN<br></code></pre></td></tr></table></figure>
<h4 id="round"><a href="#round" class="headerlink" title="round"></a>round</h4><blockquote>
<p>四舍五入，其他数字都是四舍五入，但是.5特殊，它是往大了取</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">console.log(Math.round(1.5)); // 2<br>console.log(Math.round(&#x27;-1.5&#x27;)); // -1 .5特殊，它是往大了取<br>console.log(Math.round(-1.4)); // -1<br>console.log(Math.round(-1.6)); // -2<br></code></pre></td></tr></table></figure>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<p>字符串本身是不可变的，指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var str = &#x27;abc&#x27;<br>str = &#x27;hello&#x27;<br>//当重新给str赋值的时候，常量`abc`不会被修改，依然在内存中<br>//重新给字符串赋予值没回重新在内存中开辟空间，这个特点就是字符串的不可变<br>//由于字符串的不可变，咋子大量拼接字符串的时候会有效率问题<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>js的基础学习（一）</title>
    <url>/2023/02/15/js%E7%9A%84%E5%AD%A6%E4%B9%A0/js%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>只记录js中特殊的写法</p>
</blockquote>
<span id="more"></span>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><table>
<thead>
<tr>
<th>情况</th>
<th align="left">说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>var age ; console.log (age);</td>
<td align="left">只声明 不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td align="left">不声明 不赋值 直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age = 10; console.log (age);</td>
<td align="left">不声明 只赋值</td>
<td>10</td>
</tr>
</tbody></table>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><blockquote>
<p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的 内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会 被自动确定。</p>
</blockquote>
<h3 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h3><ul>
<li>在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。 JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型:<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var x = 6; // x 为数字 <br>var x = &quot;Bill&quot;; // x 为字符串<br></code></pre></td></tr></table></figure>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>var num = 10; //全局变量<br>function fun() &#123;<br>    var num1 = 20; //局部变量<br>    num2 = 20;// 也是全局变量，在函数内部，没有声明直接赋值的变量也是全局变量<br>&#125;<br>fun(); //必须执行该方法，才可以输出num2<br>console.log(num2); // 2<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><ul>
<li>简单数据类型 (<code>Number</code>,<code>String</code>,<code>Boolean</code>,<code>Undefined</code>,<code>Null</code>)</li>
<li>复杂数据类型 (<code>object</code>)<h4 id="数字型-Number"><a href="#数字型-Number" class="headerlink" title="数字型 Number"></a>数字型 Number</h4></li>
</ul>
</li>
<li>数字型三个特殊值<ul>
<li><code>Infinity</code> ，代表无穷大，大于任何数值</li>
<li><code>-Infinity</code> ，代表无穷小，小于任何数值</li>
<li> <code>NaN</code> ，Not a number，代表一个非数值</li>
</ul>
</li>
<li> 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(&#x27;11&#x27; - &#x27;1&#x27;); // 10<br>alert(&#x27;11&#x27; - &#x27;sss&#x27;); // NaN<br>alert(&#x27;11&#x27; - undefined); // NaN<br></code></pre></td></tr></table></figure>
<h4 id="字符串型-String"><a href="#字符串型-String" class="headerlink" title="字符串型 String"></a>字符串型 String</h4></li>
<li>字符串拼接<ul>
<li>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 </li>
<li>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(&#x27;hello&#x27; + &#x27; &#x27; + &#x27;world&#x27;); // hello world <br>alert(&#x27;100&#x27; + &#x27;100&#x27;); // 100100<br>alert(&#x27;11&#x27; + 12); // 1112<br>alert(&#x27;11&#x27; + undefined); // 11undefined<br>alert(&#x27;11&#x27; + false); // 11false<br></code></pre></td></tr></table></figure>
<h4 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型 Boolean"></a>布尔型 Boolean</h4><blockquote>
<ul>
<li>布尔类型有两个值:true 和 false ，其中 true 表示真(对)，而 false 表示假(错)。 </li>
<li>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">console.log(true + 1); // 2 <br>console.log(false + 1); // 1<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>转换为布尔型<ul>
<li>代表空、否定的值会被转换为 false ，如 <code>&#39;&#39;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code></li>
<li>其余值都会被转换为 true<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">console.log(Boolean(&#x27;&#x27;)); // false <br>console.log(Boolean(0)); // false <br>console.log(Boolean(NaN)); // false <br>console.log(Boolean(null)); // false <br>console.log(Boolean(undefined)); // false <br>console.log(Boolean(&#x27;小白&#x27;)); // true <br>console.log(Boolean(12)); // true<br></code></pre></td></tr></table></figure>
<h4 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h4></li>
</ul>
</li>
<li>一个声明后没有被赋值的变量会有一个默认值 <code>undefined</code> ( 如果进行相连或者相加时，注意结果)<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var variable;<br>console.log(variable); // undefined <br>console.log(&#x27;你好&#x27; + variable); // 你好undefined <br>console.log(11 + variable); // NaN <br>console.log(true + variable); // NaN<br></code></pre></td></tr></table></figure></li>
<li>一个声明变量给 <code>null</code> 值，里面存的值为空<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var vari = null;<br>console.log(&#x27;你好&#x27; + vari); // 你好null <br>console.log(11 + vari); // 11 <br>console.log(true + vari); // 1<br></code></pre></td></tr></table></figure>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="短路运算-逻辑中断-，"><a href="#短路运算-逻辑中断-，" class="headerlink" title="短路运算(逻辑中断)，"></a>短路运算(逻辑中断)，</h3><blockquote>
<p>当有多个表达式值时，左边的表达式值可以确定结果时，就不在继续运算右边的表达式的值;</p>
</blockquote>
</li>
</ul>
<ol>
<li>逻辑与<ul>
<li>表达式1 &amp;&amp; 表达式2</li>
<li>如果第一个表达式的值为真，则返回表达式2</li>
<li>如果第一个表达式的值为假，则返回表达式1<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">console.log(123 &amp;&amp; 456); // 456<br>console.log(0 &amp;&amp; 456);  // 0<br>console.log(&quot;&quot; &amp;&amp; 456);  // &quot;&quot;<br>console.log(123 &amp;&amp; 456 &amp;&amp; 5678);  // 5678<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>逻辑或<ul>
<li>表达式1 || 表达式2</li>
<li>如果第一个表达式的值为真，则返回表达式1</li>
<li>如果第一个表达式的值为假，则返回表达式2<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数和形参匹配"><a href="#函数和形参匹配" class="headerlink" title="函数和形参匹配"></a>函数和形参匹配</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function getSum(num1,num2) &#123;<br>    consloe.log(num1 + num2);<br>&#125;<br>getSum(1,2); // 3<br>//如果实参的个数多于形参的个数，会取到形参的个数<br>getSum(1,2,3);  // 3<br>//形参可以看做是不用声明的变量，num2是为Undefined<br>getSum(1);  // NaN<br></code></pre></td></tr></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function getSum(num1,num2) &#123;<br>    consloe.log(num1 + num2);<br>&#125;<br>//没有返回值，返回Undefined<br>consloe.log(getSum(1,2)); //Undefined<br>function getSum(num1,num2) &#123;<br>    return num1，num2;<br>&#125;<br>//多个返回值，只会返回最后一个<br>consloe.log(getSum(1,2)); //2<br></code></pre></td></tr></table></figure>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><blockquote>
<p>js中arguments是函数的内置对象，存储了传递的所有实参</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function fun() &#123;<br>for (let i = 0; i &lt; arguments.length; i++) &#123;<br>         console.log(arguments[i]);<br>    &#125;<br>&#125;<br><br>fun(1,2,3,4,5); // 1 2 3 4 5<br></code></pre></td></tr></table></figure>
<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><blockquote>
<p>js引擎运行js分为两步: 预解析 代码执行</p>
<ul>
<li>预解析 js引擎会把js里面所有的var还有function提升到当前作用域的最前面</li>
<li>代码执行 按照代码书写的顺序从上往下执行</li>
</ul>
</blockquote>
<h3 id="预解析-1"><a href="#预解析-1" class="headerlink" title="预解析"></a>预解析</h3></li>
</ul>
</li>
</ol>
<ul>
<li>变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">console.log(num); //输出Undefined，只会提升作用域，不提升赋值<br>var num = 10;<br>fun(); //会报错，因不提升赋值<br>var fun = function() &#123;<br>var a = b = c = 9; //相当于 var a=9; b = 9;c = 9;b和c是全局变量(在函数内部，没有声明<br>直接赋值的变量也是全局变量),但是必须执行<br>//集体赋值是var a=9,b = 9,c = 9;这种都是局部变量<br>    console.log(num);//输出Undefined,以为当前函数作用域下也有个局部变量num,因此会提升到最前面<br>    var num = 20;<br>&#125;<br>fun()<br>console.log(c); // 9<br>console.log(b); // 9<br>console.log(a); // 报错，没有a的全局变量<br></code></pre></td></tr></table></figure></li>
<li>函数提升 就是把所有的函数声明提升到当前作用于的最前面 不调用函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">fun(); //不会报错，函数提升了<br>function fun() &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li>
<li>字面量创建对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var objc = &#123;<br>    usanme: &#x27;张三&#x27;,<br>    age:18,<br>    sayHi: function() &#123;<br>        console.log(&#x27;hi&#x27;);<br>    &#125;<br>&#125;<br>//调用属性<br>console.log(obj.usname); //张三<br>console.log(obj[&#x27;usname&#x27;]); //张三<br>obj.sayHi();<br></code></pre></td></tr></table></figure></li>
<li><code>new Objc</code>创建对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs x">var obj = new Object(); //创建一个空的对象<br>obj.uname = &#x27;张三&#x27;;<br>obj.age = 18;<br>obj.sayHi = function() &#123;<br>    console.log(&#x27;hi&#x27;);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>构造函数创建一个对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Star(uname,age,sex) &#123;<br>     this.name = uname;<br>     this.age = age;<br>     this.sex = sex;<br>     this.sayHi = function() &#123;<br>        console.log(&#x27;sayHi&#x27;)<br>     &#125;<br>&#125;<br>var star = new Star(&#x27;张三&#x27;,18,&#x27;男&#x27;); //必须new，不加则是方法，返回undefined<br></code></pre></td></tr></table></figure>
<h3 id="new关键词的执行过程"><a href="#new关键词的执行过程" class="headerlink" title="new关键词的执行过程"></a>new关键词的执行过程</h3></li>
</ul>
<ol>
<li><code>new 构造函数</code>可以在内存中创建一个空的对象</li>
<li><code>this</code>就会指向刚才创建的空对象</li>
<li>执行构造函数里面的代码，<code>this.</code>给这个空对象添加属性和方法</li>
<li>返回这个对象（所以构造函数不需要<code>return</code>）<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><blockquote>
<p>用<code>for in</code>对遍历对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">for (const key in dss) &#123;<br>   console.log(key); //属性名<br>   console.log(dss[key]); // 属性内的值<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Tagged Pointer</title>
    <url>/2023/02/15/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/TaggedPointer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a><code>Tagged Pointer</code></h1><blockquote>
<ul>
<li>从<code>64bit</code>开始，<code>iOS</code>引入了<code>Tagged Pointer</code>技术，用于优化<code>NSNumber</code>、<code>NSDate</code>、<code>NSString</code>等<code>小对象</code>的存储</li>
<li>在没有使用<code>Tagged Pointer</code>之前， <ul>
<li><code>NSNumber</code>等对象需要动态分配内存、维护引用计数等，<code>NSNumber</code>指针存储的是<code>堆</code>中<code>NSNumber</code>对象的地址值</li>
</ul>
</li>
<li>使用<code>Tagged Pointer</code>之后，<ul>
<li><code>NSNumber</code>指针里面存储的数据变成了：<code>Tag</code> + <code>Data</code>，也就是将数据直接存储在了指针中</li>
<li>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</li>
</ul>
</li>
<li><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从<code>指针</code>提取数据，节省了以前的调用开销(因为没有<code>isa</code>存在，不是<code>OC</code>对象，不会走<code>方法调用流程</code>)</li>
</ul>
</blockquote>
<h2 id="如何判断一个指针是否为Tagged-Pointer？"><a href="#如何判断一个指针是否为Tagged-Pointer？" class="headerlink" title="如何判断一个指针是否为Tagged Pointer？"></a>如何判断一个指针是否为<code>Tagged Pointer</code>？</h2><p><img src="1.png"><br><img src="2.png"></p>
<ul>
<li>iOS平台，最高有效位是<code>1</code>（第<code>64bit</code>）</li>
<li>Mac平台，最低有效位是<code>1</code></li>
</ul>
<h2 id="Tagged-Pointer存储地方思考"><a href="#Tagged-Pointer存储地方思考" class="headerlink" title="Tagged Pointer存储地方思考"></a><code>Tagged Pointer</code>存储地方思考</h2><ul>
<li>解码<code>extern</code>调用私有函数,和一个指针<code>^</code>才能得到真正的<code>taggedPointer</code>指针<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">extern</span> uintptr_t objc_debug_taggedpointer_obfuscator;<br>uintptr_t _objc_decodeTaggedPointer_(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable  ptr) &#123;<br>    <span class="hljs-keyword">return</span> (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;<br>&#125;<br><br><span class="hljs-built_in">NSNumber</span> *number1 = @<span class="hljs-number">4</span>;<br><span class="hljs-built_in">NSNumber</span> *number2 = @<span class="hljs-number">5</span>;<br><span class="hljs-built_in">NSNumber</span> *number3 = @<span class="hljs-number">100</span>;<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p  %p  %p&quot;</span>,number1,number2,number3);<br><span class="hljs-comment">///0xc96fede699842146  0xc96fede699842786  0xc96fede699861216</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;0x%lx   0x%lx   0x%lx&quot;</span>,_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(number1)),_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(number2)),_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(number3)));<br><span class="hljs-comment">///0xb000000000000042   0xb000000000000052   0xb000000000000642</span><br><br><span class="hljs-built_in">NSString</span> *str1 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;sd&quot;</span>];<br><span class="hljs-built_in">NSString</span> *str2 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;sdadad&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p  %p&quot;</span>,str1,str2);<br><span class="hljs-comment">//0xbaf35d65b6463f52  0xbaf51b73f0563f56</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;0x%lx 0x%lx&quot;</span>,_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(str1)),_objc_decodeTaggedPointer_((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable)(str2)));<br><span class="hljs-comment">//0xa000000000064732   0xa006461646164736</span><br></code></pre></td></tr></table></figure></li>
<li>分析,注意上面的数据是在<code>x86</code>模拟器上的数据<ul>
<li>前面的<code>0xb</code>明显是<code>tag</code>,为<code>0xb</code> -&gt; <code>1011</code>, <code>0xa</code> -&gt; <code>1010</code>,<ul>
<li>在iOS中最高位为<code>1</code>表明是<code>Tagged Pointer</code></li>
<li>后三位代表数据类型，<code>011</code>代表<code>int</code>（如果是带小数点的无法不会转出<code>tag</code>），<code>010</code>代表字符串</li>
</ul>
</li>
<li><code>42</code> -&gt; <code>100 0010</code>(<code>4</code>),<code>52</code> -&gt;<code>101 0010</code>(<code>5</code>)<ul>
<li>前四位代表存储的内容</li>
<li>后<code>4</code>位代表数据长度(一般是<strong>字符串长度</strong>)，后四位<code>&quot;sd&quot;</code> -&gt; <code>0010</code>长度<code>2</code>、<code>&quot;sdadad&quot;</code> -&gt; <code>0110</code>长度<code>6</code></li>
</ul>
</li>
</ul>
</li>
<li>如果是<code>iOS</code>，<code>arm64</code>下，数据格式不同,需要注意<ul>
<li><code>@5 -&gt; 0x8000000000000291</code>,<code>@8 -&gt; 0x8000000000000411</code>,最高位1是标识，低7位是<code>标识</code>和<code>数据长度</code></li>
</ul>
</li>
<li>在iOS中，<code>Tagged Pointer</code>中间<code>56</code>位用来存东西，前<code>4</code>位是tag，后<code>4</code>位是数据长度</li>
</ul>
<h2 id="Tagged-Pointer的题目思考"><a href="#Tagged-Pointer的题目思考" class="headerlink" title="Tagged Pointer的题目思考"></a><code>Tagged Pointer</code>的题目思考</h2><h3 id="关于野指针的问题"><a href="#关于野指针的问题" class="headerlink" title="关于野指针的问题"></a>关于野指针的问题</h3><ul>
<li>崩溃地方在<code>objc_release</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>            <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">self</span>.name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;abcdefghijk&quot;</span>];<br>            <span class="hljs-comment">// 解锁</span><br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>            <span class="hljs-keyword">self</span>.name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;abc&quot;</span>];<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>原因：设置<code>name</code>方法本质为如下方法，（<code>ARC</code>下也会有<code>release</code>引用释放,也会存在该问题）,因此在多线程下调用很可能会出现野指针问题<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name<br>&#123;<br>    <span class="hljs-keyword">if</span> (_name != name) &#123;<br>        [name <span class="hljs-keyword">retain</span>];<span class="hljs-comment">// 保留新对象</span><br>        [_name release];<span class="hljs-comment">//原先的引用计数减1</span><br>        _name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>但实际上，将赋值的对象设置仅为<code>[NSString stringWithFormat:@&quot;abc&quot;]</code>，或者为<code>@&quot;abcdefghijk&quot;</code>字面量时，不会出现<strong>野指针</strong>的问题。<ul>
<li>原因在于，<code>[NSString stringWithFormat:@&quot;abc&quot;]</code>类型为<code>NSTaggedPointerString</code>,不是<code>OC</code>对象不会有实际的<code>release</code>方法</li>
<li><code>@&quot;abcdefghijk&quot;</code>字面量为<code>__NSCFConstantString</code>，是字符串常量，<code>release</code>不会使其释放</li>
<li><code>[NSString stringWithFormat:@&quot;abcdefghijk&quot;]</code>,在超过<code>Tagged Pointer</code>,数据限制后，其类型为<code>__NSCFString</code>,字符串的<code>OC</code>对象，存在<code>引用计数</code>，因此会出现<code>野指针</code>问题</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>swift类的动态性</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="swift类的动态性"><a href="#swift类的动态性" class="headerlink" title="swift类的动态性"></a>swift类的动态性</h1><h2 id="动态方法查询"><a href="#动态方法查询" class="headerlink" title="动态方法查询"></a>动态方法查询</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> methodCount: <span class="hljs-type">UInt32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> methodList <span class="hljs-operator">=</span> class_copyMethodList(<span class="hljs-type">JPTeacher</span>.<span class="hljs-keyword">self</span>, <span class="hljs-operator">&amp;</span>methodCount)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-built_in">numericCast</span>(methodCount) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> method <span class="hljs-operator">=</span> methodList<span class="hljs-operator">?</span>[i] &#123;<br>            <span class="hljs-keyword">let</span> methodName <span class="hljs-operator">=</span> method_getName(method)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方法列表:<span class="hljs-subst">\(methodName)</span>&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;not found method&quot;</span>)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> count:<span class="hljs-type">UInt32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> proList <span class="hljs-operator">=</span> class_copyPropertyList(<span class="hljs-type">JPTeacher</span>.<span class="hljs-keyword">self</span>, <span class="hljs-operator">&amp;</span>count)<br>    <span class="hljs-keyword">for</span>  i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-built_in">numericCast</span>(count) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> proerty <span class="hljs-operator">=</span> proList<span class="hljs-operator">?</span>[i] &#123;<br>            <span class="hljs-keyword">let</span> proertyName <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(cString: property_getName(proerty))                      <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成员属性：<span class="hljs-subst">\(proertyName)</span>&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;not found property&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="静态性"><a href="#静态性" class="headerlink" title="静态性"></a>静态性</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JPTeacher</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------teach&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------test1&quot;</span>)<br>    &#125;<br>&#125;<br>test()<br><span class="hljs-comment">//什么都不会输出</span><br></code></pre></td></tr></table></figure>
<ul>
<li>调用<code>test()</code>方法，不会输出任何信息。因为，<code>Swift</code>是静态语言，所以没有动态特性。⽅法和属性不加任何修饰符的情况下，不具备所谓的<code>Runtime</code>特性，它的方法调度方式使用<code>V_table</code>函数表调度</li>
</ul>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JPTeacher</span>:<span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------teach&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------test1&quot;</span>)<br>    &#125;<br>&#125;<br>test()<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法列表:age</span><br><span class="hljs-comment">方法列表:setAge:</span><br><span class="hljs-comment">方法列表:teach</span><br><span class="hljs-comment">方法列表:test1</span><br><span class="hljs-comment">方法列表:init</span><br><span class="hljs-comment">成员属性：age</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>继承⾃<code>NSObject</code>的类，如果想要动态获取当前⽅法和属性，必须在其声明前添加<code>@objc</code>关键字。</li>
</ul>
<h3 id="Runtime-API交换方法"><a href="#Runtime-API交换方法" class="headerlink" title="Runtime API交换方法"></a>Runtime API交换方法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exchangeMethod</span>()</span> &#123;<br>    <span class="hljs-keyword">if</span>  <span class="hljs-keyword">let</span>  method1 <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-type">LGTeacher</span>.<span class="hljs-keyword">self</span>, <span class="hljs-type">NSSelectorFromString</span>(<span class="hljs-string">&quot;test1&quot;</span>)),<br>        <span class="hljs-keyword">let</span>  method2 <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-type">LGTeacher</span>.<span class="hljs-keyword">self</span>, <span class="hljs-type">NSSelectorFromString</span>(<span class="hljs-string">&quot;teach&quot;</span>)) &#123;<br>        method_exchangeImplementations(method1, method2)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>swift调用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-type">LGTeacher</span>().teach()<br>exchangeMethod()<br><span class="hljs-type">LGTeacher</span>().teach()<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-------teach</span><br><span class="hljs-comment">-------teach</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
<li><p>oc中调用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">[[<span class="hljs-type">LGTeacher</span> new] teach];<br>[<span class="hljs-keyword">self</span>  exchangeMethod];<br>[[<span class="hljs-type">LGTeacher</span> new] teach];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-------teach</span><br><span class="hljs-comment">------test1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
<li><p>显然<code>OC</code>中桥接的方法，进行了交互，但是<code>swift</code>中调用的并未进行交换。这是因为<code>swift</code>中的方法，仍然是函数调用，加上<code>@objc</code>后,由打印可知，增加了<code>objc</code>的方法。因此两个调用的方法实际上是不一样的</p>
<ul>
<li>但是如果是在<code>extension</code>中，加上的<code>@objc</code>，则<code>swift</code>和<code>oc</code>中调用，都是消息派发，并可以交换</li>
</ul>
</li>
<li><p>如果想在<code>swift</code>中可以交换方法，则需要添加<code>dynamic</code>关键字，让它们具备动态特性，例子</p>
<ul>
<li><code>dynamic</code>针对类中的方法，如果是<code>extension</code>中的，只需<code>@objc</code>，就会是消息派发<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LGTeacher</span>:<span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teach</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------teach&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------test1&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-type">LGTeacher</span>().teach()<br>exchangeMethod()<br><span class="hljs-type">LGTeacher</span>().teach()<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-------teach</span><br><span class="hljs-comment">------test1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>注意</strong>,如果在方法中不加<code>@objc</code>，只加<code>dynamic</code>,那么在打印的方法中将没有<code>teach</code>和<code>test1</code>方法，也无法交换。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>定时器通过<code>addTarget</code>添加的时候，会强引用<code>target</code>，如果此时<code>target</code>持有了定时器，则会出现循环引用</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//__weak typeof(self) weakSelf = self;将target的self,换成weakSelf，一样会出现循环引用 </span><br>__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>；<br><span class="hljs-comment">//和block不一样，block内部会根据weak还是strong，去引用对象</span><br><br><span class="hljs-comment">//而NSTimer中，经过传人的是weakSelf，但其内部，仍然会强引用self</span><br><span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(timerTest) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br><br><span class="hljs-comment">//出现循环引用，无法释放</span><br>- (<span class="hljs-keyword">void</span>)dealloc<br>&#123;<br>    [<span class="hljs-keyword">self</span>.timer invalidate];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="NSObjec的代理转发"><a href="#NSObjec的代理转发" class="headerlink" title="NSObjec的代理转发"></a><code>NSObjec</code>的代理转发</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> <br>                                                target:[JPProxy proxyWithTarget:<span class="hljs-keyword">self</span>] <br>                                              selector:<span class="hljs-keyword">@selector</span>(timerTest) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JPProxy</span> : <span class="hljs-title">NSObject</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target;<br><span class="hljs-keyword">@property</span> <br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">JPProxy</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target<br>&#123;<br>    JPProxy *proxy = [[JPProxy alloc] init];<br>    proxy.target = target;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br><br>- (<span class="hljs-keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.target;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<ul>
<li>通过一个代理类<code>proxy</code>，弱引用持有<code>self</code>，而定时器的<code>target</code>为该代理类，则可打破该循环引用，并且，定时器在代理类中查询<code>timerTest</code>方法时,会通过消息转发机制，由<code>self</code>来处理</li>
<li><code>CADisplayLink</code>也可以通过一样的方式，解决循环引用</li>
</ul>
<h4 id="NSProxy的代理转发"><a href="#NSProxy的代理转发" class="headerlink" title="NSProxy的代理转发"></a>NSProxy的代理转发</h4><blockquote>
<p><code>NSProxy</code>和<code>NSObject</code>一样，同样是一种基类,<code>NSProxy</code>没有<code>forwardingTargetForSelector:</code>,因此要走<code>methodSignatureForSelector</code>,<code>forwardInvocation:</code>最后一步方法转发流程</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JPProxy</span> : <span class="hljs-title">NSProxy</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span> target;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">JPProxy</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target<br>&#123;<br>    <span class="hljs-comment">// NSProxy对象不需要调用init，因为它本来就没有init方法</span><br>    JPProxy *proxy = [JPProxy alloc];<br>    proxy.target = target;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br><br><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel<br>&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.target methodSignatureForSelector:sel];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation<br>&#123;<br>    [invocation invokeWithTarget:<span class="hljs-keyword">self</span>.target];<br>&#125;<br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>对于转发来说，<code>NSProxy</code>的效率要比<code>NSObject</code>要快。<ul>
<li>因为继承自<code>NSObject</code>的代理，需要先<code>查询方法</code>-&gt;<code>方法解析</code>-&gt;最后才是<code>方法转发</code>。</li>
<li>而继承自<code>NSProxy</code>，会直接走向<code>方法转发</code>。</li>
</ul>
</li>
</ul>
<h3 id="CGD定时器"><a href="#CGD定时器" class="headerlink" title="CGD定时器"></a>CGD定时器</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dispatch_source_t timer = dispatch_source_create(DISPATCH_TIME_NOW, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dispatch_get_main_queue());<br><span class="hljs-comment">// 设置时间（start是几秒后开始执行，interval是时间间隔）</span><br>dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(start * <span class="hljs-built_in">NSEC_PER_SEC</span>)), (uint64_t)(interval * <span class="hljs-built_in">NSEC_PER_SEC</span>), <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 设置回调</span><br>dispatch_source_set_event_handler(timer, ^&#123;<br>        <br>&#125;);<br><span class="hljs-comment">// 启动定时器</span><br>dispatch_resume(timer);<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>读写锁</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li>读写锁的应用场景<ul>
<li>同一时间，只能有<code>1</code>个线程进行写的操作</li>
<li>同一时间，允许有多个线程进行读的操作</li>
<li>同一时间，不允许既有写的操作，又有读的操作</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="读写锁的方案"><a href="#读写锁的方案" class="headerlink" title="读写锁的方案"></a>读写锁的方案</h3><ul>
<li><code>pthread_rwlock</code>：读写锁</li>
<li><code>dispatch_barrier_async</code>：异步栅栏调用</li>
</ul>
<h3 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote>
<p>读用<code>pthread_rwlock_rdlock</code>，写用<code>pthread_rwlock_wrlock</code>，运行读同时并发进行，写必须按顺序进行</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">pthread_rwlock_t _lock;<br>pthread_rwlock_init(&amp;_lock, <span class="hljs-literal">NULL</span>);<br><br>- (<span class="hljs-keyword">void</span>)read &#123;<br>    pthread_rwlock_rdlock(&amp;_lock);<br>    <span class="hljs-comment">//读加锁    </span><br>    pthread_rwlock_unlock(&amp;_lock);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)write<br>&#123;<br>    pthread_rwlock_wrlock(&amp;_lock);<br>    <br>     <span class="hljs-comment">//写加锁    </span><br>    pthread_rwlock_unlock(&amp;_lock);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)dealloc<br>&#123;<br>    pthread_rwlock_destroy(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.queue = dispatch_queue_create(<span class="hljs-string">&quot;rw_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><span class="hljs-built_in">dispatch_async</span>(<span class="hljs-keyword">self</span>.queue, ^&#123;<br>    <span class="hljs-comment">//读操作</span><br>&#125;);<br><br><span class="hljs-comment">//使用栅栏添加到队列的任务，会等之前的读任务执行完，再执行该任务，</span><br><span class="hljs-comment">//并且之后添加到该队列的读任务，必须等到该任务执行完，才能执行。</span><br>dispatch_barrier_async(<span class="hljs-keyword">self</span>.queue, ^&#123;<br>    <span class="hljs-comment">//写操作</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><strong>注意</strong>，<code>dispatch_barrier_async</code>传入的并发队列必须是<strong>自己</strong>通过<code>dispatch_queue_cretate</code> 创建的如果传入的是一个<code>串行</code>或是一个<code>全局的并发队列</code>，那这个函数便等同于<code>dispatch_async</code>函数的效果，无法保证读写安全</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>多线程和锁</title>
    <url>/2023/02/02/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h2><ul>
<li>资源共享<ul>
<li><code>1</code>块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li>
<li>比如多个线程访问同一个对象、同一个变量、同一个文件</li>
</ul>
</li>
<li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li>
</ul>
<h2 id="OS中的线程同步方案"><a href="#OS中的线程同步方案" class="headerlink" title="OS中的线程同步方案"></a>OS中的线程同步方案</h2><ol>
<li><code>OSSpinLock</code></li>
<li><code>os_unfair_lock</code></li>
<li><code>pthread_mutex</code></li>
<li><code>dispatch_semaphore</code></li>
<li><code>dispatch_queue(DISPATCH_QUEUE_SERIAL)</code></li>
<li><code>NSLock</code></li>
<li><code>NSRecursiveLock</code></li>
<li><code>NSCondition</code></li>
<li><code>NSConditionLock</code></li>
<li><code>@synchronized</code></li>
</ol>
<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><blockquote>
<p>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p>
<ul>
<li>目前已经不再安全，可能会出现优先级反转问题<ul>
<li>如果等待锁的线程优先级较高，它会一直占用着CPU资源；获得锁的优先级低的线程，没有CPU资源，分配不到时间片，无法执行完，就无法释放锁<ul>
<li>多线程原理是，操作系统通过<code>时间片轮转算法</code>，每次给一个线程一个时间片，让其可以执行,(如果所给的时间片足够短，则看起来是同时执行的</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h4><blockquote>
<p>iOS10以上由于优先级反转的问题，导致被废弃，系统建议使用os_unfair_lock</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;libkern/OSAtomic.h&gt;</span></span><br><br>OSSpinLock _lock = OS_SPINLOCK_INIT;<span class="hljs-comment">//多个线程持有同一个锁</span><br><br>OSSpinLockLock(&amp;_lock);<br><span class="hljs-comment">//需要同步的代码</span><br>OSSpinLockUnlock(&amp;_lock)<br></code></pre></td></tr></table></figure>

<h4 id="自旋锁逻辑查看"><a href="#自旋锁逻辑查看" class="headerlink" title="自旋锁逻辑查看"></a>自旋锁逻辑查看</h4><ul>
<li>汇编源码查看线程等待锁时，所做的事，通过<code>lldb</code>的<code>s</code>指令(代码级别的),<code>si</code>(stepi)(汇编级别的)，一步步查看汇编执行，<code>ni</code>(<code>next</code>)指令遇到函数级别的调用会跳过<ul>
<li>如果可以获取到锁，则不会走<code>_OSSPinLockLockSlow</code>,直接执行同步代码<br><img src="2.png"></li>
<li>如果没有获取到锁，则会走<code>_OSSPinLockLockSlow</code>方法中，类似<code>while</code>循环调用，线程不会休眠<br><img src="1.png"></li>
</ul>
</li>
</ul>
<h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><blockquote>
<ul>
<li><code>mutex</code>叫做”互斥锁”，等待锁的线程会处于休眠状态</li>
<li><code>pthread_mutex</code>可以在多个平台上使用(window、linux、macos)都可以使用</li>
</ul>
</blockquote>
<h4 id="使用教程-1"><a href="#使用教程-1" class="headerlink" title="使用教程"></a>使用教程</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;pthread/pthread.h&gt;</span></span><br><br>pthread_mutex_t _pthreadMutex;<br><span class="hljs-comment">//初始化属性</span><br>pthread_mutexattr_t attr;<br>pthread_mutexattr_init(&amp;attr);<br>pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);<br><span class="hljs-comment">//初始化锁</span><br>pthread_mutex_init(&amp;_pthreadMutex, &amp;attr);<br><span class="hljs-comment">//pthread_mutex_init(&amp;_pthreadMutex, NULL);传null为DEFALT，即NORMAL</span><br><span class="hljs-comment">//销毁属性</span><br>pthread_mutexattr_destroy(&amp;attr);<br><span class="hljs-comment">//不用锁之后需要销毁</span><br>pthread_mutex_destroy(&amp;_pthreadMutex);<br></code></pre></td></tr></table></figure>

<h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTHREAD_MUTEX_NORMAL		0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTHREAD_MUTEX_ERRORCHECK	1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTHREAD_MUTEX_RECURSIVE	  2</span><br></code></pre></td></tr></table></figure>

<h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><blockquote>
<p>允许<code>**同一个线程**</code>对<code>**一把锁**</code>重复多次加锁，而不会造成死锁,<br>    - 注意，多个线程访问的话，一个线程持有之后，另一个线程访问，同样会被阻塞，休眠，直到递归锁被释放。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);<br><span class="hljs-comment">//初始化递归锁</span><br>pthread_mutex_init(&amp;_pthreadMutex, &amp;attr);<br></code></pre></td></tr></table></figure>

<h4 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 初始化条件</span><br>pthread_cond_t _cond;<br>pthread_cond_init(&amp;_cond, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//销毁</span><br>pthread_cond_destroy(&amp;_cond);<br><br><span class="hljs-comment">//执行</span><br>[[[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(__remove) object:<span class="hljs-literal">nil</span>] start];<br>[[[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(__add) object:<span class="hljs-literal">nil</span>] start];<br><span class="hljs-comment">//删除方法</span><br>- (<span class="hljs-keyword">void</span>)__remove &#123;<br>    pthread_mutex_lock(&amp;_mutex);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.data.count == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 等待，线程进行休眠，并且会释放该锁</span><br>     pthread_cond_wait(&amp;_cond, &amp;_mutex);<br>     <span class="hljs-comment">//当被signal唤醒之后，继续加锁，然后由后面unlock进行解锁</span><br>    &#125;<br>    [<span class="hljs-keyword">self</span>.data removeLastObject];<br>     pthread_mutex_unlock(&amp;_mutex); <br>&#125;<br>- (<span class="hljs-keyword">void</span>)__add &#123;<br>    <span class="hljs-comment">//添加方法</span><br>    pthread_mutex_lock(&amp;_mutex);<br>    [<span class="hljs-keyword">self</span>.data addObject:<span class="hljs-string">@&quot;Test&quot;</span>]; <br>    <span class="hljs-comment">// 信号，会唤醒一个等待的线程，让删除方法的线程继续执行</span><br>    pthread_cond_signal(&amp;_cond);<span class="hljs-comment">//放在unlock前面，则wait会先唤醒，并且再等待锁释放</span><br>    <span class="hljs-comment">// 广播，唤醒所有等待的线程</span><br>    <span class="hljs-comment">//pthread_cond_broadcast(&amp;_cond);</span><br>    pthread_mutex_unlock(&amp;_mutex);<br>    <span class="hljs-comment">//pthread_cond_signal(&amp;_cond);//放在unlock后面，则wait唤醒之后，可以立刻获取锁</span><br>&#125; <br></code></pre></td></tr></table></figure>
<h4 id="互斥锁逻辑查看"><a href="#互斥锁逻辑查看" class="headerlink" title="互斥锁逻辑查看"></a>互斥锁逻辑查看</h4><blockquote>
<p>互拆锁底层调用了<code>syscall</code>，会使当前线程休眠</p>
</blockquote>
<ul>
<li>汇编源码查看线程等待锁时，所做的事<ol>
<li>在<code>pthread_mutex_lock</code>方法中,如果可以获取到锁，则会直接retq返回，没有则会执行<code>_pthread_mutex_firstfit_lock_slow</code>方法<br> <img src="6.png"></li>
<li>在这个方法中最总会执行到<code>_pthread_mutex_firstfit_lock_wait</code>方法中<br> <img src="3.png"></li>
<li>调用<code>__psynch_mutexwait</code>方法<br><img src="4.png"></li>
<li>在该方法中，最后会走到<code>syscall</code>方法，系统调用方法，<code>si</code>执行终止，由系统调用让线程进入了休眠的状态。<br><img src="5.png"></li>
</ol>
</li>
</ul>
<h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><blockquote>
<ul>
<li><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code> ，从<code>iOS10</code>开始才支持</li>
<li>从底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等</li>
<li>系统方法底层调用的是<code>syscall</code>方法，和互斥锁一致</li>
</ul>
</blockquote>
<ul>
<li>使用教程<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;os/lock.h&gt;</span></span><br><br>os_unfair_lock _lock = OS_UNFAIR_LOCK_INIT;<br><br>os_unfair_lock_lock(&amp;_lock);<br> <span class="hljs-comment">//需要同步的代码</span><br> os_unfair_lock_unlock(&amp;_lock);<br></code></pre></td></tr></table></figure></li>
<li>汇编发现是一种互斥锁,和<code>pthread_mutex</code>一样，等待锁会走到<code>**syscall**</code>方法,系统调用使得线程进入休眠状态<br><img src="7.png"></li>
</ul>
<h3 id="NSLOCK、NSRecursiveLock"><a href="#NSLOCK、NSRecursiveLock" class="headerlink" title="NSLOCK、NSRecursiveLock"></a>NSLOCK、NSRecursiveLock</h3><blockquote>
<p><code>NSLock</code>是对<code>mutex</code>普通锁的封装<br><code>NSRecursiveLock</code>也是对<code>mutex</code>递归锁的封装，<code>API</code>跟<code>NSLock</code>基本一致</p>
</blockquote>
<ul>
<li>使用教程<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLock</span> *_lock = [[<span class="hljs-built_in">NSLock</span> alloc] init];<br><span class="hljs-comment">//NSRecursiveLock *_lock = [[NSRecursiveLock alloc] init];</span><br><span class="hljs-comment">//均实现了&lt;NSLocking&gt;协议</span><br>[_lock lock]<br><span class="hljs-comment">//[_lock tryLock]</span><br>[_lock unlock]<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><blockquote>
<p><code>NSCondition</code>是对<code>mutex</code>和<code>cond</code>的封装</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSCondition</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSLocking</span>&gt;</span><br>- (<span class="hljs-keyword">void</span>)wait<br>- (<span class="hljs-built_in">BOOL</span>)waitUntilDate:(<span class="hljs-built_in">NSDate</span> *)limit N<br>- (<span class="hljs-keyword">void</span>)signal <br>- (<span class="hljs-keyword">void</span>)broadcast;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><blockquote>
<p><code>NSConditionLock</code>是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值.</p>
<ul>
<li><code>lockWhenCondition:</code>只有满足具体条件值的才能获取到锁，<code>unlockWithCondition:</code>解锁可以重新设定(如果不传值，初始化，默认是<code>0</code>)</li>
<li><code>lock</code>和之前一样直接加锁，不会根据条件值来判断</li>
</ul>
</blockquote>
<p><img src="8.png"></p>
<h3 id="dispatch-queue-DISPATCH-QUEUE-SERIAL"><a href="#dispatch-queue-DISPATCH-QUEUE-SERIAL" class="headerlink" title="dispatch_queue(DISPATCH_QUEUE_SERIAL)"></a>dispatch_queue(DISPATCH_QUEUE_SERIAL)</h3><blockquote>
<p>直接使用<code>GCD</code>的串行队列，也是可以实现线程同步的</p>
</blockquote>
<p><img src="9.png"></p>
<h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><blockquote>
<ul>
<li><code>semaphore</code>叫做”信号量”</li>
<li>信号量的初始值，可以用来控制线程并发访问的最大数量</li>
<li>信号量的初始值为<code>1</code>，代表同时只允许<code>1</code>条线程访问资源，保证线程同步</li>
</ul>
</blockquote>
<p><img src="10.png"></p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><blockquote>
<p><code>@synchronized</code>是对<code>mutex</code>递归锁的封装,在最新版本中，锁已经改为<code>os_unfair_lock</code>了，但仍可实现递归，（<code>os_unfair_lock</code>是不支持递归的，代码做了优化，未开源）<br>源码查看：<code>objc4</code>中的<code>objc-sync.mm</code>文件<br><code>@synchronized(obj)</code>内部会生成<code>obj</code>对应的递归锁，然后进行加锁、解锁操作</p>
</blockquote>
<ul>
<li>使用<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>       <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>重要数据结构<br><img src="11.png"></li>
<li><code>723</code>以及之前的版本，用的是<code>pthread_mutex_t</code><br><img src="14.png"></li>
<li><code>723</code>之后的版本，用的是<code>os_recursive_unfair_lock</code><br><img src="12.png"></li>
<li><code>os_recursive_unfair_lock</code>结构本质上是<code>os_unfair_lock</code><br><img src="13.png"></li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>多线程的问题</title>
    <url>/2023/01/31/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>多线程原理是，操作系统通过<code>时间片轮转算法</code>，每次给一个线程一个时间片，让其可以执行,(如果所给的时间片足够短，则看起来是同时执行的)，进程也是这种方式</p>
</blockquote>
<h2 id="常见多线程方案"><a href="#常见多线程方案" class="headerlink" title="常见多线程方案"></a>常见多线程方案</h2><table>
<thead>
<tr>
<th align="center">技术方案</th>
<th align="left">简介</th>
<th align="center">语言</th>
<th align="center">线程生命周期</th>
<th align="center">使用频率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pthread</td>
<td align="left">一套通用的多线程API、适用于Unix\Linux\Windows等系统、跨平台\可移植、使用难度大</td>
<td align="center">c</td>
<td align="center">手动管理</td>
<td align="center">几乎不用</td>
</tr>
<tr>
<td align="center">NSThread</td>
<td align="left">使用更加面向对象、简单易用，可直接操作线程对象</td>
<td align="center">OC</td>
<td align="center">手动管理</td>
<td align="center">偶尔使用</td>
</tr>
<tr>
<td align="center">GCD</td>
<td align="left">旨在替代NSThread等线程技术、充分利用设备的多核</td>
<td align="center">c</td>
<td align="center">自动管理</td>
<td align="center">经常使用</td>
</tr>
<tr>
<td align="center">NSOperation</td>
<td align="left">基于GCD（底层是GCD）、比GCD多了一些更简单实用的功能、使用更加面向对象</td>
<td align="center">OC</td>
<td align="center">自动管理</td>
<td align="center">经常使用</td>
</tr>
</tbody></table>
<h2 id="常见的死锁问题"><a href="#常见的死锁问题" class="headerlink" title="常见的死锁问题"></a>常见的死锁问题</h2><ol>
<li>主队列中，用<code>dispatch_sync</code>同步在主队列中执行任务会有死锁，<ul>
<li>原因是<code>sync</code>同步执行会立刻执行<code>任务二</code>，但是在主队列中，已经添加了<code>任务三</code>，必须等<code>任务3</code>(<code>viewDidLoad</code>方法)执行完之后，才能执行<code>任务二</code>,因此造成死锁</li>
<li>改为<code>dispatch_async</code>,则不会出现死锁，会先执行<code>任务三</code>，再执行<code>任务二</code>,按主队列任务添加顺序执行<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务一&quot;</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();<br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务二&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务三&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>串行队列,和<code>1</code>相同，任务三的执行要求任务四持行完成，而<code>sync</code>要求立刻执行任务三，因此出现死锁<ul>
<li>将任务三放到另一个队列，或者采用<code>async</code>则可以避免<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务一&quot;</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;queue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务二&quot;</span>);<br>        <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务三&quot;</span>);<br>        &#125;);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务四&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务五&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果是并发队列，则不会产生死锁<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务一&quot;</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务二&quot;</span>);<br>        <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务三&quot;</span>);<br>        &#125;);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务四&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务五&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p>
</blockquote>
<h2 id="多线程的其他问题"><a href="#多线程的其他问题" class="headerlink" title="多线程的其他问题"></a>多线程的其他问题</h2><ol>
<li>下面打印结果实际为，<code>1-&gt;3</code>,其中<code>2</code>并<strong>未打印</strong><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>  [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0.0</span>];<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>&#125;);<br><br>- (<span class="hljs-keyword">void</span>)test<br>&#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>直接用<code>[self performSelector:@selector(test) withObject:nil];</code>会打印<code>1-&gt;2-&gt;3</code>,因为其源码本质是通过<code>objc_msgSend</code>调用的<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)performSelector:(SEL)sel withObject:(<span class="hljs-keyword">id</span>)obj &#123;<br>         <span class="hljs-keyword">if</span> (!sel) [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:sel];<br>      <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-keyword">id</span>))objc_msgSend)(<span class="hljs-keyword">self</span>, sel, obj);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果在主线程中调用,会打印出<code>1-&gt;3-&gt;2</code></li>
<li><strong>原因</strong>:<code>[self performSelector:@selector(test) withObject:nil afterDelay:0.0];</code>的源码是在<code>Runloop</code>相关源码中定义的，其本质是添加了一个<code>Timer</code>到<code>Runloop</code>中的。而在<code>1</code>中通过<code>dispatch_async</code>开了一个<strong>子线程</strong>(用一次就扔掉)，但是实际上，<strong>子线程</strong>是没有启动<code>runloop</code>的，因此添加到的任务是<strong>无效的</strong>，因此不会打印<ul>
<li>解决方法,增加<code>runloop</code>，再启动<code>runloop</code>后，则会打印出<code>1-&gt;3-&gt;2</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0.0</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>[[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];<br>&#125;);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>源码，<code>NSRunloop</code>不开源，但是可以通过<a href="http://www.gnustep.org/resources/downloads.php%0D">GNU</a>大致了解下源码,虽然<code>GNUstep</code>不是苹果官方源码，但还是具有一定的参考价值</li>
</ul>
<ol start="2">
<li>与<code>1</code>类似的问题,<code>waitUntilDone</code>为<code>YES</code>会崩溃，因为在当执行输出<code>1</code>后，线程已经退出了，不能在线程中执行，如果<code>waitUntilDone</code>为NO，则不会崩溃，但是不会执行<code>test</code>方法<ul>
<li>和<code>1</code>类似，要在里面启动<code>Runloop</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithBlock:^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-comment">//解决问题</span><br>    <span class="hljs-comment">//[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br>    <span class="hljs-comment">//[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br>&#125;];<br>[thread start];<br>[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>runloop的运行逻辑</title>
    <url>/2023/01/20/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop%E7%9A%84%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="运行流程分析"><a href="#运行流程分析" class="headerlink" title="运行流程分析"></a>运行流程分析</h2><p><img src="1.png"></p>
<ol>
<li>通知<code>Observers</code>：进入<code>Loop</code></li>
<li>通知<code>Observers</code>：即将处理<code>Timers</code></li>
<li>通知<code>Observers</code>：即将处理<code>Sources</code><ul>
<li><code>Observers</code>内，实际调用，<code>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</code></li>
</ul>
</li>
<li>处理<code>Blocks</code><ul>
<li>处理通过<code>CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void))</code>添加到<code>runloop</code>的<code>block</code></li>
<li>实际调用：<code>_CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</code></li>
</ul>
</li>
<li>处理<code>Source0</code>（如果返回结果是<code>true</code>，可能会再次处理<code>Blocks</code>）<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code></li>
<li>只有被<code>Signal</code>的<code>source0</code>才会去处理</li>
</ul>
</li>
<li>如果存在<code>Source1</code>，就跳转到第8步<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code></li>
</ul>
</li>
<li>通知<code>Observers</code>：开始休眠（等待消息唤醒）<ul>
<li><code>__CFRunLoopServiceMachPort</code>内，用户态会下发<code>mach_msg</code>给内核态（只有内核可以<code>真正的休眠线程</code>（而<code>非阻塞线程</code>,<code>忙等</code>），节省<code>CPU</code>），切换到内核态，当内核收到消息后，再唤醒线程，节省<code>CPU</code>资源<br><img src="2.png"></li>
</ul>
</li>
<li>通知<code>Observers</code>：结束休眠（被下面某个消息唤醒）<ol>
<li>处理<code>Timer</code><ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</code></li>
</ul>
</li>
<li>处理<code>GCD Async To Main Queue</code>,<code>GCD</code>异步回到主队列的任务<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>，注意只有通过<code>dispatch_async(dispatch_get_main_queue(),block);</code>，<code>GCD</code>异步回到主队列，才会有<code>runloop</code>的协助</li>
</ul>
</li>
<li>处理<code>Source1</code><ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code></li>
</ul>
</li>
</ol>
</li>
<li>处理<code>Blocks</code></li>
<li>根据前面的执行结果，决定如何操作<ol>
<li>回到第<code>02</code>步</li>
<li>退出<code>Loop</code></li>
</ol>
</li>
<li>通知<code>Observers：</code>退出<code>Loop</code></li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="CFRunLoopRunSpecific"><a href="#CFRunLoopRunSpecific" class="headerlink" title="CFRunLoopRunSpecific"></a><code>CFRunLoopRunSpecific</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">SInt32 <span class="hljs-title">CFRunLoopRunSpecific</span><span class="hljs-params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="hljs-comment">/* DOES CALLOUT */</span><br>    CHECK_FOR_FORK();<br>    <span class="hljs-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="hljs-keyword">return</span> kCFRunLoopRunFinished;<br>    __CFRunLoopLock(rl);<br>    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;<br>	Boolean did = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);<br>	__CFRunLoopUnlock(rl);<br>	<span class="hljs-keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;<br>    &#125;<br>    <span class="hljs-comment">// 1.这里会记录下当前mode的状态运行状态</span><br>    <span class="hljs-keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);<br>    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;<br>    rl-&gt;_currentMode = currentMode;<br>    <span class="hljs-keyword">int32_t</span> result = kCFRunLoopRunFinished;<br>    <span class="hljs-comment">// 2. CFRunLoopRunSpecific会保持前一次mode的状态属性（stopped和currentMode）然后发出即将要进入新的mode通知</span><br>	<span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);<br>	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);<br>	<span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);<br>    <span class="hljs-comment">// 3 . __CFRunLoopRun(__CFRunLoopRun会创建一个循环)，然后这个mode运行结束后再发已退出mode通知。再恢复前一次的stopped和currentMode</span><br>        __CFRunLoopModeUnlock(currentMode);<br>    <span class="hljs-comment">// 4 .这里会恢复之前记录mode的状态</span><br>        __CFRunLoopPopPerRunData(rl, previousPerRun);<br>	rl-&gt;_currentMode = previousMode;<br>    __CFRunLoopUnlock(rl);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>分析<ol>
<li>首先<code>Runloop</code>进入的是<code>kCFRunLoopDefaultMode</code> 会无限执行</li>
<li><code>CFRunLoopRunSpecific</code>会保持前一次<code>mode</code>的状态属性,并且会记录下当前<code>mode</code>的运行状态 </li>
<li>然后发出即将要进入新的<code>mode</code>通知，然后进入<code>__CFRunLoopRun</code>(<code>__CFRunLoopRun</code>会创建一个循环)</li>
<li>这个<code>mode</code>运行结束后再发已退出<code>mode</code>通知,再恢复前一次的<code>currentmode</code>,和2中记录的运行状态</li>
</ol>
</li>
<li>如果<code>CFRunLoopRunSpecific</code>被调用多次会怎么样？ <ul>
<li>因为函数调用时栈，前一次<code>mode</code>信息都是被记录在栈<code>stack</code>中，新的<code>Mode</code>开启新的<code>__CFRunLoopRun</code>(<code>do-while</code>)事件处理循环。但是所有<code>Runloop</code>的第一个<code>mode</code>，都是<code>kCFRunLoopDefaultMode</code></li>
</ul>
</li>
</ul>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="CFRunLoopRun"></a><code>CFRunLoopRun</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;<br>    <span class="hljs-comment">//获取系统启动后的CPU运行时间，用于控制超时时间</span><br>    <span class="hljs-keyword">uint64_t</span> startTSR = mach_absolute_time();<br><br>    <span class="hljs-comment">//1. 判断runloop和runloopmode是否是已经结束，如果已经结束就直接返回</span><br>    <span class="hljs-keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;<br>        __CFRunLoopUnsetStopped(rl);<br>	<span class="hljs-keyword">return</span> kCFRunLoopRunStopped;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rlm-&gt;_stopped) &#123;<br>	rlm-&gt;_stopped = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">return</span> kCFRunLoopRunStopped;<br>    &#125;<br>    <br>    <span class="hljs-comment">//2. 如果当前runloop是主线程runloop就获取dispatchPort ，dispatchPort 用来接收主队列的任务和事件</span><br>    <span class="hljs-keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;<br>    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="hljs-literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="hljs-number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));<br>    <span class="hljs-comment">////如果在主线程 &amp;&amp; runloop是主线程的runloop &amp;&amp; 该mode是commonMode，则给mach端口赋值为主线程收发消息的端口</span><br>    <span class="hljs-keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();<br>    <br>    <span class="hljs-keyword">mach_port_name_t</span> modeQueuePort = MACH_PORT_NULL;<br>    <span class="hljs-keyword">if</span> (rlm-&gt;_queue) &#123;<br>        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);<br>        <span class="hljs-keyword">if</span> (!modeQueuePort) &#123;<br>            CRASH(<span class="hljs-string">&quot;Unable to get port for run loop mode queue (%d)&quot;</span>, <span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//3. 根据seconds参数，设置一个GCD定时器</span><br>    <span class="hljs-keyword">dispatch_source_t</span> timeout_timer = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">timeout_context</span> *<span class="hljs-title">timeout_context</span> =</span> (struct __timeout_context *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*timeout_context));<br>    <span class="hljs-comment">//立即超时</span><br>    <span class="hljs-keyword">if</span> (seconds &lt;= <span class="hljs-number">0.0</span>) &#123; <span class="hljs-comment">// instant timeout</span><br>        seconds = <span class="hljs-number">0.0</span>;<br>        timeout_context-&gt;termTSR = <span class="hljs-number">0ULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;<br>        <span class="hljs-comment">//seconds为超时时间，超时时执行__CFRunLoopTimeout函数</span><br>	<span class="hljs-keyword">dispatch_queue_t</span> <span class="hljs-built_in">queue</span> = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();<br>	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">queue</span>);<br>        dispatch_retain(timeout_timer);<br>	timeout_context-&gt;ds = timeout_timer;<br>	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);<br>	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);<br>	dispatch_set_context(timeout_timer, timeout_context); <span class="hljs-comment">// source gets ownership of context</span><br>    <span class="hljs-comment">// 4. 超时后执行__CFRunLoopTimeout</span><br>	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);<br>    <span class="hljs-comment">// 5. __CFRunLoopTimeoutCancel释放runloop内存和定时器相关的环境内存</span><br>    dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);<br>    <span class="hljs-keyword">uint64_t</span> ns_at = (<span class="hljs-keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="hljs-number">1000000000ULL</span>);<br>    dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="hljs-number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="hljs-number">1000ULL</span>);<br>    dispatch_resume(timeout_timer);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// infinite timeout</span><br>        <span class="hljs-comment">//永不超时</span><br>        seconds = <span class="hljs-number">9999999999.0</span>;<br>        timeout_context-&gt;termTSR = UINT64_MAX;<br>    &#125;<br>    <span class="hljs-comment">//上一次是否是dispatch，默认为true</span><br>    Boolean didDispatchPortLastTime = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//记录最后runloop的状态</span><br>    <span class="hljs-keyword">int32_t</span> retVal = <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">// 6.进入do-while循环</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;<br>        <span class="hljs-keyword">voucher_t</span> voucherCopy = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">//初始化一个存放内核消息的缓冲池</span><br>        <span class="hljs-keyword">uint8_t</span> msg_buffer[<span class="hljs-number">3</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">mach_msg_header_t</span> *msg = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">mach_port_t</span> livePort = MACH_PORT_NULL;<br><br>        <span class="hljs-comment">//取所有需要监听的port</span><br>	__CFPortSet waitSet = rlm-&gt;_portSet;<br>        <span class="hljs-comment">// 设置Runloop为可以被唤醒状态</span><br>        __CFRunLoopUnsetIgnoreWakeUps(rl);<br><br>         <span class="hljs-comment">// 7.条件判断是否有定时器和source的相关观察，发出定时器执行之前相关的观察者事件和发出source执行之前相关的观察者事件</span><br>        <span class="hljs-keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);<br>        <span class="hljs-keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);<br>         <span class="hljs-comment">// 8, 执行Runloop的Block任务</span><br>	__CFRunLoopDoBlocks(rl, rlm);<br>         <span class="hljs-comment">//9. 处理suoce0，并且返回sourceHandledThisLoop</span><br>        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);<br>         <span class="hljs-comment">// 10, 再次执行Runloop的Block任务</span><br>        <span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>            __CFRunLoopDoBlocks(rl, rlm);<br>	     &#125;<br>         <br>         <span class="hljs-comment">// 11. 是否处理了source0，或者没有设置超时</span><br>        Boolean poll = sourceHandledThisLoop || (<span class="hljs-number">0ULL</span> == timeout_context-&gt;termTSR);<br><br>         <span class="hljs-comment">// 12. 如果当前是主线程，并且didDispatchPortLastTime为false，则会去看</span><br>         <span class="hljs-comment">//是否存在端口间的通信，source1，结束后就会标记didDispatchPortLastTime=false,</span><br>         <span class="hljs-comment">//默认是true，如果上次循环是处理GCD会设置为true</span><br>        <span class="hljs-keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;<br>            msg = (<span class="hljs-keyword">mach_msg_header_t</span> *)msg_buffer;<br>            <span class="hljs-comment">// 12 。如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br>            <span class="hljs-comment">//超时时间是0.因此实际不会休眠线程，是直接从缓冲区读取消息的，因为是主线程端口，一般是source1</span><br>            <span class="hljs-keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="hljs-number">0</span>, &amp;voucherState, <span class="hljs-literal">NULL</span>)) &#123;<br>                <br>               <span class="hljs-comment">// 如果有触发消息直接去处理消息</span><br>                <span class="hljs-keyword">goto</span> handle_msg;<br>            &#125;<br>        &#125;<br><br>        didDispatchPortLastTime = <span class="hljs-literal">false</span>;<br><br>         <span class="hljs-comment">// 13. 没有处理事件或者超时，则会通知线程即将进入休眠</span><br>	<span class="hljs-keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);<br>         <span class="hljs-comment">// 14. 标记runloop的属性为睡眠标记，设置runloop为可以唤醒</span><br>	__CFRunLoopSetSleeping(rl);<br>	<span class="hljs-comment">// do not do any user callouts after this point (after notifying of sleeping)</span><br><br>        <span class="hljs-comment">// Must push the local-to-this-activation ports in on every loop</span><br>        <span class="hljs-comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span><br>        <span class="hljs-comment">// want these ports to get serviced.</span><br>         <span class="hljs-comment">//15. 把dispatchPort添加到waitPort，解锁runloop和runloop mode</span><br>        __CFPortSetInsert(dispatchPort, waitSet);<br>        <br>	__CFRunLoopModeUnlock(rlm);<br>	__CFRunLoopUnlock(rl);<br>        <span class="hljs-comment">//睡眠开始的时间</span><br>        CFAbsoluteTime sleepStart = poll ? <span class="hljs-number">0.0</span> : CFAbsoluteTimeGetCurrent();<br>         <span class="hljs-comment">// 16. 进入_CFRunLoopServiceMachPort，会进入内核的等待mach_msg，并且while循环等待正确的唤醒</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (kCFUseCollectableAllocator) &#123;<br>                <span class="hljs-comment">// objc_clear_stack(0);</span><br>                <span class="hljs-comment">// &lt;rdar://problem/16393959&gt;</span><br>                <span class="hljs-built_in">memset</span>(msg_buffer, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(msg_buffer));<br>            &#125;<br>            msg = (<span class="hljs-keyword">mach_msg_header_t</span> *)msg_buffer;<br>            <br>            <span class="hljs-comment">//等待唤醒,livePort接收是哪个端口唤醒的</span><br>            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="hljs-number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);<br>            <br>            <span class="hljs-keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;<br>                <span class="hljs-comment">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span><br>                <span class="hljs-keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));<br>                <span class="hljs-keyword">if</span> (rlm-&gt;_timerFired) &#123;<br>                    <span class="hljs-comment">// Leave livePort as the queue port, and service timers below</span><br>                    rlm-&gt;_timerFired = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (msg &amp;&amp; msg != (<span class="hljs-keyword">mach_msg_header_t</span> *)msg_buffer) <span class="hljs-built_in">free</span>(msg);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Go ahead and leave the inner loop.</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>        <br>        <br>         <span class="hljs-comment">// 18. 对Runloop和runloop mode进行加锁，抢夺Runloop的资源运行，保证唯一操作</span><br>        __CFRunLoopLock(rl);<br>        __CFRunLoopModeLock(rlm);<br><br>        rl-&gt;_sleepTime += (poll ? <span class="hljs-number">0.0</span> : (CFAbsoluteTimeGetCurrent() - sleepStart));<br><br>        <span class="hljs-comment">// Must remove the local-to-this-activation ports in on every loop</span><br>        <span class="hljs-comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span><br>        <span class="hljs-comment">// want these ports to get serviced. Also, we don&#x27;t want them left</span><br>        <span class="hljs-comment">// in there if this function returns.</span><br>    <br>         <span class="hljs-comment">// 19. 把dispatchPort从waitPort移除，这里dispatchPort（主线的dispatchPort不在原有mode中的，是临时添加的）</span><br>        __CFPortSetRemove(dispatchPort, waitSet);<br>        <br>        __CFRunLoopSetIgnoreWakeUps(rl);<br><br>        <span class="hljs-comment">// user callouts now OK again</span><br>	__CFRunLoopUnsetSleeping(rl);<br>        <span class="hljs-comment">// 20, 如果没有处理事件或者超时，则会通知结束休眠</span><br>	<span class="hljs-keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);<br><br>        handle_msg:;<br>        __CFRunLoopSetIgnoreWakeUps(rl);<br><br>        <span class="hljs-comment">// 21. 获取livePort，消息事件来源</span><br>        <span class="hljs-keyword">if</span> (MACH_PORT_NULL == livePort) &#123;<br>            CFRUNLOOP_WAKEUP_FOR_NOTHING();<br>            <span class="hljs-comment">// handle nothing</span><br>            <span class="hljs-comment">// 22.唤醒操作，什么也不做</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;<br>            CFRUNLOOP_WAKEUP_FOR_WAKEUP();<br>            <span class="hljs-comment">// do nothing on Mac OS</span><br>            <span class="hljs-comment">// 22.唤醒操作，什么也不做</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;<br>            CFRUNLOOP_WAKEUP_FOR_TIMER();<br>            <span class="hljs-comment">//23. 处理定时任务，启动下一个定时器任务</span><br>            <span class="hljs-keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;<br>                <span class="hljs-comment">// Re-arm the next timer, because we apparently fired early</span><br>                __CFArmNextTimerInMode(rlm, rl);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (livePort == dispatchPort) &#123;<br>            CFRUNLOOP_WAKEUP_FOR_DISPATCH();<br>            <span class="hljs-comment">// 24. 处理GCD的时间，并设置didDispatchPortLastTime = true;也就是下一个循环的时候，</span><br>            <span class="hljs-comment">//不会去判断source1,这是为了保证dispatch中加入的block能及时执行</span><br>            __CFRunLoopModeUnlock(rlm);<br>            __CFRunLoopUnlock(rl);<br>            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="hljs-keyword">void</span> *)<span class="hljs-number">6</span>, <span class="hljs-literal">NULL</span>);<br>            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);<br>            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="hljs-keyword">void</span> *)<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>            __CFRunLoopLock(rl);<br>            __CFRunLoopModeLock(rlm);<br>            sourceHandledThisLoop = <span class="hljs-literal">true</span>;<br>            didDispatchPortLastTime = <span class="hljs-literal">true</span>;<br>            <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            CFRUNLOOP_WAKEUP_FOR_SOURCE();<br>            <span class="hljs-comment">// If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. </span><br>            <span class="hljs-comment">//CFMachPortBoost will look in the TSD for the voucher. </span><br>            <span class="hljs-comment">//By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance </span><br>            <span class="hljs-comment">//for anything in between the two pieces of code to set the voucher again.</span><br>            <span class="hljs-keyword">voucher_t</span> previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (<span class="hljs-keyword">void</span> *)voucherCopy, os_release);<br><br>            <span class="hljs-comment">// Despite the name, this works for windows handles as well</span><br>            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);<br>            <span class="hljs-keyword">if</span> (rls) &#123;<br>                <span class="hljs-comment">// 25处理Source1：如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br>		<span class="hljs-keyword">mach_msg_header_t</span> *reply = <span class="hljs-literal">NULL</span>;<br>		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != reply) &#123;<br>		    (<span class="hljs-keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="hljs-number">0</span>, MACH_PORT_NULL, <span class="hljs-number">0</span>, MACH_PORT_NULL);<br>		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);<br>		&#125;<br>	    &#125;<br>            <br>            <span class="hljs-comment">// Restore the previous voucher</span><br>            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span> (msg &amp;&amp; msg != (<span class="hljs-keyword">mach_msg_header_t</span> *)msg_buffer) <span class="hljs-built_in">free</span>(msg);<br>        <br>        <span class="hljs-comment">//26. 最后处理一次blocks</span><br>	__CFRunLoopDoBlocks(rl, rlm);<br>        <br>        <span class="hljs-comment">//27. 根据前面的处理结果，决定流程</span><br>	<span class="hljs-keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;<br>        <span class="hljs-comment">//stopAfterHandle为true，并且当前runloop处理了事件sourceHandledThisLoop，处理了source0或者GCD</span><br>	    retVal = kCFRunLoopRunHandledSource;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;<br>        <span class="hljs-comment">//超出传入参数标记的超时时间了</span><br>        retVal = kCFRunLoopRunTimedOut;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;<br>            __CFRunLoopUnsetStopped(rl);<br>        <span class="hljs-comment">// 当前RunLoop已经被外部调用者强制停止了</span><br>	    retVal = kCFRunLoopRunStopped;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rlm-&gt;_stopped) &#123;<br>        <span class="hljs-comment">//  当前运行模式已经被停止</span><br>	    rlm-&gt;_stopped = <span class="hljs-literal">false</span>;<br>	    retVal = kCFRunLoopRunStopped;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;<br>        <span class="hljs-comment">// source/timer/observer一个都没有了</span><br>	    retVal = kCFRunLoopRunFinished;<br>	&#125;<br>        <br>    voucher_mach_msg_revert(voucherState);<br>    os_release(voucherCopy);<br>        <span class="hljs-comment">// 如果没超时，mode里不为空也没停止，loop也没被停止，那继续loop。</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> == retVal);<br><br>    <span class="hljs-keyword">if</span> (timeout_timer) &#123;<br>        dispatch_source_cancel(timeout_timer);<br>        dispatch_release(timeout_timer);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">free</span>(timeout_context);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>分析<ol>
<li>判断<code>runloop</code>和<code>runloopmode</code>是否是已经结束，如果已经结束就直接返回<ul>
<li>这是线程安全的设计，<code>CFRunLoopRef</code>中存在各种加锁解锁的操作，它提供了纯 C 函数的 <code>API</code>，这些 <code>API</code> 都是<strong>线程安全</strong>的。</li>
<li>而<code>NSRunLoop</code>是基于 <code>CFRunLoopRef</code> 的封装，提供了面向对象的 <code>API</code>，这些 <code>API</code> 不是<strong>线程安全</strong>的</li>
</ul>
</li>
<li>如果当前<code>runloop</code>是主线程<code>runloop</code>就获取<code>dispatchPort</code> ，<code>dispatchPort</code> 用来接收主队列的任务和事件</li>
<li>根据<code>seconds</code>参数，设置一个<code>GCD</code>定时器<ol>
<li>定时器超时后执行<code>__CFRunLoopTimeout</code>,执行<code>__CFRunLoopTimeout</code>设置超时<code>context-&gt;termTSR = 0LL</code>，并且唤醒<code>Runloop</code>。 <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __CFRunLoopTimeout(<span class="hljs-keyword">void</span> *arg) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">timeout_context</span> *<span class="hljs-title">context</span> =</span> (struct __timeout_context *)arg;<br>    context-&gt;termTSR = <span class="hljs-number">0ULL</span>;<br>    CFRUNLOOP_WAKEUP_FOR_TIMEOUT();<br>    CFRunLoopWakeUp(context-&gt;rl);<br>    <span class="hljs-comment">// The interval is DISPATCH_TIME_FOREVER, so this won&#x27;t fire again</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>__CFRunLoopTimeoutCancel</code>释放<code>runloop</code>内存和定时器相关的环境内存 <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __CFRunLoopTimeoutCancel(<span class="hljs-keyword">void</span> *arg) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">timeout_context</span> *<span class="hljs-title">context</span> =</span> (struct __timeout_context *)arg;<br>    CFRelease(context-&gt;rl);<br>    dispatch_release(context-&gt;ds);<br>    <span class="hljs-built_in">free</span>(context);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>进入<code>do-while</code>的<code>Runloop</code>循环</li>
<li>条件判断是否有<code>定时器</code>和<code>source</code>的相关观察，发出定时器执行之前相关的观察者事件和发出<code>source</code>执行之前</li>
<li>执行<code>Runloop</code>的<code>Block</code>任务</li>
<li>处理<code>suoce0</code>，并且返回<code>sourceHandledThisLoop</code><ol>
<li>在每一次<code>Do-while</code>结束后，会判断是否是处理<code>stopAfterHandle</code>是否为<code>true</code>，然后结合<code>sourceHandledThisLoop</code>来退出<code>Runloop</code>，目的是为了处理单次的事件后就退出.<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">    <span class="hljs-keyword">static</span> Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) &#123;<br>        ....<br>        CFRunLoopSourceRef rls = (CFRunLoopSourceRef)sources;<br> __CFRunLoopSourceLock(rls);<br>        <span class="hljs-keyword">if</span> (__CFRunLoopSourceIsSignaled(rls)) &#123;<br>     __CFRunLoopSourceUnsetSignaled(rls);<br>     <span class="hljs-keyword">if</span> (__CFIsValid(rls)) &#123;<br>         __CFRunLoopSourceUnlock(rls);<br>                __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);<br>         CHECK_FOR_FORK();<br>         sourceHandled = <span class="hljs-literal">true</span>;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         __CFRunLoopSourceUnlock(rls);<br>     &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            __CFRunLoopSourceUnlock(rls);<br>        &#125;<br>        ....<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>source0</code>被<code>Signale</code>，并且<strong>有效</strong>才会去处理。在<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>函数中去处理<code>source0</code>，实际去执行<code>rls-&gt;_context.version0.perform</code>中的方法。并执行完后将<code>sourceHandled</code>设置为<code>true</code></li>
</ol>
</li>
<li>再次执行<code>Runloop</code>的<code>Block</code>任务,可能会有新的<code>block</code>在执行<code>source0</code>的时候被添加了</li>
<li><code>poll</code>表明是否处理了<code>source0</code>，或者没有设置超时</li>
<li>如果当前是主线程，并且<code>didDispatchPortLastTime</code>为<code>false</code>，则会去看是否存在端口间的通信<code>source1</code>，结束后就会标记<code>didDispatchPortLastTime=false</code>,默认是<code>true</code>，如果上次循环是处理<code>GCD</code>会设置为<code>true</code><ul>
<li>如果有 <code>Source1</code> (基于<code>port</code>) 处于 <code>ready</code> 状态，直接处理这个 <code>Source1</code> 然后跳转去处理消息。（主线程基于端口的通信，一般是<code>source1</code>）</li>
<li><code>__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL))</code>,超时时间是<code>0</code>，而非<code>INFINITY</code>永远，因此认为是从缓存中取，已经<code>ready</code> 状态的</li>
<li><strong>注意</strong>上次循环是处理<code>GCD</code>会<code>didDispatchPortLastTime</code>设置为<code>true</code>,这是为了保证加入到主线程的<code>GCD</code>任务，能及时处理。因此下次循环，先不查询<code>source1</code></li>
</ul>
</li>
<li><strong>没有处理事件source0或者超时</strong>，则会通知线程即将进入休眠，即上面<code>9</code>的<code>poll</code>为<code>false</code></li>
<li>标记<code>runloop</code>为睡眠标记，设置<code>runloop</code>为可以唤醒。把<code>dispatchPort</code>添加到<code>waitPort</code>，解锁<code>runloop</code>和<code>runloop mode</code></li>
<li>进入<code>_CFRunLoopServiceMachPort</code>，会进入内核的等待<code>mach_msg</code>，并且<code>while</code>循环等待正确的唤醒。<code>livePort</code>接收是哪个端口唤醒的<ul>
<li>注意如果<code>poll</code>为<code>true</code>,表明之前处理了<code>source0</code>，或者没有设置超时。则超时时间是<code>0</code>,只会快速从缓存中查询后，进入下一次循环</li>
<li>如果<code>poll</code>为<code>false</code>,则超时时间为<code>INFINITY</code>，等待唤醒</li>
</ul>
</li>
<li>对<code>Runloop</code>和<code>runloop mode</code>进行加锁，抢夺<code>Runloop</code>的资源运行，保证唯一操作</li>
<li>把<code>dispatchPort</code>从<code>waitPort</code>移除，这里<code>dispatchPort</code>（主线的<code>dispatchPort</code>不在原有<code>mode</code>中的，是临时添加的）</li>
<li><strong>没有处理事件source0或者超时</strong>，则会通知线程结束入休眠，即上面<code>9</code>的<code>poll</code>为<code>false</code></li>
<li>获取<code>livePort</code>，判断消息来源消息事件来源<ol>
<li><code>liveport</code>是空或者是<code>rl-&gt;wakeUpPort</code>，那么就什么都不做，这是<strong>唤醒操作</strong>。跳过<code>livePort</code>的判断逻辑</li>
<li><code>livePort</code>是<code>rlm-&gt;timerPort</code>,那么就执行<code>Timer</code>的事件处理，<code>modeQueuePort</code>定时器相关的端口，并启动下一个定时器任务</li>
<li><code>livePort</code>是<code>dispatchPort</code>，那么就解锁<code>Runloop</code>和<code>RunloopMode</code>，然后处理<code>dispatch_main_queue_callback_4CF</code>的<code>GCD</code>调度任务，完成后加锁<code>Runloop</code>和<code>RunloopMode</code>。<ul>
<li>处理<code>GCD</code>的时，并设置<code>didDispatchPortLastTime = true</code>;也就是下一个循环的时候，不会去判断<code>source1</code>,这是为了保证加到主线程的<code>GCD</code>能及时执行</li>
</ul>
</li>
<li>其他情况，处理<code>Source1</code>：如果一个 <code>Source1</code> (基于<code>port</code>) 发出事件了，处理这个事件</li>
</ol>
</li>
<li>最后再直接处理<code>_CFRunLoopDoBlocks</code>，再重新进入<code>do-while</code>循环处理<code>Timer</code>和<code>source0</code>的观察者逻辑等</li>
<li>最后根据前面的处理结果，决定下一次的流程<ol>
<li><code>stopAfterHandle</code>为<code>true</code>，并且当前<code>runloop</code>处理了事件<code>sourceHandledThisLoop</code>，处理了<code>source0</code>或者<code>GCD</code></li>
<li>超出传入参数标记的超时时间了</li>
<li>当前<code>RunLoop</code>已经被外部调用者强制停止了</li>
<li>当前运行模式已经被停止</li>
<li><code>source</code>/<code>timer</code>/<code>observer</code>一个都没有了</li>
</ol>
</li>
<li>如果没超时，<code>mode</code>里不为空也没停止，<code>loop</code>也没被停止，那继续<code>loop</code>。</li>
</ol>
</li>
</ul>
<h2 id="runloop执行方法需要注意的地方"><a href="#runloop执行方法需要注意的地方" class="headerlink" title="runloop执行方法需要注意的地方"></a>runloop执行方法需要注意的地方</h2><ol>
<li><code>- (void)run</code><ul>
<li><code>[[NSRunloop currentRunloop] run]</code>实际上是在一个<code>while(1)</code>中重复调用<code>-(BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate</code>方法,因此通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>只能取消一次<code>runMode:(NSRunLoopMode)mode beforeDate:</code>的调用，</li>
<li>但是在<code>run</code>方法中，还是会循环调用，是无法取消<code>run</code>方法的循环调用的</li>
</ul>
</li>
<li><code>-(BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate</code><ul>
<li> 注意，该方法，在执行完一次runloop的循环之后，则会退出，例如执行一次<code>performSelector:</code>方法便会释放</li>
</ul>
</li>
<li><strong>注意</strong>,在启动<code>runloop</code>后，要注意<code>_strong typeof(weakSelf) strongSelf = weakSelf</code>的写法。<ul>
<li>例如通过<code>initWithBlock:</code>设置线程,在回调中启动<code>runloop</code>。如果再回调中存在这种写法，则在<code>runloop</code>运行期间，一直会有一个局部强引用持有<code>self</code>，除非将当前的<code>runloop</code>结束</li>
</ul>
</li>
<li><strong>注意</strong>,通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>停止<code>runloop</code>之后。<ul>
<li>不要再使用，<code>performSelector:onThread:withObject:waitUntilDone:</code>在线程中执行。因为线程和<code>runloop</code>的生命周期是一一对应的。</li>
<li>在<code>waitUntilDone</code>为<code>true</code>,不异步执行时，会出现野指针的错误，为<code>false</code>时，异步时可能内部做了处理，不会出现野指针的问题</li>
</ul>
</li>
<li><code>CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</code>,<code>returnAfterSourceHandled</code>为<code>true</code>代表执行完<code>source</code>之后，就退出<code>runloop</code>，类似<code>2</code>中的用法,设置为<code>false</code>则，执行一次<code>source</code>后，是不会退出的。<ul>
<li>和<code>1</code>中不同可以通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>取消当前循环的<code>runloop</code></li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>runloop</code>是怎么响应用户操作的，具体流程是什么样的？<ul>
<li>由<code>source1</code>将系统事件捕获，（例如点击屏幕的事件），<code>source1</code>将事件包装成<code>EventQueue</code>，放到<code>source0</code>中处理</li>
</ul>
</li>
<li><code>NSDefaultRunLoopMode</code>、<code>UITrackingRunLoopMode</code>才是真正存在的模式<code>NSRunLoopCommonModes</code>并不是一个真的模式，它只是一个标记</li>
</ol>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>runloop相关的类</title>
    <url>/2023/01/12/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="runloop的结构"><a href="#runloop的结构" class="headerlink" title="runloop的结构"></a>runloop的结构</h2><blockquote>
<ul>
<li><code>Core Foundation</code>中关于<code>RunLoop</code>的5个类<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="CFRunLoop"><a href="#CFRunLoop" class="headerlink" title="__CFRunLoop"></a>__CFRunLoop</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> __CFRunLoop &#123;<br>    <span class="hljs-built_in">CFRuntimeBase</span> _base;<br>    pthread_mutex_t _lock;			<span class="hljs-comment">/* locked for accessing mode list */</span><br>    __CFPort _wakeUpPort;			<span class="hljs-comment">// 通过该函数CFRunLoopWakeUp内核向该端口发送消息可以唤醒runloop</span><br>    Boolean _unused;<br>    <span class="hljs-keyword">volatile</span> _per_run_data *_perRunData;              <span class="hljs-comment">// reset for runs of the run loop</span><br>    pthread_t _pthread; <span class="hljs-comment">//RunLoop相对应地线程</span><br>    uint32_t _winthread;<br>    <span class="hljs-built_in">CFMutableSetRef</span> _commonModes; <span class="hljs-comment">// 存储的是字符串，记录所有标记为common的mode</span><br>    <span class="hljs-built_in">CFMutableSetRef</span> _commonModeItems; <span class="hljs-comment">// 存储所有commonMode的item(source、timer、observer)</span><br>    <span class="hljs-built_in">CFRunLoopModeRef</span> _currentMode; <span class="hljs-comment">//当前运行的mode</span><br>    <span class="hljs-built_in">CFMutableSetRef</span> _modes; <span class="hljs-comment">// 存储的是CFRunLoopModeRef</span><br>    <span class="hljs-keyword">struct</span> _block_item *_blocks_head; <span class="hljs-comment">// do blocks的时候用到</span><br>    <span class="hljs-keyword">struct</span> _block_item *_blocks_tail;<br>    <span class="hljs-built_in">CFAbsoluteTime</span> _runTime;<br>    <span class="hljs-built_in">CFAbsoluteTime</span> _sleepTime;<br>    <span class="hljs-built_in">CFTypeRef</span> _counterpart;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>简化版<br><img src="1.png"></li>
</ul>
<h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> __CFRunLoopMode *<span class="hljs-built_in">CFRunLoopModeRef</span>;<br><br><span class="hljs-keyword">struct</span> __CFRunLoopMode &#123;<br>    <span class="hljs-built_in">CFRuntimeBase</span> _base;<br>    pthread_mutex_t _lock;	<span class="hljs-comment">/* must have the run loop locked before locking this */</span><br>    <span class="hljs-built_in">CFStringRef</span> _name; <span class="hljs-comment">// mode名称，运行模式是通过名称来识别的</span><br>    Boolean _stopped; <span class="hljs-comment">// mode是否被终止</span><br>    <span class="hljs-keyword">char</span> _padding[<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">CFMutableSetRef</span> _sources0; <br>    <span class="hljs-built_in">CFMutableSetRef</span> _sources1;<br>    <span class="hljs-built_in">CFMutableArrayRef</span> _observers;<br>    <span class="hljs-built_in">CFMutableArrayRef</span> _timers;<br>    <span class="hljs-built_in">CFMutableDictionaryRef</span> _portToV1SourceMap;<br>    __CFPortSet _portSet; <span class="hljs-comment">// 保存所有需要监听的port，比如_wakeUpPort，_timerPort都保存在这个数组中</span><br>    <span class="hljs-built_in">CFIndex</span> _observerMask;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span><br>    dispatch_source_t _timerSource;<br>    <span class="hljs-built_in">dispatch_queue_t</span> _queue;<br>    Boolean _timerFired; <span class="hljs-comment">// set to true by the source when a timer has fired</span><br>    Boolean _dispatchTimerArmed;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_MK_TIMER_TOO</span><br>    mach_port_t _timerPort;<br>    Boolean _mkTimerArmed;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span><br>    DWORD _msgQMask;<br>    <span class="hljs-keyword">void</span> (*_msgPump)(<span class="hljs-keyword">void</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    uint64_t _timerSoftDeadline; <span class="hljs-comment">/* TSR */</span><br>    uint64_t _timerHardDeadline; <span class="hljs-comment">/* TSR */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>简化版<br><img src="2.png"></li>
</ul>
<h4 id="一些常见的Mode"><a href="#一些常见的Mode" class="headerlink" title="一些常见的Mode"></a>一些常见的Mode</h4><ol>
<li><code>kCFRunLoopDefaultMode</code>: <code>App</code>的默认 <code>Mode</code>，通常主线程是在这个 <code>Mode</code> 下运行的。</li>
<li><code>UITrackingRunLoopMode</code>: 界面跟踪 <code>Mode</code>，用于 <code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他 <code>Mode</code> 影响。</li>
<li><code>UIInitializationRunLoopMode</code>: 在刚启动 <code>App</code> 时进入的第一个 <code>Mode</code>，启动完成后就不再使用。</li>
<li><code>GSEventReceiveRunLoopMode</code>: 接受系统事件的内部 <code>Mode</code>，通常用不到。</li>
<li><code>kCFRunLoopCommonModes</code>: 这是一个占位的 <code>Mode</code>，没有实际作用</li>
</ol>
<h4 id="切换mode逻辑"><a href="#切换mode逻辑" class="headerlink" title="切换mode逻辑"></a>切换mode逻辑</h4><ul>
<li><code>CFRunLoopRunSpecific</code>是启动<code>Runloop</code>和指定<code>Runloop</code>在那个<code>mode</code>下执行的。 </li>
<li>这个函数一般是操作系统进行<code>mode</code>的切换。比如滑动的时候，<code>Runloop</code>会进入<code>UITrackingRunLoopMode</code>,而<code>app</code>启动的时候<code>UIInitializationRunLoopMode</code>。</li>
<li>每一个<code>mode</code>处理完成后，如果<code>runloop</code>没有退出，就会返回之前的<code>mode</code>，初始<code>mode</code>是<code>default</code>。<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3></li>
<li>一个<code>runLoop</code>中有很多模式，存在<code>modes</code>中，但是每次只会选择一种模式,作为当前模式<br><img src="3.png"></li>
<li><code>CFRunLoopModeRef</code>代表<code>RunLoop</code>的运行模式<ul>
<li>一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code></li>
<li><code>RunLoop</code>启动时只能选择其中一个<code>Mode</code>，作为<code>currentMode</code></li>
<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li>
<li>不同组的<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code>能分隔开来，互不影响</li>
<li>如果<code>Mode</code>里没有任何<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code>，<code>RunLoop</code>会立马退出</li>
</ul>
</li>
</ul>
<h2 id="CFRunLoopModeRef-1"><a href="#CFRunLoopModeRef-1" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h2><h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopSource</span> * <span class="hljs-title">CFRunLoopSourceRef</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopSource</span> &#123;</span><br>    CFRuntimeBase _base;<br>    <span class="hljs-keyword">uint32_t</span> _bits;<br>    <span class="hljs-keyword">pthread_mutex_t</span> _lock;<br>    CFIndex _order;<span class="hljs-comment">//执行顺序</span><br>    CFMutableBagRef _runLoops;<span class="hljs-comment">//包含多个RunLoop</span><br>  	<span class="hljs-comment">//版本</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        CFRunLoopSourceContext version0;	<span class="hljs-comment">/* immutable, except invalidation */</span><br>        CFRunLoopSourceContext1 version1;	<span class="hljs-comment">/* immutable, except invalidation */</span><br>    &#125; _context;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>存在两个版本<ul>
<li><code>Source0</code> 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal (source)</code>，将这个 <code>Source</code> 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp (runloop)</code> 来唤醒 <code>RunLoop</code>，让其处理这个事件。  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    CFIndex	version;<br>    <span class="hljs-keyword">void</span> *	info;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *(*retain)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">void</span>	(*release)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    CFStringRef	(*copyDescription)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    Boolean	(*equal)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info2);<br>    CFHashCode	(*hash)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">void</span>	(*schedule)(<span class="hljs-keyword">void</span> *info, CFRunLoopRef rl, CFRunLoopMode mode);<br>    <span class="hljs-keyword">void</span>	(*cancel)(<span class="hljs-keyword">void</span> *info, CFRunLoopRef rl, CFRunLoopMode mode);<br>    <span class="hljs-keyword">void</span>	(*perform)(<span class="hljs-keyword">void</span> *info);<br>&#125; CFRunLoopSourceContext;<br></code></pre></td></tr></table></figure></li>
<li><code>Source1</code>包含了一个 <code>mach_port</code> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种<code>Source</code> 能主动唤醒<code> RunLoop</code> 的线程  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    CFIndex	version;<br>    <span class="hljs-keyword">void</span> *	info;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *(*retain)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">void</span>	(*release)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    CFStringRef	(*copyDescription)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    Boolean	(*equal)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info2);<br>    CFHashCode	(*hash)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">mach_port_t</span>	(*getPort)(<span class="hljs-keyword">void</span> *info);<br>    <span class="hljs-keyword">void</span> *	(*perform)(<span class="hljs-keyword">void</span> *msg, CFIndex size, CFAllocatorRef allocator, <span class="hljs-keyword">void</span> *info);<br> &#125; CFRunLoopSourceContext1;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a><code>Timers</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopTimer</span> &#123;</span><br>    CFRuntimeBase _base;<br>    <span class="hljs-keyword">uint16_t</span> _bits;<br>    <span class="hljs-keyword">pthread_mutex_t</span> _lock;<br>    CFRunLoopRef _runLoop;<br>    CFMutableSetRef _rlModes;<br>    CFAbsoluteTime _nextFireDate;<br>    CFTimeInterval _interval;		<span class="hljs-comment">/* immutable */</span><br>    CFTimeInterval _tolerance;          <span class="hljs-comment">/* mutable */</span><br>    <span class="hljs-keyword">uint64_t</span> _fireTSR;			<span class="hljs-comment">/* TSR units */</span><br>    CFIndex _order;			<span class="hljs-comment">/* immutable */</span><br>    CFRunLoopTimerCallBack _callout;	<span class="hljs-comment">/* immutable */</span><br>    CFRunLoopTimerContext _context;	<span class="hljs-comment">/* immutable, except invalidation */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>CFRunLoopTimerRef</code> 是基于时间的触发器，它和 <code>NSTimer</code> 是 <code>toll-free bridged</code> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 <code>RunLoop</code> 时，<code>RunLoop</code> 会注册对应的时间点，当时间点到时，<code>RunLoop</code> 会被唤醒以执行那个回调。</li>
<li><code>NSTimer</code>,新建定时器，需要添加到<code>runloop</code>才会执行</li>
<li><code>performSelector:withObject:afterDelay:</code>,<strong>本质</strong>会加到<code>runloop</code>的<code>timer</code></li>
</ul>
<h3 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a><code>Observers</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopObserver</span> &#123;</span><br>    CFRuntimeBase _base;<br>    <span class="hljs-keyword">pthread_mutex_t</span> _lock;<br>    CFRunLoopRef _runLoop; <span class="hljs-comment">//监听的RunLoop</span><br>    CFIndex _rlCount; <span class="hljs-comment">// 添加该Observer的RunLoop对象个数</span><br>    CFOptionFlags _activities;		<span class="hljs-comment">/* immutable */</span><br>    CFIndex _order;			<span class="hljs-comment">//同时间最多只能监听一个</span><br>    CFRunLoopObserverCallBack _callout; <span class="hljs-comment">// 监听的回调	/* immutable */</span><br>    CFRunLoopObserverContext _context; <span class="hljs-comment">// 上下文用于内存管理	/* immutable, except invalidation */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>用于监听<code>RunLoop</code>的状态</li>
<li><code>UI</code>刷新（<code>BeforeWaiting</code>）,在<strong>线程休眠之前</strong>，设置<code>UI</code></li>
<li><code>Autorelease pool</code>（<code>BeforeWaiting</code>）,在<strong>休眠之前</strong>释放自动释放池对象，<strong>唤醒后</strong>新建新的自动释放池</li>
</ul>
<h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><ul>
<li><code>RunLoop</code>的状态改变流程<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Run Loop Observer Activities */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">CF_OPTIONS</span>(<span class="hljs-built_in">CFOptionFlags</span>, <span class="hljs-built_in">CFRunLoopActivity</span>) &#123;<br>    kCFRunLoopEntry = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">0</span>),<br>    kCFRunLoopBeforeTimers = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">1</span>),<br>    kCFRunLoopBeforeSources = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">2</span>),<br>    kCFRunLoopBeforeWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">5</span>),<br>    kCFRunLoopAfterWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">6</span>),<br>    kCFRunLoopExit = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">7</span>),<br>    kCFRunLoopAllActivities = <span class="hljs-number">0x0FFFFFFF</span>U<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>监听<code>RunLoop的</code>状态<ul>
<li>切换<code>mode</code>之后，会先<code>kCFRunLoopExit - kCFRunLoopDefaultMode</code>，之后再<code>kCFRunLoopEntry - UITrackingRunLoopMode</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">CFRunLoopObserverRef</span> observer = <span class="hljs-built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="hljs-literal">YES</span>, <span class="hljs-number">0</span>, ^(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity) &#123;<br>    <span class="hljs-keyword">switch</span> (activity) &#123;<br>       <span class="hljs-keyword">case</span> kCFRunLoopEntry:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopEntry&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopBeforeTimers:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopBeforeSources:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeSources&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopBeforeWaiting:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopAfterWaiting:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> kCFRunLoopExit:<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopExit&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 添加Observer到RunLoop中</span><br><span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);<br>    <span class="hljs-comment">// 释放</span><br><span class="hljs-built_in">CFRelease</span>(observer);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="RunLoop的内部逻辑"><a href="#RunLoop的内部逻辑" class="headerlink" title="RunLoop的内部逻辑"></a>RunLoop的内部逻辑</h3><ul>
<li>运行逻辑<br><img src="5.png"><h4 id="来源按同步异步分类"><a href="#来源按同步异步分类" class="headerlink" title="来源按同步异步分类"></a>来源按同步异步分类</h4></li>
<li><code>Input sources</code>,输入源传递异步事件，通常消息来自于其他线程或程序，按照是否来源于内核也分为下面几种：<ul>
<li><code>Port-Based Sources</code>，基于<code>Port</code> 的 事件，系统底层的，一般由内核自动发出信号。例如 <code>CFSocketRef</code> ，在应用层基本用不到。</li>
<li><code>Custom Input Sources</code>，非基于 <code>Port</code> 事件，用户手动创建的 <code>Source</code>，则必须从其他线程手动发送信号。</li>
<li><code>Cocoa Perform Selector Sources</code>， <code>Cocoa</code> 提供的 <code>performSelector</code> 系列方法，也是一种事件源。和基于端口的源一样，执行 <code>selector</code> 请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题。不像基于端口的源，一个 <code>selector</code> 执行完后会自动从 <code>Run Loop</code> 里面<strong>移除</strong>。</li>
</ul>
</li>
<li><code>Timer sources</code>,定时源则传递同步事件，发生在特定时间或者重复的时间间隔。<ul>
<li>定时器可以产生基于时间的通知，但它并不是<code>实时机制</code>。和输入源一样，定时器也和你的 <code>Run Loop</code> 的特定模式相关。如果定时器所在的模式当前未被 <code>Run Loop</code> 监视，那么定时器将不会开始直到 <code>Run Loop</code> 运行在相应的模式下。</li>
<li>主要有<code>NSTimer</code>和<code>performSelector:withObject:afterDelay:</code></li>
</ul>
</li>
</ul>
<h4 id="来源按对象分类"><a href="#来源按对象分类" class="headerlink" title="来源按对象分类"></a>来源按对象分类</h4><ul>
<li><p><code>Source1</code>,对应于 <code>Port-Based Sources</code>，即基于 <code>Port</code> 的，通过内核和其他线程通信。</p>
<ul>
<li>常用于接收、分发系统事件，大部分屏幕交互事件都是由 <code>Source1</code> 接收，包装成 <code>Event</code>，然后分发下去，最后由 <code>Source0</code> 去处理。</li>
<li>包括:<ul>
<li>基于<code>Port</code>的线程间通信,</li>
<li>系统事件捕捉，例如，屏幕点击，最开始是<code>source1</code>,传给具体的应用，后面会分发包装成<code>source0</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Source0</code>,是非 <code>Port</code> 事件。在应用中，触摸事件的最终处理，以及 <code>perforSelector:onThread</code> 都是包装成该类型对象，最后由开发者指定回调函数，手动处理该事件。</p>
<ul>
<li><p>需要注意的是 <code>perforSelector:onThread</code> 是否有 <code>delay</code>，即是否延迟函数或者定时函数等类型。</p>
<ul>
<li><p><code>perforSelector:onThread</code> 不是 <code>delay</code> 函数时， 是 <code>Source0</code> 事件。</p>
</li>
<li><p><code>performSelector:withObject:afterDelay</code> 有 <code>delay</code> 时，则属于 <code>Timers </code>事件。</p>
</li>
</ul>
</li>
<li><p>包括:</p>
<ul>
<li>触摸事件处理<br><img src="4.png"></li>
</ul>
</li>
<li><p><code>performSelector:onThread:</code>,线程之间的通信</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>runloop</title>
    <url>/2023/01/10/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h2><ul>
<li>顾名思义<ul>
<li>运行循环</li>
<li>在程序运行过程中循环做一些事情</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理<code>App</code>中的各种事件（比如触摸事件、定时器事件等）</li>
<li>节省<code>CPU</code>资源，提高程序性能：该做事时做事，该休息时休息</li>
</ul>
</li>
<li>应用范畴<ul>
<li>定时器（<code>Timer</code>）、<code>PerformSelector</code></li>
<li><code>GCD Async Main Queue</code></li>
<li>事件响应、手势识别、界面刷新</li>
<li>网络请求</li>
<li><code>AutoreleasePool</code></li>
</ul>
</li>
<li><code>RunLoop</code>与线程<ul>
<li>每条线程都有唯一的一个与之对应的<code>RunLoop</code>对象<ul>
<li><code>CFRunLoopGetCurrent()</code>和<code>[NSRunLoop currentRunLoop]</code>,在当前线程中获取<code>runloop</code></li>
<li>从字典中获取，如果没有的话，则会创建，并存放在字典中，<code>key</code>是线程的指针地址<br><img src="1.png"></li>
</ul>
</li>
<li><code>RunLoop</code>保存在一个全局的<code>Dictionary</code>里，线程作为<code>key</code>，<code>RunLoop</code>作为<code>value</code></li>
<li>线程刚创建时并没有<code>RunLoop</code>对象，<code>RunLoop</code>会在<strong>第一次</strong>获取它时创建</li>
<li><code>RunLoop</code>会在线程结束时销毁</li>
<li>主线程的<code>RunLoop</code>已经自动获取（创建），子线程默认没有开启<code>RunLoop</code>,需要手动开启</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>中间代码（IR）</title>
    <url>/2023/01/09/iOS%E5%AD%A6%E4%B9%A0/Runtime/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><code>Objective-C</code>在变为机器代码之前，会被<code>LLVM</code>编译器转换为中间代码（<code>Intermediate Representation</code>）,<code>ir</code>中间代码代码相比于转成<code>C++</code>更接近底层（但是肯定无法和汇编相比）</p>
</blockquote>
<ul>
<li>可以使用以下命令行指令生成中间代码<ul>
<li><code>clang -emit-llvm -S main.m</code></li>
</ul>
</li>
<li>语法简介<ul>
<li><code>@</code> - 全局变量</li>
<li><code>%</code> - 局部变量</li>
<li><code>alloca</code> - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存</li>
<li><code>i32</code> - <code>32</code>位<code>4</code>字节的整数</li>
<li><code>align</code> - 对齐</li>
<li><code>load</code> - 读出，<code>store</code> 写入</li>
<li><code>icmp</code> - 两个整数值比较，返回布尔值</li>
<li><code>br</code> - 选择分支，根据条件来转向<code>label</code>，不根据条件跳转的话类似 <code>goto</code></li>
<li><code>label</code> - 代码标签</li>
<li><code>call</code> - 调用函数</li>
</ul>
</li>
<li>示例<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">main.m<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> c = a + b;<br>test(c);<br><span class="hljs-comment">//转成main.ll</span><br>  store i32 <span class="hljs-number">10</span>, i32* %<span class="hljs-number">8</span>, align <span class="hljs-number">4</span>  <span class="hljs-comment">//将10存储到局部变量 %8</span><br>  store i32 <span class="hljs-number">20</span>, i32* %<span class="hljs-number">9</span>, align <span class="hljs-number">4</span>  <span class="hljs-comment">//将20存储到局部变量 %9</span><br>  %<span class="hljs-number">19</span> = load i32, i32* %<span class="hljs-number">8</span>, align <span class="hljs-number">4</span> <span class="hljs-comment">//将%8加载到%19</span><br>  %<span class="hljs-number">20</span> = load i32, i32* %<span class="hljs-number">9</span>, align <span class="hljs-number">4</span> <span class="hljs-comment">//将%9加载到%20</span><br>  %<span class="hljs-number">21</span> = add nsw i32 %<span class="hljs-number">19</span>, %<span class="hljs-number">20</span>    <span class="hljs-comment">// %19和%20的值相加</span><br>  store i32 %<span class="hljs-number">21</span>, i32* %<span class="hljs-number">10</span>, align <span class="hljs-number">4</span> <span class="hljs-comment">//将%21的值存储到%10</span><br>  %<span class="hljs-number">22</span> = load i32, i32* %<span class="hljs-number">10</span>, align <span class="hljs-number">4</span>  <span class="hljs-comment">//将 %10的值加载到%22</span><br>  call <span class="hljs-keyword">void</span> @test(i32 %<span class="hljs-number">22</span>) <span class="hljs-comment">//调用函数，参数是 %22</span><br></code></pre></td></tr></table></figure></li>
<li><a href="https://llvm.org/docs/LangRef.html">具体文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>runtime特殊问题</title>
    <url>/2023/01/08/iOS%E5%AD%A6%E4%B9%A0/Runtime/runtime%E7%89%B9%E6%AE%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span>:<span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSString</span> *name;<br>- (<span class="hljs-keyword">void</span>)print;<br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br>- (<span class="hljs-keyword">void</span>)print<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;my name is %@&quot;</span>, <span class="hljs-keyword">self</span>-&gt;_name);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//ViewController中</span><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-comment">//NSString *test = @&quot;123&quot;;如果，前面有这个text对象，则实际会输出my name is 123</span><br>    <span class="hljs-keyword">id</span> cls = [Person <span class="hljs-keyword">class</span>];<br><br>    <span class="hljs-keyword">void</span> *obj = &amp;cls;<br><br>    [(__bridge <span class="hljs-keyword">id</span>)obj print];<br>    <span class="hljs-comment">//实际输出my name is &lt;ViewController: 0x104b08020&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="print为什么能够调用成功？"><a href="#print为什么能够调用成功？" class="headerlink" title="print为什么能够调用成功？"></a><code>print</code>为什么能够调用成功？</h3><ul>
<li>示意图<br><img src="1.jpg"></li>
<li>将<code>[Person class]</code>的类对象<code>cls</code>的地址赋值给<code>obj</code>之后，在<code>obj</code>地址上的<code>前8个字节</code>的东西是<code>cls</code>的类对象的地址。这和正常实例化后的对象<code>person</code>一样，<code>person</code>所指向的地址在内存上前<code>8</code>个字节的地址是<code>isa</code>(类对象的地址)</li>
<li>在调用<code>print</code>方法的时候，就会去<code>obj</code>内存的前<code>8</code>个字节，取出该内存上的对象（正常结构体，则是其内存上前<code>8</code>个字节的<code>isa</code>指针），刚好是类对象，因此最终和调用实例对象方法一样可以调用成功。</li>
<li>在<code>(__bridge id)</code>的时候，实际上将<code>objc</code>指针，转换成了<code>objc_object</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_object &#123;<br>    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_object *<span class="hljs-keyword">id</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="为什么self-name变成了ViewController等其他内容"><a href="#为什么self-name变成了ViewController等其他内容" class="headerlink" title="为什么self.name变成了ViewController等其他内容"></a>为什么<code>self.name</code>变成了<code>ViewController</code>等其他内容</h3><ul>
<li>栈上分配的临时对象的地址，是由<code>高</code>向<code>低</code>进行分配的,下面字符串的指针均指向常量区，其指针均相同，但是，栈给对象分配的指针地址，是不同的  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 0x0000000100998070 @&quot;123&quot;</span><br><span class="hljs-built_in">NSString</span> *test = <span class="hljs-string">@&quot;123&quot;</span>; <span class="hljs-comment">//&amp;test 0x000000016f46cc20</span><br><span class="hljs-built_in">NSString</span> *test1 = <span class="hljs-string">@&quot;123&quot;</span>; <span class="hljs-comment">// &amp;test1 0x000000016f46cc18</span><br><span class="hljs-built_in">NSString</span> *test2 = <span class="hljs-string">@&quot;123&quot;</span>; <span class="hljs-comment">// &amp;test2 0x000000016f46cc10</span><br></code></pre></td></tr></table></figure></li>
<li>实际分配的示意图<br><img src="2.jpg"></li>
<li><code>Person</code>结构体的类型<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> MJPerson_IMPL<br> &#123;<br>    Class isa;<br>     <span class="hljs-built_in">NSString</span> *_name;<br> &#125;;<br></code></pre></td></tr></table></figure></li>
<li><code>NSLog(@&quot;my name is %@&quot;, self-&gt;_name);</code>调用该方法的本质，实际<code>person</code>的前8个字节是<code>cls</code>,而在<code>isa上加8个字节</code>后去取<code>_name</code>变量(结构体越往后面的<strong>地址会越高</strong>)，则根据分配的原则，会取到<code>test</code>,因此加<code>test</code>后，则会输出<code>my name is 123</code></li>
<li>不加局部对象，则会输出<code>my name is &lt;ViewController: 0x104b08020&gt;</code>,是由于<code>[super viewDidLoad]</code>造成的，因此在没有<code>test</code>局部变量后，实际上<code>isa上加8个字节</code>后，取到的是<code>self</code>的地址。最终则会输出<code>my name is &lt;ViewController: 0x104b08020&gt;</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> <span class="hljs-comment">//[super viewDidLoad] ,源码实际</span><br> <span class="hljs-keyword">struct</span> abc = &#123;<br>       <span class="hljs-keyword">self</span>,<br>       [ViewController <span class="hljs-keyword">class</span>]<br>   &#125;;<br><span class="hljs-comment">//注意这里调用的是objc_msgSendSuper2，并非objc_msgSendSuper(这个要传入父类对象)</span><br>objc_msgSendSuper2(abc, sel_registerName(<span class="hljs-string">&quot;viewDidLoad&quot;</span>));<br><span class="hljs-comment">//因此会隐式的生成abc结构体变量，其低地址是self，高地址是[ViewController class]</span><br></code></pre></td></tr></table></figure></li>
<li><strong>注意</strong>，如果将<code>[super viewDidLoad]</code>屏蔽，则由于<code>isa地址加8字节后</code>，找不到任何东西，则会出现<strong>野指针的错误</strong></li>
<li><code>objc_msgSendSuper2</code>可以通过调试发现,<code>(x/4g</code>,打出$1地址上每8个字节存的东西，打印4个),通过调试发现，后续的内存中,第一个是<code>self</code>，第二个是<code>[ViewController class]</code>，而<strong>非父类</strong>。<ul>
<li>但实际在源码中，<code>objc_msgSendSuper2</code>最终还是会去父类去调用</li>
<li><code>lldb</code>调试<br><img src="3.png"></li>
<li>源码中，还是会去父类去调用<br><img src="4.png"></li>
<li>实际调试代码，确定是用<code>objc_msgSendSuper2</code><br><img src="5.png"></li>
</ul>
</li>
</ul>
<h2 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h2><blockquote>
<p><code>&lt;objc/runtime.h&gt;</code>的<code>APi</code></p>
</blockquote>
<h3 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h3><ul>
<li><code>Class object_getClass(id obj)</code><ul>
<li>获取<code>isa</code>指向的<code>Class</code></li>
</ul>
</li>
<li><code>Class object_setClass(id obj, Class cls)</code><ul>
<li>设置<code>isa</code>指向的<code>Class</code>,<strong>可以更改当前对象指向的<code>isa</code></strong></li>
</ul>
</li>
<li><code>BOOL object_isClass(id obj)</code><ul>
<li>判断一个<code>OC</code>对象是否为<code>Class</code></li>
</ul>
</li>
<li><code>BOOL class_isMetaClass(Class cls)</code><ul>
<li>判断一个<code>Class</code>是否为元类</li>
</ul>
</li>
<li><code>Class class_getSuperclass(Class cls)</code><ul>
<li>获取父类</li>
</ul>
</li>
</ul>
<h3 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h3><ul>
<li><code>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</code><ul>
<li>动态创建一个类（参数：父类，类名，额外的内存空间）</li>
</ul>
</li>
<li><code>void objc_registerClassPair(Class cls)</code><ul>
<li>注册一个类（要在类注册之前添加成员变量），在你需要动态创建的类中，加入方法，协议，成员变量后，再去注册</li>
<li>注意，类注册完之后，类的成员变量会在<code>class_ro_t</code>中是不可变的，而方法，协议是在<code>class_rw_t</code>中，任何时候都是可以添加的</li>
</ul>
</li>
</ul>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li><code>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</code><ul>
<li>动态添加成员变量（<strong>已经注册的类是不能动态添加成员变量的</strong>）</li>
<li>例如<code>class_addIvar(newCls, &quot;_age&quot;, 4, 1, @encode(int));</code>添加一个<code>age</code>的成员变量,设置和取值，可以通过<code>kvc</code>实现<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[dog setValue:@<span class="hljs-number">10</span> forKey:<span class="hljs-string">@&quot;_age&quot;</span>];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code><ul>
<li>动态添加属性</li>
</ul>
</li>
<li><code>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code><ul>
<li>动态替换属性</li>
</ul>
</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code><ul>
<li>动态添加方法</li>
</ul>
</li>
<li><code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code><ul>
<li>动态替换方法</li>
</ul>
</li>
</ul>
<h3 id="成员变量相关"><a href="#成员变量相关" class="headerlink" title="成员变量相关"></a>成员变量相关</h3><ul>
<li><p><code>Ivar class_getInstanceVariable(Class cls, const char *name)</code></p>
<ul>
<li>获取一个实例变量信息</li>
<li>获取成员变量的相关信息<ul>
<li><code>const char *ivar_getName(Ivar v)</code></li>
<li><code>const char *ivar_getTypeEncoding(Ivar v)</code></li>
</ul>
</li>
<li>设置和获取成员变量的值<ul>
<li><code>void object_setIvar(id obj, Ivar ivar, id value)</code><ul>
<li>如果设置基本变量,<code>object_setIvar(person, weightVar, (__bridge id)(void *)20)</code>将基本类型转成对象</li>
</ul>
</li>
<li><code>id object_getIvar(id obj, Ivar ivar)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code></p>
<ul>
<li>拷贝实例变量列表（最后需要调用<code>free</code>释放）</li>
</ul>
</li>
</ul>
<h3 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h3><ul>
<li><code>objc_property_t class_getProperty(Class cls, const char *name)</code><ul>
<li>获取一个属性</li>
<li>获取属性的一些信息<ul>
<li><code>const char *property_getName(objc_property_t property)</code></li>
<li><code>const char *property_getAttributes(objc_property_t property)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code><ul>
<li>拷贝属性列表（最后需要调用<code>free</code>释放）</li>
</ul>
</li>
</ul>
<h3 id="方法相关"><a href="#方法相关" class="headerlink" title="方法相关"></a>方法相关</h3><ul>
<li>获得一个实例方法、类方法<ul>
<li><code>Method class_getInstanceMethod(Class cls, SEL name)</code></li>
<li><code>Method class_getClassMethod(Class cls, SEL name)</code></li>
<li>获取方法的相关信息（带有<code>copy</code>的需要调用<code>free</code>去释放）<ul>
<li><code>SEL method_getName(Method m)</code></li>
<li><code>IMP method_getImplementation(Method m)</code></li>
<li><code>const char *method_getTypeEncoding(Method m)</code></li>
<li><code>unsigned int method_getNumberOfArguments(Method m)</code></li>
<li><code>char *method_copyReturnType(Method m)</code></li>
<li><code>char *method_copyArgumentType(Method m, unsigned int index)</code></li>
</ul>
</li>
</ul>
</li>
<li>方法实现相关操作<ul>
<li><code>IMP class_getMethodImplementation(Class cls, SEL name) </code></li>
<li><code>IMP method_setImplementation(Method m, IMP imp)</code></li>
<li><code>void method_exchangeImplementations(Method m1, Method m2) </code><ul>
<li>源码<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> method_exchangeImplementations(Method m1Signed, Method m2Signed)<br>&#123;<br> <span class="hljs-keyword">if</span> (!m1Signed  ||  !m2Signed) <span class="hljs-keyword">return</span>;<br><br>method_t *m1 = _method_auth(m1Signed);<br> method_t *m2 = _method_auth(m2Signed);<br><br>mutex_locker_t lock(runtimeLock);<br><br><span class="hljs-comment">//进行imp的交换</span><br>IMP imp1 = m1-&gt;imp(<span class="hljs-literal">false</span>);<br>IMP imp2 = m2-&gt;imp(<span class="hljs-literal">false</span>);<br>SEL sel1 = m1-&gt;name();<br>SEL sel2 = m2-&gt;name();<br><br>m1-&gt;setImp(imp2);<br>m2-&gt;setImp(imp1);<br><br><br><span class="hljs-comment">// RR/AWZ updates are slow because class is unknown</span><br><span class="hljs-comment">// Cache updates are slow because class is unknown</span><br><span class="hljs-comment">// fixme build list of classes whose Methods are known externally?</span><br><span class="hljs-comment">//这里会清除方法内的所有缓存</span><br>flushCaches(<span class="hljs-literal">nil</span>, __func__, [sel1, sel2, imp1, imp2](Class c)&#123;<br>  <span class="hljs-keyword">return</span> c-&gt;cache.shouldFlush(sel1, imp1) || c-         &gt;cache.shouldFlush(sel2, imp2);<br>&#125;);<br><br>adjustCustomFlagsForMethodChange(<span class="hljs-literal">nil</span>, m1);<br>adjustCustomFlagsForMethodChange(<span class="hljs-literal">nil</span>, m2);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>拷贝方法列表（最后需要调用<code>free</code>释放）</li>
<li><code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code></li>
<li>选择器相关<ul>
<li><code>const char *sel_getName(SEL sel)</code></li>
<li><code>SEL sel_registerName(const char *str)</code></li>
</ul>
</li>
<li>用block作为方法实现<ul>
<li><code>IMP imp_implementationWithBlock(id block)</code></li>
<li><code>id imp_getBlock(IMP anImp)</code></li>
<li><code>BOOL imp_removeBlock(IMP anImp)</code></li>
</ul>
</li>
</ul>
<h4 id="一些获取方法特殊的地方"><a href="#一些获取方法特殊的地方" class="headerlink" title="一些获取方法特殊的地方"></a>一些获取方法特殊的地方</h4><ul>
<li><code>class_getInstanceMethod</code>,去类对象中查找方法列表</li>
<li><code>class_getClassMethod</code>,注意，其底层还是调用<code>class_getInstanceMethod</code>,（<code>class_ro_t</code>只有方法列表，没有类方法和实例方法的区别，区别在于是存在类对象，还是元类中）<ul>
<li>如果当前调用的是元类，则元类去调用<code>class_getInstanceMethod</code></li>
<li>如果当前调用的是类对象，则从类对象获取元类后，去调用<code>class_getInstanceMethod</code></li>
</ul>
</li>
<li><code>class_getMethodImplementation</code>,该方法永远会返回<code>IMP</code>,和前两个会返回<code>nil</code>不同，如果当前接收者，没有实现该方法，则会返回<code>_objc_msgForward</code>,即消息转发的<code>IMP</code>,因此永远有值</li>
</ul>
<h4 id="方法交换需要注意的地方"><a href="#方法交换需要注意的地方" class="headerlink" title="方法交换需要注意的地方"></a>方法交换需要注意的地方</h4><blockquote>
<p>交换方法，一般认为交换的方法<code>toMethod</code>，是一定存在的</p>
</blockquote>
<ol>
<li>一般交换方法,交换两个方法的<code>Imp</code></li>
<li>交换自己没有实现的方法:<ul>
<li>给自己添加要交换的方法；</li>
<li>然后再将父类的<code>Imp</code>给要交换的方法</li>
</ul>
</li>
<li>交换父类和子类均未实现的方法<ul>
<li>给自己添加要交换的方法；</li>
<li>给交换的方法增加一个空的实现<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Method fromMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, fromSelector);<br>Method toMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, toSelector);<br><span class="hljs-comment">//3. 交换父类和子类均未实现的方法</span><br><span class="hljs-keyword">if</span> (!fromMethod) &#123;<br>        class_addMethod(<span class="hljs-keyword">class</span>, <br>        fromSelector, <br>        method_getImplementation(toMethod), <br>        method_getTypeEncoding(toMethod));<br>        method_setImplementation(toMethod, <br>        imp_implementationWithBlock(^(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>,SEL _cmd) &#123; &#125;));<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(class_addMethod(<span class="hljs-keyword">class</span>, <br>fromSelector, <br>method_getImplementation(toMethod), <br>method_getTypeEncoding(toMethod))) &#123;<br><span class="hljs-comment">//2. 交换自己没有实现的方法 </span><br>class_replaceMethod(<span class="hljs-keyword">class</span>, <br>toSelector, <br>method_getImplementation(fromMethod), <br>method_getTypeEncoding(fromMethod));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//1. 一般交换方法</span><br>    method_exchangeImplementations(fromMethod, toMethod);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="runtime面试题"><a href="#runtime面试题" class="headerlink" title="runtime面试题"></a>runtime面试题</h3><ol>
<li>什么是<code>Runtime</code><ul>
<li><code>OC</code>是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行<code>OC</code>的动态性就是由<code>Runtime</code>来支撑和实现的，<code>Runtime</code>是一套<code>C语言的API</code>，封装了很多动态性相关的函数平时编写的<code>OC</code>代码，底层都是转换成了<code>Runtime API</code>进行调用</li>
</ul>
</li>
<li>具体应用<ol>
<li>利用关联对象(<code>AssociatedObject</code>)给分类添加属性</li>
<li>遍历类的所有成员变量（利用<code>kvc</code>修改私有属性，字典转模型，自动归档接档）</li>
<li>交换方法实现（交换系统的方法）</li>
<li>利用消息转发机制解决方法找不到的异常问题，(重写<code>forwardInvocation:</code>实现)</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>isKindofClass和isMemberofClass</title>
    <url>/2023/01/08/iOS%E5%AD%A6%E4%B9%A0/Runtime/isKindofclass%E5%92%8CisMemberofClass/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li><code>isKindofClass</code>是判断是否是当前类,或者其子类</li>
<li><code>isMemberOfClass</code>是否是当前类</li>
</ul>
</blockquote>
<span id="more"></span>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//判断是否是元类成员</span><br>+ (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br>    <span class="hljs-comment">//取出元类</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>-&gt;ISA() == cls;<br>&#125;<br><br>- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] == cls;<br>&#125;<br><br><span class="hljs-comment">//判断元类</span><br><span class="hljs-comment">// [LGPerson isKindOfClass:object_getClass([LGPerson class])] 返回true</span><br>+ (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br>    <span class="hljs-comment">//取出元类，取出元类</span><br>    <span class="hljs-keyword">for</span> (Class tcls = <span class="hljs-keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;getSuperclass()) &#123;<br>        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><br><span class="hljs-comment">// [[LGPerson new] isKindOfClass:[LGPerson class]] 返回true</span><br>- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">for</span> (Class tcls = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;<br>        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span>:<span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student</span>:<span class="hljs-title">Person</span></span><br><span class="hljs-keyword">@end</span><br>[Student isKindofClass:[Person <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//false,类对象是元类的类型（isa指向），并不是类的类型</span><br>[Student isKindofClass:object_class([Person <span class="hljs-keyword">class</span>])] <span class="hljs-comment">// true,类对象是元类(类的类)的类型</span><br>[[Student new] isKindofClass:[Person <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//true，实例对象的父类是，Person</span><br><span class="hljs-comment">//不管方法调用者，不管是实例对象还是类对象，都是返回true，（只要是NSObject体系下的）</span><br>[Student isKindofClass:[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//true，基元类的父类是NSObject，所以是成立的</span><br><br>[Person isMemberOfClass:[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//false，是直接判断isa指针的</span><br>[Person isMemberOfClass:object_class([Sturdent <span class="hljs-keyword">class</span>])] <span class="hljs-comment">//false</span><br>[Person isMemberOfClass:object_class([Person <span class="hljs-keyword">class</span>])] <span class="hljs-comment">//true</span><br>[[Person new] isMemberOfClass:[Person <span class="hljs-keyword">class</span>]] <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>super容易混淆的问题</title>
    <url>/2023/01/06/iOS%E5%AD%A6%E4%B9%A0/Runtime/super/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>关于super的,一些容易混淆问题的记录</p>
</blockquote>
<hr>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><ul>
<li>方法中子类调用<code>[super class]</code>实际输出还是子类的对象，这和一般语言中的有所不同<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student</span>:<span class="hljs-title">Person</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Student</span></span><br>- (<span class="hljs-keyword">instancetype</span>)init<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[self class] = %@&quot;</span>, [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]); <span class="hljs-comment">// Student</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[self superclass] = %@&quot;</span>, [<span class="hljs-keyword">self</span> superclass]); <span class="hljs-comment">// Person</span><br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[super class] = %@&quot;</span>, [<span class="hljs-keyword">super</span> <span class="hljs-keyword">class</span>]); <span class="hljs-comment">// 实际输出 Student</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[super superclass] = %@&quot;</span>, [<span class="hljs-keyword">super</span> superclass]); <span class="hljs-comment">// MJPerson</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="原因解答"><a href="#原因解答" class="headerlink" title="原因解答"></a>原因解答</h3><h4 id="实际调用super的方法"><a href="#实际调用super的方法" class="headerlink" title="实际调用super的方法"></a>实际调用<code>super</code>的方法</h4><pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param super A pointer to an \c objc_super data structure. Pass values identifying the</span><br><span class="hljs-comment"> *  context the message was sent to, including the instance of the class that is to receive the</span><br><span class="hljs-comment"> *  message and the superclass at which to start searching for the method implementation.</span><br><span class="hljs-comment"> * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.</span><br><span class="hljs-comment"> * @param ...</span><br><span class="hljs-comment"> *   A variable argument list containing the arguments to the method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return The return value of the method identified by \e op.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @see objc_msgSend</span><br><span class="hljs-comment"> */</span><br>objc_msgSendSuper(<span class="hljs-keyword">struct</span> objc_super * _Nonnull <span class="hljs-keyword">super</span>, SEL _Nonnull op, ...)<br></code></pre></td></tr></table></figure>
</code></pre>
<h4 id="objc-super的结构体"><a href="#objc-super的结构体" class="headerlink" title="objc_super的结构体"></a><code>objc_super</code>的结构体</h4><pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_super &#123;<br><span class="hljs-comment">/// Specifies an instance of a class.</span><br>__<span class="hljs-keyword">unsafe_unretained</span> _Nonnull <span class="hljs-keyword">id</span> receiver;<br><br><span class="hljs-comment">/// Specifies the particular superclass of the instance to message. </span><br>__<span class="hljs-keyword">unsafe_unretained</span> _Nonnull Class super_class;<br><br><span class="hljs-comment">/* super_class is the first class to search */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</code></pre>
<h4 id="编译后的代码"><a href="#编译后的代码" class="headerlink" title="编译后的代码"></a>编译后的代码</h4><pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">objc_msgSendSuper(<br>(__rw_objc_super)&#123;(<span class="hljs-keyword">id</span>)<span class="hljs-keyword">self</span>, <br>(<span class="hljs-keyword">id</span>)class_getSuperclass(objc_getClass(<span class="hljs-string">&quot;Student&quot;</span>))&#125;,<br> sel_registerName(<span class="hljs-string">&quot;class&quot;</span>)));<br></code></pre></td></tr></table></figure>
</code></pre>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>由编译后的代码可知<code>objc_super</code>结构中的<code>receiver</code>,仍然是<code>self</code>。表明消息接收者仍然是<code>self</code></p>
</li>
<li><p>对<code>super</code>发消息的本质有</p>
<ol>
<li><strong>消息接收者仍然是<code>super</code>的子类对象</strong></li>
<li>其消息的查找是从<strong>父类开始查找方法的实现</strong></li>
</ol>
</li>
<li><p>本问题中,<code>- (Class)class</code>方法是在<code>NSObject</code>上实现的，因此不管是<code>[self class]</code>从当前类开始查找,还是<code>[super class]</code>从父类开始查找方法，实际上都是在<code>NSObject</code>上实现的，因此最终和<code>[self class]</code>一样，还是会返回<code>Student</code></p>
</li>
</ul>
<h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><ul>
<li>注意在查看汇编时，实际调用的是<code>objc_msgSendSuper2</code>,其第二个参数是当前类对象，而非父类对象，但是在实际源码中<code>objc_msgSendSuper2</code>内，最终还是会取父类去调用。因此最终和编译后的<code>objc_msgSendSuper</code>实现实际是一样的</li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>objc_msgSend</title>
    <url>/2023/01/02/iOS%E5%AD%A6%E4%B9%A0/Runtime/objc-msgSend/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h1><blockquote>
<ul>
<li><code>OC</code>中的方法调用，其实都是转换为<code>objc_msgSend</code>函数的调用</li>
<li><code>objc_msgSend</code>的执行流程可以分为3大阶段<ul>
<li>消息发送</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="objc-msgSend源码-866-执行流程"><a href="#objc-msgSend源码-866-执行流程" class="headerlink" title="objc_msgSend源码(866)执行流程"></a>objc_msgSend源码(866)执行流程</h2><h3 id="objc-msg-arm64-s"><a href="#objc-msg-arm64-s" class="headerlink" title="objc-msg-arm64.s"></a>objc-msg-arm64.s</h3><ul>
<li><code>objc-msg-arm64.s</code><ol>
<li><code>MSG_ENTRY _objc_msgSend </code><ul>
<li>到 <code>END_ENTRY _objc_msgSend，objc_msgSend</code>的定义</li>
</ul>
</li>
<li><code>b.le    LNilOrTagged</code><ul>
<li>首先会判断是否时<code>nil</code>，为<code>nil</code>，则会跳转到<code>LReturnZero</code>直接返回，</li>
</ul>
</li>
<li><code>CacheLookup NORMAL</code><ul>
<li>不是<code>nil</code>,去查找缓存</li>
</ul>
</li>
<li><code>.macro CacheLookup</code><ul>
<li>缓存命中<code>CacheHit</code>，直接返回<code>IMP</code></li>
</ul>
</li>
<li>缓存未命中，<code>__objc_msgLookup_uncached</code><ul>
<li>没找到方法，则会调用<code>MethodTableLookup</code>去查找，<code>MethodTableLookup</code></li>
<li>最终调用的是C函数的方法是<code>lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</code>（注意汇编中的比C函数方法多一个<code>_</code>）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="第一阶段，消息发送"><a href="#第一阶段，消息发送" class="headerlink" title="第一阶段，消息发送"></a>第一阶段，消息发送</h3><ul>
<li>在<code>objc-runtime-new.mm</code>文件中，<code>第一个阶段</code>，查找方法<ol>
<li><code>lookUpImpOrForward</code>,为从缓存中查找的逻辑</li>
<li><code>realizeAndInitializeIfNeeded_locked</code><ul>
<li>确保类已经<code>realize</code>了,初始化了</li>
</ul>
</li>
<li><code>for</code>循环进行遍历查找类<code>cls</code>中方法，有个最大的数进行记录，防止陷入死循环<ol>
<li>先去<code>cache_getImp</code>从缓存中获取<ul>
<li>在查找中间的方法过程中，可能会有新方法在中间添加进来，也都会先加到缓存中</li>
</ul>
</li>
<li><code>getMethodNoSuper_nolock</code>、<code>search_method_list_inline</code>、<code>log_and_fill_cache</code><ol>
<li>从<code>class_rw_t</code>的<code>methods</code>中找到所有类和分类的方法，遍历<code>method_list_t</code>查找，因此需要类先<code>realize</code></li>
<li>如果是排好序列的，<code>findMethodInSortedMethodList</code>中去查找方法,根据方法名查找，已经排序，<code>二分查找</code>的方式<ul>
<li>如果有相同的有很多，会倒序查找，找到排序的第一个方法</li>
<li>排序，会在<code>prepareMethodLists</code>中调用<code>fixupMethodList</code>方法<ul>
<li><code>method_t</code>中方法类型有<code>big</code>、<code>small</code>、<code>bigSigned</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">    <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> Kind &#123;<br>        <span class="hljs-comment">// Note: method_invoke detects small methods by detecting 1 in the low</span><br>        <span class="hljs-comment">// bit. Any change to that will require a corresponding change to</span><br>        <span class="hljs-comment">// method_invoke.</span><br>        big = <span class="hljs-number">0</span>,<br><br>        <span class="hljs-comment">// `small` encompasses both small and small direct methods. We</span><br>        <span class="hljs-comment">// distinguish those cases by doing a range check against the shared</span><br>        <span class="hljs-comment">// cache.</span><br>        small = <span class="hljs-number">1</span>,<br>        bigSigned = <span class="hljs-number">2</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>big</code>是默认的，大方法，其值为指针  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> big &#123;<br>    SEL name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types;<br>    MethodListIMP imp;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><code>small</code>，小方法，其值表示为相对每个字段的额外地址，其结构是  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> small &#123;<br>    <span class="hljs-comment">// The name field either refers to a selector (in the shared</span><br>    <span class="hljs-comment">// cache) or a selref (everywhere else).</span><br>    RelativePointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *&gt; name;<br>    RelativePointer&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *&gt; types;<br>    RelativePointer&lt;IMP, <span class="hljs-comment">/*isNullable*/</span><span class="hljs-literal">false</span>&gt; imp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>其引用的选择器在(共享缓存)或者是在磁盘上，考虑<code>相关动态库的系统方法</code>,该方法是只读内存，因此<code>small</code>的是无法修改的。其是否是<code>smal</code>l方法，是由编译器决定，进行设置的</li>
</ul>
</li>
<li><code>bigSigned</code>,和<code>big</code>相同，但是其<code>name</code>已经签名，该方法是由运行时添加的，类似<code>class_addMethod</code>方法添加的</li>
</ul>
</li>
<li>对方法排序，只会对非<code>small</code>的方法进行排序,排序是根据方法名<code>SEL</code>的地址由低到高排序的<br><img src="4.png"></li>
<li>排序的方式采用的是<code>**归并排序**</code><br><img src="5.png"></li>
</ul>
</li>
</ul>
</li>
<li>不是排好序的方法，调用<code>findMethodInUnsortedMethodList</code>，<code>线性遍历查找</code>，找到第一个方法名相同的，后，返回 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">template&lt;<span class="hljs-keyword">class</span> getNameFunc&gt;<br>ALWAYS_INLINE <span class="hljs-keyword">static</span> method_t *<br>findMethodInUnsortedMethodList(SEL sel, <span class="hljs-keyword">const</span> method_list_t *list, <span class="hljs-keyword">const</span> getNameFunc &amp;getName)<br>&#123;<br>    <span class="hljs-keyword">for</span> (auto&amp; meth : *list) &#123;<br>        <span class="hljs-keyword">if</span> (getName(meth) == sel) <span class="hljs-keyword">return</span> &amp;meth;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>log_and_fill_cache(cls, imp, sel, inst, curClass)</code>,查找到方法后，调用<code>void cache_t::insert</code>,去插入到缓存中,保存的类是最开始查找的类方法<code>cls</code>中,而并非当前的类(即如果查找到了父类的<code>IMP</code>,最后会将这个<code>IMP</code>保存到子类的<code>cache</code>)。</li>
<li>当前<code>curClass</code>中没有找到，则会去父类遍历查找<code>curClass = curClass-&gt;getSuperclass()) == nil</code><ul>
<li>如果找到最后的父类，都没有找到方法，则会设置当前<code>imp = _objc_msgForward_impcache</code></li>
<li>或者从缓存中取到的方法，等于<code>_objc_msgForward_impcache</code>,则会跳出循环</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>消息发送流程<br><img src="1.png"></li>
</ul>
<h3 id="第二阶段，动态方法解析"><a href="#第二阶段，动态方法解析" class="headerlink" title="第二阶段，动态方法解析"></a>第二阶段，动态方法解析</h3><ul>
<li><code>log_and_fill_cache</code>，<code>第二个阶段</code>，动态方法解析<ul>
<li><code>(behavior &amp; LOOKUP_RESOLVER) == 0</code>由最开始汇编中，传入，需要进行方法解析，则进入方法解析流程<ol>
<li> <code>behavior ^= LOOKUP_RESOLVER</code>,解析之后，就不需要了</li>
<li> <code>resolveMethod_locked(inst, sel, cls, behavior)</code>,进入方法解析流程</li>
<li>不是元类，则走<code>resolveInstanceMethod</code>方法 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> resolveInstanceMethod(<span class="hljs-keyword">id</span> inst, SEL sel, Class cls)<br>&#123;<br>    lockdebug::assert_unlocked(&amp;runtimeLock);<br>    ASSERT(cls-&gt;isRealized());<br>    SEL resolve_sel = <span class="hljs-keyword">@selector</span>(resolveInstanceMethod:);<br><br>    <span class="hljs-keyword">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(<span class="hljs-comment">/*authenticated*/</span><span class="hljs-literal">true</span>))) &#123;<br>        <span class="hljs-comment">// Resolver not implemented.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="hljs-keyword">typeof</span>(msg))objc_msgSend;<br>    <span class="hljs-keyword">bool</span> resolved = msg(cls, resolve_sel, sel);<br><br>    <span class="hljs-comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span><br>    <span class="hljs-comment">// +resolveInstanceMethod adds to self a.k.a. cls</span><br>    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>会先去找<code>resolveInstanceMethod</code>,<code>_lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(true))</code>先去,其<code>isa</code>，也就是其元类对象，缓存中找，找不到，则走<code>阶段一</code>的方法查找，这次的<code>behavior</code>不包含<code>LOOKUP_RESOLVER</code>,这次是不会去走动态方法解析<ul>
<li> 其中<code>NSObject</code>中<code>+(BOOL)resolveInstanceMethod</code>会有基础实现</li>
<li>因为后续会同步再次去查询方法，因此是否返回<code>true</code>还是<code>false</code>，不影响实际的结果，但是按规范，返回<code>true</code></li>
</ul>
</li>
<li>会用<code>objc_msgSend</code>调用方法</li>
<li>会再调用<code>lookUpImpOrNilTryCache(inst, sel, cls)</code>,去查找，一开始寻找的方法</li>
<li>方法的返回，最后通过调用<code>lookUpImpOrForwardTryCache</code>去查找<ul>
<li><strong>注意</strong>，用<code>lookUpImpOrNilTryCache</code>传入的<code>behavior</code>包括<code>LOOKUP_NIL</code>，即没有搜索到，会返回<code>nil</code>,不会出现<strong>找不到方法的异常</strong></li>
</ul>
</li>
</ol>
</li>
<li>是元类，则会查找<code>resolveClassMethod</code>，同时，如果调用<code>lookUpImpOrNilTryCache</code>,没有找到，也会去走<code>resolveInstanceMethod</code>方法，即上面的流程(注意，此时他会去元类的<code>isa</code>指针中找方法，而元类的<code>isa</code>指针，实际上是基元类，也就是NSObjec类方法中)，解析类的方法和实例方法流程一样 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// try [nonMetaClass resolveClassMethod:sel]</span><br><span class="hljs-comment">// and [cls resolveInstanceMethod:sel]</span><br>resolveClassMethod(inst, sel, cls);<br><span class="hljs-keyword">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;<br>    resolveInstanceMethod(inst, sel, cls);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>同样会先去找方法<code>resolveClassMethod</code>，其在NSObject中也已实现</li>
<li>会用<code>objc_msgSend</code>的方式调用</li>
<li>最终用<code>lookUpImpOrForwardTryCache</code>去查找方法</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>示例代码<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> c_other(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL _cmd)<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;c_other - %@ - %@&quot;</span>, <span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>&#125;<br>- (<span class="hljs-keyword">void</span>)other &#123;<br> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;other - %@ - %s&quot;</span>, <span class="hljs-keyword">self</span>, __func__);<br>&#125;<br>+ (<span class="hljs-built_in">BOOL</span>)resolveClassMethod:(SEL)sel<br>&#123;<br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(test)) &#123;<br>        <span class="hljs-comment">// 第一个参数是object_getClass(self)</span><br>       <span class="hljs-comment">// c函数 class_addMethod(object_getClass(self), sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br>       Method method = class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(other));<br>        class_addMethod(<br>        object_getClass(<span class="hljs-keyword">self</span>), <br>        sel,<br>        method_getImplementation(method), <br>        method_getTypeEncoding(method));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveClassMethod:sel];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>动态解析流程<br><img src="2.png"></li>
</ul>
<h3 id="第三阶段，消息转发"><a href="#第三阶段，消息转发" class="headerlink" title="第三阶段，消息转发"></a>第三阶段，消息转发</h3><ul>
<li>在<code>第二阶段</code>中，最终会用<code>lookUpImpOrForwardTryCache</code>,再次去查找一次方法，这次，如果动态解析方法添加到了，则会查找到方法，并直接返回；否则会将<code>imp</code>设置为<code>_objc_msgForward_impcache</code>，返回。</li>
<li>最终方法调用者会去执行<code>_objc_msgForward_impcache</code>,会跳转到该方法的实现上，该方法在<code>objc-msg-arm64.s</code>文件内，属于汇编<ul>
<li><code>ENTRY __objc_msgForward</code></li>
<li><code>Core Foundation</code></li>
<li><code>__forwarding__</code>（不开源)<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// __forwarding__伪代码</span><br><span class="hljs-keyword">int</span> __forwarding__(<span class="hljs-keyword">void</span> *frameStackPointer, <span class="hljs-keyword">int</span> isStret) &#123;<br>    <span class="hljs-keyword">id</span> receiver = *(<span class="hljs-keyword">id</span> *)frameStackPointer;<br>    SEL sel = *(SEL *)(frameStackPointer + <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *selName = sel_getName(sel);<br>    Class receiverClass = object_getClass(receiver);<br><br>    <span class="hljs-comment">// 调用 forwardingTargetForSelector:</span><br>    <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(forwardingTargetForSelector:))) &#123;<br>        <span class="hljs-keyword">id</span> forwardingTarget = [receiver forwardingTargetForSelector:sel];<br>        <span class="hljs-keyword">if</span> (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;<br>            <span class="hljs-keyword">if</span> (isStret == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">int</span> ret;<br>                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);<br>                <span class="hljs-keyword">return</span> ret;<br>            &#125;<br>            <span class="hljs-keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 僵尸对象</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *className = class_getName(receiverClass);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zombiePrefix = <span class="hljs-string">&quot;_NSZombie_&quot;</span>;<br>    size_t prefixLen = strlen(zombiePrefix); <span class="hljs-comment">// 0xa</span><br>    <span class="hljs-keyword">if</span> (strncmp(className, zombiePrefix, prefixLen) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelError,<br>              <span class="hljs-string">@&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;</span>,<br>              className + prefixLen,<br>              selName,<br>              receiver);<br>        &lt;breakpoint-interrupt&gt;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span><br>    <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(methodSignatureForSelector:))) &#123;<br>        <span class="hljs-built_in">NSMethodSignature</span> *methodSignature = [receiver methodSignatureForSelector:sel];<br>        <span class="hljs-keyword">if</span> (methodSignature) &#123;<br>            <span class="hljs-built_in">BOOL</span> signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;<br>            <span class="hljs-keyword">if</span> (signatureIsStret != isStret) &#123;<br>                <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>                      <span class="hljs-string">@&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#x27;%s&#x27;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;</span>,<br>                      selName,<br>                      signatureIsStret ? <span class="hljs-string">&quot;&quot;</span> : not,<br>                      isStret ? <span class="hljs-string">&quot;&quot;</span> : not);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(forwardInvocation:))) &#123;<br>                <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> _invocationWithMethodSignature:methodSignature frame:frameStackPointer];<br><br>                [receiver forwardInvocation:invocation];<br><br>                <span class="hljs-keyword">void</span> *returnValue = <span class="hljs-literal">NULL</span>;<br>                [invocation getReturnValue:&amp;value];<br>                <span class="hljs-keyword">return</span> returnValue;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>                      <span class="hljs-string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement forwardInvocation: -- dropping message&quot;</span>,<br>                      receiver,<br>                      className);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    SEL *registeredSel = sel_getUid(selName);<br><br>    <span class="hljs-comment">// selector 是否已经在 Runtime 注册过</span><br>    <span class="hljs-keyword">if</span> (sel != registeredSel) &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>              <span class="hljs-string">@&quot;*** NSForwarding: warning: selector (%p) for message &#x27;%s&#x27; does not match selector known to Objective C runtime (%p)-- abort&quot;</span>,<br>              sel,<br>              selName,<br>              registeredSel);<br>    &#125; <span class="hljs-comment">// doesNotRecognizeSelector</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass,<span class="hljs-keyword">@selector</span>(doesNotRecognizeSelector:))) &#123;<br>        [receiver doesNotRecognizeSelector:sel];<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>              <span class="hljs-string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement doesNotRecognizeSelector: -- abort&quot;</span>,<br>              receiver,<br>              className);<br>    &#125;<br><br>    <span class="hljs-comment">// The point of no return.</span><br>    kill(getpid(), <span class="hljs-number">9</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>实际实现,类方法中也有消息转发处理<ol>
<li><code>-(id)forwardingTargetForSelector:</code>返回可以转发该方法的对象，如果是类方法则是<code>+</code><ul>
<li><strong>注意</strong>，也可以在该实例方法中返回可以响应的类对象（如果类方法支持的话）</li>
</ul>
</li>
<li>如果<code>1</code>中返回的是该对象本身，则会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>,先获取方法签名<ul>
<li>注意方法签名，会决定<code>NSInvocation</code>中的参数和返回值</li>
</ul>
</li>
<li><code>2</code>中获取了方法签名之后，再会调用<code>forwardInvocation:(NSInvocation *)anInvocation</code>方法</li>
<li>如果最后还是没有实现方法<code>3</code>，则会走<code>doesNotRecognizeSelector </code>方法，发出未找到方法的错误<ul>
<li>注意，只要方法<code>3</code>实现了，就算没有任何实现，那么也不会走到<code>doesNotRecognizeSelector</code>的流程，要<strong>注意</strong><code>NSObjec</code>中<code>forwardInvocation:</code>的默认实现,如果没实际实现转发的方法，还是会触发<code>doesNotRecognizeSelector </code></li>
</ul>
</li>
</ol>
</li>
<li><strong>注意</strong>，消息转发成功之后，在当前<strong>调用的类</strong>中是不会缓存方法的，但是在<strong>转发的类</strong>中会缓存;因此,后续调用该方法，仍然无法从缓存中获取，每次调用该方法，都会<strong>重新走消息转发流程</strong>。<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//如果是类方法则是+</span><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">if</span> (aSelector == <span class="hljs-keyword">@selector</span>(text)) &#123;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;v16@0:8i20&quot;</span>];<br>        <span class="hljs-comment">//不带数字位置也是可以的，v-&gt;void、@-&gt;self、:-&gt;SEL、i-&gt;int</span><br>        <span class="hljs-comment">// return [NSMethodSignature signatureWithObjCTypes:&quot;v@:i&quot;]</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>  [<span class="hljs-keyword">super</span> methodSignatureForSelector: aSelector];<br>&#125;<br><span class="hljs-comment">//如果是类方法则是+</span><br>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation &#123;<br>    [anInvocation invokeWithTarget:[[LGPersonText alloc] init]];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>NSObject</code>中的内部实现<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>+ (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation &#123;<br>    [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="hljs-number">0</span>)];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation &#123;<br>    [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="hljs-number">0</span>)];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>方法转发流程<br><img src="3.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
<li><code>OC</code>的消息机制<ul>
<li><code>OC</code>中的方法调用其实都是转成了<code>objc_msgSend</code>函数的调用，给<code>receiver</code>发送一条消息（<code>selector</code>方法）</li>
<li><code>objc_msgSend</code>底层有3大阶段<ol>
<li>消息发送（当前类、父类中查找）</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>objc_class</title>
    <url>/2023/01/01/iOS%E5%AD%A6%E4%B9%A0/Runtime/objc-class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h1><p><img src="1.png"></p>
<h1 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h1><blockquote>
<p><code>class_rw_t</code>里面的<code>methods</code>、<code>properties</code>、<code>protocols</code>是二维数组，是可读可写的，包含了类的初始内容、分类的内容。</p>
</blockquote>
<p><img src="2.png"></p>
<h2 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h2><blockquote>
<p><code>class_ro_t</code>里面的<code>baseMethodList</code>、<code>baseProtocols</code>、<code>ivars</code>、<code>baseProperties</code>是一维数组，是只读的，包含了类的初始内容。</p>
</blockquote>
<p><img src="3.png"></p>
<h2 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h2><blockquote>
<p><code>method_t</code>是对方法\函数的封装</p>
</blockquote>
<p><img src="4.png"></p>
<ul>
<li><code>IMP</code>代表函数的具体实现<ul>
<li><code>typedef id _Nullable (*IMP)(id _Nonnull,SEL _Nonnull,...)</code></li>
</ul>
</li>
<li><code>SEL</code>代表方法\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似 <ul>
<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>
<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是<strong>相同</strong>的 </li>
</ul>
</li>
<li><code>types</code>包含了函数返回值、参数编码的字符串  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">types -&gt;  i24@<span class="hljs-number">0</span>:<span class="hljs-number">8</span>i16f20<br> i <span class="hljs-number">24</span> @ <span class="hljs-number">0</span> : <span class="hljs-number">8</span> i <span class="hljs-number">16</span> f <span class="hljs-number">20</span><br>- (<span class="hljs-keyword">int</span>)test:(<span class="hljs-keyword">int</span>)age height:(<span class="hljs-keyword">float</span>)height;<br></code></pre></td></tr></table></figure>
<ul>
<li>方法为<code>objc_msgSend(id self,SEL,...)</code></li>
<li><code>i-&gt;int</code>,<code>@-&gt;id</code>,<code>@-&gt;SEL</code>,<code>f-&gt;float</code></li>
<li><code>24</code>参数总字节，<code>0</code>从<code>0</code>字节开始，<code>8</code>从第<code>8</code>字节开始</li>
</ul>
</li>
</ul>
<h2 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h2><blockquote>
<p><code>Class</code>内部结构中有个方法缓存（<code>cache_t</code>），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p>
</blockquote>
<ul>
<li><code>mask</code>存储的是散列表的长度减1<br><img src="5.png"></li>
<li>缓存查找<ul>
<li><code>objc-cache.mm</code></li>
<li><code>void cache_t::insert(SEL sel, IMP imp, id receiver)</code></li>
</ul>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol>
<li>插入之前，会先判断是否需要扩容，扩容为条件为，大于之前的<code>3/4</code>倍,扩容为<code>2</code>倍扩容，不超过最大缓存尺寸<br><img src="8.png"></li>
<li>当扩容时，生成的新的<code>buckets</code>会直接替换旧的，会清除之前缓存的方法，也就是说，之前缓存的方法，不会传给新扩容的缓存，缓存会全部释放。新缓存又要重新开始计数。<br><img src="9.png"></li>
<li>向缓存中插入方法<br><img src="6.png"></li>
<li><code>hash</code>的方式是直接用<code>SEL &amp; mask</code>得到<code>key</code>的方式。存在冲突时，会根据取到的<code>sel</code>判断是不是同一方法<br><img src="10.png"> <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">bucket_t *buckets = cache._buckets;<br>bucket_t bucket = buckets[(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-keyword">@selector</span>(studentTest) &amp; cache._mask];<br><span class="hljs-comment">//即可拿到缓存中的选择器，和实现，可能会有hash冲突，源码中会根据拿到的sel看是不是一致的</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %p&quot;</span>, bucket._key, bucket._imp);<br></code></pre></td></tr></table></figure>
<ul>
<li>解决<code>hash</code>冲突的方式，<strong>开放地址法-线性探测</strong><br><img src="7.png"></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>OC类结构</tag>
      </tags>
  </entry>
  <entry>
    <title>isa</title>
    <url>/2023/01/01/iOS%E5%AD%A6%E4%B9%A0/Runtime/isa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><blockquote>
<ul>
<li><code>objective-C</code>的动态性是由<code>runtime API</code>来支撑的</li>
<li><code>runtime API</code>提供的接口基本都是<code>C</code>语言的，源码由<code>C\C++\</code>汇编语言编写</li>
</ul>
</blockquote>
<h2 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h2><blockquote>
<ul>
<li>在<code>arm64</code>架构之前，<code>isa</code>就是一个普通的指针，存储着<code>Class</code>、<code>Meta-Class</code>对象的内存地址</li>
<li>从<code>arm64</code>架构开始，对<code>isa</code>进行了优化，变成了一个共用体（<code>union</code>）(结构体和数据共用的一个内存地址，实际共用体中的结构体，只做展示作用)结构，使用位域来存储更多信息</li>
</ul>
</blockquote>
<h3 id="isa结构"><a href="#isa结构" class="headerlink" title="isa结构"></a>isa结构</h3><ol>
<li>共用体（<code>union</code>）结构(结构体和数据共用的一个内存地址，实际数据存储在<code>bits</code>中，共用体中的结构体，只做展示作用)<br><img src="1.png"><img src="2.png"></li>
</ol>
<h3 id="isa指针每位的含义"><a href="#isa指针每位的含义" class="headerlink" title="isa指针每位的含义"></a>isa指针每位的含义</h3><blockquote>
<p>从内存地址，从上往下，即地址从右边，往左</p>
</blockquote>
<ul>
<li><code>nonpointer</code><ul>
<li><code>0</code>,代表普通的指针，存储着<code>Class</code>、<code>Meta—Class</code>对象的内存地址</li>
<li><code>1</code>,代表优化过，使用位域存储更多的信息</li>
</ul>
</li>
<li><code>has_assoc</code><ul>
<li>是否有设置过关联对象，如果没有，释放会更快</li>
</ul>
</li>
<li><code>has_cxx_dtor</code><ul>
<li>是否有<code>C++</code>的析构函数（<code>.cxx_destruct</code>),如果没有，释放会更快</li>
</ul>
</li>
<li><code>shiftcls</code><ul>
<li>存储着<code>Class</code>、<code>Meta-Class</code>对象的内存地址信息</li>
<li><code>ios</code>中<code>mask</code>为<code>0x0000000ffffffff8</code>,因此，很多类以及元类的地址是以8和0结尾的，因为最后三位均是<code>000</code>.</li>
</ul>
</li>
<li><code>magic</code><ul>
<li>用于在调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li><code>weakly_referenced</code><ul>
<li>是否有被弱引用指向过，如果没有,释放时会更快</li>
</ul>
</li>
<li><code>deallocating</code>/<code>unused</code>(818版本之后)<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li><code>extra_rc</code><ul>
<li>里面存储的值是引用计数器减<code>1</code></li>
</ul>
</li>
<li><code>has_sidetable_rc</code><ul>
<li>引用计数器是否过大无法存储在<code>isa</code>中，如果为<code>1</code>，那么引用计数会存储在一个叫<code>SideTable</code>的类的属性中</li>
</ul>
</li>
</ul>
<p>注意，这里的都是<strong>是否有设置过</strong>，就像关联对象，就算最后将所有的关联对象删除，仍是<code>1</code>，如果有这些，在销毁的时候，会做额外工作.<br><img src="3.png"></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>OC类结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Block</title>
    <url>/2022/12/29/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Block%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="block的本质"><a href="#block的本质" class="headerlink" title="block的本质"></a>block的本质</h1><ul>
<li><p><code>block</code>本质上也是一个OC对象，它内部也有个<code>isa</code>指针</p>
</li>
<li><p><code>block</code>是封装了函数调用以及函数调用环境的<code>OC</code>对象</p>
</li>
<li><p><code>block</code>的底层结构如右图所示<br><img src="1.png"></p>
<h2 id="block编译成C"><a href="#block编译成C" class="headerlink" title="block编译成C++"></a>block编译成C++</h2><blockquote>
<p>通过将<code>block</code>编译成<code>C++</code>来分析<code>block</code>的本质</p>
</blockquote>
</li>
<li><p>执行命令<code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件</code></p>
</li>
<li><p>捕获了<code>auto</code>变量<code>JPPerson</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  JPPerson *__<span class="hljs-keyword">strong</span> person;<br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, JPPerson *__<span class="hljs-keyword">strong</span> _person, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : person(_person) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>  <span class="hljs-keyword">void</span> (*<span class="hljs-keyword">copy</span>)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>  <span class="hljs-keyword">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>与<code>block</code>相关的<code>__block</code>变量,编译器会将<code>__block</code>变量包装成一个对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> __Block_byref_p_1 &#123;<br>  <span class="hljs-keyword">void</span> *__isa;<br>__Block_byref_p_1 *__forwarding;<br> <span class="hljs-keyword">int</span> __flags;<br> <span class="hljs-keyword">int</span> __size;<br> <span class="hljs-keyword">void</span> (*__Block_byref_id_object_copy)(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*);<br> <span class="hljs-keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="hljs-keyword">void</span>*);<br> <span class="hljs-built_in">NSObject</span> *__<span class="hljs-keyword">weak</span> p;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>再将有<code>_weak</code>的方法，使用<code>clang</code>转换OC为<code>C++</code>代码时，注意支持<code>ARC</code>、以及指定运行时系统版本</p>
<ul>
<li><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-16.0.0 main.m -o main.cpp</code></li>
</ul>
</li>
</ul>
<h2 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h2><table>
<thead>
<tr>
<th>block类型</th>
<th>环境</th>
</tr>
</thead>
<tbody><tr>
<td><em>NSGlobalBlock</em></td>
<td>没有访问auto变量</td>
</tr>
<tr>
<td><em>NSStackBlock</em></td>
<td>访问了auto变量</td>
</tr>
<tr>
<td><em>NSMallocBlock</em></td>
<td>_NSStackBlock_调用了copy</td>
</tr>
</tbody></table>
<ul>
<li>注意在非<code>ARC</code>环境下是准确的，如果在<code>ARC</code>环境下,编译器会根据情况，将栈上的<code>block</code>,变成<code>NSMalloCBlock</code></li>
</ul>
<h3 id="block的copy"><a href="#block的copy" class="headerlink" title="block的copy"></a><code>block</code>的<code>copy</code></h3><ul>
<li>每一种<code>block</code>调用<code>copy</code>后的结果如图所示</li>
</ul>
<table>
<thead>
<tr>
<th>block的类</th>
<th>副本源的配置存储域</th>
<th>赋值效果</th>
</tr>
</thead>
<tbody><tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody></table>
<ul>
<li>在<code>ARC</code>环境下，编译器会根据情况，将栈上的<code>block</code>,拷贝到堆上,有以下情况<ol>
<li><code>block</code>作为函数的返回值时</li>
<li>将<code>block</code>赋值给<code>__strong</code>引指针</li>
<li><code>block</code>作为<code>Cocoa api</code>名含有<code>usingBlock</code>的方法参数输入时</li>
<li><code>block</code>作为<code>GCD API</code>的方法参数时</li>
</ol>
</li>
</ul>
<h3 id="当block内部访问了对象类型的auto变量时"><a href="#当block内部访问了对象类型的auto变量时" class="headerlink" title="当block内部访问了对象类型的auto变量时"></a>当block内部访问了对象类型的auto变量时</h3><ul>
<li>如果<code>block</code>是在栈上，将不会对<code>auto</code>变量产生强引用</li>
<li>如果<code>block</code>是在堆上<ul>
<li>会调用<code>block</code>内部的<code>copy</code>函数</li>
<li><code>copy</code>函数内部会调用<code>_Block_objc_assign</code>函数</li>
<li><code>_Block_objc_assign</code>函数会根据<code>auto</code>变量的修饰符（<code>_strong</code>、<code>_weak</code>、<code>_unsafe_unretained</code>）做出相应的操作，类似于<code>retain</code>（形成强引用、弱引用）</li>
</ul>
</li>
</ul>
<h2 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="block的内存管理"></a>block的内存管理</h2><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><ul>
<li><code>block</code>的内存管理代码  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;person, (<span class="hljs-keyword">void</span>*)src-&gt;person, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;person, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>当<code>block</code>在栈上</strong>时，并不会对<code>__block</code>变量，以及<code>auto</code>的对象产生强引用</li>
<li>当<code>block</code>被<code>copy</code>到堆时<ul>
<li>会调用<code>block</code>内部的<code>copy</code>函数</li>
<li><code>copy</code>函数内部会调用<code>_Block_object_assign</code>函数</li>
<li><code>_Block_object_assign</code>函数会对<code>_block</code>变量形成强引用,会区分是<code>auto</code>对象（会区分是<code>_weak</code>还是<code>_strong</code>），还是<code>_block</code>对象（强引用）</li>
</ul>
</li>
<li>当<code>block</code>从堆移除<ul>
<li>会调用<code>block</code>内部的<code>dispose</code>函数</li>
<li><code>dispose</code>函数内部会调用<code>_Block_object_dispose</code>函数</li>
<li><code>_Block_object_dispose</code>函数会自动释放引用的<code>_block</code>变量</li>
</ul>
</li>
</ul>
<h3 id="block-1"><a href="#block-1" class="headerlink" title="__block"></a>__block</h3><ul>
<li><p><code>__block</code>一个对象的内存管理代码,<code>copy</code>方法中加的<code>40</code>,是对象p相对结构体的偏移</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">_attribute__((__blocks__(<span class="hljs-keyword">byref</span>))) __attribute__((objc_ownership(<span class="hljs-keyword">weak</span>))) __Block_byref_p_1 p = &#123;<br>(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>,<br>(__Block_byref_p_1 *)&amp;p, <br><span class="hljs-number">33554432</span>, <br><span class="hljs-keyword">sizeof</span>(__Block_byref_p_1), <br>__Block_byref_id_object_copy_131, <br>__Block_byref_id_object_dispose_131, <br>((<span class="hljs-built_in">NSObject</span> *(*)(<span class="hljs-keyword">id</span>, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((<span class="hljs-keyword">id</span>)objc_getClass(<span class="hljs-string">&quot;NSObject&quot;</span>), sel_registerName(<span class="hljs-string">&quot;new&quot;</span>))&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __Block_byref_id_object_copy_131(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">void</span> *src) &#123;<br>    _Block_object_assign((<span class="hljs-keyword">char</span>*)dst + <span class="hljs-number">40</span>, *(<span class="hljs-keyword">void</span> * *) ((<span class="hljs-keyword">char</span>*)src + <span class="hljs-number">40</span>), <span class="hljs-number">131</span>);<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __Block_byref_id_object_dispose_131(<span class="hljs-keyword">void</span> *src) &#123;<br>     _Block_object_dispose(*(<span class="hljs-keyword">void</span> * *) ((<span class="hljs-keyword">char</span>*)src + <span class="hljs-number">40</span>), <span class="hljs-number">131</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>当<code>__block</code>修饰对象时，其构建的_<code>block</code>变量内，也会有<code>copy</code>方法和<code>dispose</code>方法</p>
<ul>
<li>其内<code>copy</code>方法，同样也有<code>_Block_object_assign</code>,以及<code>_Block_object_dispose</code>,对其内修饰的对象进行内存管理（跟外围是<code>_strong</code>还是<code>_weak</code>有一定关系）<ul>
<li> <strong>但是注意，该内存管理只会在<code>ARC</code>下生效，如果在<code>MRC</code>下，在<code>__block</code>不会增加其内对象的引用，属于<code>unowned</code>关系</strong></li>
<li> <strong>如果不是<code>__block</code>,而是直接引用了<code>auto</code>对象，则和此前一样，<code>block</code>直接引用对象(<code>mrc</code>下，<code>copy</code>时，内部也会对<code>auto</code>增加引用)，而非通过<code>__block</code>间接引用</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><code>_block</code>的生成的对象，通过<code>fowarding</code>去指向的原因</p>
<ul>
<li>在栈上的时候，指针指向自己</li>
<li>而赋值到堆上时，栈上的指向堆上复制的，栈上赋值时，其值是保存堆上的值，从而保证了，无论是在栈上还是堆上修改，最后值都会保存的堆上。最终使用的是堆上的<code>block</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>在main函数之前应用启动做了什么</title>
    <url>/2022/12/28/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%9C%A8main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="App编译流程及启动流程dyld"><a href="#App编译流程及启动流程dyld" class="headerlink" title="App编译流程及启动流程dyld"></a>App编译流程及启动流程dyld</h2><p><img src="1.png"></p>
<ul>
<li>注意：只有静态库会在编译阶段会打包进入可执行文件，动态库是在程序运行时才会被加入可执行文件。</li>
</ul>
<h2 id="从App启动角度深入了解dyld"><a href="#从App启动角度深入了解dyld" class="headerlink" title="从App启动角度深入了解dyld"></a>从App启动角度深入了解dyld</h2><blockquote>
<p>应用程序启动前，会先对代码进行编译，在编译阶段会把静态库打包到可执行性文件中，编译完成后，进入启动阶段，谈及App启动流程，肯定少不了我们的动态链接器dyld，整个启动过程都是它在进行协调。</p>
</blockquote>
<ul>
<li><p>dyld操作流程如下图：<br><img src="2.png"></p>
</li>
<li><p>分析</p>
<ol>
<li><code>main()</code>之前通过调用<code>dyld</code>对主程序运行环境初始化，生成<code>imageLoader</code>把动态库生成对应的<code>image</code>镜像文件，载入到内存中。</li>
<li>然后进行链接绑定，接着初始化所有动态库，在执行所有插入的动态库初始化的时候，同时也对<code>load_images</code>进行了绑定。</li>
<li>执行初始化这个过程中，会<strong>优先初始化</strong>系统库<code>libSystem</code>，运行起来<code>Runtime</code>，这个过程会进入<code>Runtime</code>的入口函数<code>_objc_init</code>，</li>
<li>接下来把之前链接的动态库及符号都交给<code>Runtime</code>进行<code>map_images</code>和<code>load_images</code>操作，<a href="/map-images.md">map_images</a>和<a href="/load.md">load_images</a></li>
<li>然后<code>Runtime</code>执行完<code>load_images</code>之后会回调到<code>dyld</code>内部，<code>dyld</code>收到信息回调后，最后查找<code>main()</code>函数的入口<code>LC_MAIN</code>，找到后就会调起我们的<code>main()</code>函数，进入我们开发者的代码。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ol>
<li>程序启动时，系统XNU执行程序的可执行二进制文件，从内核态切换到用户态，</li>
<li>根据路径找到并运行动态链接器<code>dyld</code>，并把控制权交给<code>dyld</code>，</li>
<li>然后启动<code>dyld</code>进行程序环境初始化，然后读取可执行文件<code>Mach-O</code>，开始根据头文件内容读取动态库并初始化主程序，</li>
<li>初始化主程序后，就开始链接读取完成的动态库到主程序可执行文件中，然后初始化动态库。</li>
<li>在初始化其他动态库之前，会最先初始化系统库<code>libsystem</code>，运行<code>Runtime</code>。系统库<code>libsystem</code>初始化完成后，就会初始化其他动态库，</li>
<li>然后由<code>Runtime</code>调用<code>map_images</code>来读取类、方法、协议以及分类并存储到对应的表中(注意：分类并不是直接存，而是通过<code>attachLists</code>方法把分类的数据添加到类里面)，</li>
<li>然后<code>Runtime</code>会继续调用<code>load_images</code>调用所有类的<code>load</code>方法以及分类的<code>load</code>方法，</li>
<li>这些都做完之后，通过<code>dyld</code>提供的回调<code>_dyld_objc_notify_register</code>，告诉<code>dyld</code>加载完毕，然后<code>dyld</code>就开始找主程序的入口<code>main</code>函数，最后进入程序的<code>main</code>函数</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>应用启动</tag>
      </tags>
  </entry>
  <entry>
    <title>load、initialize方法的区别</title>
    <url>/2022/12/28/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/load%E3%80%81initialize%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="load、initialize方法的区别"><a href="#load、initialize方法的区别" class="headerlink" title="load、initialize方法的区别"></a>load、initialize方法的区别</h4><ol>
<li><p>调用方式</p>
<ul>
<li> <code>load</code>是根据函数地址直接调用</li>
<li> <code>initialize</code>是通过<code>objc_msgSend</code>调用</li>
</ul>
</li>
<li><p>调用时刻</p>
<ul>
<li><code>load</code>是<code>runtime</code>加载类、分类的时候调用（只会调用1次）</li>
<li><code>initialize</code>是类第一次发送到消息的时候调用，每个类只会<code>initialize</code>一次（父类的<code>initialize</code>方法可能会被调用多次）</li>
</ul>
</li>
<li><p><code>load</code>、<code>initialize</code>的调用顺序</p>
<ol>
<li><code>load</code><ul>
<li>先调用类的<code>load</code><ul>
<li>先编译的类，优先调用<code>load</code></li>
<li>调用子类的<code>load</code>之前，会先调用父类的<code>load</code></li>
</ul>
</li>
<li>再调用分类的<code>load</code><ul>
<li>先编译的分类，优先调用<code>load</code></li>
</ul>
</li>
</ul>
</li>
<li><code>initialize</code><ul>
<li>在，第一次使用的时候调用，先初始化父类，</li>
<li>再初始化子类（可能最终调用的是父类的）</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>initialize</title>
    <url>/2022/12/27/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/initialize/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><span id="more"></span>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ol>
<li>在查找方法前，进行<code>initialize</code>的调用<br><img src="16721352310424.png"><img src="16721353684859.png"></li>
</ol>
<ul>
<li>类没有初始化，则去调用初始化<br><img src="16721354586849.png"></li>
<li>先查看有没有父类，有父类，且没有初始化，则先初始化父类的<code>initialize</code><br><img src="16721355384202.png"></li>
<li>采用的是<code>objc_msSend</code>去调用<code>initialize</code>方法<br><img src="16721356497584.png"></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>initialize</code>和<code>load</code>的最大区别是，<code>initialize</code>是通过<code>objc_msgSend</code>进行调用的。而<code>load</code>是拿到函数地址后直接调用的<ul>
<li>如果子类没有实现<code>initialize</code>，会调用父类的<code>initialize</code>（所以父类的<code>initialize</code>可能会调用多次）</li>
<li>如果分类实现了<code>initialize</code>，就会覆盖本身的<code>initialize</code>调用</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>Load</title>
    <url>/2022/12/26/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Load/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Load方法"><a href="#Load方法" class="headerlink" title="Load方法"></a>Load方法</h3><ul>
<li><code>+load</code>方法会在<code>runtime</code>加载类、分类时调用</li>
<li>每个类、分类的<code>+load</code>，在程序运行过程中只调用一次<ul>
<li><code>flags</code>标识位保证类只会加载一次</li>
<li>首先会先将父类添加到数组，后将自己加进去数组，因此，先父类，再执行子类，最后分类中的<code>load</code>方法</li>
<li>同一级的关系时按照编译的顺序来</li>
</ul>
</li>
<li>尽管load中方法在源码中只会调用一次，但实际上主动<code>[Class load]</code>也会触发load,因此在调用<code>method_exchangeImplementations</code>做hook时，会加上<code>dispatch_once</code>，保证只会执行一次。</li>
</ul>
<span id="more"></span>

<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ol>
<li><p>如果此前没有将分类加载到类中，则这里会调用<code>loadAllCategories</code>方法</p>
</li>
<li><p>在<code>load_images</code>中加载,首先会在<code>prepare_load_methods</code>方法中，找到类和分类的所有<code>load</code>方法<br><img src="16720646359112.png"></p>
</li>
<li><p>构建有类<code>load</code>方法的数组，以及有分类<code>load</code>方法的数组，整个添加顺序是</p>
<ol>
<li>类先按编译的顺序进行添加，递归调用,其中父类会比子类先添加到数组中<ul>
<li>这里有递归，首选会先将父类添加到数组，后将自己加进去数组，因此最后，先父类，再添加子类的<code>load</code>方法（获取类<code>class_ro_t</code>中<code>baseMethod</code>的<code>load</code>方法）<br><img src="16720649726860.png"></li>
</ul>
</li>
<li>分类按编译的顺序进行添加的，这里获取<code>category_t</code>中的<code>classMethods</code>中的load方法<br><img src="16720651219179.png"></li>
</ol>
</li>
<li><p>先调用类中的<code>load</code>方法，再调用分类中的<code>load</code>方法<br><img src="16720639325952.png"></p>
</li>
<li><p>再找到类中的load方法（<code>prepare_load_methods</code>方法事前找到），用函数调用的方式直接执行，分类也是这样的，不是<code>objc_msg</code>的方式<br><img src="16720641861246.png"></p>
</li>
</ol>
<h4 id="load-images流程"><a href="#load-images流程" class="headerlink" title="load_images流程"></a><code>load_images</code>流程</h4><ol>
<li><code>loadAllCategories</code>,加载所有的分类，这里如果类已经<code>Realized</code>,则将分类中的方法、属性、协议加到类的<code>class_rw_t</code>中,否则将分类中类和分类映射加到<code>objc::unattachedCategories</code>存储，会在类<code>Realized</code>的时候，在添加</li>
<li>准备<code>load</code>方法:<code>prepare_load_methods</code><ul>
<li>先处理类，后处理分类 以及 先处理父类，后处理子类的顺序存储到待调度的表中。<ul>
<li>类的处理逻辑：把类对象<code>Class</code>和类对应的<code>load</code>方法的<code>IMP</code>整合成一个<code>loadable_class</code>类型的结构体对象存储在表<code>loadable_classes</code>中。</li>
<li>分类的处理逻辑：把分类对象<code>Category</code>和对应的<code>load</code>方法<code>IMP</code>整合成一个<code>loadable_category</code>类型的结构体对象存储在表<code>loadable_categories</code>中。</li>
</ul>
</li>
</ul>
</li>
<li>调用<code>load</code>方法:<code>call_load_methods</code><ul>
<li>先调用类<code>Class</code>的<code>load</code>，后处理分类<code>Category</code>，通过分类找到对应的类，然后由类调用<code>load</code>方法的顺序进行处理</li>
<li>这个调用处理的顺序是根据准备方法<code>prepare_load_method</code>s中准备好的两张表<code>loadable_classes</code>和<code>loadable_categories</code>的顺序而来的。调用完就从表中移除，全部调用完结束循环。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>调用顺序</li>
</ul>
<ol>
<li><p>先调用类的<code>+load</code></p>
<ol>
<li>按照编译先后的顺序调用，先编译，先调用</li>
<li>调用子类的<code>+load</code>之前会先调用父类的<code>+load</code></li>
</ol>
</li>
<li><p>再调用分类的<code>+load</code></p>
<ol>
<li>按照编译先后顺序调用，先编译，先调用</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>map_images</title>
    <url>/2022/12/26/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/map-images/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><code>runtime</code>初始化<code>objc_init</code>,会注册三个函数<code>map_images</code>、<code>load_images</code>、<code>unmap_image</code>,这里对<code>map_images</code>所做的工作进行探索,</p>
<ul>
<li>整个流程是<code>map_images</code> -&gt; <code>map_images_nolock</code> -&gt; <code>_read_images</code>。这里对<code>map_images_nolock</code>和<code>_read_images</code>进行分享</li>
</ul>
</blockquote>
<h3 id="map-images-nolock"><a href="#map-images-nolock" class="headerlink" title="map_images_nolock"></a>map_images_nolock</h3><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> <br>map_images_nolock(<span class="hljs-keyword">unsigned</span> mhCount, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> mhPaths[],<br>                  <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> mach_header * <span class="hljs-keyword">const</span> mhdrs[],<br>                  <span class="hljs-keyword">bool</span> *disabledClassROEnforcement)<br>&#123;<br>    <span class="hljs-comment">//定义一系列变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> firstTime = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> executableHasClassROSigning = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> executableIsARM64e = <span class="hljs-literal">false</span>;<br><br>    header_info *hList[mhCount];<br>    uint32_t hCount;<br>    size_t selrefCount = <span class="hljs-number">0</span>;<br><br>    *disabledClassROEnforcement = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//如果是第一次，就准备初始化环境</span><br>    <span class="hljs-keyword">if</span> (firstTime) &#123;<br>        preopt_init();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (PrintImages) &#123;<br>        _objc_inform(<span class="hljs-string">&quot;IMAGES: processing %u newly-mapped images...\n&quot;</span>, mhCount);<br>    &#125;<br><br><br>    <span class="hljs-comment">// Find all images with Objective-C metadata.</span><br>    hCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//计算class数量，根据总数调整各种表的大小。</span><br>    <span class="hljs-keyword">int</span> totalClasses = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> unoptimizedTotalClasses = <span class="hljs-number">0</span>;<br>    &#123;<br>        uint32_t i = mhCount;<br>        <span class="hljs-keyword">while</span> (i--) &#123;<br>            <span class="hljs-keyword">const</span> headerType *mhdr = (<span class="hljs-keyword">const</span> headerType *)mhdrs[i];<br><br>            auto hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);<br>            <span class="hljs-keyword">if</span> (!hi) &#123;<br>                <span class="hljs-comment">// no objc data in this entry</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;<br>                <span class="hljs-comment">// Size some data structures based on main executable&#x27;s size</span><br><br>                <span class="hljs-comment">// If dyld3 optimized the main executable, then there shouldn&#x27;t</span><br>                <span class="hljs-comment">// be any selrefs needed in the dynamic map so we can just init</span><br>                <span class="hljs-comment">// to a 0 sized map</span><br>                <span class="hljs-keyword">if</span> ( !hi-&gt;hasPreoptimizedSelectors() ) &#123;<br>                  size_t count;<br>                  _getObjc2SelectorRefs(hi, &amp;count);<br>                  selrefCount += count;<br>                  _getObjc2MessageRefs(hi, &amp;count);<br>                  selrefCount += count;<br>                &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_GC_COMPAT</span><br>                <span class="hljs-comment">// 兼容旧版本OC的GCC功能</span><br>                <span class="hljs-comment">// Halt if this is a GC app.</span><br>                <span class="hljs-keyword">if</span> (shouldRejectGCApp(hi)) &#123;<br>                    _objc_fatal_with_reason<br>                        (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, <br>                         OS_REASON_FLAG_CONSISTENT_FAILURE, <br>                         <span class="hljs-string">&quot;Objective-C garbage collection &quot;</span> <br>                         <span class="hljs-string">&quot;is no longer supported.&quot;</span>);<br>                &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>                <span class="hljs-keyword">if</span> (hasSignedClassROPointers(hi)) &#123;<br>                    executableHasClassROSigning = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>            hList[hCount++] = hi;<br><br>            <span class="hljs-keyword">if</span> (PrintImages) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;IMAGES: loading image for %s%s%s%s%s\n&quot;</span>, <br>                             hi-&gt;fname(),<br>                             mhdr-&gt;filetype == MH_BUNDLE ? <span class="hljs-string">&quot; (bundle)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                             hi-&gt;info()-&gt;isReplacement() ? <span class="hljs-string">&quot; (replacement)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                             hi-&gt;info()-&gt;hasCategoryClassProperties() ? <span class="hljs-string">&quot; (has class properties)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                             hi-&gt;info()-&gt;optimizedByDyld()?<span class="hljs-string">&quot; (preoptimized)&quot;</span>:<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//执行一次运行时初始化，必须将其推迟到找到可执行文件本身为止。 </span><br><span class="hljs-comment">//这需要在进一步初始化之前完成。（如果可执行文件不包含Objective-C代码，</span><br><span class="hljs-comment">//但稍后会动态加载Objective-C，则该可执行文件可能不会出现在此infoList中.</span><br>    <span class="hljs-keyword">if</span> (firstTime) &#123;<br>        sel_init(selrefCount); <span class="hljs-comment">//这里会初始化方法列表，并注册系统内部专门的方法。</span><br>        arr_init();<span class="hljs-comment">//这里会初始化`SideTablesMap`表，`associations`关联表</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_GC_COMPAT</span><br>        <span class="hljs-comment">// Reject any GC images linked to the main executable.</span><br>        <span class="hljs-comment">// We already rejected the app itself above.</span><br>        <span class="hljs-comment">// Images loaded after launch will be rejected by dyld.</span><br><br>        <span class="hljs-keyword">for</span> (uint32_t i = <span class="hljs-number">0</span>; i &lt; hCount; i++) &#123;<br>            auto hi = hList[i];<br>            auto mh = hi-&gt;mhdr();<br>            <span class="hljs-keyword">if</span> (mh-&gt;filetype != MH_EXECUTE  &amp;&amp;  shouldRejectGCImage(mh)) &#123;<br>                _objc_fatal_with_reason<br>                    (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, <br>                     OS_REASON_FLAG_CONSISTENT_FAILURE, <br>                     <span class="hljs-string">&quot;%s requires Objective-C garbage collection &quot;</span><br>                     <span class="hljs-string">&quot;which is no longer supported.&quot;</span>, hi-&gt;fname());<br>            &#125;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TARGET_OS_OSX</span><br>        <span class="hljs-keyword">for</span> (uint32_t i = <span class="hljs-number">0</span>; i &lt; hCount; i++) &#123;<br>            auto hi = hList[i];<br>            auto mh = hi-&gt;mhdr();<br>            <span class="hljs-keyword">if</span> (mh-&gt;filetype != MH_EXECUTE) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;<br>            <span class="hljs-keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;__objc_fork_ok&quot;</span>, &amp;size)) &#123;<br>                DisableInitializeForkSafety = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (PrintInitializing) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;INITIALIZE: disabling +initialize fork &quot;</span><br>                                 <span class="hljs-string">&quot;safety enforcement because the app has &quot;</span><br>                                 <span class="hljs-string">&quot;a __DATA,__objc_fork_ok section&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// assume only one MH_EXECUTE image</span><br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// TARGET_OS_OSX</span></span><br><br>    <span class="hljs-comment">// If the main executable is ARM64e, make sure every image that is loaded</span><br>    <span class="hljs-comment">// has pointer signing turned on.</span><br>    <span class="hljs-keyword">if</span> (executableIsARM64e) &#123;<br>        <span class="hljs-keyword">bool</span> shouldWarn = (executableHasClassROSigning<br>                           &amp;&amp; DebugClassRXSigning);<br>        <span class="hljs-keyword">for</span> (uint32_t i = <span class="hljs-number">0</span>; i &lt; hCount; ++i) &#123;<br>            auto hi = hList[i];<br>            <span class="hljs-keyword">if</span> (!hasSignedClassROPointers(hi)) &#123;<br>                <span class="hljs-keyword">if</span> (!objc::disableEnforceClassRXPtrAuth) &#123;<br>                    *disabledClassROEnforcement = <span class="hljs-literal">true</span>;<br>                    objc::disableEnforceClassRXPtrAuth = <span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (shouldWarn) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;%s has un-signed class_ro_t pointers, but the &quot;</span><br>                                 <span class="hljs-string">&quot;main executable was compiled with class_ro_t &quot;</span><br>                                 <span class="hljs-string">&quot;pointer signing enabled&quot;</span>, hi-&gt;fname());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//直接开始镜像读取</span><br>    <span class="hljs-keyword">if</span> (hCount &gt; <span class="hljs-number">0</span>) &#123;<br>        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);<br>    &#125;<br><br>    firstTime = <span class="hljs-literal">NO</span>;<br><br>    <span class="hljs-comment">// Call image load funcs after everything is set up.</span><br>    <span class="hljs-keyword">for</span> (auto func : loadImageFuncs) &#123;<br>        <span class="hljs-keyword">for</span> (uint32_t i = <span class="hljs-number">0</span>; i &lt; mhCount; i++) &#123;<br>            func(mhdrs[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h4><ol>
<li>判断<code>firstTime</code>，<code>firstTime</code>为<code>YES</code>，则执行环境初始化的准备，为<code>NO</code>就不执行</li>
<li>计算<code>class</code>数量，根据总数调整各种表的大小并做了<code>GC</code>相关逻辑处理(不支持<code>GC</code>则打印提示信息)</li>
<li>判断<code>firstTime</code>，<code>firstTime</code>为YES，执行各种表(<code>SideTablesMap</code>表，<code>associations</code>关联表,<code>sel</code>方法表)初始化操作，为<code>NO</code>则不执行</li>
<li>执行<code>_read_images</code>进行读取，然后将<code>firstTime</code>置为<code>NO</code>，就不再进入上面的逻辑了，下次进入<code>map_images_nolock</code>就开始直接<code>_read_images</code></li>
</ol>
<h3 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h3><h4 id="read-images源码"><a href="#read-images源码" class="headerlink" title="_read_images源码"></a>_read_images源码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> _read_images(header_info **hList, uint32_t hCount, <span class="hljs-keyword">int</span> totalClasses, <span class="hljs-keyword">int</span> unoptimizedTotalClasses)<br>&#123;<br>    header_info *hi;<br>    uint32_t hIndex;<br>    size_t count;<br>    size_t i;<br>    Class *resolvedFutureClasses = <span class="hljs-literal">nil</span>;<br>    size_t resolvedFutureClassCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> doneOnce;<br>    <span class="hljs-keyword">bool</span> launchTime = <span class="hljs-literal">NO</span>;<br>    TimeLogger ts(PrintImageTimes);<br><br>    lockdebug::assert_locked(&amp;runtimeLock);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EACH_HEADER \</span><br><span class="hljs-meta">    hIndex = 0;         \</span><br><span class="hljs-meta">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="hljs-meta">    hIndex++</span><br><br>    <span class="hljs-keyword">if</span> (!doneOnce) &#123;<br>        doneOnce = <span class="hljs-literal">YES</span>;<br>        launchTime = <span class="hljs-literal">YES</span>;<br>        <span class="hljs-comment">// 1.重新初始化TaggePointer环境</span><br>        <span class="hljs-keyword">if</span> (DisableTaggedPointers) &#123;<br>            disableTaggedPointers();<br>        &#125;<br><br>        initializeTaggedPointerObfuscator();<br><br>        <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);<br>        &#125;<br><br>        <span class="hljs-comment">// 创建gdb_objc_realized_classes表</span><br>        <span class="hljs-keyword">int</span> namedClassesSize =<br>            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="hljs-number">4</span> / <span class="hljs-number">3</span>;<br>        gdb_objc_realized_classes =<br>            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);<br><br>        ts.log(<span class="hljs-string">&quot;IMAGE TIMES: first time tasks&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//2. 修复预编译阶段的`@selector`的混乱问题</span><br>    <span class="hljs-keyword">static</span> size_t UnfixedSelectors;<br>    &#123;<br>        mutex_locker_t lock(selLock);<br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            <span class="hljs-keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">bool</span> isBundle = hi-&gt;isBundle();<br>            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);<br>            UnfixedSelectors += count;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = sel_cname(sels[i]);<br>                <span class="hljs-comment">//这里注册实际是将方法名存储到namedSelectors中保存</span><br>                SEL sel = sel_registerNameNoLock(name, isBundle);<br>                <span class="hljs-comment">//方法列表和注册时不同的，重新赋值</span><br>                <span class="hljs-keyword">if</span> (sels[i] != sel) &#123;<br>                    sels[i] = sel;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);<br><br>    <span class="hljs-keyword">bool</span> hasDyldRoots = dyld_shared_cache_some_image_overridden();<br>    <span class="hljs-number">3.</span> 开始遍历头文件，进行类与元类的读取操作并标记(旧类改动后会生成新的类，并重映射到新的类上)<br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-keyword">if</span> (! mustReadClasses(hi, hasDyldRoots)) &#123;<br>            <span class="hljs-comment">// Image is sufficiently optimized that we need not call readClass()</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        classref_t <span class="hljs-keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);<br><br>        <span class="hljs-keyword">bool</span> headerIsBundle = hi-&gt;isBundle();<br>        <span class="hljs-keyword">bool</span> headerIsPreoptimized = hi-&gt;hasPreoptimizedClasses();<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            Class cls = (Class)classlist[i];<br>            <span class="hljs-comment">//readClass读取类的信息及类的更新</span><br>            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);<br>            <span class="hljs-comment">//旧类和新类不同，则会加到resolvedFutureClasses中</span><br>            <span class="hljs-keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;<br>                <span class="hljs-comment">// Class was moved but not deleted. Currently this occurs</span><br>                <span class="hljs-comment">// only when the new class resolved a future class.</span><br>                <span class="hljs-comment">// Non-lazily realize the class below.</span><br>                resolvedFutureClasses = (Class *)<br>                    realloc(resolvedFutureClasses,<br>                            (resolvedFutureClassCount+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(Class));<br>                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover classes&quot;</span>);<br><br>    <span class="hljs-comment">// Fix up remapped classes</span><br>    <span class="hljs-comment">// Class list and nonlazy class list remain unremapped.</span><br>    <span class="hljs-comment">// Class refs and super refs are remapped for message dispatching.</span><br><br>    <span class="hljs-keyword">if</span> (!noClassesRemapped()) &#123;<br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                remapClassRef(&amp;classrefs[i]);<br>            &#125;<br>            <span class="hljs-comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span><br>            classrefs = _getObjc2SuperRefs(hi, &amp;count);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                remapClassRef(&amp;classrefs[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: remap classes&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_FIXUP</span><br>    <span class="hljs-comment">// Fix up old objc_msgSend_fixup call sites</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (PrintVtables) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot;</span><br>                         <span class="hljs-string">&quot;call sites in %s&quot;</span>, count, hi-&gt;fname());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            fixupMessageRef(refs+i);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up objc_msgSend_fixup&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><br>    <span class="hljs-comment">// Discover protocols. Fix up protocol refs.</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;<br>        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;<br>        ASSERT(cls);<br>        NXMapTable *protocol_map = protocols();<br>        <span class="hljs-keyword">bool</span> isPreoptimized = hi-&gt;hasPreoptimizedProtocols();<br><br>        <span class="hljs-comment">// Skip reading protocols if this is an image from the shared cache</span><br>        <span class="hljs-comment">// and we support roots</span><br>        <span class="hljs-comment">// Note, after launch we do need to walk the protocol as the protocol</span><br>        <span class="hljs-comment">// in the shared cache is marked with isCanonical() and that may not</span><br>        <span class="hljs-comment">// be true if some non-shared cache binary was chosen as the canonical</span><br>        <span class="hljs-comment">// definition</span><br>        <span class="hljs-keyword">if</span> (launchTime &amp;&amp; isPreoptimized) &#123;<br>            <span class="hljs-keyword">if</span> (PrintProtocols) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;PROTOCOLS: Skipping reading protocols in image: %s&quot;</span>,<br>                             hi-&gt;fname());<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">bool</span> isBundle = hi-&gt;isBundle();<br><br>        protocol_t * <span class="hljs-keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            readProtocol(protolist[i], cls, protocol_map,<br>                         isPreoptimized, isBundle);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover protocols&quot;</span>);<br><br>    <span class="hljs-comment">// Fix up @protocol references</span><br>    <span class="hljs-comment">// Preoptimized images may have the right</span><br>    <span class="hljs-comment">// answer already but we don&#x27;t know for sure.</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-comment">// At launch time, we know preoptimized image refs are pointing at the</span><br>        <span class="hljs-comment">// shared cache definition of a protocol.  We can skip the check on</span><br>        <span class="hljs-comment">// launch, but have to visit @protocol refs for shared cache images</span><br>        <span class="hljs-comment">// loaded later.</span><br>        <span class="hljs-keyword">if</span> (launchTime &amp;&amp; hi-&gt;isPreoptimized())<br>            <span class="hljs-keyword">continue</span>;<br>        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            remapProtocolRef(&amp;protolist[i]);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);<br><br>    <span class="hljs-comment">// Discover categories. Only do this after the initial category</span><br>    <span class="hljs-comment">// attachment has been done. For categories present at startup,</span><br>    <span class="hljs-comment">// discovery is deferred until the first load_images call after</span><br>    <span class="hljs-comment">// the call to _dyld_objc_notify_register completes. rdar://problem/53119145</span><br>    <span class="hljs-keyword">if</span> (didInitialAttachCategories) &#123;<br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            load_categories_nolock(hi);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover categories&quot;</span>);<br><br>    <span class="hljs-comment">// Category discovery MUST BE Late to avoid potential races</span><br>    <span class="hljs-comment">// when other threads call the new category code before</span><br>    <span class="hljs-comment">// this thread finishes its fixups.</span><br><br>    <span class="hljs-comment">// +load handled by prepare_load_methods()</span><br><br>    <span class="hljs-comment">// Realize non-lazy classes (for +load methods and static instances)</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        classref_t <span class="hljs-keyword">const</span> *classlist = hi-&gt;nlclslist(&amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            Class cls = remapClass(classlist[i]);<br>            <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">continue</span>;<br><br>            addClassTableEntry(cls);<br><br>            <span class="hljs-keyword">if</span> (cls-&gt;isSwiftStable()) &#123;<br>                <span class="hljs-keyword">if</span> (cls-&gt;swiftMetadataInitializer()) &#123;<br>                    _objc_fatal(<span class="hljs-string">&quot;Swift class %s with a metadata initializer &quot;</span><br>                                <span class="hljs-string">&quot;is not allowed to be non-lazy&quot;</span>,<br>                                cls-&gt;nameForLogging());<br>                &#125;<br>                <span class="hljs-comment">// fixme also disallow relocatable classes</span><br>                <span class="hljs-comment">// We can&#x27;t disallow all Swift classes because of</span><br>                <span class="hljs-comment">// classes like Swift.__EmptyArrayStorage</span><br>            &#125;<br>            realizeClassWithoutSwift(cls, <span class="hljs-literal">nil</span>);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);<br><br>    <span class="hljs-comment">// Realize newly-resolved future classes, in case CF manipulates them</span><br>    <span class="hljs-keyword">if</span> (resolvedFutureClasses) &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;<br>            Class cls = resolvedFutureClasses[i];<br>            <span class="hljs-keyword">if</span> (cls-&gt;isSwiftStable()) &#123;<br>                _objc_fatal(<span class="hljs-string">&quot;Swift class is not allowed to be future&quot;</span>);<br>            &#125;<br>            realizeClassWithoutSwift(cls, <span class="hljs-literal">nil</span>);<br>            cls-&gt;setInstancesRequireRawIsaRecursively(<span class="hljs-literal">false</span><span class="hljs-comment">/*inherited*/</span>);<br>        &#125;<br>        free(resolvedFutureClasses);<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: realize future classes&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (DebugNonFragileIvars) &#123;<br>        realizeAllClasses();<br>    &#125;<br><br><br>    <span class="hljs-comment">// Print preoptimization statistics</span><br>    <span class="hljs-keyword">if</span> (PrintPreopt) &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PreoptTotalMethodLists;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PreoptOptimizedMethodLists;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PreoptTotalClasses;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PreoptOptimizedClasses;<br><br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            <span class="hljs-keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: honoring preoptimized selectors &quot;</span><br>                             <span class="hljs-string">&quot;in %s&quot;</span>, hi-&gt;fname());<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hi-&gt;info()-&gt;optimizedByDyld()) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: IGNORING preoptimized selectors &quot;</span><br>                             <span class="hljs-string">&quot;in %s&quot;</span>, hi-&gt;fname());<br>            &#125;<br><br>            classref_t <span class="hljs-keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                Class cls = remapClass(classlist[i]);<br>                <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">continue</span>;<br><br>                PreoptTotalClasses++;<br>                <span class="hljs-keyword">if</span> (hi-&gt;hasPreoptimizedClasses()) &#123;<br>                    PreoptOptimizedClasses++;<br>                &#125;<br><br>                <span class="hljs-keyword">const</span> method_list_t *mlist;<br>                <span class="hljs-keyword">if</span> ((mlist = cls-&gt;bits.safe_ro()-&gt;baseMethods)) &#123;<br>                    PreoptTotalMethodLists++;<br>                    <span class="hljs-keyword">if</span> (mlist-&gt;isFixedUp()) &#123;<br>                        PreoptOptimizedMethodLists++;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((mlist = cls-&gt;ISA()-&gt;bits.safe_ro()-&gt;baseMethods)) &#123;<br>                    PreoptTotalMethodLists++;<br>                    <span class="hljs-keyword">if</span> (mlist-&gt;isFixedUp()) &#123;<br>                        PreoptOptimizedMethodLists++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: %zu selector references not &quot;</span><br>                     <span class="hljs-string">&quot;pre-optimized&quot;</span>, UnfixedSelectors);<br>        _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted&quot;</span>,<br>                     PreoptOptimizedMethodLists, PreoptTotalMethodLists,<br>                     PreoptTotalMethodLists<br>                     ? <span class="hljs-number">100.0</span>*PreoptOptimizedMethodLists/PreoptTotalMethodLists<br>                     : <span class="hljs-number">0.0</span>);<br>        _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered&quot;</span>,<br>                     PreoptOptimizedClasses, PreoptTotalClasses,<br>                     PreoptTotalClasses<br>                     ? <span class="hljs-number">100.0</span>*PreoptOptimizedClasses/PreoptTotalClasses<br>                     : <span class="hljs-number">0.0</span>);<br>        _objc_inform(<span class="hljs-string">&quot;PREOPTIMIZATION: %zu protocol references not &quot;</span><br>                     <span class="hljs-string">&quot;pre-optimized&quot;</span>, UnfixedProtocolReferences);<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> EACH_HEADER</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>主要流程如下：<ol>
<li>静态变量<code>doneOnce</code>,控制只加载一次，这里主要的工作时初始化<strong>类映射表</strong><code>gdb_objc_realized_classes</code>以及重新初始化<code>TaggePointer</code>环境</li>
<li>修复预编译阶段的<code>@selector</code>的混乱问题,方法列表(从mach-o中拿到的，一般是使用过的方法，并且不会重复,就是类不同，但方法名一样也只会在mach-o中出现一次)和注册时不同的，重新修复</li>
<li>开始遍历头文件，进行类与元类的读取操作并标记(旧类改动后会生成新的类，并重映射到新的类上),主要的方法是<code>readClass</code>,其内部<ul>
<li>找不到该类的父类，可能是弱绑定，直接返回<code>nil</code></li>
<li>找到类了，判断这个类是否是一个<code>future</code>的类(可以理解为需要实现的一个类，也可以理解为这个类是否有变化)，如果有变化则创建新类，并把旧类的数据拷贝一份然后赋值给新类<code>newCls</code>，然后调用<code>addRemappedClass</code>进行重映射，用新的类替换掉旧的类，并返回新类<code>newCls</code>的地址</li>
<li>找到类了，如果类没有任何变化，则不进行任何操作，直接返回<code>class</code></li>
<li>期间会将类的信息加入<code>NXMapTable</code>(类映射表)和<code>objc::allocatedClasses</code>(所有类的表,这个表在<code>runtime_init</code>时初始化的)<ul>
<li><code>addNamedClass</code>,<code>key</code>是<code>类名</code>，<code>value</code>是<code>Class</code>,哈希表结构</li>
<li><code>addClassTableEntry</code>,直接将<code>Class</code>和其元类加入<code>objc::allocatedClasses</code>类似<code>set</code>中，会通过这个来判断是否是<code>isKnownClass</code></li>
</ul>
</li>
<li><code>readClass</code>会返回一个类，这里会判断，类表中的类和<code>readClass</code>生成的新类是否相等，如果不等，且认为新类，该类认为是<code>Future</code>类（在镜像加载之前就存在的类，需要重新映射，这个类有变化）</li>
</ul>
</li>
<li>修复重映射⼀些没有被镜像⽂件加载进来的类,主要方法<code>remapClassRef</code></li>
<li>修复⼀些旧的<code>objc</code>方法,在方法<code>fixupMessageRef</code>，类似<code>alloc</code>、<code>allocWithZone:</code>、<code>retain</code>、<code>release</code>、<code>autorelease</code>、<code>objc_msgSendSuper2_fixup</code>等一些方法，会重写赋值新的<code>imp</code>。在调试发现，并未触发，显然是对旧版本方法的修复</li>
<li>找到所有的协议<code>protocols</code>，和3类似，主要方法是<code>readProtocol</code>,会将协议加载到一个<code>NXMapTable</code>的映射表中，这里如果声明的协议没有使用，是不会加入的</li>
<li>和4类似，重映射没有从镜像中加载的协议，主要方法<code>remapProtocolRef</code></li>
<li>分类处理，将分类合并到类中。<strong>注意</strong>,这里的合并操作，是在真正的分类合并操作完成之后（也就是在<code>load_images</code>内），才能进行合并，一般情况下，并不会执行</li>
<li>对类中有<code>+load</code>存在的,即非懒加载类（有<code>+load</code>的类）,加入到所有类的表中，并进行加载<code>realizeClassWithoutSwift</code>。的作用是，<code>对类 cls 进行首次初始化，包括分配其读写数据。不执行任何 Swift 端初始化。返回该类的真实类结构</code>。</li>
<li>对3中得到的<code>FutureClasses</code>重新映射</li>
</ol>
</li>
</ul>
<h4 id="realizeClassWithoutSwift-源码"><a href="#realizeClassWithoutSwift-源码" class="headerlink" title="realizeClassWithoutSwift 源码"></a>realizeClassWithoutSwift 源码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)<br>&#123;<br>    lockdebug::assert_locked(&amp;runtimeLock);<br><br>      class_rw_t *rw;<br>      Class supercls;<br>      Class metacls;<br><br>        <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        <span class="hljs-keyword">if</span> (cls-&gt;isRealized()) &#123;<br>            validateAlreadyRealizedClass(cls);<br>            <span class="hljs-keyword">return</span> cls;<br>    &#125;<br>     ASSERT(cls == remapClass(cls));<br><br>     <span class="hljs-comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span><br><br>     auto ro = cls-&gt;safe_ro(); <span class="hljs-comment">// 读取类的数据</span><br>     auto isMeta = ro-&gt;flags &amp; RO_META;<br>     <span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;  <span class="hljs-comment">// rw已经有值的话走这里</span><br>    <span class="hljs-comment">// This was a future class. rw data is already allocated.</span><br>      rw = cls-&gt;data();<br>      ro = cls-&gt;data()-&gt;ro();<br>      ASSERT(!isMeta);<br>       cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 正常的类走这里</span><br>      <span class="hljs-comment">// Normal class. Allocate writeable class data.</span><br>       rw = objc::zalloc&lt;class_rw_t&gt;();<br>       rw-&gt;set_ro(ro);<br>       rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;<br>       cls-&gt;setData(rw);<br>  &#125;<br><br>  cls-&gt;cache.initializeToEmptyOrPreoptimizedInDisguise();<br><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> FAST_CACHE_META</span><br>  <span class="hljs-keyword">if</span> (isMeta) cls-&gt;cache.setBit(FAST_CACHE_META);<br> <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-comment">// Choose an index for this class.</span><br> <span class="hljs-comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are         available</span><br> cls-&gt;chooseClassArrayIndex();<br>    <br> <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>      _objc_inform(<span class="hljs-string">&quot;CLASS: realizing class &#x27;%s&#x27;%s %p %p #%u %s%s&quot;</span>,<br>             cls-&gt;nameForLogging(), isMeta ? <span class="hljs-string">&quot; (meta)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>             (<span class="hljs-keyword">void</span>*)cls, ro, cls-&gt;classArrayIndex(),<br>             cls-&gt;isSwiftStable() ? <span class="hljs-string">&quot;(swift)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>             cls-&gt;isSwiftLegacy() ? <span class="hljs-string">&quot;(pre-stable swift)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br> &#125;<br><br> <span class="hljs-comment">// Realize superclass and metaclass, if they aren&#x27;t already.</span><br>  <span class="hljs-comment">//实现超类和元类（如果尚未实现）。</span><br>  <span class="hljs-comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span><br>  <span class="hljs-comment">//对于根类，需要在上面设置了RW_REALIZED之后执行此操作。</span><br> <span class="hljs-comment">// This needs to be done after class index is chosen, for root metaclasses.</span><br> <span class="hljs-comment">//对于根元类，需要在选择类索引之后执行此操作。</span><br>  <span class="hljs-comment">// This assumes that none of those classes have Swift contents,</span><br>  <span class="hljs-comment">//   or that Swift&#x27;s initializers have already been called.</span><br>  <span class="hljs-comment">//   fixme that assumption will be wrong if we add support</span><br>  <span class="hljs-comment">//   for ObjC subclasses of Swift classes.</span><br>  <span class="hljs-comment">// 递归调用 realizeClassWithoutSwift ，实现父类和元类</span><br>  supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), <span class="hljs-literal">nil</span>);<br> metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), <span class="hljs-literal">nil</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span><br>  <span class="hljs-keyword">if</span> (isMeta) &#123; <span class="hljs-comment">// 如果是元类，对isa处理</span><br>        <span class="hljs-comment">// Metaclasses do not need any features from non pointer ISA</span><br>     <span class="hljs-comment">// This allows for a faspath for classes in objc_retain/           objc_release.</span><br>        cls-&gt;setInstancesRequireRawIsa();<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 不是元类，也是对isa处理</span><br>      <span class="hljs-comment">// Disable non-pointer isa for some classes and/or platforms.</span><br>       <span class="hljs-comment">// Set instancesRequireRawIsa.</span><br>       <span class="hljs-keyword">bool</span> instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();<br>       <span class="hljs-keyword">bool</span> rawIsaIsInherited = <span class="hljs-literal">false</span>;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> hackedDispatch = <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-keyword">if</span> (DisableNonpointerIsa) &#123;<br>            <span class="hljs-comment">// Non-pointer isa disabled by environment or app SDK version</span><br>         instancesRequireRawIsa = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="hljs-number">0</span> == strcmp(ro-&gt;getName(),  <span class="hljs-string">&quot;OS_object&quot;</span>))<br>       &#123;<br>         <span class="hljs-comment">// hack for libdispatch et al - isa also acts as vtable pointer</span><br>         hackedDispatch = <span class="hljs-literal">true</span>;<br>            instancesRequireRawIsa = <span class="hljs-literal">true</span>;<br>     &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;getSuperclass()  &amp;&amp;<br>                 supercls-&gt;instancesRequireRawIsa())<br>     &#123;<br>            <span class="hljs-comment">// This is also propagated by addSubclass()</span><br>           <span class="hljs-comment">// but nonpointer isa setup needs it earlier.</span><br>           <span class="hljs-comment">// Special case: instancesRequireRawIsa does not propagate</span><br>            <span class="hljs-comment">// from root class to root metaclass</span><br>            instancesRequireRawIsa = <span class="hljs-literal">true</span>;<br>            rawIsaIsInherited = <span class="hljs-literal">true</span>;<br>      &#125;<br><br>        <span class="hljs-keyword">if</span> (instancesRequireRawIsa) &#123;<br>            cls-&gt;setInstancesRequireRawIsaRecursively(rawIsaIsInherited);<br>       &#125;<br> &#125;<br><span class="hljs-comment">// SUPPORT_NONPOINTER_ISA</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br> <span class="hljs-comment">// Update superclass and metaclass in case of remapping</span><br> <span class="hljs-comment">// 确定继承链，赋值父类和元类</span><br>    cls-&gt;setSuperclass(supercls);<br>    cls-&gt;initClassIsa(metacls);<br>    <span class="hljs-comment">// 协调实例变量的偏移量/布局。</span><br>    <span class="hljs-comment">// Reconcile instance variable offsets / layout.</span><br>    <span class="hljs-comment">// This may reallocate class_ro_t, updating our ro variable.</span><br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);<br>    <span class="hljs-comment">// 经过上一步，再次协调属性对齐后，设置实例大小</span><br>    <span class="hljs-comment">// Set fastInstanceSize if it wasn&#x27;t set already.</span><br>    cls-&gt;setInstanceSize(ro-&gt;instanceSize);<br>    <span class="hljs-comment">// 赋值一些 ro 中的 flags标识位 到 rw</span><br>    <span class="hljs-comment">// Copy some flags from ro to rw</span><br>    <span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;<br>        cls-&gt;setHasCxxDtor();<br>        <span class="hljs-keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;<br>            cls-&gt;setHasCxxCtor();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Propagate the associated objects forbidden flag from ro or from</span><br>    <span class="hljs-comment">// the superclass.</span><br>    <span class="hljs-comment">// 从ro或父类传播关联的对象禁止标志。</span><br>    <span class="hljs-keyword">if</span> ((ro-&gt;flags &amp; RO_FORBIDS_ASSOCIATED_OBJECTS) ||<br>        (supercls &amp;&amp; supercls-&gt;forbidsAssociatedObjects()))<br>    &#123;<br>        rw-&gt;flags |= RW_FORBIDS_ASSOCIATED_OBJECTS;<br>    &#125;<br><br>    <span class="hljs-comment">// Connect this class to its superclass&#x27;s subclass lists</span><br>    <span class="hljs-comment">// 添加当前类到父类的子类列表中，如果没有父类，设置自己就是根类</span><br>    <span class="hljs-keyword">if</span> (supercls) &#123;<br>        addSubclass(supercls, cls);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addRootClass(cls);<br>    &#125;<br><br>    <span class="hljs-comment">// Attach categories</span><br>    methodizeClass(cls, previously);<br><br>    <span class="hljs-keyword">return</span> cls;<br>    &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>非懒加载的类的<code>realizeClassWithoutSwift</code>是在<code>map_images</code>是实现的，而懒加载类则是在,第一次使用该类时，调用相关<code>objc_msgSend</code>方法时调用。（代码中不使用的类，则会回加载解析）</li>
<li><code>methodizeClass</code>方法，修复 cls 的方法列表，协议列表和属性列表，将类<code>class_ro_t</code>中的方法添加到<code>class_rw_t</code>中来  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> methodizeClass(Class cls, Class previously)<br>    &#123;<br>        runtimeLock.assertLocked();<br>    <br>        <span class="hljs-keyword">bool</span> isMeta = cls-&gt;isMetaClass();<br>        auto rw = cls-&gt;data();<br>        auto ro = rw-&gt;ro(); <span class="hljs-comment">// 读取ro数据</span><br>        auto rwe = rw-&gt;ext(); <span class="hljs-comment">// 读取ext，赋值给rwe</span><br>    <br>        <span class="hljs-comment">// Methodizing for the first time</span><br>        <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;CLASS: methodizing class &#x27;%s&#x27; %s&quot;</span>, <br>                         cls-&gt;nameForLogging(), isMeta ? <span class="hljs-string">&quot;(meta)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    <br>        <span class="hljs-comment">// Install methods and properties that the class implements itself.</span><br>        method_list_t *list = ro-&gt;baseMethods(); <span class="hljs-comment">// 获取ro中的方法列表</span><br>        <span class="hljs-keyword">if</span> (list) &#123;<br>            <span class="hljs-comment">// 对方法列表list重新排序</span><br>            prepareMethodLists(cls, &amp;list, <span class="hljs-number">1</span>, <span class="hljs-literal">YES</span>,  isBundleClass(cls));<br>            <span class="hljs-keyword">if</span> (rwe) rwe-&gt;methods.attachLists(&amp;list, <span class="hljs-number">1</span>); <span class="hljs-comment">// 如果有rwe，添加方法列表list到rwe的methodsList</span><br>        &#125;<br>    <br>        property_list_t *proplist = ro-&gt;baseProperties;<br>        <span class="hljs-keyword">if</span> (rwe &amp;&amp; proplist) &#123;<br>            rwe-&gt;properties.attachLists(&amp;proplist, <span class="hljs-number">1</span>);<br>        &#125;<br>    <br>        protocol_list_t *protolist = ro-&gt;baseProtocols;<br>        <span class="hljs-keyword">if</span> (rwe &amp;&amp; protolist) &#123;<br>            rwe-&gt;protocols.attachLists(&amp;protolist, <span class="hljs-number">1</span>);<br>        &#125;<br>    <br>        <span class="hljs-comment">// Root classes get bonus method implementations if they don&#x27;t have </span><br>        <span class="hljs-comment">// them already. These apply before category replacements.</span><br>        <span class="hljs-keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;<br>            <span class="hljs-comment">// root metaclass 根元类添加initialize方法</span><br>            addMethod(cls, <span class="hljs-keyword">@selector</span>(initialize), (IMP)&amp;objc_noop_imp, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">NO</span>);<br>        &#125;<br>    <br>        <span class="hljs-comment">// Attach categories. 附加分类</span><br>        <span class="hljs-keyword">if</span> (previously) &#123;<br>            <span class="hljs-keyword">if</span> (isMeta) &#123;<br>                objc::unattachedCategories.attachToClass(cls, previously,<br>                                                         ATTACH_METACLASS);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// When a class relocates, categories with class methods</span><br>                <span class="hljs-comment">// may be registered on the class itself rather than on</span><br>                <span class="hljs-comment">// the metaclass. Tell attachToClass to look for those.</span><br>                objc::unattachedCategories.attachToClass(cls, previously,<br>                                                         ATTACH_CLASS_AND_METACLASS);<br>            &#125;<br>        &#125;<br>        objc::unattachedCategories.attachToClass(cls, cls,<br>                                                 isMeta ? ATTACH_METACLASS : ATTACH_CLASS);<br>    <br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG</span><br>        <span class="hljs-comment">// Debug: sanity-check all SELs; log method list contents</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> auto&amp; meth : rw-&gt;methods()) &#123;<br>            <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;METHOD %c[%s %s]&quot;</span>, isMeta ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                             cls-&gt;nameForLogging(), sel_getName(meth.name));<br>            &#125;<br>            ASSERT(sel_registerName(sel_getName(meth.name)) == meth.name); <br>&#125;<br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>     &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>懒加载类以及分类的加载</title>
    <url>/2022/12/26/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E4%BB%A5%E5%8F%8A%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li>官方在对类进行处理的时候, 为了提高对类处理的效率以及性能, 就对类进行了识别, 当类需要使用的时候, 系统才会对类进行实现. 如果没有使用就不会实现. 当需要实现才进行加载的类就被称为懒加载类. 反之无论是否使用到这个类, 都对这个类进行加载的类就被称为非懒加载类</li>
<li>懒加载类和非懒加载类的区别在于是否实现了<code>+(void)load</code>方法</li>
<li>所有的类在使用前都会调用<code>realizeClassMaybeSwiftAndLeaveLocked</code>对类进行加载,通过这个来判断类和分类加载的时机</li>
</ul>
</blockquote>
<span id="more"></span>
<h3 id="验证的方式"><a href="#验证的方式" class="headerlink" title="验证的方式"></a>验证的方式</h3><blockquote>
<p>定义两个类<code>LGPerson</code>和<code>LGPerson(Text)</code>,在<code>load_categories_nolock</code><br>和<code>realizeClassWithoutSwift</code>源码中加入以下代码:</p>
</blockquote>
<ul>
<li>分类<code>load_categories_nolock</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//加载分类的地方<br>static void load_categories_nolock(header_info *hi) &#123;<br>    bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();<br><br>    size_t count;<br>    auto processCatlist = [&amp;](category_t * const *catlist) &#123;<br>        for (unsigned i = 0; i &lt; count; i++) &#123;<br>            category_t *cat = catlist[i];<br>            Class cls = remapClass(cat-&gt;cls);<br>            locstamped_category_t lc&#123;cat, hi&#125;;<br>            const char * sd = &quot;LGPerson&quot;;<br>            if (strcmp(sd, cls-&gt;mangledName()) == 0) &#123;<br>                printf(&quot;定位到了&quot;);<br>            &#125;<br>        ....<br></code></pre></td></tr></table></figure></li>
<li>类加载<code>realizeClassWithoutSwift</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">static Class realizeClassWithoutSwift(Class cls, Class previously)<br>&#123;<br>    lockdebug::assert_locked(&amp;runtimeLock);<br><br>    class_rw_t *rw;<br>    Class supercls;<br>    Class metacls;<br>      <br>    <br>    if (!cls) return nil;<br>    const char * sd = &quot;LGPerson&quot;;<br>    if (strcmp(sd, cls-&gt;mangledName()) == 0) &#123;<br>        printf(&quot;定位到了&quot;);<br>    &#125;<br>    if (cls-&gt;isRealized()) &#123;<br>        validateAlreadyRealizedClass(cls);<br>        return cls;<br>    &#125;<br>    .....<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="懒加载类和分类"><a href="#懒加载类和分类" class="headerlink" title="懒加载类和分类"></a>懒加载类和分类</h3><blockquote>
<p>查看懒加载类和分类的加载时机</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[[LGPerson alloc] init]<br></code></pre></td></tr></table></figure>
<h4 id="加载的时机"><a href="#加载的时机" class="headerlink" title="加载的时机"></a>加载的时机</h4><ol>
<li><p>第一次断点</p>
<ul>
<li>通过断点查看,显然懒加载类是在第一次调用类相关方法的时候，才会去加载类,首先会调用类方法<br><img src="1.png"></li>
<li><code>lldb</code>查看<code>class_ro_t</code>中的代码,首先调用的是<code>[LGPerson alloc]</code>，会先加载元类，并且从方法可知，<code>class_ro_t</code>中存放有分类的方法，<code>class_ro_t</code>从一开始是不能变的，显然分类中的方法，在编译期间，就加载到原始类的方法中了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(lldb) p ro.baseMethods<br>(const WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt;) $2 = &#123;<br>  ptr = 0x00000001000083f0<br>&#125;<br>  <br>(lldb) p $2[0]<br>(method_list_t) $3 = &#123;<br>  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; = (entsizeAndFlags = 24, count = 1)<br>&#125;<br>(lldb) p $3.get(0).big<br>(method_t::big) $4 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f3e &quot;v16@0:8&quot;<br>  imp = 0x00000001000037f0 (KCObjcBuild`+[LGPerson(Text) textCategory])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第二次断点</p>
<ul>
<li><p>通过断点查看<br><img src="2.png"></p>
</li>
<li><p><code>lldb</code>查看<code>class_ro_t</code>中的代码，这里会调用<code>init</code>,是当前的实例方法，指向<code>LGPerson</code>。同样从其内存中也可发现分类中的方法一开始就在<code>class_ro_t</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">    p ro.baseMethods<br>(const WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt;) $6 = &#123;<br>  ptr = 0x0000000100008410<br>&#125;<br>  <br>(lldb) p $6[0]<br>(method_list_t) $7 = &#123;<br>  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; = (entsizeAndFlags = 24, count = 17)<br>&#125;<br>(lldb) p $6[0].get(0).big<br>(method_t::big) $8 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f3e &quot;v16@0:8&quot;<br>  imp = 0x0000000100003820 (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br> <br>(lldb) p $6[0].get(1).big<br>(method_t::big) $9 = &#123;<br>  name = &quot;text1&quot;<br>  types = 0x0000000100003f3e &quot;v16@0:8&quot;<br>  imp = 0x0000000100003880 (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第三次断点</p>
<ul>
<li>第三次断点，会去查找元类，由于元类已经初始化，会直接返回。且，整个过程中会不会触发，<code>load_categories_nolock</code>断点。</li>
</ul>
</li>
<li><p>查看加载完成类中的<code>class_rw_t</code>方法，分类方法和类方法，均在<code>class_rw_t</code>的第一张表内，而非分开存放，显然是一开始均在<code>class_ro_t</code>,因此均在二维表<code>class_rw_t</code>的第一张内</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(lldb) p (objc_class *)cls<br>(objc_class *) $0 = 0x0000000100008600<br>(lldb) p $0-&gt;data()<br>(class_rw_t *) $1 = 0x00006000002349a0<br>(lldb) p $1-&gt;methods()<br>(const method_array_t) $2 = &#123;<br>    list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; = &#123;<br>         = &#123;<br>          list = &#123;<br>            ptr = 0x0000000100008410<br>          &#125;<br>          arrayAndFlag = 4295001104<br>        &#125;<br>      &#125;<br>    &#125;<br>    (lldb) p $2.list[0]<br>(method_list_t) $3 = &#123;<br>entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; = (entsizeAndFlags = 27, count = 17)<br>&#125;<br>(lldb) p $2.list[0].get(0).big<br>(method_t::big) $4 = &#123;<br>    name = &quot;textCategory&quot;<br>    types = 0x0000000100003f44 &quot;v16@0:8&quot;<br>    imp = 0x0000000100003820 (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br>(lldb) p $2.list[0].get(1).big<br>(method_t::big) $5 = &#123;<br>    name = &quot;text1&quot;<br>    types = 0x0000000100003f44 &quot;v16@0:8&quot;<br>    imp = 0x0000000100003880 (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>(lldb) p $2.list[1].get(0).big<br>(method_t::big) $6 = &#123;<br>    name = &quot;v16@0:8&quot;<br>    types = 0x0000000100003820 &quot;UH\x89\xe5H\x83\xec\U00000010H\x89&#125;\xf0H\x89u\xf8H\x8d=\x89\b&quot;<br>    imp = 0x0000000100003e33 (&quot;text1&quot;)<br>&#125;<br>(lldb) p $2.list[2].get(0).big<br>(method_t::big) $7 = &#123;<br>name = &quot;UH\x89\xe5H\x83\xec\U00000010H\x89&#125;\xf0H\x89u\xf8H\x8d=\x89\b&quot;<br>types = 0x0000000100003e33 &quot;text1&quot;<br>    imp = 0x0000000100003f44 (&quot;v16@0:8&quot;)<br>&#125;<br>(lldb)<br></code></pre></td></tr></table></figure></li>
<li><p>总结</p>
<blockquote>
<p>懒加载中的类和分类，在方法初始化的时候才会去,调用<code>realizeClassWithoutSwift</code>,加载类;<br>懒加载类中的分类方法，一开始就在类的<code>class_ro_t</code>中类，即类加载之前。表明在编译的时候就加到类中了。整个过程中不会去调用<code>load_categories_nolock</code>(将分类方法加到类中)。</p>
</blockquote>
</li>
</ol>
<h3 id="非懒加载类和懒加载分类"><a href="#非懒加载类和懒加载分类" class="headerlink" title="非懒加载类和懒加载分类"></a><span id="jump">非懒加载类和懒加载分类</span></h3><blockquote>
<p>类中实现load方法，分类中不实现。上述一样的排查方式</p>
</blockquote>
<h4 id="加载的时机-1"><a href="#加载的时机-1" class="headerlink" title="加载的时机"></a>加载的时机</h4><ol>
<li><p>第一次断点</p>
<ul>
<li>通过断点查看,显然在<code>runtime</code>启动的时候，在<code>read_images</code>时，对所有的非懒加载类，进行了加载，并且先加载的时候类，而非元类<br><img src="3.png"></li>
<li><code>lldb</code>查看此时类中<code>class_ro_t</code>中的方法可知,懒加载分类中的方法，一开始就在类中，并在编译的时候就确定了<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(lldb) p ro.baseMethods[0].get(0).big()<br>   (method_t::big) $4 = &#123;<br>     name = &quot;textCategory2&quot;<br>     types = 0x0000000100003f47 &quot;v16@0:8&quot;<br>     imp = 0x0000000100003770 (KCObjcBuild`-[LGPerson(Text2) textCategory2])<br>   &#125;<br>     <br>   (lldb) p ro.baseMethods[0].get(1).big()<br>   (method_t::big) $5 = &#123;<br>     name = &quot;textCategory&quot;<br>     types = 0x0000000100003f47 &quot;v16@0:8&quot;<br>     imp = 0x00000001000037d0 (KCObjcBuild`-[LGPerson(Text) textCategory])<br>   &#125;<br>    <br>   (lldb) p ro.baseMethods[0].get(2).big()<br>   (method_t::big) $6 = &#123;<br>     name = &quot;text1&quot;<br>     types = 0x0000000100003f47 &quot;v16@0:8&quot;<br>     imp = 0x0000000100003830 (KCObjcBuild`-[LGPerson text1])<br>   &#125;<br>     <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第二次断点，会去加载元类，且从<code>lldb</code>查看，元类中的<code>class_ro_t</code>中，同样一开始就有分类中的方法，表明在编译的时候，分类方法就加载到类中了</p>
</li>
<li><p>总结</p>
<blockquote>
<p>非懒加载中的类和懒加载分类，在<code>runtime</code>初始化的时候,在<code>read_images</code>时,调用<code>realizeClassWithoutSwift</code>加载类;<br>懒加载分类中的方法，一开始就在非懒加类的<code>class_ro_t</code>中类，即类加载之前。表明在编译的时候就加到类中了。整个过程中不会去调用<code>load_categories_nolock</code>(将分类方法加到类中)。</p>
</blockquote>
</li>
</ol>
<h3 id="懒加载类和非懒加载分类"><a href="#懒加载类和非懒加载分类" class="headerlink" title="懒加载类和非懒加载分类"></a>懒加载类和非懒加载分类</h3><blockquote>
<p>分类中实现load方法，类中不实现。上述一样的排查方式</p>
</blockquote>
<h4 id="一个懒加载分类"><a href="#一个懒加载分类" class="headerlink" title="一个懒加载分类"></a>一个懒加载分类</h4><blockquote>
<p><code>LGPerson(Text)</code>分类中实现load方法,<code>LGPerson (Text2)</code>中不实现</p>
</blockquote>
<ol>
<li>第一次断点<ul>
<li>通过断点查看,和上一节一样,<code>runtime</code>启动的时候，在<code>read_images</code>时，对所有的非懒加载类，进行了加载。这里显然,懒加载的类由于非懒加载的分类，而变成了非懒加载类。一样先加载的是类，而非元类<br><img src="3.png"></li>
<li><code>lldb</code>查看<code>class_ro_t</code>中的方法，发现非懒加载分类<code>LGPerson(Text2)</code>和懒加载分类<code>LGPerson(Text)</code>中的方法，一开始就在懒加载类中，显然也是由编译的时候就加到类中了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"> (lldb) p ro.baseMethods[0].get(0).big()<br>(method_t::big) $8 = &#123;<br>  name = &quot;textCategory2&quot;<br>  types = 0x0000000100003f41 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003750 (KCObjcBuild`-[LGPerson(Text2) textCategory2])<br>&#125;<br>  <br>(lldb) p ro.baseMethods[0].get(1).big()<br>(method_t::big) $9 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f41 &quot;v16@0:8&quot;<br>  imp = 0x00000001000037e0 (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br><br>(lldb) p ro.baseMethods[0].get(2).big()<br>(method_t::big) $10 = &#123;<br>  name = &quot;text1&quot;<br>  types = 0x0000000100003f41 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003840 (KCObjcBuild`-[LGPerson text1])<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>第二次断点，会去加载元类，且从<code>lldb</code>查看，元类中的<code>class_ro_t</code>中，同样一开始就有分类中的方法，是在编译的时候，分类方法就加载到类中了</li>
<li>总结<blockquote>
<p>懒加载中的类和一个非懒加载分类，和<a href="#jump">非懒加载类和懒加载分类</a>中的表现一致。</p>
</blockquote>
</li>
</ol>
<h4 id="一个以上懒加载分类"><a href="#一个以上懒加载分类" class="headerlink" title="一个以上懒加载分类"></a><span id="jump1">一个以上懒加载分类</span></h4><blockquote>
<p><code>LGPerson(Text)</code>和<code>LGPerson (Text2)</code>分类中均实现load方法，<code>LGPerson (Text2)</code>分类中不实现</p>
</blockquote>
<ol>
<li><p>第一次断点</p>
<ul>
<li>在<code>load_images</code>时，<code>load_categories_nolock</code>加载所有分类时。其中<code>load_images</code>在<code>read_images</code>之后，并且之前并未有断点，显然，此时，类并未加载。<br><img src="4.png"></li>
<li><code>lldb</code>查看根据分类<code>remapClass</code>出的类，查看其中<code>class_ro_t</code>的方法,显然，最开始的类中不包含分类<code>LGPerson(Text)</code>、<code>LGPerson (Text2)</code>和<code>LGPerson (Text3)</code>的方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(lldb)  p (objc_class *)cls<br>    (objc_class *) $0 = 0x0000000100008778<br>(lldb) p $0.safe_ro()<br>    (const class_ro_t *) $1 = 0x0000000100008500<br>(lldb) p $1.baseMethods[0].get(0).big()<br>    (method_t::big) $2 = &#123;<br>      name = &quot;text1&quot;<br>      types = 0x0000000100003f39 &quot;v16@0:8&quot;<br>      imp = 0x0000000100003820 (KCObjcBuild`-[LGPerson text1])<br>    &#125;<br>(lldb) p $1.baseMethods[0].get(1).big()<br>    (method_t::big) $3 = &#123;<br>      name = &quot;text2&quot;<br>      types = 0x0000000100003f39 &quot;v16@0:8&quot;<br>      imp = 0x0000000100003850 (KCObjcBuild`-[LGPerson text2])<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看<code>category_t</code>中的方法，很显然是<code>LGPerson(Text)</code>,<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">    (lldb) p cat.instanceMethods[0].get(0).big()<br>(method_t::big) $4 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f43 &quot;v16@0:8&quot;<br>  imp = 0x00000001000037d0 (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br>  <br>(lldb) p cat.classMethods[0].get(0).big()<br>(method_t::big) $5 = &#123;<br>  name = &quot;load&quot;<br>  types = 0x0000000100003f43 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003770 (KCObjcBuild`+[LGPerson(Text) load])<br>&#125;<br>  <br>(lldb) p cat.classMethods[0].get(1).big()<br>(method_t::big) $6 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f43 &quot;v16@0:8&quot;<br>  imp = 0x00000001000037a0 (KCObjcBuild`+[LGPerson(Text) textCategory])<br>&#125;<br> <br>(lldb) <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第二,三次断点</p>
<ul>
<li>仍然在分类加载的循环中，一共有3个分类会，加载3次。</li>
<li><code>lldb</code>查看类的<code>class_ro_t</code>的方法,类<code>class_ro_t</code>并未发生任何改变,并且由于类未加载，<code>class_rw_t</code>还未生成。显然分类中的方法并未加载到类中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"> (lldb) p (objc_class *)cls<br>        (objc_class *) $10 = 0x0000000100008778<br> (lldb) p $10.safe_ro().baseMethods[0].get(0).big()<br>        (method_t::big) $11 = &#123;<br>          name = &quot;text1&quot;<br>          types = 0x0000000100003f39 &quot;v16@0:8&quot;<br>          imp = 0x0000000100003820 (KCObjcBuild`-[LGPerson text1])<br>        &#125;<br>          <br>(lldb) p $10.safe_ro().baseMethods[0].get(1).big()<br>        (method_t::big) $12 = &#123;<br>          name = &quot;text2&quot;<br>          types = 0x0000000100003f39 &quot;v16@0:8&quot;<br>          imp = 0x0000000100003850 (KCObjcBuild`-[LGPerson text2])<br>        &#125;<br>         <br>(lldb) <br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>查看<code>category_t</code>中的方法，第二次是<code>LGPerson(Text2)</code>,第三次是<code>LGPerson(Text3)</code></li>
<li>此外，没有加载的类，无法<code>attach分类方法</code>，会调用方法<code>objc::unattachedCategories.addForClass</code>方法。里面也有个<code>attachToClass</code>方法，在里面增加断点。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">if (cls-&gt;ISA()-&gt;isRealized()) &#123;<br>                attachCategories(cls-&gt;ISA(), &amp;lc, 1, ATTACH_EXISTING | ATTACH_METACLASS);<br>            &#125; else &#123;<br>                objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());<br>            &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>realizeClassWithoutSwift</code>中的断点</p>
<ul>
<li><p>在后续调用<code>prepare_load_methods</code>,加载所有分类中的<code>load</code>方法时，会调用<code>realizeClassWithoutSwift</code>开始加载类。和此前一样，先类，后元类。<br><img src="5.png"></p>
</li>
<li><p>在上面新增的断点<code>attachToClass</code>中触发了，这里是对元类方法对，分类方法进行添加<br>  <img src="6.png"></p>
</li>
<li><p><code>lldb</code>查看添加完后的<code>class_rw_t</code>,显然，元类中的分类的方法已经添加完毕</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(lldb)  p rw.methods.beginLists()[0][0]<br>(method_list_t) $3 = &#123;<br>  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; = (entsizeAndFlags = 27, count = 1)<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[0][0].get(0).big()<br>(method_t::big) $4 = &#123;<br>  name = &quot;textCategory3&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003670 (KCObjcBuild`+[LGPerson(Text3) textCategory3])<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[1][0].get(0).big()<br>(method_t::big) $5 = &#123;<br>  name = &quot;textCategory2&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003700 (KCObjcBuild`+[LGPerson(Text2) textCategory2])<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[2][0].get(0).big()<br>(method_t::big) $6 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003790 (KCObjcBuild`+[LGPerson(Text) textCategory])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
<li><p>接下来是类中的分类方法添加，<code>lldb</code>查看添加完后的<code>class_rw_t</code>,显然也添加完成了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">    (lldb) p rw.methods.beginLists()[0][0].get(0).big()<br>(method_t::big) $11 = &#123;<br>  name = &quot;textCategory3&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x00000001000036a0 (KCObjcBuild`-[LGPerson(Text3) textCategory3])<br>&#125;<br><br>(lldb) p rw.methods.beginLists()[1][0].get(0).big()<br>(method_t::big) $12 = &#123;<br>  name = &quot;textCategory2&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003730 (KCObjcBuild`-[LGPerson(Text2) textCategory2])<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[2][0].get(0).big()<br>(method_t::big) $13 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x00000001000037c0 (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br>  <br>(lldb) p rw.methods.beginLists()[3][0].get(0).big()<br>(method_t::big) $14 = &#123;<br>  name = &quot;text1&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003820 (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>总结</p>
<blockquote>
<ul>
<li>懒加载中的类和一个以上非懒加载分类，也就是<code>+load</code>方法超过1个,类不是非懒加载类，不会在<code>read_image</code>中加载，而是会在<code>load_image</code>中，加载所有分类时,<code>load_categories_nolock</code>,<code>remapClass</code>出类。</li>
<li><code>remapClass</code>出类后，并未进行加载，因此，此时不会将分类中的方法加载到类中，但会将分类加载到<code>objc::unattachedCategories</code>中，构建类和分类的映射表</li>
<li>在获取所有分类中的load方法<code>prepare_load_methods</code>时，会去加载分类对应的类方法，并在在加载时，会调用<code>objc::unattachedCategories:attachToClass</code>方法，在这里，将分类中的分类中的方法，加载到类中。</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="非懒加载类和非懒加载分类"><a href="#非懒加载类和非懒加载分类" class="headerlink" title="非懒加载类和非懒加载分类"></a>非懒加载类和非懒加载分类</h3><blockquote>
<p>分类中实现<code>load</code>方法，类中实现<code>load</code></p>
</blockquote>
<ol>
<li><p><code>read_images</code>断点</p>
<ul>
<li>非懒加载类，在<code>read_images</code>中，就进行<code>realize</code>，并且是，先元类，后类<br><img src="3.png"></li>
</ul>
</li>
<li><p><code>load_images</code>断点</p>
<ul>
<li><code>load_categories_nolock</code>,加载所有的分类，此时，类已经加载完成了，此时会将分类方法添加到类中<br><img src="4.png"></li>
<li><code>lldb</code>查看方法加载<ol>
<li><p>最开始加载的是<code>LGPerson(Text)</code>的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(lldb) p cat.instanceMethods[0].get(0).big()<br>    (method_t::big) $0 = &#123;<br>     name = &quot;textCategory&quot;<br>     types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>     imp = 0x0000000100003780 (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>LGPerson(Text)</code>分类方法，加载到类中</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(lldb) p $2-&gt;data()-&gt;methods().beginLists[0][0].get(0).big()<br>(method_t::big) $6 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003780 (KCObjcBuild`-[LGPerson(Text)        textCategory])<br>&#125;<br>  <br>(lldb) p $2-&gt;data()-&gt;methods().beginLists[1][0].get(0).big()<br>(method_t::big) $7 = &#123;<br>  name = &quot;text1&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x00000001000037e0 (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
<li><p>然后是<code>LGPerson(Text2)</code>分类方法，加载到类中</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(lldb) p $2-&gt;data()-&gt;methods().beginLists[0][0].get(0).big()<br>(method_t::big) $8 = &#123;<br>  name = &quot;textCategory2&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x00000001000036f0 (KCObjcBuild`-[LGPerson(Text2) textCategory2])<br>&#125;<br>  <br>(lldb) p $2-&gt;data()-&gt;methods().beginLists[1][0].get(0).big()<br>(method_t::big) $9 = &#123;<br>  name = &quot;textCategory&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x0000000100003780 (KCObjcBuild`-[LGPerson(Text) textCategory])<br>&#125;<br>  <br>(lldb) p $2-&gt;data()-&gt;methods().beginLists[2][0].get(0).big()<br>(method_t::big) $10 = &#123;<br>  name = &quot;text1&quot;<br>  types = 0x0000000100003f46 &quot;v16@0:8&quot;<br>  imp = 0x00000001000037e0 (KCObjcBuild`-[LGPerson text1])<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li>
<li><p>最后是<code>LGPerson(Text3)</code>分类方法，加载到类中，到此，分类中的方法加载完毕。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>总结</p>
<blockquote>
<ul>
<li>和<a href="#jump1">一个以上懒加载分类</a>不同，非懒加载类和分类，会先在<code>read_images</code>，加载类</li>
<li>在<code>load_images</code>的<code>load_categories_nolock</code>，将所有分类加载到类中</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>懒加载类和懒加载分类，分类中的方法在编译的时候就加载到类中，其方法在<code>class_ro_t</code>中；在使用类的时候才会去加载类，一般是触发<code>objc_msgsend</code>，发送消息时</li>
<li>非懒加载类和懒加载分类,分类中的方法在编译的时候就加载到类中，其方法在<code>class_ro_t</code>中;类的加载，在<code>runtime</code>启动时，即<code>read_image</code>中，进行加载</li>
<li>懒加载类和非懒加载分类,分两种<ul>
<li>一个非懒加载分类，分类中的方法在编译的时候就加载到类中，其方法在<code>class_ro_t</code>中;类的加载，在<code>runtime</code>启动时，即<code>read_image</code>中，进行加载。此时的类受分类影响，变成了非懒加载类。</li>
<li>一个以上非懒加载分类,分类的方法在<code>runtime</code>启动，<code>load_images</code>时，在<code>load_categories_nolock</code>时，由于类未加载，会将分类和类的映射在<code>objc::unattachedCategories.addForClass</code>中构建。并在<code>prepare_load_methods</code>回去加载类，在类加载时，会调用<code>objc::unattachedCategories:attachToClass</code>，这里会将分类中的方法加载到类中，之后完成类的加载。</li>
</ul>
</li>
<li>非懒加载类和非懒加载分类，<code>runtime</code>启动时，类的加载会在<code>read_image</code>中，进行加载。分类中的方法，会在<code>load_images</code>的<code>load_categories_nolock</code>，将所有分类加载到类中。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>分类</title>
    <url>/2022/12/25/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ol>
<li>通过<code>runtime</code>动态将分类的方法合并到类对象、元类对象中，注意如果是懒加载类，则会在编译的时候，合并，如果是非懒加载类，则会在运行时合并</li>
<li>一个分类文件的编译后的结构体实际为<span id="more"></span>
<img src="16719733229400.png"><ul>
<li>由runtime在运行，或者在编译时（懒加载和非懒加载，有优化），将分类的方法合并到类对象、元类对象中,</li>
<li>编译成<code>.cpp文件</code>，<code>MJPerson(Eat)</code>生成的 <code>_category_t</code>的静态结构体变量，其是单独的静态变量，其在编译的时后,并未合入到类对象中<br><img src="16719737845768.png"></li>
</ul>
</li>
</ol>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul>
<li><p><code>objc4</code>源码解读过程：<code>objc-os.mm</code></p>
<ol>
<li><p><code>_objc_init</code></p>
</li>
<li><p><code>map_images</code></p>
<ul>
<li><code>_read_images</code></li>
</ul>
</li>
<li><p><code>load_images</code></p>
</li>
<li><p><code>prepare_load_methods</code></p>
<ul>
<li><code>schedule_class_load</code></li>
<li><code>add_class_to_loadable_list</code></li>
<li><code>add_category_to_loadable_list</code></li>
</ul>
</li>
<li><p><code>call_load_methods</code></p>
<ul>
<li><code>call_class_loads</code></li>
<li><code>call_category_loads</code></li>
<li><code>(*load_method)(cls, SEL_load)</code></li>
</ul>
</li>
</ol>
</li>
<li><p><code>load</code>方法是根据方法地址直接调用，并不是经过<code>objc_msgSend</code>函数调用</p>
</li>
</ul>
<h3 id="method-array-t的构建"><a href="#method-array-t的构建" class="headerlink" title="method_array_t的构建"></a>method_array_t的构建</h3><blockquote>
<p>在<code>runtime</code>运行后，添加到<code>class_rw_t</code>的<code>method_array_t</code>二维方法数组中</p>
</blockquote>
<ul>
<li><p>类的加载<code>realize</code>方法，可以看到<code>class_rw_t</code>实际上是在运行时创建的，此前类中的<code>bits</code>中保存的是<code>class_ro_t</code>相关数据，在运行时<code>realize</code>，创建<code>class_rw_t</code>数据，并将其赋给<code>bits</code>中<br><img src="2.png" alt="截屏2023-01-01 23.10.16"></p>
</li>
<li><p>加载分类的方法，保证类<code>realize</code>完成后，再去加载分类<br><img src="1.png" alt="截屏2023-01-01 23.10.16"></p>
</li>
<li><p>核心添加方法 <code>attachLists</code></p>
</li>
<li><p><code>objc_838</code>版本，在构建分类大数组是，最后编译的分类，放到最前面，将所有的分类方法、属性、协议数据合并到一个大数组中<br><img src="16720409049409.png"></p>
</li>
<li><p>构建一个新数组，由后往前添加,新加的方法，放到最前面<br><img src="16720258260842.png"></p>
</li>
<li><p><code>objc_750</code>方法，最后编译的分类，放到最前面，最终所有的分类方法、属性、协议数据合并到一个大数组中<br><img src="16720410519764.png"> </p>
</li>
<li><p>会通过<code>memmove</code>（内存挪动）(会根据方向挪动位置，保证数据完整性)将原来的方法列表，往后移动相应增加分类容量的位置。前面空出来的位置，用<code>memcpy</code>（内存拷贝）（只会从小地址，开始拷贝），添加在方法列表前面。也就是分类的方法，会在原方法的前面<br><img src="16720259301593.png"></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Category</code>的实现原理<ul>
<li><code>Category</code>编译之后的底层结构是<code>struct category_t</code>,里面吗存储着分类的对象方法、类方法、属性、协议信息</li>
<li>在程序运行的时候，<code>runtime</code>会将<code>Category</code>的数据，合并到类信息中（类对象、元类对象中）(并不是所有的分类均会，详情见<a href="%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E4%BB%A5%E5%8F%8A%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD.md">懒加载类以及分类的加载</a>)</li>
</ul>
</li>
<li><code>Category</code>和<code>Class EXtension</code>的区别是什么<ul>
<li><code>Class Extension</code>在<strong>编译</strong>的时候，他的数据已经包含在类信息中</li>
<li><code>Category</code>是在运行时，才会将数据合并到类信息中（并不是所有的分类均会）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC</title>
    <url>/2022/12/23/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/KVC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><ol>
<li>通过<code>KVC</code>修改属性会触发<code>KVO</code>，例如<code>age</code>属性,<ul>
<li>注意，就算<code>age</code>属性没有实现<code>set</code>的方法，只有<code>成员变量</code>，通过<code>KVC</code>设置，同样会触发<code>KVO</code></li>
<li>表明<code>KVC</code>内部实际上有调用<code>willchangForkey</code>、以及<code>didChangeForKey:</code>方法</li>
</ul>
</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="16719622557599.png"></p>
<ol>
<li>根据<code>setAge:</code>,<code>_setAge:</code>的顺序找到，找到则调用,设置值</li>
<li>如果<code>1</code>没找到，查看<code>accessInstanceVariablesDirectly</code>（是否可直接查找成员变量）是否返回<code>true</code>，为<code>No</code>，直接报没找到<code>key</code>的异常</li>
<li>如果为<code>true</code>，则按照<code>_age</code>,<code>_isAge</code>,<code>age</code>,<code>isAge</code>的顺序查找成员变量，找到直接赋值<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><img src="%E6%88%AA%E5%B1%8F2022-12-25%2020.15.39.png" alt="截屏2022-12-25 20.15.39"></li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO</title>
    <url>/2022/12/22/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/KVO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><h3 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h3><ul>
<li><p>未使用<code>KVO</code>监听，其<code>isa</code>指针指向的是其<code>class</code>对象。</p>
<ul>
<li><code>class对象</code>包含：（<code>isa</code>指针、<code>superclass</code>指针、实例方法、协议列表、属性列表、成员变量）</li>
</ul>
</li>
<li><p>使用<code>KVO</code>监听，其<code>isa</code>指向为<code>NSKVONotifying_class</code>，一个全新的<code>class对</code>象,</p>
<ul>
<li>由<code>runtime</code>运行时，动态创建的类,</li>
<li>该类实现为其<code>class对象</code>的子类，其内部实现了<code>class</code>、<code>delloc</code>、<code>_isKVOA</code>，以及重写了相关的<code>set</code>方法</li>
<li>通过<code>runtime</code>输出方法，示例代码如下</li>
</ul>
  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span>.person1 addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;height&quot;</span> options:options    context:<span class="hljs-string">@&quot;456&quot;</span>];<br> <span class="hljs-keyword">int</span> num;<br> <span class="hljs-comment">//=注意，这里如果用[self.person1 class]拿不到，被重写了，不会拿到实际的类</span><br>   Method * list = class_copyMethodList(object_getClass(<span class="hljs-keyword">self</span>.person1),     &amp;num);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; num;i++) &#123;<br>      Method method = list[i];<br>       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method)));<br>&#125;<br> free(list);<br> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 输出setHeight:、setAge:、class、dealloc、_isKVOA</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li>
<li><p>在调用<code>set</code>方法后实际调用了<code>_NSSetIntValueAndNotify();</code></p>
<ul>
<li>(整型所以是<code>int</code>，如果是<code>double</code>则是<code>_NSSetDoubleValueAndNotify()</code>)</li>
</ul>
</li>
<li><p><code>_NSSetIntValueAndNotify()</code>内，类似实现的伪代码如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSKVONotifying_MJPerson</span>中<br>- (<span class="hljs-keyword">void</span>)setAge:(<span class="hljs-keyword">int</span>)age &#123;<br>    _NSSetIntValueAndNotify()<br>&#125;<br><br><span class="hljs-keyword">void</span> _NSSetIntValueAndNotify() &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">&quot;age&quot;</span>]<br>    [<span class="hljs-keyword">super</span> setAge:age]<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">&quot;age&quot;</span>] <span class="hljs-comment">//里面调用监听器的方法</span><br>&#125;<br><br>- (<span class="hljs-keyword">void</span>) didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [observer observeValueForKeyPath:key ofObject: change: content:]<span class="hljs-comment">//通知观察者</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>，如果内存中有个<code>NSKVONotifying_xxx</code>类，则相应的<code>kvo</code>无法实现</p>
</li>
<li><p>通过<code>[self.person1 methodForSelector:@selector(setAge:)]</code>找到对应方法的实现。</p>
<ul>
<li>在<code>lldb</code>中根据内存，用<code>p (IMP)0x7ff800bde9cb</code>即可找到实际实现的方法<code>Foundation _NSSetIntValueAndNotify</code></li>
</ul>
</li>
<li><p>此外，被<code>kvo</code>的对象，其元类对象也是不同的。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><code>KVO</code>的本质是什么</p>
<ul>
<li>利用<code>RuntimeAPI</code>动态生成一个子类，并且让<code>instance</code>对象的<code>isa</code>指向这个全新的子类</li>
<li>当修改<code>instance</code>对象的属性时，会调用<code>Foundation</code>的<code>_NSSetxxxValueAndNotif</code>函数。内部实际调用:<ul>
<li><code>willchangValueForKey</code></li>
<li>父类原来的<code>setter</code></li>
<li><code>didChangeValueForKey</code><ul>
<li>其内部会触发监听器<code>Obserser</code>的监听方法<code>（observeValueForKeyPath:ofObject:change:）</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何触发<code>KVO</code></p>
<ul>
<li>设置方法时，自动触发</li>
<li>手动调用<code>willChangeForKey：</code>和<code>didChangeForKey：</code> </li>
</ul>
</li>
<li><p>直接修改成员变量会触发KVO么？</p>
<ul>
<li>不会触发<code>KVO</code>,除非手动调用<code>willChangeForKey：</code>和<code>didChangeForKey：</code> </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>objc_class的结构</title>
    <url>/2022/12/21/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/objc_class%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="objc-class的结构"><a href="#objc-class的结构" class="headerlink" title="objc_class的结构"></a>objc_class的结构</h1><p><img src="16715558479895.png"></p>
<ul>
<li>如何去查看<code>objc_class</code>的源码在真实项目中用，吧<code>objc_class</code>结构体，在函数类直接写出来，用桥接的方式实现</li>
<li>也可以加入<code>objc</code>源码，通过<code>lldb</code>进行调试<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MJClassInfo_h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MJClassInfo_h</span><br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> __arm64__</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">elif</span> __x86_64__</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __LP64__</span><br><span class="hljs-keyword">typedef</span> uint32_t mask_t;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> uint16_t mask_t;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">typedef</span> uintptr_t cache_key_t;<br><br><span class="hljs-keyword">struct</span> bucket_t &#123;<br>    cache_key_t _key;<br>    IMP _imp;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> cache_t &#123;<br>    bucket_t *_buckets;<br>    mask_t _mask;<br>    mask_t _occupied;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> entsize_list_tt &#123;<br>    uint32_t entsizeAndFlags;<br>    uint32_t count;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> method_t &#123;<br>    SEL name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types;<br>    IMP imp;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> method_list_t : entsize_list_tt &#123;<br>    method_t first;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> ivar_t &#123;<br>    int32_t *offset;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *type;<br>    uint32_t alignment_raw;<br>    uint32_t size;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> ivar_list_t : entsize_list_tt &#123;<br>    ivar_t first;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> property_t &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *attributes;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> property_list_t : entsize_list_tt &#123;<br>    property_t first;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> chained_property_list &#123;<br>    chained_property_list *next;<br>    uint32_t count;<br>    property_t list[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> uintptr_t protocol_ref_t;<br><span class="hljs-keyword">struct</span> protocol_list_t &#123;<br>    uintptr_t count;<br>    protocol_ref_t list[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-keyword">struct</span> class_ro_t &#123;<br>    uint32_t flags;<br>    uint32_t instanceStart;<br>    uint32_t instanceSize;  <span class="hljs-comment">// instance对象占用的内存空间</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    uint32_t reserved;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">const</span> uint8_t * ivarLayout;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name;  <span class="hljs-comment">// 类名</span><br>    method_list_t * baseMethodList;<br>    protocol_list_t * baseProtocols;<br>    <span class="hljs-keyword">const</span> ivar_list_t * ivars;  <span class="hljs-comment">// 成员变量列表</span><br>    <span class="hljs-keyword">const</span> uint8_t * weakIvarLayout;<br>    property_list_t *baseProperties;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> class_rw_t &#123;<br>    uint32_t flags;<br>    uint32_t version;<br>    <span class="hljs-keyword">const</span> class_ro_t *ro;<br>    method_list_t * methods;    <span class="hljs-comment">// 方法列表</span><br>    property_list_t *properties;    <span class="hljs-comment">// 属性列表</span><br>    <span class="hljs-keyword">const</span> protocol_list_t * protocols;  <span class="hljs-comment">// 协议列表</span><br>    Class firstSubclass;<br>    Class nextSiblingClass;<br>    <span class="hljs-keyword">char</span> *demangledName;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="hljs-keyword">struct</span> class_data_bits_t &#123;<br>    uintptr_t bits;<br>public:<br>    class_rw_t* data() &#123;<br>        <span class="hljs-keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/* OC对象 */</span><br><span class="hljs-keyword">struct</span> mj_objc_object &#123;<br>    <span class="hljs-keyword">void</span> *isa;<br>&#125;;<br><br><span class="hljs-comment">/* 类对象 */</span><br><span class="hljs-keyword">struct</span> mj_objc_class : mj_objc_object &#123;<br>    Class superclass;<br>    cache_t cache;<br>    class_data_bits_t bits;<br>public:<br>    class_rw_t* data() &#123;<br>        <span class="hljs-keyword">return</span> bits.data();<br>    &#125;<br>    <br>    mj_objc_class* metaClass() &#123;<br>        <span class="hljs-keyword">return</span> (mj_objc_class *)((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)isa &amp; ISA_MASK);<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* MJClassInfo_h */</span></span><br></code></pre></td></tr></table></figure></li>
<li>实际使用,即可查看相关类<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        MJStudent *stu = [[MJStudent alloc] init];<br>        stu-&gt;_weight = <span class="hljs-number">10</span>;<br>        <br>        mj_objc_class *studentClass = (__bridge mj_objc_class *)([MJStudent <span class="hljs-keyword">class</span>]);<br>        mj_objc_class *personClass = (__bridge mj_objc_class *)([MJPerson <span class="hljs-keyword">class</span>]);<br>        <br>        class_rw_t *studentClassData = studentClass-&gt;data();<br>        class_rw_t *personClassData = personClass-&gt;data();<br>        <br>        class_rw_t *studentMetaClassData = studentClass-&gt;metaClass()-&gt;data();<br>        class_rw_t *personMetaClassData = personClass-&gt;metaClass()-&gt;data();<br><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1111&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>isa指针简介</title>
    <url>/2022/12/19/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/isa%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h1 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h1><ul>
<li>从<code>64bit</code>开始，<code>isa</code>需要进行一次位运算，才能计算出真实地址,<code>isa &amp; ISA_MASK</code>即为实际的<code>isa</code>地址<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> __arm64__</span><br><span class="hljs-meta">#     <span class="hljs-meta-keyword">define</span> ISA_MASK   0x0000000ffffffff8ULL</span><br>elif __x86_64__<br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span><br></code></pre></td></tr></table></figure></li>
<li><code>lldb</code>获取方式  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">&lt;LGPerson: <span class="hljs-number">0x6000002321a0</span>&gt;<br>(lldb) x/<span class="hljs-number">4</span>xg <span class="hljs-number">0x6000002321a0</span><br><span class="hljs-number">0x6000002321a0</span>: <span class="hljs-number">0x011d800100008609</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000002321b0</span>: <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000000000</span><br>p/x <span class="hljs-number">0x011d800100008609</span> &amp; <span class="hljs-number">0x00007ffffffffff8</span><br>(<span class="hljs-keyword">long</span>) $<span class="hljs-number">0</span> = <span class="hljs-number">0x0000000100008608</span><br>(lldb) po $<span class="hljs-number">0</span><br>LGPerson<br></code></pre></td></tr></table></figure></li>
<li><code>Class</code>中的<code>isa</code>指针没有暴露出来，可以通过构建一个相同的结构体，通过桥接得到<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_class &#123;<br>    Class isa;<br>    Class superclass;<br>&#125;;<br><span class="hljs-keyword">struct</span> objc_class *personClass = (__bridge <span class="hljs-keyword">struct</span> objc_class *)([Person <span class="hljs-keyword">class</span>]);<br></code></pre></td></tr></table></figure></li>
<li><code>superclass</code>直接指向父类，不需要转换</li>
<li><code>isa</code>是一个union体结构，主要是位了节省消耗，数据共享一片内存。也是通过<code>mask</code>来获取属性<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">union</span> isa_t &#123;<br>    isa_t() &#123; &#125;<br>    isa_t(uintptr_t value) : bits(value) &#123; &#125;<br>    uintptr_t bits;<br><br>    <span class="hljs-keyword">struct</span> &#123;<br>        uintptr_t nonpointer        : <span class="hljs-number">1</span>;                                       <br>        uintptr_t has_assoc         : <span class="hljs-number">1</span>;                                       <br>        uintptr_t has_cxx_dtor      : <span class="hljs-number">1</span>;                                       <br>        uintptr_t shiftcls          : <span class="hljs-number">33</span>; <span class="hljs-comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> <br>        uintptr_t magic             : <span class="hljs-number">6</span>;                                       <br>        uintptr_t weakly_referenced : <span class="hljs-number">1</span>;                                       <br>        uintptr_t unused            : <span class="hljs-number">1</span>;                                       <br>        uintptr_t has_sidetable_rc  : <span class="hljs-number">1</span>;                                       <br>        uintptr_t extra_rc          : <span class="hljs-number">19</span>;  <span class="hljs-comment">// defined in isa.h</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>OC对象的分类</title>
    <url>/2022/12/18/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h2 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h2><p>主要分为3种</p>
<ol>
<li><code>instance</code>对象，实例对象 </li>
<li><code>class</code>对象，类对象</li>
<li><code>meta-class</code>对象，元类对象</li>
</ol>
<h3 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h3><ul>
<li>通过类<code>alloc</code>出来的对象，<code>instance</code>对象在内存种存储的信息（只有成员变量）包括<ul>
<li><code>isa</code>指针</li>
<li>其他成员变量</li>
</ul>
</li>
<li><code>isa</code>指针始终在对象结构体的前面，因此，<code>isa</code>指针的地址即实例对象的地址</li>
</ul>
<h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><ul>
<li><code>[objec class]</code>、<code>[NSObject class]</code>、<code>object_getClass(object)</code>都是获取<code>NSobject</code>的<code>class</code>对象</li>
<li>它们都是同一个对象，在内存中有且只有一个<code>class</code>对象</li>
<li><code>class</code>对象在内存中存储的信息主要包括</li>
</ul>
<ol>
<li><code>isa</code>指针</li>
<li><code>superclass</code>指针</li>
<li>类的属性信息（<code>@property</code>）、类的对象方法信息（<code>instance method</code>）</li>
<li>类的协议信息（<code>protocol</code>）、类的成员变量信息（<code>ivar</code>）<ol>
<li><code>ivar</code>并非成员变量的值，成员变量的值由<code>instance</code>决定</li>
<li><code>ivar</code>实际存储的类型，名称等描述信息</li>
</ol>
</li>
</ol>
<h3 id="元类对象"><a href="#元类对象" class="headerlink" title="元类对象"></a>元类对象</h3><p><code>object_getClass([NSObject class])</code>获取元类对象，元类对象结构和类结构一样都是<code>class</code>,其结构相同，不过元类对象中除<code>isa</code>指针、<code>superclass</code>指针、<code>类方法信息</code>外，其他均为<code>null</code></p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="16713605118546.png"></p>
<ul>
<li>关系总结<ol>
<li><code>instance</code>的<code>isa</code>指向<code>class</code></li>
<li><code>class</code>的<code>isa</code>指向<code>meta-class</code></li>
<li><code>meta-class</code>的<code>isa</code>指向基类<code>meta-class</code><ul>
<li>基类<code>meta-class</code>的<code>isa</code>指向自己</li>
</ul>
</li>
<li><code>class</code>的<code>superclass</code>指向父类的<code>class</code><ol>
<li>如果没有父类，<code>superclass</code>指针为<code>nil</code></li>
</ol>
</li>
<li><code>meta-class</code>的<code>superclass</code>指向父类的<code>meta-class</code><ol>
<li>基类<code>meta-class</code>的<code>superclass</code>指向基类<code>class</code></li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>NSObject</title>
    <url>/2022/12/17/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/NSObject/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一个NSObject对象占用多少内存？"><a href="#一个NSObject对象占用多少内存？" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个<code>NSObject</code>对象占用多少内存？</h3><h4 id="一个NSObject对象占用多少内存？-1"><a href="#一个NSObject对象占用多少内存？-1" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个<code>NSObject</code>对象占用多少内存？</h4><ul>
<li>系统分配了<code>16</code>个字节给<code>NSObject</code>对象（通过<code>malloc_size</code>函数获得）</li>
<li>但<code>NSObject</code>对象内部只使用了<code>8</code>个字节（<code>isa</code>指针）的空间（<code>64bit</code>环境下，可以通过<code>class_getInstanceSize</code>函数（经过内存对齐过的值）获得<ol>
<li>用<code>clang -rewrite-objc main.m -o main.cpp</code>编译成<code>C++</code>文件（全平台），</li>
<li><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code>(推荐)编译成指定平台的</li>
<li><code>16字节</code>而不是<code>8字节</code>的原因,源码中可以看到，是<code>Foundation</code>框架规定的，最小<code>16字节</code><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> _class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="hljs-keyword">void</span> *zone)<br>&#123;<br>    <span class="hljs-keyword">void</span> *bytes;<br>    size_t size;<br><br>    <span class="hljs-comment">// Can&#x27;t create something for nothing</span><br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><br>    <span class="hljs-comment">// Allocate and initialize</span><br>    size = cls-&gt;alignedInstanceSize() + extraBytes;<br><br>    <span class="hljs-comment">// CF requires all objects be at least 16 bytes.</span><br>    <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">16</span>) size = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-keyword">if</span> (zone) &#123;<br>        bytes = malloc_zone_calloc((malloc_zone_t *)zone, <span class="hljs-number">1</span>, size);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bytes = calloc(<span class="hljs-number">1</span>, size);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> objc_constructInstance(cls, bytes);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>扩展的例子<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> _no;<br>    <span class="hljs-keyword">int</span> _age;<br>    <span class="hljs-keyword">int</span> _height; <br> &#125; <br> <span class="hljs-keyword">@end</span><br> <br> <span class="hljs-comment">// 实际为</span><br><span class="hljs-keyword">struct</span> Student_IMPL &#123;<br>    Class isa; <span class="hljs-comment">//8字节，（注意NSObect会分配16字节，但是isa结构体是8字节）</span><br>    <span class="hljs-keyword">int</span> _no; <span class="hljs-comment">//4字节</span><br>    <span class="hljs-keyword">int</span> _age; <span class="hljs-comment">//4 字节</span><br>    <span class="hljs-keyword">int</span> _height; <span class="hljs-comment">// 4 字节</span><br>&#125;<br><span class="hljs-comment">// 内存对齐: 结构体的大小必须是最大成员大小的倍数,实际为24字节，但是用`malloc_size`计算分配是32</span><br></code></pre></td></tr></table></figure></li>
<li>注意，<code>ios</code>操作系统的内存对齐，是按<code>16</code>倍为来进行分配的， 例如<code>class_getInstanceSize</code>计算<strong>只需(至少)</strong><code>24</code>位大小，但是用<code>malloc_size</code>计算<strong>实际</strong>分配的确是<code>32</code>位 </li>
<li>注意，<code>sizeof</code>实际上是运算符，并不是函数，和以上两个函数有区别，在编译的时候，就会决定了，例如<code>sizeof(指针)</code>，在编译就设置为<code>8</code>，实际不知道内存中的大小</li>
</ul>
<h4 id="alloc-init的问题"><a href="#alloc-init的问题" class="headerlink" title="alloc/init的问题"></a><code>alloc</code>/<code>init</code>的问题</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Student *s = [Student alloc];<br>Student *s1 = [s init];<br>Student *s2 = [s init];<br><span class="hljs-comment">//最终s,s1和s2返回的地址均相同</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>alloc</code>最终会调用<code>_class_createInstanceFromZone</code>创建了堆对象，即实例对象</li>
<li>而调用<code>init</code>实际上底层什么也没做，源码如下：<ul>
<li>这是种设计主要是为了让继承它的子类可以重写该方法，在返回实例变量之前初始化子类的额外属性<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> _objc_rootInit(<span class="hljs-keyword">id</span> obj)<br>  &#123;<br>       <span class="hljs-keyword">return</span> obj;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="swift类和OC类，内存分配的区别"><a href="#swift类和OC类，内存分配的区别" class="headerlink" title="swift类和OC类，内存分配的区别"></a>swift类和OC类，内存分配的区别</h4><ul>
<li><code>OC类</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JBPerson</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">//有个基础的isa指针，8字节</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name1; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 4</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">int</span> age1; <span class="hljs-comment">//4</span><br><span class="hljs-keyword">@end</span><br><br>修改后<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JBPerson</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">//有个基础的isa指针，8字节</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name1; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 4</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">int</span> age1; <span class="hljs-comment">//4</span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure></li>
<li><code>swift类</code>  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">//基本16</span><br>    <span class="hljs-keyword">var</span> age1:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">var</span> age2:<span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//4</span><br>&#125;<br><br>修改后<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">//基本16</span><br>    <span class="hljs-keyword">var</span> age:<span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">var</span> age1:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">var</span> age2:<span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//4</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li>对比声明位置，对内存的影响分析  <figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 16 + 8 + 4 + 4,//8字节对齐</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">Person</span>.<span class="hljs-keyword">self</span>))  <span class="hljs-comment">// 32</span><br><span class="hljs-comment">// 8 + + 8 + 4 + 4,// 8字节对齐</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">JBPerson</span>.<span class="hljs-keyword">self</span>)) <span class="hljs-comment">// 32</span><br><br>修改后<br><span class="hljs-comment">// 16 + 4 + 8 + 4,//8字节对齐，其中age由于age1为8字节，对其占用8字节，age2同样对齐</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">Person</span>.<span class="hljs-keyword">self</span>))  <span class="hljs-comment">// 40</span><br><span class="hljs-comment">//没有变化，很显然OC中属性的声明，会对属性的内存进行优化，采用最佳的内存分布</span><br><span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-type">JBPerson</span>.<span class="hljs-keyword">self</span>)) <span class="hljs-comment">// 32</span><br></code></pre></td></tr></table></figure></li>
<li>注意如果<code>OC</code>中的直接声明实例子变量，则和swift中一样，受到顺序的影响，下面情况，内存为<code>40</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JBPerson</span> : <span class="hljs-title">NSObject</span></span>&#123;<br><span class="hljs-built_in">NSString</span> *name1;<br><span class="hljs-keyword">int</span> _age;<br><span class="hljs-built_in">NSString</span> *_name;<br><span class="hljs-keyword">int</span> age1;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>OC中属性的声明，会对属性的内存进行优化，采用最佳的内存分布，不会受声明顺序的影响</li>
<li>而OC中直接声明实例变量的方式，则和swift中一样，受到顺序的影响</li>
</ul>
</li>
</ul>
<h3 id="对象的isa指针指向哪里"><a href="#对象的isa指针指向哪里" class="headerlink" title="对象的isa指针指向哪里"></a>对象的<code>isa</code>指针指向哪里</h3><ul>
<li><code>instance</code>对象的<code>isa</code>指针指向类对象</li>
<li>类对象的<code>isa</code>指针指向元类对象</li>
<li>元类对象的<code>isa</code>指针指向基类的元类对象</li>
</ul>
<h3 id="OC的类信息存放在哪里"><a href="#OC的类信息存放在哪里" class="headerlink" title="OC的类信息存放在哪里"></a><code>OC</code>的类信息存放在哪里</h3><ul>
<li>对象的方法、属性、协议信息、成员变量，存放在类对象</li>
<li>类方法存放在元类对象</li>
<li>成员变量的具体值，存放在<code>instance</code></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>FishHook</title>
    <url>/2022/12/10/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/FishHook/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FishHook"><a href="#FishHook" class="headerlink" title="FishHook"></a>FishHook</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS中通过<code>Method Swizzling</code>实现<code>hook</code>，其原理是利用OC的<code>Runtime</code>特性，动态改变<code>SEL</code>（方法编号）和<code>IMP</code>（方法实现）的对应关系，达到OC方法交换的目的。然而只适用于动态的OC方法，对于C函数Hook，可以引用fishHook，通过修改machO文件中<code>la_symbol_ptr</code>和<code>non_la_symbol_ptr</code>两个表的指针达到C函数HOOK的目的。</p>
<h2 id="框架地址"><a href="#框架地址" class="headerlink" title="框架地址"></a>框架地址</h2><p><code>fishhook</code>是一个非常简单的库，可以在模拟器和设备上运行在iOS上的Mach-O二进制文件中动态重新绑定符号,代码地址<a href="https://github.com/facebook/fishhook">https://github.com/facebook/fishhook</a></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>头文件导入<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#import &quot;fishhook.h&quot;<br></code></pre></td></tr></table></figure></li>
<li>交换制定的C函数,构建<code>rebinding</code>结构体<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">struct rebinding rebindSend;<br>rebindSend.name = &quot;NSLog&quot;;<br>rebindSend.replacement = (void *)hook_Objc_nslog;<br>rebindSend.replaced = (void **)&amp;orig_objc_nslog;<br></code></pre></td></tr></table></figure></li>
<li><code>rebind_symbols</code>重新绑定符号<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">struct rebinding rebs[] = &#123;rebindSend&#125;;<br>rebind_symbols(rebs, 1);<br></code></pre></td></tr></table></figure></li>
<li>完整使用用例<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//<br>//  FishHooklViewController.m<br>//  transitionController<br>//<br>//  Created by 陈晶泊 on 2022/8/10.<br>//<br>#import &quot;fishhook.h&quot;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdarg.h&gt;<br>#import &quot;FishHooklViewController.h&quot;<br><br>@interface FishHooklViewController ()<br><br>@end<br><br>@implementation FishHooklViewController<br>__unused static void(*orig_objc_nslog)(NSString *format, ...);<br><br>- (void)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    self.view.backgroundColor = UIColor.whiteColor;<br>    struct rebinding rebindSend;<br>    rebindSend.name = &quot;NSLog&quot;;<br>    rebindSend.replacement = (void *)hook_Objc_nslog;<br>    rebindSend.replaced = (void **)&amp;orig_objc_nslog;<br>    struct rebinding rebs[] = &#123;rebindSend&#125;;<br>    rebind_symbols(rebs, 1);<br>&#125;<br><br>void hook_Objc_nslog(NSString *format, ...) &#123;<br>    format = [format stringByAppendingFormat:@&quot;已hook&quot;];<br>    orig_objc_nslog(format);<br>&#125;<br><br>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;<br>    NSLog(@&quot;FishHooklViewController&quot;);<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure>
<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><code>MachO</code>文件的静态链接在编译的时候，就确定了方法地址，位于代码段模，是不可写的，因此静态链接的函数方法，在运行时是无法更改的。<br>然而动态链接，是在运行时进行方法链接的，在<code>MachO</code>文件中，访问动态库里的数据符号地址放在<code>got</code>(也称<code>Non-Lazy Symbol Pointers</code>)数据段，调用动态库的函数的地址放在<code>la_symbol_ptr</code>数据段的数据段中，是可读写的，因此可以在程序运行期间修改<code>got</code>(<code>non_la_symbol_ptr</code>)和<code>la_symbol_ptr</code>数据段，来替换函数跟全局变量的地址。<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-传入需要替换的函数"><a href="#1-传入需要替换的函数" class="headerlink" title="1. 传入需要替换的函数"></a>1. 传入需要替换的函数<img src="16706577321150.png"></h4> <code>rebindings_head</code>的<code>next</code>为nil是第一次调用；去注册方法，其中<code>_dyld_register_func_for_add_image</code>做了2件事，1.是跟<code>else</code>里面一样，为每个image(镜像)调用<code>_rebind_symbols_for_image</code>，2.是当<code>dyld</code>后面加载镜像时候，也为这个新镜像调用<code>_rebind_symbols_for_image</code>。<br> <code>rebindings_head</code>采用的链表结构，具体如下:<br><img src="16706578333010.jpg"><h4 id="2-计算地址"><a href="#2-计算地址" class="headerlink" title="2. 计算地址"></a>2. 计算地址</h4><code>rebind_symbols_for_image</code>方法的目的，主要是计算基址，找到符号表、字符串表、间接符号表、<code>nl_symbol_ptr(got)</code>以及<code>la_symbol_ptr</code>数据段的地址。</li>
<li>首先遍历加载命令，获得<code>MachO</code>文件中符号表、间接符号表、<code>LINKEDIT</code>三个加载命令<br><img src="16706583225213.png"></li>
<li>根据<code>LINKEDIT</code>获取的真实基址，根据第一步中得到的加载命令，确定符号表、间接符号表、字符串表的虚拟内存地址<br><img src="16706584145390.png"></li>
<li>遍历加载命令，找到数据段，在从数据段的<code>section</code>中找到<code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code></li>
</ol>
<p><img src="16706586123063.png"></p>
<h4 id="3-方法替换"><a href="#3-方法替换" class="headerlink" title="3. 方法替换"></a>3. 方法替换</h4><p>最后遍历<code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code>可修改的变量和数据地址，并结合间接符号表、符号表、以及字符串表，得到地址对应的函数，变量名称，找到相同的名称，即可进行地址的替换。<br><img src="16706587741784.png"></p>
<h2 id="通过MachOView分析"><a href="#通过MachOView分析" class="headerlink" title="通过MachOView分析"></a>通过MachOView分析</h2><ol>
<li>计算出符号表、间接符号表、字符串表的地址<br><img src="16706010476870.png"></li>
<li><code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code>可修改的变量和函数数据地址，其中<code>reserved1</code>即为数据段中的函数在间接符号表中的位置<br><img src="1.png"></li>
<li>间接符号表中的地址，和实际数据段地址是对应的，其中间接符号表中的数据，实际对应的是符号表中的索引。<br><img src="2.png"></li>
</ol>
<p><img src="16706604848859.png"><br>4. 符号表中，关联由字符串表，从而知道函数的名称，因此，最终，根据名称，从间接符号表中拿到原始函数地址，从而完成了方法的替换。<br><img src="16706604848859.png"></p>
<h2 id="FishHook应用实例"><a href="#FishHook应用实例" class="headerlink" title="FishHook应用实例"></a>FishHook应用实例</h2><p><code>SMCallTrace</code>通过hook<code>objc_msgSend</code>方法，hook了所有OC的方法，在hook方法中通过汇编语言来计算方法的耗时，可以用来项目中方法的执行情况。在需要检测耗时时间的地方调用 <code>[SMCallTrace start]</code>，结束时调用 <code>stop</code> 和 <code>save</code> 就可以打印出方法的调用层级和耗时了。还可以设置最大深度和最小耗时检测，来过滤不需要看到的信息。<a href="https://github.com/ming1016/GCDFetchFeed">源码地址</a><br>具体使用后的效果<img src="4.jpeg"></p>
]]></content>
      <categories>
        <category>应用技巧</category>
      </categories>
      <tags>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>越狱练习</title>
    <url>/2022/12/04/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/%E8%B6%8A%E7%8B%B1%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="练习一-喜玛拉广告去除"><a href="#练习一-喜玛拉广告去除" class="headerlink" title="练习一 喜玛拉广告去除"></a>练习一 喜玛拉广告去除</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><code>Revel</code>中查看广告的图层信息，通过Cycript<code>[#0x12333 removeFromSuperlayer]</code>只能暂时将广告屏蔽</li>
<li>用<code>CLutch</code>脱壳应用，<code>class-dump</code>指令拿到头文件信息，查看相关视图图层的信息，通过hook的方式去去除广告<h1 id="练习二，桌面更新数字去除"><a href="#练习二，桌面更新数字去除" class="headerlink" title="练习二，桌面更新数字去除"></a>练习二，桌面更新数字去除</h1></li>
</ol>
<ul>
<li>iOS桌面为<code>springboard</code>，位置在<code>/System/Library/CoreServices/SpringBoard.app</code></li>
<li><code>springboard</code>无法通过<code>revel</code>的方式查看，需要用<code>cycript</code>的方式查看</li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>theos</tag>
      </tags>
  </entry>
  <entry>
    <title>Cycript</title>
    <url>/2022/12/03/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/Cycript/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h2 id="Cycript"><a href="#Cycript" class="headerlink" title="Cycript"></a>Cycript</h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><ul>
<li>cycript</li>
<li>cycript -p 进程ID （越狱环境下，可以获取相关app的进程id/名称）</li>
<li>cycript -p 进程名称<h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3></li>
<li>UIApp<ul>
<li>[UIApplication sharedApplication]</li>
</ul>
</li>
<li>定义变量<ul>
<li>var 变量名 = 变量值</li>
</ul>
</li>
<li>用内存地址获取对象<ul>
<li><code>#</code>内存地址</li>
</ul>
</li>
<li>ObjectiveC.classes<ul>
<li>已加载的所有OC类</li>
</ul>
</li>
<li>查看对象的所有成员变量<ul>
<li><code>*</code>对象</li>
</ul>
</li>
<li>获取所有子视图的东西(Cycripty,可以多语言混用)<ul>
<li>[UIApp.keyWindow recursiveDescription].toString()</li>
<li>UIApp.keyWindow .recursiveDescription() .toString()</li>
</ul>
</li>
<li>筛选出当前内存下某种类型的对象<ul>
<li>choose(UIViewController)<h3 id="将文件做成库"><a href="#将文件做成库" class="headerlink" title="将文件做成库"></a>将文件做成库</h3></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>将.cy文件编译成库导入到/usr/lib/cycript0.9中</li>
<li>然后用@import导入，就可以用文件中的方法了</li>
<li>示例代码<code>text.cy</code>，直接用sum（1,2）后者用text.minus(1,2)<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(function(exports)&#123;<br>	sum = function(a,b) &#123;<br>		return a + b;<br>	&#125;;<br>	sum123 = function(a,b) &#123;<br>	var arr = [1,2];<br>	[arr addObject:a];<br>	[arr addObject:b];<br>		return arr;<br>	&#125;;<br>	exports.minus = function(a,b) &#123;<br>		return a - b;<br>	&#125;;<br>	exports.name = function(a,b) &#123;<br>		return a * b;<br>	&#125;;<br>	exports.appId = [NSBundle mainBundle].bundleIdentifier;<br><br>	exports.rootVc = function() &#123;<br>		return UIApp.keyWindow.rootViewController;<br>	&#125;<br><br>	docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];<br>&#125;)(exports);<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>Cycript</tag>
      </tags>
  </entry>
  <entry>
    <title>theos</title>
    <url>/2022/12/03/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/theos/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h2 id="用theos去hook"><a href="#用theos去hook" class="headerlink" title="用theos去hook"></a>用theos去hook</h2><ol>
<li>安装threos<a href="media/16676513774655/07-theos%E7%9A%84%E5%89%AF%E6%9C%AC.pdf">theos安装教程</a></li>
<li><code>nic.pl</code>指令选择创建<code>iphone/tweak</code>项目,（自己的bundId，和越狱app的bundId）<ol>
<li>在生成的Makefile文件内，增加端口信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export THEOS_DEVICE_IP = localhost<br>export THEOS_DEVICE_PORT = 100010<br>include $(THEOS)/makefiles/common.mk<br>TWEAK_NAME = tingweak<br></code></pre></td></tr></table></figure>
<ul>
<li><code>THES_DEVICE_IP</code>,<code>THEOS_DEVICE_PORT</code>可以配置到.bash_profile的文件下,全局配置</li>
</ul>
</li>
<li>实际在Tweak.x文件内进行hook，找到相应的view，然后写hook后的方法.<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">  #import &lt;UIKit/UIView.h&gt;<br> %hook XMNowPlayingADView<br>   - (id)initWithFrame:(struct CGRect)arg1 &#123;<br>       return nil;<br>   &#125;<br> %end<br> ///%orig(arg1,arg2);调用原始方法<br> <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>make</code> 自动编译makefile中的文件</li>
<li><code>make package</code>打包成越狱插件</li>
<li><code>make install</code>默认安装到手机上</li>
<li>手机重启，则会看到修改后的程序，注入的包位置在<code>/library/MobileSubstrate/DynamicLibraries</code>位置，删除，则无效果了（Cydia中也有该插件）<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></li>
</ol>
</li>
<li>在生成的Tweak.x文件中的方法，一般均会被认为是要hook替换的，如果没有的话，则不会生效。如果是新方法的话，需要在方法前加<code>%new</code></li>
<li><code>%orig</code>为原始方法</li>
<li>资源文件，<ol>
<li>内部图片，则放到<code>对应应用内</code>,</li>
<li>如果加载自己的，则用<code>imageWithContentsOfFile:</code>加载图片路径，例如，<code>/text.png</code>则在文件根目录</li>
<li>在theos中直接打包资源文件，在中，构建一个<code>layout</code>文件夹(实际放在<code>根目录</code>下)，将资源放进去，一般会放到<code>layout/Library/PreferenceLoader/Preferences</code>目录下（偏好设置），其他的可以放到<code>layout/Library/Caches</code>文件中</li>
</ol>
</li>
<li>注意<code>theos</code>将其他类型认为是id，因此直接用<code>self.view</code>是会报错的，要用<code>[self view]</code></li>
<li>可以像OC项目一样,多文件开发，建立相关的.h和.m文件，然后在<code>Tweak.x</code>文件中按正常的#import导入(注意文件夹)即可，此外在<code>Makefile</code>中要指定编译的文件<code>tweaksp_FILES = xxx/Tweak.x xxx/xxxx.m</code>，也可以通过<code>tweaksp_FILES = xxx/*.x</code>导入，但是无法用<code>xxx/**/*.x</code>的方式,必须指定文件夹</li>
<li>生成<code>Realease</code>版本，<code>make package debug=0</code><h2 id="theos-tweak原理"><a href="#theos-tweak原理" class="headerlink" title="theos-tweak原理"></a>theos-tweak原理</h2></li>
<li><code>make</code>指令实际上是将<code>Tweak.xm</code>的代码编译成动态库</li>
<li><code>make packpage</code>指令，将动态库文件打包成了<code>deb</code>文件，插件安装包</li>
<li><code>make install</code>指令，远程登录手机安装插件到app内，<code>Makefile</code>文件内配置<ol>
<li>安装完的包会在<code>/Library/MobileSubstrate/DynamicLibraries</code>文件夹内,包含动态库，以及相关的<code>.plist</code>文件(里面由相关应用的bundlId)</li>
<li>该文件夹由Cydia管理</li>
</ol>
</li>
<li>对应bundlId的应用打开后，会加载相关插件的动态库到内存中（不会缓存，每次重新打开，都会加载），去做交换方法的操作</li>
<li>实际上没次动态修改，并为修改代码<h3 id="过程图"><a href="#过程图" class="headerlink" title="过程图"></a>过程图</h3><img src="16703398332015.png"></li>
</ol>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>theos</tag>
      </tags>
  </entry>
  <entry>
    <title>theos</title>
    <url>/2022/12/02/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><ul>
<li>利用特殊的算法，对可执行文件的编码进行改变（比如压缩、加密），以达到保护程序代码的目的</li>
</ul>
<hr>
<ul>
<li><code>ldyd</code> -&gt; 加密后的可执行文件程序,<code>ldyd</code>是无法识别的</li>
<li>加密后的<code>可执行文件</code>，有<code>壳程序</code>包装，<code>壳程序</code>可以对其进行解密，解密完之后，才通过<code>ldyd</code>去执行<code>可执行文件</code><br><img src="16675757633856.png"><h3 id="判断是否加密，"><a href="#判断是否加密，" class="headerlink" title="判断是否加密，"></a>判断是否加密，</h3></li>
</ul>
<ol>
<li>cryptId为0表示加密<ol>
<li><img src="16675783941612.png"></li>
</ol>
</li>
<li>只有用<code>otool -l macho文件 | grep crypt</code>去查询macho文件<h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2></li>
</ol>
<ul>
<li>摘掉壳程序，将未加密的可执行文件还原出来（有些人也称为“砸壳”）</li>
</ul>
<hr>
<ul>
<li>脱壳主要有2种方法：硬脱壳、动态脱壳<br><img src="16675780924102.png"></li>
<li>iOS脱壳工具<ul>
<li><a href="https://github.com/KJCracks/Clutch/releases">Clutch</a>,<a href="https://github.com/stefanesser/dumpdecrypted/%0D">dumpdecrypted</a>,AppCrackr、Crackulous<h3 id="CLutch脱壳"><a href="#CLutch脱壳" class="headerlink" title="CLutch脱壳"></a>CLutch脱壳</h3></li>
</ul>
</li>
<li>载越狱手机内使用,(放到/usr/lib内)<ol>
<li><code>Clutch -i</code>,获取所有加载的应用</li>
<li><code>Clutch -d id/序号（1中的）</code>,导出解密后的包</li>
</ol>
</li>
</ul>
<h3 id="dumpdecrypted脱壳"><a href="#dumpdecrypted脱壳" class="headerlink" title="dumpdecrypted脱壳"></a>dumpdecrypted脱壳</h3><ul>
<li>下载完之后，要进行编译,将.c文件编译成动态库，在当前目录下用<code>make</code>可直接编译成动态库，<code>make</code>灰编译<code>Makefile</code>中的相关指令</li>
<li>与<code>clutch</code>命令不一样，为动态库，将动态库放到手机/var/root(其他位置会出现权限不足的问题，<code>注意后的版本和IOS系统版本要对应</code>) </li>
<li>使用环境变量<code>DYLD_INSERT_LIBRARIES</code>将编译生成的<code>dylib</code>注入到需要脱壳的可执行文件（可执行文件路径可以通过ps -A查看获取）-<ul>
<li><code>DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib 可执行文件路径</code></li>
<li>生成的.decrypte可执行文件</li>
<li>_<em>attribute</em>(…)方法，在注入的时候，就去执行，然后会去脱壳</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>theos</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-o文件</title>
    <url>/2022/11/04/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/Mach-o%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h2 id="Mach-o文件"><a href="#Mach-o文件" class="headerlink" title="Mach-o文件"></a>Mach-o文件</h2><ul>
<li>一个Mach-O文件包含3个主要区域<ul>
<li>Header <ul>
<li>文件类型、目标架构类型等</li>
</ul>
</li>
<li>Load commands<ul>
<li>描述文件在虚拟内存中的逻辑结构、布局</li>
</ul>
</li>
<li>Raw segment data<ul>
<li>在Load commands中定义的Segment的原始数据<br><img src="16674865436160.jpg"><h2 id="常见的Mach-o文件"><a href="#常见的Mach-o文件" class="headerlink" title="常见的Mach-o文件"></a>常见的Mach-o文件</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>MH_OBJECT<ul>
<li>目标文件（.o）</li>
<li>静态库文件(.a），静态库其实就是N个.o合并在一起</li>
</ul>
</li>
<li>MH_EXECUTE：可执行文件<ul>
<li>.app/xx</li>
</ul>
</li>
<li>MH_DYLIB：动态库文件<ul>
<li>.dylib</li>
<li>.framework/xx</li>
</ul>
</li>
<li>MH_DYLINKER：动态链接编辑器<ul>
<li>/usr/lib/dyld</li>
</ul>
</li>
<li>MH_DSYM：存储着二进制文件符号信息的文件<ul>
<li>.dSYM/Contents/Resources/DWARF/xx（常用于分析APP的崩溃信息）</li>
</ul>
</li>
</ol>
<h2 id="ios系统Mach-o文件在手机上"><a href="#ios系统Mach-o文件在手机上" class="headerlink" title="ios系统Mach-o文件在手机上"></a>ios系统Mach-o文件在手机上</h2><ul>
<li>从iOS3.1开始，为了提高性能，绝大部分的系统动态库文件都打包存放到了一个缓存文件中（<code>dyld shared cache</code>）<ol>
<li>缓存文件路径：<code>/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armX</code></li>
<li>绝大部分的系统动态库都放在共享缓存中，一个文件中，（多个动态库<code>mach</code>会有多个描述信息，因此降低内存，放到了一个文件中，也就是mach文件中<code>dlyld</code>(命令在/usr/lib中)加载指令(通过这个指令去加载动态库)，只会加载到一处）</li>
<li>用<code>[[NSBundle bundleWithPath:&quot;/System/Library/Frameworks/UIKit.framework&quot;] load]</code>去加载动态库，实际上是调用2.中<code>dlyld</code>去判断是否在缓存中，有则去1.位置处的共享缓存去加载<code>UIKit.framework</code></li>
<li><a href="https://opensource.apple.com/tarballs/dyld/">dyld源码 </a></li>
<li><code>dlyld</code>中的<code>dsc_extractor</code>文件可以，将1中缓存文件抽取出压缩在里面的库<ol>
<li>先用<code>clang++</code>编译,`clang++ -o dsc_extractor dsc_extractor.cpp</li>
<li><code>/dsc_extractor dyld_shared_cache_armv7s armv7s</code>所有动态库在呵rmv7s文件夹中<h2 id="Universal-Binary（胖二进制文件）"><a href="#Universal-Binary（胖二进制文件）" class="headerlink" title="Universal Binary（胖二进制文件）"></a>Universal Binary（胖二进制文件）</h2></li>
</ol>
</li>
</ol>
</li>
<li>通用二进制文件同时适用于多种架构的二进制文件包含了多种不同架构的独立的二进制文件</li>
<li>因为需要储存多种架构的代码，通用二进制文件通常比单一平台二进制的程序要大</li>
<li>由于两种架构有共同的一些资源，所以并不会达到单一版本的两倍之多</li>
</ul>
<h2 id="由于执行过程中，只调用一部分代码，运行起来也不需要额外的内存"><a href="#由于执行过程中，只调用一部分代码，运行起来也不需要额外的内存" class="headerlink" title="由于执行过程中，只调用一部分代码，运行起来也不需要额外的内存"></a>由于执行过程中，只调用一部分代码，运行起来也不需要额外的内存</h2><ul>
<li><code>lipo -info 文件</code>，获取胖二进制文件支持架构信息</li>
<li><code>lipo 文件 -thin armv64 - output Text_arm64</code>，抽出其中的arm64二进制文件</li>
<li><code>lipo -create Text_arm64 Text_armv7 -output test</code>，生成出胖二进制文件</li>
</ul>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="file："><a href="#file：" class="headerlink" title="file："></a>file：</h3><ul>
<li><p>查看Mach-O的文件类型</p>
</li>
<li><p><code>file  文件路径</code></p>
<h3 id="otool："><a href="#otool：" class="headerlink" title="otool："></a>otool：</h3></li>
<li><p>查看Mach-O特定部分和段的内容</p>
<ul>
<li><code>otool -L 文件路径</code>查看依赖的库</li>
<li><code>otool -h 文件路径</code>mach中head的信息</li>
<li><code>otool -l 文件路径</code>mach中loadcommand的信息<h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3></li>
</ul>
</li>
<li><p><code>dyld</code>是mach-o文件（MH_DYLINKER），但是它也能加载mach-o文件，但是只能加载</p>
<ul>
<li><code>MH_EXEUTE</code>，可执行文件</li>
<li><code>MH_DYLIB</code>,动态库</li>
<li><code>MH_BUNDLE</code><h3 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h3></li>
</ul>
</li>
<li><p>它的作用就是把Mach-O文件的class信息给dump出来（把类信息给导出来），生成对应的.h头文件</p>
<ul>
<li>命令放到/usr/local/bin目录下(mac下不能放到/usr/bin下)</li>
<li><code>class-dump  -H  Mach-O文件路径  -o  头文件存放目录</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
      <tags>
        <tag>Mach-o</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH常用指令</title>
    <url>/2022/10/29/iOS%E5%AD%A6%E4%B9%A0/iOS%E8%B6%8A%E7%8B%B1/SSH%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>
<h1 id="SSH常用指令"><a href="#SSH常用指令" class="headerlink" title="SSH常用指令"></a>SSH常用指令</h1><ul>
<li>ssh <a href="mailto:&#114;&#111;&#x6f;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#x38;&#46;&#x31;&#x2e;&#x31;&#x34;">&#114;&#111;&#x6f;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#x38;&#46;&#x31;&#x2e;&#x31;&#x34;</a>,跳转到指定ip的命令</li>
<li>ssh-keygen -R 192.168.1.14,删除ip保存的公钥<h2 id="客户端认证密钥"><a href="#客户端认证密钥" class="headerlink" title="客户端认证密钥"></a>客户端认证密钥</h2></li>
</ul>
<ol>
<li>ssh-keygen -t rsa,生成公钥和私钥,认证密钥，下次不用输入密码<ul>
<li>公钥追加到服务器授权文件（.ssh/authorized_keys）的尾部，ssh-copy-id <a href="mailto:&#x72;&#111;&#x6f;&#x74;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x31;&#x2e;&#x31;&#52;">&#x72;&#111;&#x6f;&#x74;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x31;&#x2e;&#x31;&#52;</a>，追加到当前ip服务器授权文件的尾部</li>
</ul>
</li>
<li>scp <del>/.ssh/id_rsa.pub <a href="mailto:&#x72;&#111;&#x6f;&#x74;&#x40;&#49;&#57;&#x32;&#46;&#49;&#x36;&#56;&#x2e;&#x31;&#46;&#x31;&#x34;">&#x72;&#111;&#x6f;&#x74;&#x40;&#49;&#57;&#x32;&#46;&#49;&#x36;&#56;&#x2e;&#x31;&#46;&#x31;&#x34;</a>:</del>/.ssh，基于SSH登录进行安全的远程文件拷贝命令,将id_rsa.pub文件拷贝到.ssh文件下<ul>
<li>cat id_rsa.pub &gt;&gt; authorized_keys,将id_rsa.pub内容加到authorized_keys中(同样可以实现认证密钥，不用输入密码)<h2 id="权限赋予"><a href="#权限赋予" class="headerlink" title="权限赋予"></a>权限赋予</h2></li>
</ul>
</li>
</ol>
<ul>
<li>chmod 755 ~/.ssh 给文件夹赋予权限，755含义<ul>
<li>读（r=4），写（w=2），执行（x=1）</li>
<li>文件所有者可读可写可执行                                   –7</li>
<li>与文件所有者同属一个用户组的其他用户可读可执行                 –5 </li>
<li>其它用户组可读可执行                                       –5<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2></li>
</ul>
</li>
<li>每个端口都有个端口号，（范围是0～65535，公2^16）</li>
<li>21端口，FTP服务</li>
<li>80端口，http服务</li>
<li>22端口，ssh服务<h2 id="通过USB进行SSH登录"><a href="#通过USB进行SSH登录" class="headerlink" title="通过USB进行SSH登录"></a>通过USB进行SSH登录</h2></li>
<li>默认会用网络登录，USB登录的方式是，先用SSH登录MAC上的10010端口(非保留端口均可)，在通过usbmuxd连接22端口</li>
<li>将iPhone的22端口（SSH端口）映射到Mac本地的10010端口</li>
<li>用python脚本，将mac上10010映射到22，python3 tcprelay.py -t 22:10010</li>
<li>ssh root@localhost -p 10010,直接连接本地的10010接口</li>
<li>scp -P 10010 <del>/.ssh/id_rsa.pub root@localhost:</del>,拷贝的方法</li>
</ul>
]]></content>
      <categories>
        <category>iOS越狱</category>
      </categories>
  </entry>
  <entry>
    <title>flutter和iOS交互</title>
    <url>/2022/09/11/Flutter/%E6%8C%87%E4%BB%A4/flutter%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="flutter的创建"><a href="#flutter的创建" class="headerlink" title="flutter的创建"></a>flutter的创建</h3><ol>
<li>集成SDK<ul>
<li><a href="https://flutter.cn/docs/get-started/install/macos#get-sdk">Flutter地址</a></li>
</ul>
</li>
<li>创建<code>flutter</code>项目<ul>
<li><code>flutter create -i swift -a java --org com.flutter. test_flutter</code></li>
</ul>
</li>
<li>运行<code>flutter</code>项目<ul>
<li><code>flutter run</code><h3 id="创建packages"><a href="#创建packages" class="headerlink" title="创建packages"></a>创建packages</h3><blockquote>
<ol>
<li>纯flutter的<code>Dart package</code></li>
<li>原生插件<code>Plugin packages</code></li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="Dart-package"><a href="#Dart-package" class="headerlink" title="Dart package"></a><code>Dart package</code></h4><ul>
<li><code>flutter create --template=package hello</code></li>
<li><code>flutter pub publish --dry-run</code><ul>
<li>发布检查包是否合法</li>
</ul>
</li>
</ul>
<h4 id="原生-plugin"><a href="#原生-plugin" class="headerlink" title="原生 plugin"></a><code>原生 plugin</code></h4><ul>
<li><code>flutter create --org com.example --template=plugin --platforms=android,ios -a kotlin -i swift hello</code></li>
<li>创建插件目录结构如下<ul>
<li><code>TestPlugin</code>是原生的插件代码，在这里实现原生代码</li>
<li><code>lib</code>文件下的是，<code>flutter</code>项目调用插件功能的相关接口，以及和原生交互的<code>channel</code><br><img src="1.png"></li>
</ul>
</li>
<li>创建插件时，会顺带生成一个示例的<code>flutter</code>项目，其中的iOS文件夹内<code>GeneratedPluginRegistrant</code>,将插件注册的<code>AppDelegate</code>中<br><img src="2.png"></li>
</ul>
<h3 id="在iOS项目中集合flutter项目"><a href="#在iOS项目中集合flutter项目" class="headerlink" title="在iOS项目中集合flutter项目"></a>在iOS项目中集合flutter项目</h3><blockquote>
<p>创建<code>plugin</code>的方式，是在以<code>flutter</code>为主的项目中使用的，这里介绍下，在原生为主的项目中，如何嵌入<code>flutter</code></p>
</blockquote>
<ol>
<li>创建<code>Flutter-Flutter module</code><ul>
<li><code>flutter create --template module test_module</code></li>
</ul>
</li>
<li>将创建的<code>module</code>加入iOS工程中，并在<code>Podfile</code>文件中加入以下代码，然后<code>pod install</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">lutter_application_path = &#x27;../my_flutter&#x27;<br>load File.join(flutter_application_path, &#x27;.ios&#x27;, &#x27;Flutter&#x27;, &#x27;podhelper.rb&#x27;)<br>target &#x27;MyApp&#x27; do<br>     install_all_flutter_pods(flutter_application_path)<br>end<br><br>post_install do |installer|<br>    flutter_post_install(installer) if defined?(flutter_post_install)<br>end<br></code></pre></td></tr></table></figure></li>
<li>热重载调试Flutter<ol>
<li>项目中需要配置网络权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;key&gt;NSBonjourServices&lt;/key&gt;<br>&lt;array&gt;<br>&lt;string&gt;_dartobservatory._tcp&lt;/string&gt;<br> &lt;/array&gt;<br> &lt;key&gt;NSLocalNetworkUsageDescription&lt;/key&gt;<br>&lt;string&gt;需要访问本地网络权限&lt;/string&gt;<br></code></pre></td></tr></table></figure></li>
<li>运行<code>iOS</code>项目</li>
<li>在flutter项目中，输入指令<code>flutter attach</code>,即可,<ul>
<li><code>r</code>为热重载，<code>R</code>为热启动，<code>q</code>退出调试</li>
</ul>
</li>
</ol>
</li>
<li>创建<code>FlutterViewController</code><ol>
<li><code>Flutter</code>设置路由的代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">MaterialApp(<br>    routes: &#123;<br>      &quot;/one_page&quot;: ((context) =&gt; const AnimationHomePage()),<br>      &quot;/two_page&quot;: ((context) =&gt;<br>          const MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;))<br>    &#125;,<br>    title: &#x27;Flutter Demo&#x27;,<br>    theme: ThemeData(<br>      primarySwatch: Colors.blue,<br>    ),<br>    home: _widgetForRoute(window.defaultRouteName));<br></code></pre></td></tr></table></figure></li>
<li>每次都会生成一新的<code>flutterEngine</code>,很占内存<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let flutterVc = FlutterViewController(project: nil, initialRoute: &quot;/two_page&quot;, nibName: nil, bundle: nil)<br>self.navigationController?.pushViewController(flutterVc, animated: true)<br></code></pre></td></tr></table></figure></li>
<li>设置一个全局变量<code>flutterEngine</code>，每次根据<code>flutter</code>的路由运行不同的结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">static let flutterVC =  &#123;<br>    let engine =  FlutterEngine(name: &quot;my flutter engine&quot;)<br>    engine.run(withEntrypoint: nil, initialRoute: &quot;/two_page&quot;)<br>    let vc = FlutterViewController(engine: engine, nibName: nil, bundle: nil)<br>    return vc<br>&#125;()<br><br>Self.flutterVC.pushRoute(&quot;/two_page&quot;)<br>navigationController?.pushViewController(Self.flutterVC, animated: true)<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="flutter和原生的交互"><a href="#flutter和原生的交互" class="headerlink" title="flutter和原生的交互"></a>flutter和原生的交互</h3><blockquote>
<p>Flutter定义了三种不同的Channel</p>
<ul>
<li><code>MethodChannel</code>：传递方法调用，一次通讯</li>
<li><code>BasicMessageChannel</code>：持续通讯，</li>
<li><code>EventChannel</code>：数据流，仅原生到flutter传递数据,<code>flutter</code>端，可以控制、暂停、取消</li>
</ul>
</blockquote>
<h4 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a><code>MethodChannel</code></h4><ul>
<li><code>flutter</code>代码  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">final channel = const MethodChannel(&#x27;methodChannel&#x27;);<br><br>//监听消息<br>channel.setMethodCallHandler((call) &#123;<br>  switch (call.method) &#123;<br>    case &quot;nativeInvoke&quot;:<br>      setState(() &#123;<br>        _message = &#x27;MethodChannel :$&#123;call.arguments as String&#125;&#x27;;<br>      &#125;);<br>      break;<br>    default:<br>  &#125;<br>  return Future((() =&gt; &#x27;MethodCall消息&#x27;));<br>&#125;);<br><br>//下发消息<br>channel.invokeMethod(&#x27;toRoot&#x27;).then((value) =&gt; print(&quot;收到原生结果的回调,$value&quot;))<br></code></pre></td></tr></table></figure></li>
<li><code>原生</code>代码，注意这里的消息通道是<code>flutterVC</code>的<code>binaryMessenger</code>即<code>/two_page</code>，也就是最后，在Flutter中创建的<code>MethodChannel</code>,也要在<code>/two_page</code>的<code>Widget</code>生成，<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"> Self.flutterVC.pushRoute(&quot;/two_page&quot;)<br>let channel = FlutterMethodChannel(name: &quot;methodChannel&quot;, binaryMessenger: Self.flutterVC.binaryMessenger)<br>channel.invokeMethod(&quot;nativeInvoke&quot;, arguments: &quot;来自native的methodChannel---\(Self.time)&quot;)<br>channel.setMethodCallHandler &#123;[weak self] call, result in<br>    switch call.method &#123;<br>    case &quot;toRoot&quot;:self?.navigationController?.popToRootViewController(animated: true)<br>    default:break<br>     &#125;<br> &#125;<br>navigationController?.pushViewController(Self.flutterVC, animated: true)<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="BasicMessageChannel"><a href="#BasicMessageChannel" class="headerlink" title="BasicMessageChannel"></a><code>BasicMessageChannel</code></h4><ul>
<li><code>flutter</code>代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">final _messageChannel =<br>  const BasicMessageChannel(&quot;basicMessageChannel&quot;, StandardMessageCodec());<br>  <br>_methodChanel.invokeMethod(&quot;toRoot&quot;)<br><br> _messageChannel.setMessageHandler((message) &#123;<br>  print(&#x27;收到来自iOS的$message&#x27;);<br>  return Future((() =&gt; &#x27;messageChannel&#x27;));<br>&#125;);<br></code></pre></td></tr></table></figure></li>
<li>原生代码  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let  messageChannel = FlutterBasicMessageChannel(name: &quot;basicMessageChannel&quot;, binaryMessenger: Self.flutterVC.binaryMessenger)<br>messageChannel.sendMessage(&quot;methodChannelTwo&quot;) &#123; result in<br>        print(&quot;原生：methodChannelTwo---\(String(describing: result))&quot;)<br>    &#125;<br>messageChannel.setMessageHandler &#123; data, reply in<br>        print(&quot;收到了Flutter的数据\(String(describing: data))&quot;)<br>        reply(&quot;收到了&quot;)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a><code>EventChannel</code></h3></li>
<li><code>flutter</code>代码  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">final _evenChannel = const EventChannel(&quot;eventChannel&quot;);<br>StreamSubscription? _streamSubscription;<br><br>_streamSubscription =<br>    _evenChannel.receiveBroadcastStream([&quot;abc&quot;, 123, &quot;dasw&quot;]).listen(<br>  (event) &#123;<br>    print(&quot;evenChannel$event&quot;);<br>  &#125;,<br>  onDone: () &#123;&#125;,<br>);<br><br><br>//取消监听<br>_streamSubscription?.cancel();<br></code></pre></td></tr></table></figure></li>
<li>原生代码  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let eventChannel = FlutterEventChannel(name: &quot;eventChannel&quot;, binaryMessenger: Self.flutterVC.binaryMessenger)<br>eventChannel.setStreamHandler(self)<br>  <br>  //MARK: FlutterStreamHandler<br>func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -&gt; FlutterError? &#123;<br>    print(&quot;onListen收到了Flutter的数据\(String(describing: arguments))&quot;)<br>    timer = Observable&lt;Int&gt;.timer(.seconds(0),period: .seconds(1), scheduler: MainScheduler.instance).subscribe &#123; num in<br>        events(num)<br>    &#125;<br>    timer?.disposed(by: bag)<br>    return nil<br>&#125;<br><br>func onCancel(withArguments arguments: Any?) -&gt; FlutterError? &#123;<br>    print(&quot;onCancel收到了Flutter的数据\(String(describing: arguments))&quot;)<br>    timer?.dispose()<br>    return nil<br>&#125;  <br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="flutter嵌入原生的view"><a href="#flutter嵌入原生的view" class="headerlink" title="flutter嵌入原生的view"></a>flutter嵌入原生的view</h3><ol>
<li><p>自定义的视图view</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">class TestView:NSObject,FlutterPlatformView &#123;<br>        lazy var nameLabel: UILabel = &#123;<br>            let label = UILabel()<br>            label.font = .systemFont(ofSize: 15)<br>            label.textColor = .white<br>            label.backgroundColor = .red<br>            label.textAlignment = .center<br>            return label<br>          &#125;()<br>        <br>        func view() -&gt; UIView &#123;<br>            return nameLabel<br>        &#125;<br>        <br>        init(_ frame: CGRect,viewID: Int64,args :Any?,messenger:FlutterBinaryMessenger) &#123;<br>            super.init()<br>            if let map = args as? [String:String],<br>               let text = map[&quot;text&quot;] &#123;<br>                nameLabel.text = text<br>            &#125;<br>            methodChannel(messenger: messenger)<br>        &#125;<br>        <br>        private func methodChannel(messenger:FlutterBinaryMessenger)&#123;<br>            let  messageChannel = FlutterBasicMessageChannel(name: &quot;TestViewMessageChannel&quot;, binaryMessenger: messenger)<br>            messageChannel.setMessageHandler &#123;[weak self] data, reply in<br>                if let text = data as? String &#123;<br>                    self?.nameLabel.text = text<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    class TestViewFactory:NSObject, FlutterPlatformViewFactory &#123;<br>        <br>     <br>      var messenger: FlutterBinaryMessenger<br>      init(messenger:FlutterBinaryMessenger) &#123;<br>         self.messenger = messenger<br>         super.init()<br>       &#125;<br>        <br>       <br>       func createArgsCodec() -&gt; FlutterMessageCodec &amp; NSObjectProtocol &#123;<br>         return FlutterStandardMessageCodec.sharedInstance()<br>       &#125;<br>      <br>      func create(withFrame frame: CGRect, viewIdentifier viewId: Int64, arguments args: Any?) -&gt; FlutterPlatformView &#123;<br>            return TestView(frame, viewID: viewId, args: args,messenger: messenger)<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在iOS中注册该view,只执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">static let register: () = &#123;<br>        GeneratedPluginRegistrant.register(with: TextFlutterViewController.flutterVC)<br>        <br>        if let registrar = TextFlutterViewController.flutterVC.registrar(forPlugin: &quot;custom_platform_view_plugin&quot;) &#123;<br>            let factory = TestViewFactory(messenger: registrar.messenger())<br>            registrar.register(factory, withId: &quot;custom_platform_view&quot;)<br>        &#125;<br>&#125;()<br></code></pre></td></tr></table></figure></li>
<li><p><code>flutter</code>中使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">UiKitView(<br>    viewType: &#x27;custom_platform_view&#x27;,<br>    creationParams: &#123;&#x27;text&#x27;: &#x27;Flutter传给IOSTextView的参数&#x27;&#125;,<br>    creationParamsCodec: StandardMessageCodec(),<br>);<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>flutter和原生交互</category>
      </categories>
  </entry>
  <entry>
    <title>flutter指令</title>
    <url>/2022/09/11/Flutter/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Flutter-常用指令"><a href="#Flutter-常用指令" class="headerlink" title="Flutter 常用指令"></a>Flutter 常用指令</h4><ul>
<li>flutter run –no-sound-null-safety  解决flutter插件旧版本兼容问题</li>
<li>flutter create –template=package hello 创建pakcage</li>
<li>flutter create -t module flutter_module 创建fluttermodule</li>
<li>flutter create example 创建flutter项目<h4 id="Flutter包发布指令"><a href="#Flutter包发布指令" class="headerlink" title="Flutter包发布指令"></a>Flutter包发布指令</h4></li>
<li>flutter packages pub publish –dry-run 检查发布前需要准备什么</li>
<li>flutter packages pub publish 直接发布，需要外网，还有授权（注意不要设置代理使用国内镜像）<h4 id="flutter插件"><a href="#flutter插件" class="headerlink" title="flutter插件"></a>flutter插件</h4></li>
<li>flutter create –org com.flutter_plugine –template=plugin –platforms=ios,macos -i swift flutter_plugin  插件新建</li>
</ul>
<h3 id="创建flutter"><a href="#创建flutter" class="headerlink" title="创建flutter"></a>创建flutter</h3><ol>
<li>集成SDK<ul>
<li><a href="https://flutter.cn/docs/get-started/install/macos#get-sdk">Flutter地址</a></li>
</ul>
</li>
<li>创建<code>flutter</code>项目<ul>
<li><code>flutter create -i swift -a java --org com.flutter. test_flutter</code></li>
</ul>
</li>
<li>运行<code>flutter</code>项目<ul>
<li><code>flutter run</code><h3 id="创建packages"><a href="#创建packages" class="headerlink" title="创建packages"></a>创建packages</h3><blockquote>
<ol>
<li>纯flutter的<code>Dart package</code></li>
<li>原生插件<code>Plugin packages</code></li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="Dart-package"><a href="#Dart-package" class="headerlink" title="Dart package"></a><code>Dart package</code></h4><ul>
<li><code>flutter create --template=package hello</code></li>
<li><code>flutter pub publish --dry-run</code><ul>
<li>发布检查包是否合法</li>
</ul>
</li>
</ul>
<h4 id="原生-plugin"><a href="#原生-plugin" class="headerlink" title="原生 plugin"></a><code>原生 plugin</code></h4><ul>
<li><code>flutter create --org com.example --template=plugin --platforms=android,ios -a kotlin -i swift hello</code></li>
<li>创建目录结构如下</li>
</ul>
]]></content>
      <categories>
        <category>flutter指令</category>
      </categories>
  </entry>
  <entry>
    <title>详解iOS的presentViewController</title>
    <url>/2021/07/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E8%AF%A6%E8%A7%A3iOS%E7%9A%84presentViewController/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS中显示ViewController的方式有两种push和modal，modal也叫模态，模态显示VC是iOS的重要特性之一，其主要用于有以下场景：</p>
<ol>
<li>收集用户输入信息 </li>
<li> 临时呈现一些内容 </li>
<li>临时改变工作模式 </li>
<li>相应设备方向变化（用于针对不同方向分别是想两个ViewController的情况）</li>
<li> 显示一个新的view层级</li>
</ol>
<p>这些场景都会暂时中断APP的正常执行流程，主要作用是收集信息以及显示一些重要的提示等。当VCA模态的弹出了VCB，那么VCA就是<code>presenting view controller</code>，VCB就是<code>presented view controller</code></p>
</blockquote>
<h3 id="ModalPresentationStyle-amp-Presentation-Context"><a href="#ModalPresentationStyle-amp-Presentation-Context" class="headerlink" title="ModalPresentationStyle &amp; Presentation Context"></a>ModalPresentationStyle &amp; Presentation Context</h3><h4 id="ModalPresentationStyle"><a href="#ModalPresentationStyle" class="headerlink" title="ModalPresentationStyle"></a>ModalPresentationStyle</h4><p>​        <code>presented VC </code>的<code>modalPresentationStyle</code>属性决定了此次<code>presentation</code>的行为方式及UIKit寻找<code>presentation context</code>的方法，iOS提供了以下几种常用的<code>presentation style</code></p>
<ol>
<li><p><strong>UIModalPresentationFullScreen</strong></p>
<p>UIKit默认的<code>presentation style</code>。 使用这种模式时，<code>presented VC</code>的宽高与屏幕相同，并且UIKit会直接使用<code>rootViewController</code>做为<code>presentation context</code>，在此次presentation完成之后，UIKit会将<code>presentation context及其子VC</code>都移出UI栈，这时候观察VC的层级关系，会发现UIWindow下只有<code>presented VC</code>（视图层级下UIWindow上只有presented VC）.</p>
</li>
<li><p><strong>UIModalPresentationCurrentContext</strong></p>
<p>使用这种方式<code>present VC</code>时，<code>presented VC</code>的宽高取决于<code>presentation context</code>的宽高，并且UIKit会寻找属性<code>definesPresentationContext</code>为YES的VC作为<code>presentation context</code> 。当此次<code>presentation</code>完成之后，<code>presentation context</code>及其子VC都将被暂时移出当前的UI栈。</p>
</li>
<li><p><strong>UIModalPresentationCustom</strong></p>
<p>自定义模式，需要实现UIViewControllerTransitioningDelegate的相关方法，并将presented VC的transitioningDelegate 设置为实现了UIViewControllerTransitioningDelegate协议的对象。</p>
</li>
<li><p><strong>UIModalPresentationOverFullScreen</strong></p>
<p>与<code>UIModalPresentationFullScreen</code>的唯一<strong>区别</strong>在于，UIWindow下除了<code>presented VC</code>，还有其他正常的VC层级关系。也就是说该模式下，UIKit以<code>rootViewController</code>为<code>presentation context</code>，但presentation完成之后不会将<code>rootViewController移出当前的UI栈</code>。</p>
</li>
<li><p><strong>UIModalPresentationOverCurrentContext</strong></p>
<p>寻找<code>presentation context</code>的方式与<code>UIModalPresentationCurrentContext</code>相同，所不同的是<code>presentation</code>完成之后，不会将<code>context及其子VC移出当前UI栈</code>。但是，这种方式只<strong>适用于transition style为UIModalTransitionStyleCoverVertical的情况</strong>(UIKit默认就是这种transition style)。其他transition style下使用这种方式将会触发异常。</p>
</li>
<li><p><strong>UIModalPresentationBlurOverFullScreen</strong></p>
<p><code>presentation</code>完成之后，如果<code>presented VC</code>的背景有透明部分，会看到presented VC下面的VC会变得模糊，其他与<code>UIModalPresentationOverFullScreen</code>模式没有区别。</p>
</li>
<li><p><strong>UIModalPresentationPageSheet</strong></p>
<p>在常规型设备（大屏手机，例如plus系列以及iPad系列）的水平方向，<code>presented VC</code>的高为当前屏幕的高度，宽为该设备竖直方向屏幕的宽度，其余部分用透明背景做填充。对于紧凑型设备（小屏手机）的水平方向及所有设备的竖直方向，其显示效果与<code>UIModalPresentationFullScreen</code>相同。</p>
</li>
<li><p><strong>UIModalPresentationFormSheet</strong></p>
<p>在常规型设备的水平方向，<code>presented VC</code>的宽高均小于屏幕尺寸，其余部分用透明背景填充。对于紧凑型设备的水平方向及所有设备的竖直方向，其显示效果与<code>UIModalPresentationFullScreen</code>相同</p>
</li>
</ol>
<p><code>UIModalPresentationFullScreen</code>、<code>UIModalPresentationCurrentContext</code>在转场完成后会将<code>context及其子VC移出当前UI栈</code>,因此转场结束后是无法看到presenting的视图的，而其他情况下的style是可以看到的</p>
<h4 id="presentation-context"><a href="#presentation-context" class="headerlink" title="presentation context"></a>presentation context</h4><blockquote>
<p><code>presentation context</code>是指为本次<code>present</code>提供上下文环境的类，需要指出的是，<code>presenting VC</code>通常并不是<code>presentation context</code></p>
</blockquote>
<p>​        当我们需要<code>present VC</code>的时候，除非我们指定了<code>context</code>，否则UIKit会优先选择<code>presenting VC</code>所属的容器类做为<code>presentation context</code>，如果没有容器类，那么会选择<code>rootViewController</code>。但是，UIKit搜索context的方式还与<code>presented VC</code>的<code>modalPresentationStyle</code>属性有关，当<code>modalPresentationStyle</code>为<code>UIModalPresentationFullScreen</code>、<code>UIModalPresentationOverFullScreen</code>等模式时，UIKit会直接选择<code>rootViewController</code>做为<code>context</code>。当<code>modalPresentationStyle</code>为<code>UIModalPresentationOverCurrentContext</code>、<code>UIModalPresentationCurrentContext</code>模式时，UIKit搜索<code>context</code>的方式如下：</p>
<ul>
<li><p><code>UIModalPresentationOverCurrentContext</code>、<code>UIModalPresentationCurrentContext</code>模式下，一个VC能否成为<code>presentation context</code> 是由VC的<code>definesPresentationContext</code>属性决定的，这是一个<code>BOOL</code>值，默认<code>UIViewController的definesPresentationContext</code>属性值是<code>NO</code>，而<strong>container view controller</strong>（容器控制器）的<code>definesPresentationContext</code>默认值是<code>YES</code>，这也是上文中，UIKit总是将<code>container view controller</code>做为<code>presentation context</code>的原因。如果我们想指定<code>presenting VC</code>做为<code>context</code>，只需要在<code>presenting VC</code>的<code>viewDidLoad</code>方法里添加如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">self.definesPresentationContext = YES<br></code></pre></td></tr></table></figure></li>
</ul>
<p>UIKit搜索<code>presentation context</code>的顺序为： </p>
<ol>
<li><code>presenting VC</code> </li>
<li><code>presenting VC</code> 的<code>父VC </code></li>
<li><code>presenting VC</code> 所属的<code>container VC </code></li>
<li><code>rootViewController</code></li>
</ol>
<h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><blockquote>
<p><strong>presented VC 总是与 presentation context 处于同一层级，而与presenting VC所在的层级无关，且同一个presentation context同时只能有一个presented VC。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>协议注意的点</title>
    <url>/2021/07/10/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="协议注意的点"><a href="#协议注意的点" class="headerlink" title="协议注意的点"></a>协议注意的点</h1><h2 id="已重写的限制条件会在某些泛型上下文中失效"><a href="#已重写的限制条件会在某些泛型上下文中失效" class="headerlink" title="已重写的限制条件会在某些泛型上下文中失效"></a>已重写的限制条件会在某些泛型上下文中失效</h2><p>对于一些通过条件遵循获得了特定行为的类型，在某些泛型上下文中，并不能够确保能够使用协议限制中的特定实现。为了说明这个行为，下面的例子中定义了两个协议以及一个有条件地遵循两个协议的泛型类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Loggable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span>()</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Loggable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TitledLoggable</span>: <span class="hljs-title">Loggable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> logTitle: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TitledLoggable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-keyword">Self</span>.logTitle)</span>: <span class="hljs-subst">\(<span class="hljs-keyword">self</span>)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt;: <span class="hljs-title">CustomStringConvertible</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> first: <span class="hljs-type">T</span><br>    <span class="hljs-keyword">let</span> second: <span class="hljs-type">T</span><br>    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(<span class="hljs-subst">\(first)</span>, <span class="hljs-subst">\(second)</span>)&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Pair</span>: <span class="hljs-title">Loggable</span> <span class="hljs-title">where</span> <span class="hljs-title">T</span>: <span class="hljs-title">Loggable</span> </span>&#123; &#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Pair</span>: <span class="hljs-title">TitledLoggable</span> <span class="hljs-title">where</span> <span class="hljs-title">T</span>: <span class="hljs-title">TitledLoggable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> logTitle: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pair of &#x27;<span class="hljs-subst">\(T.logTitle)</span>&#x27;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">String</span>: <span class="hljs-title">TitledLoggable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> logTitle: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;String&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当其泛型类型遵循<code>Loggable</code> 协议以及 <code>TitleLoggale</code> 协议时，结构体 <code>Pair</code> 遵循 <code>Loggable</code> 协议以及 <code>TitleLoggale</code> 协议。下面的例子中，<code>oneAndTwo</code> 是 <code>Pair&lt;String&gt; </code>的一个实例。因为 <code>String</code> 遵循 <code>TitleLoggable</code>，因此 <code>oneAndTwo</code> 也遵循此协议。当 <code>log()</code> 方法被 <code>oneAndTwo</code> 直接调用时，此方法使用的是包含标题的特定版本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> oneAndTwo <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;Pair of &#x27;String&#x27;: (one, two)&quot;</span><br></code></pre></td></tr></table></figure>
<p>虽然如此，当<code>oneAndTwo</code> 在泛型上下文中使用，或者它是 <code>Loggable/TitledLoggable</code> 类型的实例时，包含标题的特定版本 <code>log()</code> 方法不会被使用。</p>
<ol>
<li>会根据该协议查找方法，如果实现了，则直接用实现了的，否则<strong>Swift 只会根据这样的规则来选择 log() 的实现版本—— <code>Pair 遵循 Loggable 所需要的最少的限制条件</code>。因此 <code>Loggable</code> 所提供的默认实现版本会被使用</strong>。<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> oneAndTwo:<span class="hljs-type">Loggable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;(one, two)&quot;</span><br><span class="hljs-keyword">let</span> oneAndTwo:<span class="hljs-type">TitledLoggable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;(one, two)&quot;</span><br></code></pre></td></tr></table></figure></li>
<li>如果<code>Loggable</code>协议中没有定义<code>func log()</code>方法，则会走各自协议默认的<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> oneAndTwo:<span class="hljs-type">Loggable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;(one, two)&quot;</span><br><span class="hljs-keyword">let</span> oneAndTwo:<span class="hljs-type">TitledLoggable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Pair</span>(first: <span class="hljs-string">&quot;one&quot;</span>, second: <span class="hljs-string">&quot;two&quot;</span>)<br>oneAndTwo.log()<br><span class="hljs-comment">// Prints &quot;Pair of &#x27;String&#x27;: (one, two)&quot;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="协议的动态派发"><a href="#协议的动态派发" class="headerlink" title="协议的动态派发"></a>协议的动态派发</h2><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Chef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeFood</span>()</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Chef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeFood</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;makeFood&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeafoodChef</span>: <span class="hljs-title">Chef</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeFood</span>()</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Cook Seafood&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> chefone:<span class="hljs-type">Chef</span> <span class="hljs-operator">=</span> <span class="hljs-type">SeafoodChef</span>()<br><span class="hljs-keyword">let</span> cheftwo:<span class="hljs-type">SeafoodChef</span> <span class="hljs-operator">=</span>  <span class="hljs-type">SeafoodChef</span>()<br>chefone.makeFood() <span class="hljs-comment">//Cook Seafood</span><br>cheftwo.makeFood() <span class="hljs-comment">//Cook Seafood</span><br></code></pre></td></tr></table></figure>
<ul>
<li>上述的结果均为<code>Cook Seafood</code>，因为协议中是动态派发、扩展中是静态派发，如果是协议的方法会根据对象的实际类型进行调用</li>
<li>如果将协议中的<code>makeFood()</code>方法去掉，则会打印<code>makeFood / Cook Seafood</code>,如果没有协议方法，则会根据声明类型进行调用。</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>碰到的一些问题</title>
    <url>/2021/07/10/iOS%E5%AD%A6%E4%B9%A0/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="场景图片的问题"><a href="#场景图片的问题" class="headerlink" title="场景图片的问题"></a>场景图片的问题</h3><ol>
<li>从相册中导出全场景图片存在的问题<ol>
<li>压缩图片的质量</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">[[PHCachingImageManager defaultManager]<br>        requestImageDataForAsset:mAsset<br>                         options:nil<br>                   resultHandler:^(NSData *_Nullable imageData, NSString *_Nullable dataUTI, UIImageOrientation orientation, NSDictionary *_Nullable info) &#123;<br>                     UIImage *resultImage = [UIImage imageWithData:imageData];<br>                     //获得的image要转换为正确的方向<br>                    // 然后将该image导入到本地文件中<br>                     //注意要用jpg的形式导入本地，否则，图片文件的大小会激增，有4M多变成90Mb（原因未知）<br>                      BOOL result = [UIImageJPEGRepresentation(image, 0.5) writeToFile:filePath atomically:YES];<br>                     //采用png的形式保存场景图片，会出现存储图片内存激增<br>                     BOOL result = [UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];<br>                   &#125;];<br></code></pre></td></tr></table></figure>

<p>​        2. 全场景图片一般为十几万✖️几千的分辨率，上述压缩的方式可以使全场景图片在iphone6plus上显示，没有卡顿现象，但是这样的图片在iphone6上仍有有明显的卡顿，</p>
<h3 id="单例block引用导致内存泄漏的问题"><a href="#单例block引用导致内存泄漏的问题" class="headerlink" title="单例block引用导致内存泄漏的问题"></a>单例block引用导致内存泄漏的问题</h3><ol>
<li>注意如果block为单例的属性，那么在该block中要注意内存泄露的问题，因为单例会一直无法释放，会一直持有属性，而属性会一直持有block中的对象，那么就会导致block中捕获的对象，造成对象无法释放</li>
<li>如果是方法中的block，那么方法在执行完毕之后，便会释放block，不会一直持有，不用担心内存泄露的问题</li>
</ol>
]]></content>
      <categories>
        <category>零碎知识点</category>
      </categories>
  </entry>
  <entry>
    <title>iOS视图控制器转场详解</title>
    <url>/2021/07/02/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/iOS%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BD%AC%E5%9C%BA%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>视图控制器中的视图显示在屏幕上有两种方式：</p>
<ol>
<li>最主要的方式是内嵌在容器控制器中，比如<code>UINavigationController</code>（<code>push</code>或<code>pop</code>一个<code>viewController</code>），<code>UITabBarController</code>（切换到其他<code>viewController</code>）, <code>UISplitController</code>；</li>
<li>由另一个视图控制器显示它，也就是模态(<code>Modal</code>)显示(以Model方式显示另一个<code>viewController</code>)</li>
</ol>
<p>在 <code>storyboard</code> 里，每个<code>View Controller</code>是一个<code> Scene</code>，<code>View Controller Transition </code>便是从一个 <code>Scene</code> 转换到另外一个 <code>Scene</code>。</p>
<p>在iOS7之前，只能使用系统提供的转场效果，iOS7之后开放相关API运行对转场效果进行定制</p>
</blockquote>
<span id="more"></span>

<h3 id="Transition-解释"><a href="#Transition-解释" class="headerlink" title="Transition 解释"></a>Transition 解释</h3><p>转场时视图控制器和其对应的视图在结构上的变化：</p>
<p><img src="1.png" alt="1.png"></p>
<p>​        转场过程中，作为容器的父 VC 维护着多个子 VC，但在视图结构上，只保留一个子 VC 的视图，所以转场的本质是下一场景(子 VC)的视图替换当前场景(子 VC)的视图以及相应的控制器(子 VC)的替换，表现为当前视图消失和下一视图出现。</p>
<h3 id="系统自带的方式"><a href="#系统自带的方式" class="headerlink" title="系统自带的方式"></a>系统自带的方式</h3><h4 id="CATransition"><a href="#CATransition" class="headerlink" title="CATransition"></a>CATransition</h4><p><code>CATransition</code>是<code>CAAnimation</code>的子类，用于过渡动画或转场动画。为视图层移入移除屏幕提供转场动画。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">CATransition *animation = [CATransition animation];<br>animation.type = type;<br>animation.subtype = kCATransitionFromRight;<br>animation.duration = 1.0;<br>[vc.view.window.layer addAnimation:animation forKey:kCATransition];<br></code></pre></td></tr></table></figure>

<ul>
<li>type：转场动画的类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">fade=1,                   //淡入淡出<br>  pageCurl,                 //翻页<br>  push,                     //推挤<br>  pageUnCurl,               //反翻页<br>  reveal,                   //揭开<br>  cameraIrisHollowOpen,     //开镜头<br>  moveIn,                   //覆盖<br>  cameraIrisHolowClose,     //关镜头<br>  cube,                     //立方体<br>  suckEffect,               //吮吸<br>  oglFlip,                  //翻转<br>  rippleEffect,             //波纹<br></code></pre></td></tr></table></figure>

<ul>
<li>subtype：动画类型的方向，4个方向上下左右</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">kCATransitionFromRight,<br>kCATransitionFromLeft,<br>kCATransitionFromTop,<br>kCATransitionFromBottom<br></code></pre></td></tr></table></figure>

<h4 id="TransitionFromViewController"><a href="#TransitionFromViewController" class="headerlink" title="TransitionFromViewController"></a>TransitionFromViewController</h4><ul>
<li>同一页面显示多个视图的方式，采用<code>UIViewController</code>自带的方法：<code>transitionFromViewController:toViewController:duration:options:animations:completion:</code>这种转场动画是在当一个父视图控制器中有几个<code>childViewController</code>，当要在这个几个子视图控制器之间切换时可以用这个方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">//1. 在一个控制器内加入多个子控制器<br>[self addChildViewCOntroller:fristVc];<br>[self addChildViewCOntroller:secondVc];<br>//2. 当前控制器显示的视图<br>[self.view addSubview:[self.childViewControllers[0] view]];<br>//3. 多视图的转换<br>/*<br>     *  fromViewController      当前显示在父视图控制器中的子视图控制器<br>     *  toViewController        将要显示的姿势图控制器<br>     *  duration                动画时间(这个属性,old friend 了 O(∩_∩)O)<br>     *  options                 动画效果(渐变,从下往上等等,具体查看API)<br>     *  animations              转换过程中的动画<br>     *  completion              转换完成<br>*/<br>[self transitionFromViewController:self.childViewControllers[0] toViewController:self.childViewControllers[1] duration:0.5 options:UIViewAnimationOptionTransitionCurlUp animations:^&#123;<br>        <br> &#125; completion:^(BOOL finished) &#123;<br>        <br>&#125;];<br></code></pre></td></tr></table></figure>

<h4 id="Transition-Animation（自定义转场动画的实现）"><a href="#Transition-Animation（自定义转场动画的实现）" class="headerlink" title="Transition Animation（自定义转场动画的实现）"></a>Transition Animation（自定义转场动画的实现）</h4><p>官方支持以下几种方式的自定义转场：</p>
<ol>
<li><code>UINavigationController</code> 中<code> push</code> 和 <code>pop</code></li>
<li><code> UITabBarController</code> 中切换 <code>Tab</code></li>
<li><code>Modal</code>转场：<code>presentation</code> 和 <code>dismissal</code>，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code> 这两种模式;</li>
<li><code>UICollectionViewController</code> 的布局转场：<code>UICollectionViewController </code>与 <code>UINavigationController </code>结合的转场方式</li>
</ol>
<p>转场协议由5种协议组成，实际中只需要提供其中的两个或者三个便能实现绝大部分的转场动画</p>
<h5 id="转场代理（Transition-Delegate）"><a href="#转场代理（Transition-Delegate）" class="headerlink" title="转场代理（Transition Delegate）"></a>转场代理（<strong>Transition Delegate</strong>）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。<br>&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。<br>&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。<br></code></pre></td></tr></table></figure>

<ul>
<li>转场发生时，<code>UIKit </code>将要求转场代理将提供转场动画的核心构件：动画控制器和交互控制器(可选的)；由我们实现。</li>
</ul>
<h5 id="动画控制器-Animation-Controller-："><a href="#动画控制器-Animation-Controller-：" class="headerlink" title="动画控制器(Animation Controller)："></a>动画控制器(Animation Controller)：</h5><ul>
<li>最重要的部分，负责添加视图以及执行动画；遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议。</li>
</ul>
<h5 id="交互控制器-Interaction-Controller-："><a href="#交互控制器-Interaction-Controller-：" class="headerlink" title="交互控制器(Interaction Controller)："></a>交互控制器(Interaction Controller)：</h5><p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议；系统已经打包好现成的类供我们使用。</p>
<h5 id="转场环境-Transition-Context"><a href="#转场环境-Transition-Context" class="headerlink" title="转场环境(Transition Context):"></a>转场环境(Transition Context):</h5><p>提供转场中需要的数据；遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议；由 <code>UIKit </code>在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</p>
<h5 id="转场协调器-Transition-Coordinator-："><a href="#转场协调器-Transition-Coordinator-：" class="headerlink" title="转场协调器(Transition Coordinator)："></a>转场协调器(Transition Coordinator)：</h5><p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<code>&lt;UIViewCOntrollerTrabsitionCoordinator&gt;</code>协议；由<code> UIKit</code> 在转场时生成，<code>UIViewController</code> 在 iOS 7 中新增了方法<code> transitionCoordinator()</code>返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</p>
<h3 id="阶段一：非交互转场"><a href="#阶段一：非交互转场" class="headerlink" title="阶段一：非交互转场"></a>阶段一：非交互转场</h3><blockquote>
<p>这个阶段要做两件事，提供转场代理并由代理提供动画控制器。在转场代理协议里动画控制器和交互控制器都是可选实现的，没有实现或者返回 nil 的话则使用默认的转场效果。动画控制器是表现转场效果的核心部分</p>
</blockquote>
<h4 id="动画控制器协议"><a href="#动画控制器协议" class="headerlink" title="动画控制器协议"></a>动画控制器协议</h4><ol>
<li>动画控制器实现代理<code>&lt;UIViewControllerAnimatedTransitioning&gt;</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">-(void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; <br>  //1. <br>  UIView *container = [transitionContext containerView];<br>  <br>  //2. <br> if ([transitionContext respondsToSelector:@selector(viewForKey:)]) &#123;<br>        // iOS8以上新增加API获取参与转场的视图，能精确获取参与转场的视图<br>        fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];<br>        toView = [transitionContext viewForKey:UITransitionContextToViewKey];<br>    &#125; else &#123;<br>   		//获取参与转场的控制器视图<br>        fromView = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey].view;<br>        toView = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey].view;<br>    &#125;<br>  <br>  //3. <br>  [container addSubview:toView];<br>  ......<br>  [UIView animateWithDuration:[self transitionDuration:transitionContext] 					animations:^&#123;<br>  				  ......<br>        &#125; completion:^(BOOL finished) &#123;<br>    //4. <br>   					BOOL isCancelled = [transitionContext transitionWasCancelled];<br>            [transitionContext completeTransition:!isCancelled];<br>        &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>返回容器视图，也就是转场动画发生的地方</li>
<li>通过<code>viewForKey:</code>获取的视图是<code>viewControllerForKey:</code>返回的控制器的根视图，或者<code> nil</code>。<code>viewForKey:</code>方法返回<code> nil</code> 只有一种情况：<code> UIModalPresentationCustom</code>以及 <code> UIModalPresentationOverFullScreen</code>等模式下的<code> Modal</code> 转场 （这些转场结束后不会移除<code>preserting</code>），通过此方法获取 <code>presentingView </code>时得到的将是 nil。</li>
<li>将<code>toView</code>添加到容器视图中，使得<code>toView</code>在屏幕上显示（<code>Modal</code>转场中此点稍有不同）</li>
<li>正确地结束转场过程。转场的结果有两种：完成或取消。非交互转场的结果只有完成一种情况，不过交互式转场需要考虑取消的情况。如何结束取决于转场的进度，通过<code>transitionWasCancelled</code>方法来获取转场的状态，使用<code>completeTransition:</code>来完成或取消转场</li>
</ol>
<p>​    转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的场景的视图为<code> fromView</code>，对应的视图控制器为<code> fromVC</code>，即将出现的视图为 <code>toView</code>，对应的视图控制器称之为<code> toVC</code>。几种转场方式的转场操作都是可逆的，一种操作里的<code> fromView</code> 和 <code>toView</code> 在逆向操作里的角色互换成对方，<code>fromVC</code> 和<code>toVC</code>也是如此。在动画控制器里，参与转场的视图只有 <code>fromView </code>和<code> toView</code> 之分，与转场方式无关。</p>
<p>​    实际上无论是简单的转场动画，还是那些很复杂的转场动画在转场的部分要做的事情都是上面提到的4个过程，它们的区别主要在于动画的部分。</p>
<h5 id="逐帧播放的动画方式"><a href="#逐帧播放的动画方式" class="headerlink" title="逐帧播放的动画方式"></a>逐帧播放的动画方式</h5><blockquote>
<p>与原来的动画相比能在动画里面，在通过帧率逐帧的实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">[UIView animateKeyframesWithDuration:self.duration delay:0 options:0 animations:^&#123;<br>            [UIView addKeyframeWithRelativeStartTime:0 relativeDuration:0.9 animations:^&#123;<br>                ......<br>            &#125;];<br>            [UIView addKeyframeWithRelativeStartTime:0.9 relativeDuration:0.1 animations:^&#123;<br>                ......<br>            &#125;];<br>        &#125; completion:^(BOOL finished) &#123;<br>            [imageView removeFromSuperview];<br>            BOOL wasCancelled = [transitionContext transitionWasCancelled];<br>            [transitionContext completeTransition:!wasCancelled];<br>        &#125;];<br></code></pre></td></tr></table></figure>

<h4 id="特殊的Modal转场"><a href="#特殊的Modal转场" class="headerlink" title="特殊的Modal转场"></a>特殊的Modal转场</h4><blockquote>
<p>Modal 转场中需要做的事情和两种容器 VC 的转场一样，但在细节上有些差异。</p>
</blockquote>
<p><img src="2.png" alt="2.png"></p>
<ol>
<li>根视图是否参与转场</li>
</ol>
<p>​        <code>   UINavigationController</code>和<code>UITabBarController</code>这两个容器 <code>VC</code> 的根视图在屏幕上是不可见的(或者说是透明的)，可见的只是内嵌在这两者中的<code>子 VC </code>中的视图，转场是从<code>子 VC </code>的视图转换到另外一个<code>子 VC </code>的视图，其根视图并未参与转场；而<code>Modal</code>转场，以 <code>presentation </code>为例，是从 <code>presentingView </code>转换到 <code>presentedView</code>，根视图 <code>presentingView </code>也就是<code>fromView</code>参与了转场。而且 <code>NavigationController</code> 和 <code>TabBarController</code> 转场中的<code> containerView</code> 也并非这两者的根视图。</p>
<ol start="2">
<li>转场后的<code>fromView</code>是否依然可见</li>
</ol>
<p>​        <code>Modal </code>转场结束后 <code>presentingView </code>可能依然可见，除<code>UIModalPresentationFullScreen</code>之外，其他模式就是这样。这种不同导致了 <code>Modal </code>转场和<code>容器 VC</code> 的转场对 <code>fromView</code> 的处理差异：<code>容器 VC</code> 的转场结束后 <code>fromView </code>会被主动移出视图结构，这是可预见的结果，我们也可以在转场结束前手动移除；而<code>Modal</code> 转场中，<code>presentation</code> 结束后 <code>presentingView(fromView) </code>并未主动被从视图结构中移除。准确来说，是 <code>UIModalPresentationCustom </code>这种模式下的 <code>Modal</code> 转场结束时<code>fromView</code>并未从视图结构中移除；<code>UIModalPresentationFullScreen </code>模式的<code> Modal</code> 转场结束后<code>fromView</code>依然主动被从视图结构中移除了。这种差异导致在处理<code> dismissal</code> 转场的时候很容易出现问题，没有意识到这个不同点的话出错时就会毫无头绪。</p>
<p>​        下面来看看 <code>dismissal</code> 转场时的场景：</p>
<ol>
<li><code>UIModalPresentationFullScreen </code>模式：:转场时 <code>containerView </code>并不管理 <code>presentingView</code> ，<code>presentation</code> 后，<code>presentingView </code>被主动移出视图结构，在 <code>dismissal</code> 中<code> presentingView</code> 是 <code>toView</code> 的角色，其将会重新加入<code>containerView</code>中，实际上，我们不主动将其加入，<code>UIKit </code>也会这么做，前面的两种容器控制器的转场里不是这样处理的，不过这个差异基本没什么影响。</li>
<li><code>UIModalPresentationCustom 模式</code>:转场时 <code>containerView </code>并不担任 <code>presentingView</code> 的父视图，后者由 <code>UIKit</code> 另行管理。在 <code>presentation</code> 后，<code>fromView(presentingView) </code>未被移出视图结构，在 <code>dismissal </code>中，注意不要像其他转场中那样将 <code>toView(presentingView)</code> 加入 <code>containerView </code>中，否则本来可见的<code> presentingView</code> 将会被移除出自身所处的视图结构消失不见<ol>
<li>这里注意：如果采用<code>viewForKey</code>直接获取视图，那么<code>custon模式</code>下，**present时，<code>fromView（presentingView）为nil</code>，而<code>dimissal</code>时，<code>toView（presentingView）为nil</code>**，也就是用这种方式获取的视图，添加到containerView中，<code>dismissal</code>不会出问题。但是如果通过<code>viewControllerForKey</code>直接获取控制器中的<code>View</code>则不会为nil，这时候添加则会出现问题</li>
</ol>
</li>
</ol>
<h4 id="实现代理"><a href="#实现代理" class="headerlink" title="实现代理"></a>实现代理</h4><ol>
<li><code>UINavigationController</code>转场动画的实现，实现代理 <code>&lt;UINavigationControllerDelegate&gt;</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">//self.navigationController.delegate = self;<br><br>-(id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; <br>  ....<br>    //返回自定义的动画控制器，push和pop都在这个方法中返回<br>  switch (operation) &#123;<br>        case UINavigationControllerOperationPush:<br>            animationController.type = AnimationTypePush;<br>            return  animationController;<br>        case UINavigationControllerOperationPop:<br>            animationController.type = AnimationTypePop;<br>            return animationController;<br>        default: return nil;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><code>presenting</code>出的视图</li>
</ol>
<h3 id="阶段二：交互式转场"><a href="#阶段二：交互式转场" class="headerlink" title="阶段二：交互式转场"></a>阶段二：交互式转场</h3><blockquote>
<p>实现交互化，在非交互转场的基础上将之交互化需要两个条件：</p>
</blockquote>
<ol>
<li>由转场代理提供交互控制器，这是一个遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。</li>
<li>交互控制器还需要交互手段的配合，最常见的是使用手势</li>
</ol>
<p>正确的提供交互控制器:</p>
<p>​    转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程（比如手势），转场过程将一直处于开始阶段无法结束，应用界面也会失去响应：在<code>NavigationController </code>中点击 <code>NavigationBar </code>也能实现 <code>pop </code>返回操作，但此时没有了交互手段的支持，转场过程卡壳；在 <code>TabBarController </code>的代理里提供交互控制器存在同样的问题，点击 <code>TabBar</code> 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。、</p>
<h4 id="UINavigationControllerDelegaate的交互转场"><a href="#UINavigationControllerDelegaate的交互转场" class="headerlink" title="UINavigationControllerDelegaate的交互转场"></a>UINavigationControllerDelegaate的交互转场</h4><ol>
<li>实现代理方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController<br>                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController &#123;<br>    //注意没有手势的时候要返回nil，否则无法通过点击导航栏左边的item正常退出                        <br>    if (self.interactiveAnimation.isInteractive) &#123;<br>        return self.interactiveAnimation;<br>    &#125;<br>    return  nil<br>                          &#125;<br></code></pre></td></tr></table></figure>

<h4 id="modal弹窗显示交互手势"><a href="#modal弹窗显示交互手势" class="headerlink" title="modal弹窗显示交互手势"></a>modal弹窗显示交互手势</h4><ol>
<li>实现代理</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123;<br>    return nil;<br>&#125;<br><br>- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123;<br>    if (self.interactiveAnimation.isInteractive) &#123;<br>        return self.interactiveAnimation;<br>    &#125;<br>    return  nil;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="交互控制器的实现"><a href="#交互控制器的实现" class="headerlink" title="交互控制器的实现"></a>交互控制器的实现</h4><p>交互控制器为继承<code>UIPercentDrivenInteractiveTransition</code>的类，主要结合边缘滑动手势</p>
<p><code>UIScreenEdgePanGestureRecognizer</code>，其中主要依靠的方法</p>
<ol>
<li><p><code>[self updateInteractiveTransition:_percent]</code>,更新交互转场完成的百分比;</p>
</li>
<li><p><code>[self finishInteractiveTransition]</code>完成交互转场</p>
</li>
<li><p><code>[self cancelInteractiveTransition];</code>取消交互转场</p>
</li>
</ol>
<h5 id="具体的实现"><a href="#具体的实现" class="headerlink" title="具体的实现"></a>具体的实现</h5><ol>
<li>给页面添加边缘滑动手势</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">UIScreenEdgePanGestureRecognizer *interactiveTransitionRecognizer  = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(panAction:)];<br>interactiveTransitionRecognizer.edges = UIRectEdgeLeft;<br>[vc.view addGestureRecognizer:interactiveTransitionRecognizer];<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>找到转场动画的容器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">- (void)startInteractiveTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;<br>    [super startInteractiveTransition:transitionContext];<br>    self.transitionContext = transitionContext;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>实际手势的实现</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">- (void)panAction:(UIPanGestureRecognizer *)pan&#123;<br>    _percent = 0.0;<br>    //UIView *transitionContainerView = pan.view;从手势中也可以获取手势滑动的view，但是转场动画中涉及3d变化的动画操作，那么将无法从手势中获取相应变换的相对位置<br>    UIView *transitionContainerView = self.transitionContext.containerView;<br>    CGFloat totalWidth  = CGRectGetWidth(transitionContainerView.bounds);<br>    CGFloat totalHeight = CGRectGetHeight(transitionContainerView.bounds);<br>  	CGFloat x = [pan translationInView:transitionContainerView].x;<br>            _percent = -x/totalWidth;<br>  switch (pan.state) &#123;<br>        case UIGestureRecognizerStateBegan:<br>            _isInter = YES;<br>            [self.vc.navigationController popViewControllerAnimated:YES];<br>    			//  [self.vc dismissViewControllerAnimated:YES completion:nil];<br>            break;<br>        case UIGestureRecognizerStateChanged:<br>            [self updateInteractiveTransition:_percent];<br>            break;<br>        case UIGestureRecognizerStateEnded:<br>            _isInter = NO;<br>            [self continueAction];<br>            break;<br>        default:<br>            break;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>手势结束后动画UI的变化，</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">//采用gui定时器的方式来处理转场动画变换<br>- (void)continueAction&#123;<br>    if (_displayLink) &#123;<br>        return;<br>    &#125;<br>    _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(UIChange)];<br>    [_displayLink  addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];<br><br>&#125;<br>//转场uI的变换<br>- (void)UIChange &#123;<br>    CGFloat timeDistance = 2.0/60;<br>    if (_percent &gt; 0.4) &#123;<br>        _percent += timeDistance;<br>    &#125;else &#123;<br>        _percent -= timeDistance;<br>    &#125;<br>    [self updateInteractiveTransition:_percent];<br>    if (_percent &gt;= 1.0) &#123;<br>        [self finishInteractiveTransition];<br>        [self stopDisplayLink];<br>    &#125;<br>    <br>    if (_percent &lt;= 0.0) &#123;<br>        [self stopDisplayLink];<br>        [self cancelInteractiveTransition];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>​        </p>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>图层视觉效果</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%B1%82%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图层蒙板"><a href="#图层蒙板" class="headerlink" title="图层蒙板"></a>图层蒙板</h2><blockquote>
<p><code>CALayer</code>有一个属性叫做<code>mask</code>可以解决这个问题，这个属性本身就是个<code>CALayer</code>类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，不同于那些绘制在父图层中的子图层，<code>mask</code>图层定义了父图层的部分可见区域。</p>
</blockquote>
<ul>
<li><code>mask</code>图层的Color属性是无关紧要的，真正重要的是图层的轮廓。其显示的轮廓即为图层能显示的区域</li>
</ul>
<span id="more"></span>

<h2 id="拉伸过滤算法"><a href="#拉伸过滤算法" class="headerlink" title="拉伸过滤算法"></a>拉伸过滤算法</h2><blockquote>
<p>当图片需要显示不同的大小的时候<code>minificationFilter</code>和<code>magnificationFilter</code>属性。，有一种叫做拉伸过滤的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
</blockquote>
<ul>
<li>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。<code>CALayer</code>为此提供了三种拉伸过滤方法，他们是：<ol>
<li> kCAFilterLinear</li>
<li> kCAFilterNearest</li>
<li> kCAFilterTrilinear</li>
</ol>
</li>
</ul>
<h3 id="kCAFilterLinear和kCAFilterTrilinear"><a href="#kCAFilterLinear和kCAFilterTrilinear" class="headerlink" title="kCAFilterLinear和kCAFilterTrilinear"></a><code>kCAFilterLinear</code>和<code>kCAFilterTrilinear</code></h3><ul>
<li><p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是<code>kCAFilterLinear</code>，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。</p>
</li>
<li><p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<h3 id="kCAFilterNearest"><a href="#kCAFilterNearest" class="headerlink" title="kCAFilterNearest"></a><code>kCAFilterNearest</code></h3></li>
<li><p><code>kCAFilterNearest</code>是一种比较武断的方法,这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3></li>
<li><p>总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。因此对于大图来说，双线性滤波和三线性滤波表现得更出色,而对于没有斜线的小图来说，最近过滤算法要好很多。</p>
</li>
<li><p>用法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//对于小图片极少斜线的图，用最近的放大算法较好<br>view.layer.magnificationFilter = kCAFilterNearest;<br></code></pre></td></tr></table></figure>
<h2 id="组透明"><a href="#组透明" class="headerlink" title="组透明"></a>组透明</h2><blockquote>
<p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
</blockquote>
<ul>
<li>下图展示了一个内嵌UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</li>
</ul>
<p><img src="1.png" alt="1.png"></p>
<ul>
<li>这是由透明度混合叠加造成的，当你显示一个个50%透明度的图层时，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来自图层本身的颜色，另外的25%则来自背景色。所以合起来中间标签可见度为75%</li>
<li>处理方法<ul>
<li>可以设置CALayer的一个叫做<code>shouldRasterize</code>属性来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了.</li>
<li>为了启用<code>shouldRasterize</code>属性，我们设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了<code>shouldRasterize</code>属性，你就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕(Retina的像素比和一般屏幕不一样)像素化的问题。</li>
<li>代码</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">button2.layer.shouldRasterize = YES;<br>button2.layer.rasterizationScale = [UIScreen mainScreen].scale;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>视频H264硬编码</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E8%A7%86%E9%A2%91H264%E7%A1%AC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>像素的大小是8bit，一张1920✖️1080的图片需要1920✖️1080✖️8✖️3bit / (1024✖️1024) = 47Mbit = 5.8MB；在观看30FPS的视频时，1s需要30张图片，也就是需要47 ✖️ 30 = 1.4Gbit，也就是1.4Gbit的带宽；以我们现在的网络带宽远远不够。所以必须进行视频源压缩编码。</p>
</blockquote>
<span id="more"></span>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS视频采集的格式类型</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/iOS%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86%E7%9A%84%E6%A0%BC%E5%BC%8F%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS定义了很多的视频格式，这里简单介绍一下它的命名规则，具体还需要看开发文档。</p>
</blockquote>
<span id="more"></span>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>在视频采集中，设置视频输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">COPYNSDictionary *videoSetting = @&#123;(id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;<br><br>self.videoPutData = [[AVCaptureVideoDataOutput alloc] init];<br>self.videoPutData.videoSettings = videoSetting;<br></code></pre></td></tr></table></figure>

<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol>
<li>命名规则</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">COPYkCVPixelFormatType_&#123;长度|序列&#125;&#123;颜色空间&#125;&#123;Planar|BiPlanar&#125;&#123;VideoRange|FullRange&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>Planar</code>：平面；<code>BiPlanar</code>：双平面</p>
<ul>
<li>平面/双平面主要用在<code>YUV</code>上。<code>UV</code>分开存储为<code>Planar</code>，反之是<code>BiPlanar</code>。所以：<ul>
<li><code>kCVPixelFormatType_420YpCbCr8PlanarFullRange</code>是420p</li>
<li><code>kCVPixelFormatType_420YpCbCr8BiPlanarFullRange</code>是nv12</li>
</ul>
</li>
</ul>
</li>
<li><p><code>VideoRange</code>和<code>FullRange</code> 的区别在于数值的范围，<code>FullRange</code>比<code>VideoRange</code>大一些，颜色也更丰富一些</p>
<ul>
<li>如果没有指定颜色范围，默认都是<code>FullRange</code>。但有一种情况除外，例如:<ul>
<li><code>kCVPixelFormatType_420YpCbCr8Planar</code>和<code>kCVPixelFormatType_420YpCbCr8PlanarFullRange</code>,因为已经有FullRange了，所以未指定的应该为<code>VideoRange</code></li>
</ul>
</li>
</ul>
</li>
<li><p>颜色空间对应的就是它在内存中的顺序。比如<code>  kCVPixelFormatType_32BGRA</code>，内存中的顺序是<code>B G R A B G R A B…</code>。</p>
<ul>
<li>也有一些特别的，比如<code>kCVPixelFormatType_16BE555</code>，这里需要用BE或LE指定字节顺序。其后面还带有一种数字，用于表示bit长度</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS拍摄流程</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/iOS%E6%8B%8D%E6%91%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS相机拍摄所需框架为&lt;ACFoundation/AVFoundation.h&gt;，该框架中基本上包含了视频中所需的全部方法。</p>
</blockquote>
<span id="more"></span>

<h2 id="拍摄的流程"><a href="#拍摄的流程" class="headerlink" title="拍摄的流程"></a>拍摄的流程</h2><h3 id="session-初始化"><a href="#session-初始化" class="headerlink" title="session 初始化"></a>session 初始化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">[AVCaptureSession alloc] init]<br></code></pre></td></tr></table></figure>

<h3 id="Input初始化"><a href="#Input初始化" class="headerlink" title="Input初始化"></a>Input初始化</h3><ol>
<li>device初始化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">//音频设备初始化，AVMediaTypeAudio替换为AVMediaTypeVideo即为视频，默认为后置摄像头<br>[AVCaptureDeviceInput deviceInputWithDevice:[AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio] error:&amp;error];<br>//视频设置初始化，详细版<br>AVCaptureDeviceDiscoverySession *captureDeviceDiscoverySession =<br>            [AVCaptureDeviceDiscoverySession discoverySessionWithDeviceTypes:@[ AVCaptureDeviceTypeBuiltInWideAngleCamera ] mediaType:AVMediaTypeVideo position:AVCaptureDevicePositionBack];//发现所有后置视频设备的会话<br>[[AVCaptureDeviceDiscoverySession devices] enumeratObjectsUsingBlock:^(AVCaptureDevice *camera, NSUInteger idx, BOOL *_Nonnull stop) &#123;<br>            if (camera.position == AVCaptureDevicePositionBack) &#123;<br>                backCamera = camera;<br>            &#125;<br>        &#125;];//遍历会话获取后置设备，可以对设备进行一些属性设置，例如曝光模式，但是，要调用lockForConfiguration:调用完之后使用unlockForConfiguration方法解锁，<br>[AVCaptureDeviceInput deviceInputWithDevice:backCamera error:nil];//同样的方式初始化设备输入<br></code></pre></td></tr></table></figure>

<ol>
<li>然后通过<code>canAddInput</code>来判断是否能在会话中，通过<code>addInput</code>将input添加到会话中，视频要添加2个会话，视频输入以及语音输入</li>
<li>如果要切换摄像头<ol>
<li>在<code>session</code>的<code>beginConfiguration</code>和<code>commitConfiguration</code>之间重新设置摄像头，</li>
<li><code>removeInput</code>删除原来的媒体设备输入</li>
<li>获取后置的摄像头的设备<code>AVCaptureDevice</code></li>
<li><code>[AVCaptureDeviceInput deviceInputWithDevice:swithToDevice error:**nil**];</code>重新设置摄像头，并将其添加到<code>session</code>中</li>
<li><strong>注意</strong>，如果为前置摄像头，遍历会话中的<code>outputs</code>，将其输入和输出的连接会话<code>AVCaptureConnection</code>的视频镜像属性<code>videoMirrored</code>，设为<code>YES</code></li>
</ol>
</li>
</ol>
<h3 id="output初始化"><a href="#output初始化" class="headerlink" title="output初始化"></a>output初始化</h3><ol>
<li><p><code>AVCaptureMovieFileOutput</code> 输出视频，</p>
<ol>
<li><p>只用初始化<code>AVCaptureMovieFileOutput</code>，将视频输出加到会话当中</p>
</li>
<li><p>调用<code>startRecordingToOutputFileURl:recordingDelegate:</code>处理输出的视频，通过调用<code>stopRecod</code>停止录屏</p>
</li>
<li><p>实现<code>AVCaptureFileOutputRecordingDelegate</code></p>
<ol>
<li><code>captureOutput:didStartRecordingToOutputFileAtURL:fromConnections:</code>开始写入视频文件时调用</li>
<li><code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>写入完成时调用</li>
</ol>
</li>
</ol>
</li>
<li><p><code>AVAssetWriter</code>输出数据，见第2节</p>
</li>
</ol>
<h3 id="初始化预览层AVCaptureVideoPreviewLayer"><a href="#初始化预览层AVCaptureVideoPreviewLayer" class="headerlink" title="初始化预览层AVCaptureVideoPreviewLayer"></a>初始化预览层AVCaptureVideoPreviewLayer</h3><ol>
<li>根据媒体会话初始化视图层，也就是预览层，该属性可以添加到相应图层的子层中</li>
<li><code>[AVCaptureVideoPreviewLayer layerWithSession:self.captureSession];</code>获取一个预览图层</li>
<li><code>addSublayer</code>加到要显示的视图图层内</li>
</ol>
<h3 id="开始录制"><a href="#开始录制" class="headerlink" title="开始录制"></a>开始录制</h3><ol>
<li><code>[session StartRunning]</code>，会话开始，开始录制（每次录制都需要<code>StartRunning</code>）</li>
</ol>
<h2 id="AVAssetWriter实现拍摄"><a href="#AVAssetWriter实现拍摄" class="headerlink" title="AVAssetWriter实现拍摄"></a>AVAssetWriter实现拍摄</h2><h3 id="初始化视频-音频数据输出"><a href="#初始化视频-音频数据输出" class="headerlink" title="初始化视频/音频数据输出"></a>初始化视频/音频数据输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">NSDictionary *videoSetting = @&#123;(id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;//32BGRA像素格式，和后面要取的视频帧数据对应<br>self.videoPutData = [[AVCaptureVideoDataOutput alloc] init];<br>self.videoPutData.videoSettings = videoSetting;<br><br>[[AVCaptureAudioDataOutput alloc] init];<br></code></pre></td></tr></table></figure>

<p>在<code>canAddOutput</code>判断后，通过<code>addOutput</code>添加到session中</p>
<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>通过<code>setSampleBufferDelegate:queue: </code>设置应该调用回调的缓冲区委托和队列,获取视频流</p>
<h3 id="配置AVAssetWriter"><a href="#配置AVAssetWriter" class="headerlink" title="配置AVAssetWriter"></a>配置AVAssetWriter</h3><ol>
<li><p>配置并发队列，<code>dispatch_async</code>异步执行</p>
</li>
<li><p>在队列中配置<code>AVAssetWriter</code>，用<code>[AVAsswtWriter assWriterWithURL:文件输出地址 fileType:AVFileTypeMPEG4 error:&amp;error]</code>初始化<code>AVAssetWriter</code>;</p>
</li>
<li><p>配置详细参数，视频硬编码参数</p>
<ol>
<li><p>码率和帧率的设置</p>
<ol>
<li><p><code>AVVideoAverageBitRateKey</code>：指单位时间内处理的数据位数，单位是 b/s 。码率=视频文件大小/视频时长。数值越大，显示越精细</p>
</li>
<li><p><code>AVVideoMaxKeyFrameIntervalKey</code>：关键帧最大间隔，1为每个都是关键帧，数值越大压缩率越高，也就是文件越大（如果画面包含大量场景变换或迅速移动的动作或动画，那么减少关键帧距离将会提高图像的整体品质。一个较小的关键帧距离对应于一个较大的输出文件。注意减少了关键帧间距，注意增大比特率也就是码率，保证视频质量）</p>
</li>
<li><p><code>AVVideoProfileLevelKey</code>：H.264专用参数，代表画质级别，从低到高分贝为BP、EP、MP、HP</p>
<ol>
<li><p>而H264最大的优势就是低码率情况下提供高质量的视频图像，总的来说编码流程可以分为五部分：帧间和帧内预测（Estimation）、变换（Transform）和反变换、量化（Quantization）和反量化、环路滤波（Loop Filter）、熵编码（Entropy Coding）</p>
</li>
<li><p>H264为了满足不同设备不同场景的需要（比如直播注重实时性，存储注重压缩比）定义了多种编码层次也就是Profile，具体如下</p>
<ol>
<li><p><code>BaslineProfile</code>：支持I/P 帧，只支持无交错（Progressive）和CAVLC</p>
</li>
<li><p><code>Extended Profile</code>：支持I/P/B/SP/SI 帧，只支持无交错（Progressive）和CAVLC</p>
</li>
<li><p><code>MainProfile</code>：提供I/P/B 帧，支持无交错（Progressive）和交错（Interlaced），也支持CAVLC 和CABAC</p>
</li>
<li><p><code>High Profile</code>：在mainProfile 的基础上增加了8x8内部预测、自定义量化、 无损视频编码和更多的YUV 格式；</p>
</li>
<li><p>视频压缩很重要的一个就是帧间预测，也就是视频相邻的几帧有很大的相关性，变化不会太大，所以存在很多冗余信息，压缩要做的就是去除这些冗余信息。帧类型主要有以下几种</p>
<ol>
<li>I帧表示关键帧，这一帧保留完整的画面数据，解码时只需要本帧数据就可以完成</li>
<li>P帧，前向预测帧，表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前的画面叠加上本帧定义的差别，生成最终画面。</li>
<li>B帧是双向预测帧，也就是B帧记录的是本帧与前后帧的差别，要解码B帧，不仅要取得之前的画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时比较耗费CPU 。</li>
</ol>
</li>
<li><p><code>Profile</code> 越高，压缩比就越高，但是编码、解码时要求的设备性能也就越高，编码、解码的效率也就越低。</p>
</li>
<li><p>这里的<code>level</code>就是对每个<code>profile</code>的能力细分。</p>
<ol>
<li>实时直播</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">COPY低清Baseline Level 1.3<br>标清Baseline Level 3<br>半高清Baseline Level 3.1<br>全高清Baseline Level 4.1<br></code></pre></td></tr></table></figure>

<ol>
<li>存储媒体</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">低清 Main Level 1.3<br>标清 Main Level 3<br>半高清 Main Level 3.1<br>全高清 Main Level 4.1<br></code></pre></td></tr></table></figure>

<ol>
<li>高清存储</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">半高清 High Level 3.1<br>全高清 High Level 4.1<br></code></pre></td></tr></table></figure>

<ol>
<li>iPad 支持：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">Baseline Level 1-3.1<br>Main Level 1-3.1<br>High Level 1-3.1<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p><code>AVVideoExpectedSourceFrameRateKey</code>：预期的源帧速率，不用于控制帧速率，作为提示提供给视频编码器的，如果使用率自动级别的AVVideoProfileLevelKey，或者源内容的帧率高于30fps，则应设置此项。如果没有指定的话，编码器可能必须丢弃帧以满足位流要求</p>
</li>
</ol>
</li>
<li><p>视频属性设置</p>
<ol>
<li><code>AVVideoCodecKey</code>:用于压缩视频的编码器的名称，这里用的是硬编码AVVideoCodecTypeH264</li>
<li><code>AVVideoWidthKey</code>、AVVideoHeightKey：设定视频的宽高</li>
<li><code>AVVideoScalingModeKey</code>：视频压缩填充的方式，AVVideoScalingModeResizeAspectFill</li>
<li><code>AVVideoCompressionPropertiesKey</code>：视频压缩编码器，压缩的属性字典，即1中码率和帧率的设置</li>
</ol>
</li>
<li><p>音频设置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">NSDictionary *audioSetting =<br>                @&#123;AVEncoderBitRatePerChannelKey : @(28000),//声道采样率<br>                  AVFormatIDKey : @(kAudioFormatMPEG4AAC),//音频格式，在视频中也是mp4格式<br>                  AVNumberOfChannelsKey : @(1),//声道数<br>                  AVSampleRateKey : @(22050)&#125;;//采样率<br></code></pre></td></tr></table></figure>

<ol>
<li>初始化视频采集<code>AVAssetWriterInput</code>，采用方法<code>[AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSetting:视频设置]</code>，也用同样方式设置音频采集<code>AVAssetWriterInput</code></li>
<li>对于视频采集，可以通过视频采集的transform来调整视频流的方向，横屏还是竖屏，拍摄完默认是横的，要调整transform属性，<code>self.writerVideoInput.transform = CGAffineTransformMakeRotation(-M_PI / 2.0);</code></li>
<li>最后将视频采集和声音采集，通过<code>canAddInput</code>判断，<code>addInput</code>添加到创建的写入<code>AVAssetWrite</code>中</li>
</ol>
</li>
</ol>
<h3 id="代理实现"><a href="#代理实现" class="headerlink" title="代理实现"></a>代理实现</h3><p>实现<code>AVCaptureAudioDataOutSampleBufferDelegate</code>、<code>AVCaptureVideoDataOutSampleBufferDelegate</code>，具体是在<code>captureOutput:didOutputSampleBuffer:fromConnection:</code>方法中实现（每当输出捕获和输出新视频帧时，委托将接收此消息，并按照其<code>videoSetting</code>属性指定对其进行解码或重新编码，该方法在输出的<code>sampleBufferCallbackQueue</code>属性指定的调度队列上调用，为周期性的调用）</p>
<ol>
<li><p><code>CMSampleBufferRef</code>，是相关媒体流数据，可以获取媒体流的类型为语音还是视频流以及资源的时间戳</p>
</li>
<li><p>在媒体流属性为视频里(确保写入的第一帧为视频图像，保证不会出现有声音但无画面的情况)，调用（AVAssetWriter）的<code>startWriting</code>方法开始写入，从视频流中获取最早时间戳，调用<code>startSessionAtSourceTime</code>，开始写入</p>
<ol>
<li>视频和音频开始写入的判断<code>canWritting</code>（Bool）放在<code>startSessionAtSourceTime</code>下，会导致视频前几帧相同，因为调用<code>startSessionAtSourceTime````就开始录制了，所以要放在startsessionAtSourceTime</code>的上面</li>
</ol>
</li>
<li><p>配置中初始化的视频采集以及声音采集<code>AVAssetWriterInput</code>，在其属性<code>readyForMoreMediaData</code>（输入准备好接收更多数据），调用apppendSampleBuffer:方法，将<code>CMSampleBufferRef</code>添加进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">#pragma mark - AVCaptureVideoDataOutputSampleBufferDelegate method<br>- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123;<br>    if (!self.videoRecording) &#123;<br>        return;<br>    &#125;<br><br>    CMFormatDescriptionRef desMedia = CMSampleBufferGetFormatDescription(sampleBuffer);<br>    CMMediaType mediaType = CMFormatDescriptionGetMediaType(desMedia);<br><br>    if (mediaType == kCMMediaType_Video) &#123;<br>        if (!self.canWritting) &#123;<br>            [self.writer startWriting];<br><br>            CMTime timestamp = CMSampleBufferGetPresentationTimeStamp(sampleBuffer);<br><br>            self.canWritting = YES;<br>            [self.writer startSessionAtSourceTime:timestamp];<br>        &#125;<br>    &#125;<br><br><br>    if (self.canWritting) &#123;<br>        if (mediaType == kCMMediaType_Video) &#123;<br>            if (self.writerVideoInput.readyForMoreMediaData) &#123;<br>                BOOL success = [self.writerVideoInput appendSampleBuffer:sampleBuffer];<br>                if (!success) &#123;<br>                    LOG_DEBUG(@&quot;video write failed&quot;);<br>                &#125;<br>            &#125;<br><br>        &#125; else if (mediaType == kCMMediaType_Audio &amp;&amp; self.canWritting) &#123;<br>            if (self.writerAudioInput.readyForMoreMediaData) &#123;<br>                BOOL success = [self.writerAudioInput appendSampleBuffer:sampleBuffer];<br>                if (!success) &#123;<br>                    LOG_DEBUG(@&quot;audio write failed&quot;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="录制完成"><a href="#录制完成" class="headerlink" title="录制完成"></a>录制完成</h3><p>AVCaptureSession的startRunning方法是个耗时操作，如果在主线程调用的话会卡UI。完成写入，AVAssetWriter的状态为正在写入，则调用<code>finishWritingWithCompletionHandler:</code>完成数据的写入</p>
<h2 id="AVAssetWriter实现视频压缩"><a href="#AVAssetWriter实现视频压缩" class="headerlink" title="AVAssetWriter实现视频压缩"></a>AVAssetWriter实现视频压缩</h2><h3 id="传统视频压缩的方式"><a href="#传统视频压缩的方式" class="headerlink" title="传统视频压缩的方式"></a>传统视频压缩的方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">AVURLAsset *avAsset = [AVURLAsset URLAssetWithURL:inputURL options:nil];<br>AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:avAsset presetName:AVAssetExportPresetMediumQuality];//视频压缩的类型，还有AVAssetExportPresset960x540具体压缩的分辨率<br>   exportSession.outputURL = outputURL;<br>   exportSession.outputFileType = AVFileTypeMPEG4;<br>   exportSession.shouldOptimizeForNetworkUse = YES;<br>   [exportSession exportAsynchronouslyWithCompletionHandler:^(void) &#123;<br>       switch(exportSession.status) &#123;<br>         case AVAssetExportSessionStatusCompleted://压缩完成<br>         case AVAssetExportSessionStatusFailed://压缩失败<br>         default:<br>       &#125;<br>   &#125;];<br></code></pre></td></tr></table></figure>

<p>绝大多数的情况下可以通过传统的压缩方式对视频进行压缩。为了获得最大的视频压缩率(最低的码率)最好的方式是</p>
<ol>
<li>指定high的<code>profile</code></li>
<li>降低帧率</li>
<li>适当降低分辨率</li>
</ol>
<p>但是传统的压缩方式不支持指定profile，帧率和码率，所以只有通过其他方式来实现。可以在相机录像时需要将拍摄的每一帧<code>sampleBuffer</code>（音频或者视频）传给<code>AVassetWriter</code>，并制定压缩参数。</p>
<h3 id="AVAassetWriter实现视频压缩"><a href="#AVAassetWriter实现视频压缩" class="headerlink" title="AVAassetWriter实现视频压缩"></a>AVAassetWriter实现视频压缩</h3><h4 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h4><p><img src="1.png" alt="img"></p>
<h4 id="代码的实现"><a href="#代码的实现" class="headerlink" title="代码的实现"></a>代码的实现</h4><ol>
<li>初始化<code>reader</code>，<code>writer</code>，<code>video/audio track</code>, <code>video/audio input</code>, <code>video/audio output</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">- (void)comppressVideoUrl:(NSURL *) videoUrl withOutputUrl:(NSURL *)outputUrl &#123;<br>    AVAsset *asset = [AVAsset assetWithURL:videoUrl];<br>    AVAssetReader *reader = [AVAssetReader assetReaderWithAsset:asset error:nil];<br>    AVAssetWriter *writer = [AVAssetWriter assetWriterWithURL:outputUrl fileType:AVFileTypeMPEG4 error:nil];<br>    <br>    AVAssetTrack *videoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] firstObject];//获取轨道，一般视频至少两个轨道，一个播放声音的一个播放画面的<br>    <br>    //视频输出源<br>    NSDictionary *videoOuptSetting = @&#123;(id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;<br>    AVAssetReaderTrackOutput *videoOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:videoTrack outputSettings:videoOuptSetting];<br>    <br>    //视频采集输入设置，<br>    // 码率和帧率设置<br>    NSDictionary *compressionProperties = @&#123;<br>        AVVideoAverageBitRateKey : @(DSScreenWidth() * DSScreenHeight()*12),<br>        AVVideoExpectedSourceFrameRateKey : @(15),<br>        AVVideoMaxKeyFrameIntervalKey : @(10),<br>        AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel<br>    &#125;;<br><br>    //视频属性<br>    NSDictionary *videoSetting = @&#123;<br>        AVVideoCodecKey : AVVideoCodecTypeH264,<br>        AVVideoWidthKey : @(DSScreenHeight() * 2),<br>        AVVideoHeightKey : @(DSScreenWidth() * 2),<br>        AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill,<br>        AVVideoCompressionPropertiesKey : compressionProperties<br>    &#125;;<br>    AVAssetWriterInput *videoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:videoSetting];<br>  //注意要设置视频的方向，每个视频都有方向，这里先获取视频的方向<br>  int degress = [self degressFromVideoFileWithAsset:asset];<br>    videoInput.transform = CGAffineTransformMakeRotation(M_PI * (degress / 180.0));<br>    if([reader canAddOutput:videoOutput])&#123;<br>        [reader addOutput:videoOutput];<br>    &#125;<br>    if ([writer canAddInput:videoInput]) &#123;<br>        [writer addInput:videoInput];<br>    &#125;<br>    <br>    //音频部分<br>  //音频输出设置，和视频拍摄不一样，视频拍摄时，指点了缓存流的格式，而文件压缩的时候则没有因此视频和音频一定要设置输出格式<br>  NSDictionary *readerOutputSettings = @&#123;AVFormatIDKey: @(kAudioFormatLinearPCM)&#125;;<br>    AVAssetTrack *audioTrack = [[asset tracksWithMediaType:AVMediaTypeAudio] firstObject];<br>    AVAssetReaderTrackOutput *audioOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:audioTrack outputSettings:readerOutputSettings];<br>    //声音采集设置<br>    NSDictionary *audioSetting =<br>        @&#123;AVEncoderBitRatePerChannelKey : @(28000),<br>          AVFormatIDKey : @(kAudioFormatMPEG4AAC),<br>          AVNumberOfChannelsKey : @(1),<br>          AVSampleRateKey : @(22050)&#125;;<br>    AVAssetWriterInput *audioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:audioSetting];<br>    if ([reader canAddOutput:audioOutput]) &#123;<br>        [reader addOutput:audioOutput];<br>    &#125;<br>    if ([writer canAddInput:audioInput]) &#123;<br>        [writer addInput:audioInput];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>获取视频的方向</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">/// 获取视频的方向<br>+ (int)degressFromVideoFileWithAsset:(AVAsset *)asset &#123;<br>    int degress = 0;<br>    NSArray *tracks = [asset tracksWithMediaType:AVMediaTypeVideo];<br>    if ([tracks count] &gt; 0) &#123;<br>        AVAssetTrack *videoTrack = [tracks objectAtIndex:0];<br>        CGAffineTransform t = videoTrack.preferredTransform;<br>        if (t.a == 0 &amp;&amp; t.b == 1.0 &amp;&amp; t.c == -1.0 &amp;&amp; t.d == 0) &#123;<br>            // Portrait<br>            degress = 90;<br>        &#125; else if (t.a == 0 &amp;&amp; t.b == -1.0 &amp;&amp; t.c == 1.0 &amp;&amp; t.d == 0) &#123;<br>            // PortraitUpsideDown<br>            degress = 270;<br>        &#125; else if (t.a == 1.0 &amp;&amp; t.b == 0 &amp;&amp; t.c == 0 &amp;&amp; t.d == 1.0) &#123;<br>            // LandscapeRight<br>            degress = 0;<br>        &#125; else if (t.a == -1.0 &amp;&amp; t.b == 0 &amp;&amp; t.c == 0 &amp;&amp; t.d == -1.0) &#123;<br>            // LandscapeLeft<br>            degress = 180;<br>        &#125;<br>    &#125;<br>    return degress;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>开始读写</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">COPY[reader startReading];<br>[writer startWriting];<br>[writer startSessionAtSourceTime:KCMTimeZero];<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>设置写入的队列，注意音频、视频写入的队列要一样的，并且是FIFO队列。因为是写入同一个writer，如果用并发，会出现reader的状态不对，导致崩溃</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">dispatch_queue_t writeQueueCreate = dispatch_queue_create(&quot;writeQueueCreate&quot;, DISPATCH_QUEUE_SERIAL);<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>视频逐帧写入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">dispatch_group_t group = dispatch_group_create();<br>dispatch_group_enter(group);<br>[videoInout requestMediaDataWhenReadyOnQueue:  usingBlock:^&#123;<br>  while ([videoInput isReadyForMoreMediaData]) &#123;<br>    CMSampleBufferRef sampleBuffer;<br>    if ([reader status] == AVAssetReaderStatusReading &amp;&amp; (sampleBuffer = [videoOutput copyNextSampleBuffer]))&#123;<br>      BOOL result = [videoInput appendSampleBuffer:sampleBuffer];<br>      CFRelease(sampleBuffer);<br>      if (!result) &#123;<br>        [reader cancelReading];<br>        break;<br>      &#125;<br>    &#125;<br>  &#125; else &#123;<br>    [videoInput markAsFinished];<br>    dispatch_group_leave(group);<br>    break;<br>  &#125;<br>&#125;];<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>音频逐帧写入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">dispatch_group_enter(group);<br>[audioInout requestMediaDataWhenReadyOnQueue:  usingBlock:^&#123;<br>  while ([audioInput isReadyForMoreMediaData]) &#123;<br>    CMSampleBufferRef sampleBuffer;<br>    if ([reader status] == AVAssetReaderStatusReading &amp;&amp; (sampleBuffer = [audioOutput copyNextSampleBuffer]))&#123;<br>      BOOL result = [audioInput appendSampleBuffer:sampleBuffer];<br>      CFRelease(sampleBuffer);<br>      if (!result) &#123;<br>        [reader cancelReading];<br>        break;<br>      &#125;<br>    &#125;<br>  &#125; else &#123;<br>    [audioInput markAsFinished];<br>    dispatch_group_leave(group);<br>    break;<br>  &#125;<br>&#125;];<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>完成压缩</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">dispatch_group_notify(group,dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAYLT,0),^&#123;<br>  if ([reader status] == AVAssetReaderStatusReading)&#123;<br>    [reader cancelReading];<br>  &#125;<br>  switch (writer.status) &#123;<br>    case AVAssetWriterStatusWriting:<br>      &#123;<br>        [writer finishWritingWithCompletionHandler:^&#123;<br>          <br>        &#125;];<br>        break;<br>      &#125;<br>    default:<br>      break;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>图层几何学</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%B1%82%E5%87%A0%E4%BD%95%E5%AD%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图层布局"><a href="#图层布局" class="headerlink" title="图层布局"></a>图层布局</h2><blockquote>
<p>UIView有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，CALayer对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。<code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>（也可以理解为中心）所在的位置。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>下图显示了这些属性是如何展示的：<br><img src="1.png" alt="img"></p>
</li>
<li><p>视图的<code>frame</code> ，<code>bounds</code>和<code>center</code>属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<ul>
<li>对于视图或者图层而言，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，<code>frame</code>都会变化。相反，改变frame的值同样会影响到他们当中的值</li>
<li>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了,具体见下图</li>
</ul>
</li>
</ul>
<p><img src="2.png" alt="img"></p>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><blockquote>
<p>视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置。默认来说<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。对于UIView而言，没有暴露<code>anchorPoint</code>,只有center；而图层的暴露出来了，<code>anchorPoint</code>可以被移动。anchorPoint为单位坐标</p>
</blockquote>
<p><img src="3.png" alt="img"></p>
<ul>
<li>改变<code>anchorPoint</code>，图层的内容会向右下角的<code>position</code>方向移动，而并不是居中了;图中当改变anchorPoint，position是<code>anchorPoint</code>与父图层的位置，由于锚点的变化，相对位置的基础点，发生改变（从原来中心点，变成了右上角），图层右下角移动，frame改变了。</li>
<li><code>anchorPoint</code>属性为锚点，一般在<code>transform</code>图层旋转中常用到，作为旋转的基点.</li>
</ul>
<h3 id="Z坐标轴"><a href="#Z坐标轴" class="headerlink" title="Z坐标轴"></a>Z坐标轴</h3><blockquote>
<p>和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了<code>position</code>和<code>anchorPoint</code>属性之外，CALayer还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
</blockquote>
<ul>
<li><code>zPosition</code>常用的地方<ul>
<li><code>CATransform3D</code>,在三维空间移动和旋转图层</li>
<li>改变图层的显示顺序<ul>
<li>通常，图层是根据它们子图层的sublayers出现的顺序来类绘制的，后被绘制上的图层将会遮盖住之前的图层。</li>
<li>但是通过增加图层的<code>zPosition</code>,可以把图层前置显示，在其他图层的前面，（图层是很薄的，在这里只用提高一个像素即可实现前置）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图层中常用的方法"><a href="#图层中常用的方法" class="headerlink" title="图层中常用的方法"></a>图层中常用的方法</h2><blockquote>
<p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。这里有两个常见的方法帮处理事件：</p>
<ol>
<li><code>-containsPoint:</code></li>
<li><code>-hitTest:</code></li>
</ol>
</blockquote>
<ul>
<li><code>-containsPoint:</code>,接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层frame范围内就返回YES</li>
<li><code>-hitTest:</code>,方法同样接受一个<code>CGPoint</code>类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。<ul>
<li><code>注意</code>当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上<code>图层的顺序</code>，但不能改变<code>事件传递的顺序</code>。</li>
<li>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。</li>
</ul>
</li>
</ul>
<h2 id="图层的视觉效果展示"><a href="#图层的视觉效果展示" class="headerlink" title="图层的视觉效果展示"></a>图层的视觉效果展示</h2><blockquote>
<p>一些常用的视觉显示所需要的图层属性</p>
</blockquote>
<ol>
<li><p>圆角:</p>
<ol>
<li><code>cornerRadius</code>,控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角）</li>
<li><code> masksToBounds</code>,默认情况下，<code>cornerRadius</code>只影响背景颜色而不影响背景图片或是子图层,把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会受到影响，被截取。</li>
</ol>
</li>
<li><p>图层边框</p>
<ol>
<li><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0</li>
<li><code>borderColor</code>定义了边框的颜色，默认为黑色。(CGColorRef类型，而不是UIColor)</li>
</ol>
</li>
<li><p>阴影</p>
<ol>
<li><code>shadowOpacity</code>:给<code>shadowOpacity</code>属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下</li>
<li><code>shadowColor</code>属性控制着阴影的颜色,(CGColorRef),默认是黑色</li>
<li><code>shadowOffset</code>属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。默认值是 {0, -3}(Mac与iphone的y轴颠倒的，因此在mac上是向下，而iphone是向上)</li>
<li><code>shadowRadius</code>属性控制着阴影的模糊度，为0的时候，阴影就和视图一样有一个非常确定的边界线，当值越来越大的时候，边界线看上去就会越来越模糊和自然。<ol>
<li>注意，阴影通常就是在layer的边界之外，如果开启masksToBounds属性，所有从图层中突出来的内容都会被裁剪掉，阴影也就不存在了</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="shadowPath属性"><a href="#shadowPath属性" class="headerlink" title="shadowPath属性"></a><code>shadowPath</code>属性</h3><blockquote>
<p><code>shadowPath</code>属性,图层阴影是从图层内容的形状继承而来,实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候</p>
</blockquote>
<ol>
<li>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。<ol>
<li><code>shadowPath</code>是一个<code>CGPathRef</code>类型(一个指向CGPath的指针)。CGPath是一个<code>Core Graphics</code>对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</li>
<li>代码</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">//enable layer shadows<br>  self.layerView1.layer.shadowOpacity = 0.5f;<br>  self.layerView2.layer.shadowOpacity = 0.5f;<br><br>  //方形的阴影<br>  CGMutablePathRef squarePath = CGPathCreateMutable();<br>  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);<br>  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);<br><br>  ￼//圆形的阴影<br>  CGMutablePathRef circlePath = CGPathCreateMutable();<br>  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);<br>  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS核心动画技巧</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/iOS%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CALayer和UIView的区别"><a href="#CALayer和UIView的区别" class="headerlink" title="CALayer和UIView的区别"></a>CALayer和UIView的区别</h2><blockquote>
<p><code>CALayer</code>类在概念上和<code>UIView</code>类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和<code>UIView</code>最大的不同是<code>CALayer</code>不处理用户的交互。<code>CALayer</code>并不清楚具体的<em>响应链</em>（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
</blockquote>
<span id="more"></span>

<h3 id="平行层级关系"><a href="#平行层级关系" class="headerlink" title="平行层级关系"></a>平行层级关系</h3><ul>
<li><p>每一个<code>UIview</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<em>backing layer</em>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作</p>
</li>
<li><p>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，<code>UIView</code>仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
</li>
<li><p>但是为什么iOS要基于<code>UIView</code> 和 <code>CALayer</code></p>
<p>提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？</p>
<ul>
<li>原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和<code>UIView</code>，但是Mac OS有AppKit和<code>NSView</code>的原因。他们功能上很相似，但是在实现上有着显著的区别。</li>
<li>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</li>
</ul>
</li>
<li><p>图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些<code>UIView</code>没有暴露出来的CALayer的功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
</li>
</ul>
<h3 id="CALayer一些特殊属性"><a href="#CALayer一些特殊属性" class="headerlink" title="CALayer一些特殊属性"></a>CALayer一些特殊属性</h3><h3 id="contents属性"><a href="#contents属性" class="headerlink" title="contents属性"></a>contents属性</h3><ul>
<li>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</li>
<li>事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的<code>contents</code>，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象(OC对象)，而是一个Core Foundation类型。实际要用<code>layer.contents = (__bridge id)image.CGImage;</code></li>
</ul>
<h3 id="contentsGravity"><a href="#contentsGravity" class="headerlink" title="contentsGravity"></a>contentsGravity</h3><blockquote>
<p>对于加载的图片无法适应视图时，对于UIimageView有一个contentMode属性，<code>view.contentMode = UIViewContentModeScaleAspectFit;</code>，而CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。</p>
</blockquote>
<ul>
<li><code>self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</code>，<code>kCAGravityResizeAspect</code>，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</li>
</ul>
<h3 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h3><blockquote>
<p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。它的优先级要低于了<code>contentsGravity</code>。</p>
</blockquote>
<ul>
<li><code>contentsScale</code>属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置<code>contentsGravity</code>属性）。UIView有一个类似功能但是非常少用到的<code>contentScaleFactor</code>属性。</li>
<li>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕</li>
<li>这并不会对我们在使用<code>kCAGravityResizeAspect</code>时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把<code>contentsGravity</code>设置为<code>kCAGravityCenter</code>（这个值并不会拉伸图片）。</li>
<li>和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。可以通过设置<code>self.layerView.layer.contentsScale = image.scale;</code></li>
</ul>
<h3 id="maskToBounds"><a href="#maskToBounds" class="headerlink" title="maskToBounds"></a>maskToBounds</h3><blockquote>
<p>默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。UIView有一个叫做<code>clipsToBounds</code>的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做<code>masksToBounds</code>。</p>
</blockquote>
<h3 id="contentsRect"><a href="#contentsRect" class="headerlink" title="contentsRect"></a>contentsRect</h3><blockquote>
<p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比<code>contentsGravity</code>灵活多了和<code>bounds</code>，<code>frame</code>不同，<code>contentsRect</code>不是按点来计算的，它使用了<em>单位坐标</em>，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。</p>
</blockquote>
<ul>
<li>iOS使用了以下的坐标系统：<ol>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ol>
</li>
<li>默认的<code>contentsRect</code>是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪。事实上给<code>contentsRect</code>设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</li>
<li>可以通过<code>contentsRect</code>从大图中截取小图，分给其他的视图（1个image，分给不同的视图显示），因为单张大图比多张小图载入地更快，可以有效地提高了载入性能</li>
</ul>
<h3 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h3><blockquote>
<p><code>contentsCenter</code>其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
</blockquote>
<ul>
<li>默认情况下，<code>contentsCenter</code>是{0, 0, 1, 1}，这意味着如果大小（由<code>conttensGravity</code>决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。下图展示了<code>contentsCenter</code>设置为{0.25, 0.25, 0.5, 0.5}的效果。</li>
</ul>
<p><img src="1.png" alt="img"></p>
<h2 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h2><blockquote>
<p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
</blockquote>
<ul>
<li><p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
</li>
<li><p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费。这为屏外渲染而非GPU渲染</p>
</li>
<li><p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来(屏外渲染的缓存区)直到它需要被更新（通常是因为开发者调用了<code>-setNeedsDisplay</code>方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
</li>
<li><p>CALayer有一个可选的<code>delegate</code>属性，实现了<code>CALayerDelegate</code> 协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议（凡是NSObject或其子类的类别，都是非正式协议）。其代理方法有：</p>
<ul>
<li><code>- (void)displayLayer:(CALayerCALayer *)layer;</code></li>
<li><code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</code></li>
<li>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</li>
</ul>
</li>
<li><p>当使用寄宿了视图的图层的时候，你也不必实现<code>-displayLayer:</code>和<code>-drawLayer:inContext:</code>方法来绘制你的寄宿图。通常做法是实现UIView的<code>-drawRect:</code>方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用<code>-display</code>方法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>碎片化笔记</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A2%8E%E7%89%87%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>记录偶尔发现有用的知识点</p>
</blockquote>
<span id="more"></span>

<h2 id="delegate能一对多吗"><a href="#delegate能一对多吗" class="headerlink" title="delegate能一对多吗"></a>delegate能一对多吗</h2><ul>
<li><p>在不同控制页面实现同一代理，并且执行代理的类为单例执行；代码验证时发现</p>
<ul>
<li>尽管为单例，但是其属性<code>delegate</code>为唯一，与当前控制页是相互持有关系，因此，在页面1时，只会执行页面1上的代理方法；</li>
<li>当从页面1进入页面2后，<code>delegate</code>的对象变成了页面2，因此，在页面2时，只会执行页面1上的代理方法</li>
<li>当从页面2退到页面1后，页面1销毁，由于为weak，弱引用，在页面1上也不会执行代理方法，被销毁的页面2上更不会执行了</li>
</ul>
</li>
<li><p>通过相关的设计也可以实现一对多的关系</p>
<ol>
<li><p>用多播代理的方式，多播代理相比一般的只是多了一个中间层，由中间层实现代理，获取数据；中间层与控制器之间</p>
<ol>
<li>用一个block数组，作为中间层单例的属性</li>
<li>在其他控制器中，都设置一个回调的block，并将该block添加到数组中</li>
<li>在中间层实现代理获取数据的时候，遍历这个blcok数组，将数据进行分发</li>
</ol>
</li>
<li><p>1个代理在多个页面内实现，</p>
<ol>
<li><p>关键点在于</p>
<ol>
<li>协议名称和对象构成一个健值对，形成1-1对应关系</li>
<li><code>NSPointerArray</code>的使用，使得弱引用对象，且在对象释放时自动删除<code>NSPointerArray</code>中的元素。</li>
</ol>
</li>
<li><p>使用</p>
<ol>
<li><p>将其他页面要实现的代理同样均设为一个单例消息分发中心，有一个字典数据(键为协议，值为<code>NSPointerArray</code>，数组中存有各个页面的对象)</p>
</li>
<li><p>在一个页面触发代理后，首先会实现代理的消息分发中心是否实现了，在这里是没有实现相关的代理方法的，</p>
<ol>
<li><p>借助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">- (BOOL)respondsToSelector:(SEL)aSelector;<br></code></pre></td></tr></table></figure>

<p>，判断本管理对象是否可以响应方法</p>
<ol>
<li>如果存的<code>pointArray</code>中可以响应方法则返回YES</li>
</ol>
</li>
<li><p>下面有两种方式实现</p>
<ol>
<li>借助<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</code>以及<code>-(void)forwardInvocation:(NSInvocation *)anInvocation;</code>（这两个方法是一起的）。可以实现在多个未销毁页面中，同时实现代理，达成通知的效果，实现消息的分发</li>
<li>也可以单独实现<code>- (id)forwardingTargetForSelector:(SEL)aSelector;</code>（返回未识别消息应首先指向的对象（本来默认是向上传的）），但这是在相应的NSPointArray中找到能实现该方法的对象，只能实现消息的转发，在多个页面的对象中找到真正一个能响应该方法的</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><hr>
<blockquote>
<p>众所周知，当某个对象持有着一个Block的时候，如果在Block内部使用强引用反过来持有这个对象，就会导致引用循环。为了避免引用循环，可以使用__weak修饰符。</p>
</blockquote>
<h4 id="block中的引用"><a href="#block中的引用" class="headerlink" title="block中的引用"></a>block中的引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">__weak typeof(self) weakSelf = self;<br>self.block = ^&#123;<br>  _strong typeof(self) strongSelf = weakSelf;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>C语言编译后可以发现，<code>Block</code>本身对<code>self</code>的引用仍然只是弱引用，并不造成引用循环</li>
<li><code>strongSelf</code>只存在于Block对应的函数里，它的生命周期只在这个函数执行的过程中，函数执行前它不会存在，函数执行完它立刻就被释放了.因此<ol>
<li>如果函数执行前self变为nil了，那么函数不会执行，没有任何引用循环发生；</li>
<li>如果函数执行过程中self变为nil了，那么函数一开始声明的strongSelf会暂时持有着self，此时会有一个暂时的引用循环。当函数执行完（即是Block执行完），strongSelf超出作用域被释放，引用循环从这里开始打破。接下来，由于没有任何强引用持有self了，于是self被释放，最后Block也因为没有任何强引用持有它也被释放了。所有对象就都被顺利释放了。</li>
</ol>
</li>
</ol>
<h5 id="解决block循环引用"><a href="#解决block循环引用" class="headerlink" title="解决block循环引用"></a>解决block循环引用</h5><ol>
<li>通过Weak修饰的方式来处理的。 weak是弱引用，用weak来修饰、描述所引用对象的计数器并不会加1，weak会在引用对象被释放的时候自动置为nil</li>
<li><code>__block</code>修饰变量，依赖于中介者模式，属于手动释放。其实现是通过<code>__block</code>修饰对象，因为<code>__block</code>修饰的对象是可以改变的，可以在block中手动的释放掉引用的对象</li>
<li>直接将对象作为参数，直接将对象作为参数传入了block中，block中并没有对对象进行持有，因此也不会造出循环引用的问题</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">typedef void(^TBlock)(ViewController *); <br>@property(nonatomic, copy) TBlock tBlock; <br>self.tBlock = ^(ViewController *vc)&#123; <br>  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(),    ^&#123; <br>       NSLog(@&quot;%@&quot;,vc.name);<br>   &#125;);<br> &#125;; <br>self.tBlock(self);<br><br></code></pre></td></tr></table></figure>

<ol start="4">
<li><code>NSProxy</code>转发消息打破循环引用，实际上也是使用了<code>weak</code>修饰,在<code>NSProxt</code>中使用了<code>weak</code>来修饰对象属性</li>
</ol>
<h4 id="block中变量捕获"><a href="#block中变量捕获" class="headerlink" title="block中变量捕获"></a>block中变量捕获</h4><ol>
<li>局部变量捕获瞬时值,局部静态变量捕获指针。</li>
<li>全局变量、全局静态变量直接使用不捕获</li>
<li>成员变量是指针捕获</li>
<li>_block修饰自动变量，会将本来传值的，变为地址</li>
</ol>
<h3 id="UIView用weak修饰还是strong修饰"><a href="#UIView用weak修饰还是strong修饰" class="headerlink" title="UIView用weak修饰还是strong修饰"></a>UIView用weak修饰还是strong修饰</h3><hr>
<ol>
<li>从stroryboard中拖出来的控件一般用weak来修饰，这么做的原因是因为stroryboard已经持有控件的，引用计数已经加1了，不需要在用strong时引用数加1，但是用strong修饰也可以，因为在控制器销毁后，不管是strong还是weak，引用计数都会变为0。</li>
<li>在控制器中手写UI也可以用weak修饰，因为subViews为copy修饰的强引用数组，因为会持有控件，但是要注意一定要在addSubview作用范围内进行赋值属性，否则出来作用范围，由于用weak修饰，属性的引用计数为0，会销毁掉；同样用strong修饰的话也可以，在控制器销毁后，不管是strong还是weak，引用计数都会变为0<ol>
<li>注意这里的不能直接对成员变量进行赋值，否则会直接提醒无引用计数，要设置一个临时变量，这样临时变量会暂时持有，等addsubview添加后，由控制器持有</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>零碎知识点</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2017/03/23/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/LXDAppFluecyMonitor-master/LXDAppFluecyMonitor/Assets.xcassets/AppIcon.appiconset/Contents/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>{"images":[{"idiom":"iphone","size":"29x29","scale":"2x"},{"idiom":"iphone","size":"29x29","scale":"3x"},{"idiom":"iphone","size":"40x40","scale":"2x"},{"idiom":"iphone","size":"40x40","scale":"3x"},{"idiom":"iphone","size":"60x60","scale":"2x"},{"idiom":"iphone","size":"60x60","scale":"3x"}],"info":{"version":1,"author":"xcode"}}]]></content>
  </entry>
</search>
