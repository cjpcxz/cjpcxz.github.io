<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>闭包</title>
    <url>/2023/02/27/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>一个函数和它所捕获的变量\常量环境组合起来，称为闭包</p>
<ul>
<li>一般指定义在函数内部的函数</li>
<li>一般它捕获的是外层西数的局部变量\常量</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>结构体与类</title>
    <url>/2023/02/26/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="结构体是值类型（枚举也是值类型），类是引用类型（指针类型）"><a href="#结构体是值类型（枚举也是值类型），类是引用类型（指针类型）" class="headerlink" title="结构体是值类型（枚举也是值类型），类是引用类型（指针类型）"></a>结构体是值类型（枚举也是值类型），类是引用类型（指针类型）</h3><ul>
<li>例子<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Size &#123;</span><br><span class="line">    var width = 1</span><br><span class="line">    var height = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 3</span><br><span class="line">    var y = 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">    var size = Size()</span><br><span class="line">    var point = Point()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行test()方法，时的内存地址,(64位)<br><img src="1.png"><ul>
<li>内存地址由高到低在栈中赋值，结构体直接存储在栈上，类在栈上存的是8字节的指针地址</li>
<li>堆空间的Size对象占32位，其中16位存width，height数据，8位存引用计数，8位类型信息的地址</li>
</ul>
</li>
<li>注意，类的指针和结构体存的地方不一定在栈，<ul>
<li>如果在全局区生成，则类的指针和结构体在全局区，</li>
<li>如果结构体变量为类的属性，则会和该类一起在堆区生成</li>
<li>如果在函数内生成，则类的指针和结构体在栈区<h3 id="类和结构体的大小"><a href="#类和结构体的大小" class="headerlink" title="类和结构体的大小"></a>类和结构体的大小</h3></li>
</ul>
</li>
<li>类中用MemoryLayout获取的大小，实际是指针大小始终位8<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(MemoryLayout&lt;Size&gt;.stride) // 8,Size指针变量因此是8</span><br><span class="line">print(MemoryLayout&lt;Point&gt;.stride) // 16，</span><br></pre></td></tr></table></figure></li>
<li>获取类内存中的指针数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var size = Size()</span><br><span class="line">let sizePoint = UnsafeRawPointer(bitPattern: unsafeBitCast(size, to: UInt.self))! //存放在堆中的引用地址</span><br><span class="line">malloc_size(sizePoint) //32 获取堆中的内存数据大小</span><br></pre></td></tr></table></figure>
<h3 id="值类型赋值"><a href="#值类型赋值" class="headerlink" title="值类型赋值"></a>值类型赋值</h3></li>
<li>值类型赋值给<code>var</code>、<code>let</code>或者给函数传参，是直接将所有内容拷贝一份</li>
<li>类似于对文件进行copy、paste操作，产生了全新的文件副本。属于深拷贝 ( deep copy )<h4 id="结构体的Copy-on-Write"><a href="#结构体的Copy-on-Write" class="headerlink" title="结构体的Copy on Write"></a>结构体的Copy on Write</h4></li>
<li>在swift标准库中，为了提升性能，<code>String</code>、<code>Array</code>、<code>Dictionary</code>、<code>set</code>采取了<code>Copy On Write</code>的技术<ul>
<li>比如仅当有“写〞操作时 ，才会真正执行拷贝操作</li>
<li>对于标准库值类型的赋值操作 ，<code>Swift</code> 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值<ul>
<li>如果是非标准库的结构体，时不会有写时拷贝的操作<h3 id="引用类型赋值"><a href="#引用类型赋值" class="headerlink" title="引用类型赋值"></a>引用类型赋值</h3></li>
</ul>
</li>
</ul>
</li>
<li>引用赋值给var、 let或者给函数传参，是将内存地址拷贝一份</li>
<li>类似于制作一个文件的替身（快捷方式、链接），指向的是同一个文件。属于浅拷贝 (shallow copy)</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>汇编基本认识</title>
    <url>/2023/02/25/iOS%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/LLDB%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>软件、程序的执行过程<br><img src="1.png"></li>
<li>通常，cpu会将内存中的数据存储到寄存器中，然后再对寄存器中的数据进行计算</li>
<li>假设内存中有块<code>红色内存空间</code>的值是3，现在想把它的值加1，并将结果存储到<code>蓝色内存空间</code><ul>
<li>CPU首先会将<code>红色内存空间</code>的值放到<code>rax寄存器</code>中: <code>movq</code> <code>红色内存空间</code>, <code>%rax</code></li>
<li>然后让rax寄存器与1相加，送回到rax中：<code>addq</code> <code>$0x1</code>,<code>%rax</code>,</li>
<li>最后将值赋值给内存空间：<code>movq</code> <code>%rax</code>，<code>蓝色内存空间</code></li>
</ul>
</li>
<li>CPU不支持内存之间的改变，因此要通过寄存器，并且寄存器内操作，速度要快些<h3 id="语言发展"><a href="#语言发展" class="headerlink" title="语言发展"></a>语言发展</h3></li>
</ul>
<ol>
<li>机器语言<ul>
<li>由0和1组成</li>
</ul>
</li>
<li>汇编语言( Assembly Language )<ul>
<li>用符号代替了O和1，比机器语言便于阅读和记忆</li>
</ul>
</li>
<li>高级语言<ul>
<li>C\C++\java\javaScript\Python等，更接近人类自然语言</li>
</ul>
</li>
</ol>
<ul>
<li>例如，将寄存器BX的内容送入奇存器AX<ul>
<li>机器语言：1000100111011000</li>
<li>汇编语言：movw %bx, %ax</li>
<li>高级语言：ax = bx;</li>
</ul>
</li>
<li>汇编语言与机器语言一一对应，但是高级语言和汇编语言不是一一对应的</li>
<li>汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言</li>
<li>高级语言可以通过编译得到;汇编语言\机器语言 ，但汇编语言\机器语言几乎不可能还原成高级语言</li>
<li>iOS中，主要的汇编语言是<ul>
<li>AT&amp;T汇编 -＞ ioS模拟器</li>
<li>ARM汇编 -＞ ioS真机设备<h3 id="常见的"><a href="#常见的" class="headerlink" title="常见的"></a>常见的</h3></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th align="left">AT&amp;T</th>
<th>Intel</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器命名</td>
<td align="left">%rax</td>
<td>rax</td>
<td align="left"></td>
</tr>
<tr>
<td>操作数顺序</td>
<td align="left">movq %rax, %rdx</td>
<td>mov rdx, rax</td>
<td align="left">将rax的值赋值给rdx</td>
</tr>
<tr>
<td>常数\立即数</td>
<td align="left">movq $3, %rax              movq $0x10, %rax</td>
<td>mov rax, 3                        mov rax, 0x10</td>
<td align="left">将3赋值给rax;  将Ox10赋值给rax</td>
</tr>
<tr>
<td>内存赋值</td>
<td align="left">movq $0xa, 0x1ff7(%rip)</td>
<td>mov qword ptr [rip+0x1ff7],     0xa</td>
<td align="left">将0xa赋值给地址为rip +0x1ff7的内存空间</td>
</tr>
<tr>
<td>取内存地址</td>
<td align="left">leaq -0x18(%rbp), %rax</td>
<td>lea rax, [rbp - 0x181]</td>
<td align="left">将rbp-0x18这个地址值赋值给rax</td>
</tr>
<tr>
<td>jmp指令</td>
<td align="left">jmp *%rdx; jmp 0×4001002; jmp *(%rax)</td>
<td>jmp rdx ;jmp 0×4001002;jmp [rax]</td>
<td align="left">jmp 0×4001002 ，跳到指定内存地址，去执行代码。  jmp *%rdx  间接跳转rdx的地址</td>
</tr>
<tr>
<td>call 指令</td>
<td align="left">call 0x19001632               call *%rdx</td>
<td>callq 0x19001632              call   %rdx</td>
<td align="left">跳转到函数地址进行执行，会和retq(会返回当初callq调用的下一个指令)配和使用，和jmp不同</td>
</tr>
<tr>
<td>操作数长度</td>
<td align="left">movl %eax, %edx; movb $0x10, %al; leaw 0x10(%d×), %ax</td>
<td>mov edx, eax;mov al, 0x10;lea ax, [dx + 0x10]</td>
<td align="left">b = byte (8-bit) ;s = short (16-bit integer or 32-bit floating point) ;W = word (16-bit);I = long (32-bit integer or 64-bit floating point);q = quad (64 bit);t = ten bytes (80-bit floating point)</td>
</tr>
</tbody></table>
<ul>
<li>操作数长度，代表要覆盖的长度，列如<code>movq 0xa, (0x110)</code>,将0xa存放在0x110地址中(考虑大小端存放)，占8字节（q为64位），而<code>movw 0xa, (0x110)</code>,表示占2字节（w为16位）<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3></li>
<li>寄存器命名特点<ul>
<li>r开头：64bit,8字节</li>
<li>e开头: 32bit,4字节</li>
<li>ax,bx,cx: 2字节</li>
<li>ah al:8bit 1字节</li>
</ul>
</li>
<li>iOS中为64位寄存器，但是也有其他地位寄存器，会拿出一半来做4字节及一下的寄存器，其内存是共用的<br><img src="2.png"></li>
<li>寄存器只能存储8个字节的，像对象都是存在堆中的 </li>
<li>常用有16个常用寄存器<ul>
<li>rax、rbx rex、rdx. rsi rdi rbp.rsp</li>
<li>r8.r9. r10.r11、 r12、r13、rl4、r15</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编基本认识</title>
    <url>/2023/02/25/iOS%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>软件、程序的执行过程<br><img src="1.png"></li>
<li>通常，cpu会将内存中的数据存储到寄存器中，然后再对寄存器中的数据进行计算</li>
<li>假设内存中有块<code>红色内存空间</code>的值是3，现在想把它的值加1，并将结果存储到<code>蓝色内存空间</code><ul>
<li>CPU首先会将<code>红色内存空间</code>的值放到<code>rax寄存器</code>中: <code>movq</code> <code>红色内存空间</code>, <code>%rax</code></li>
<li>然后让rax寄存器与1相加，送回到rax中：<code>addq</code> <code>$0x1</code>,<code>%rax</code>,</li>
<li>最后将值赋值给内存空间：<code>movq</code> <code>%rax</code>，<code>蓝色内存空间</code></li>
</ul>
</li>
<li>CPU不支持内存之间的改变，因此要通过寄存器，并且寄存器内操作，速度要快些<h3 id="语言发展"><a href="#语言发展" class="headerlink" title="语言发展"></a>语言发展</h3></li>
</ul>
<ol>
<li>机器语言<ul>
<li>由0和1组成</li>
</ul>
</li>
<li>汇编语言( Assembly Language )<ul>
<li>用符号代替了O和1，比机器语言便于阅读和记忆</li>
</ul>
</li>
<li>高级语言<ul>
<li>C\C++\java\javaScript\Python等，更接近人类自然语言</li>
</ul>
</li>
</ol>
<ul>
<li>例如，将寄存器BX的内容送入奇存器AX<ul>
<li>机器语言：1000100111011000</li>
<li>汇编语言：movw %bx, %ax</li>
<li>高级语言：ax = bx;</li>
</ul>
</li>
<li>汇编语言与机器语言一一对应，但是高级语言和汇编语言不是一一对应的</li>
<li>汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言</li>
<li>高级语言可以通过编译得到;汇编语言\机器语言 ，但汇编语言\机器语言几乎不可能还原成高级语言</li>
<li>iOS中，主要的汇编语言是<ul>
<li>AT&amp;T汇编 -＞ ioS模拟器</li>
<li>ARM汇编 -＞ ioS真机设备<h3 id="常见的"><a href="#常见的" class="headerlink" title="常见的"></a>常见的</h3></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th align="left">AT&amp;T</th>
<th>Intel</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器命名</td>
<td align="left">%rax</td>
<td>rax</td>
<td align="left"></td>
</tr>
<tr>
<td>操作数顺序</td>
<td align="left">movq %rax, %rdx</td>
<td>mov rdx, rax</td>
<td align="left">将rax的值赋值给rdx</td>
</tr>
<tr>
<td>常数\立即数</td>
<td align="left">movq <code>$3</code>, <code>%rax</code> ;movq <code>$0x10</code>, %rax</td>
<td>mov rax, 3   ;  mov rax, 0x10</td>
<td align="left">将3赋值给rax;  将Ox10赋值给rax,(带$富豪的都是立即数，即常数)</td>
</tr>
<tr>
<td>内存赋值</td>
<td align="left">movq $0xa, 0x1ff7(%rip)</td>
<td>mov qword ptr [rip+0x1ff7],     0xa</td>
<td align="left">将0xa赋值给地址为rip +0x1ff7的内存空间（注意执行指令，<code>rip</code>中存放了下一条指令的地址,因此此时相加的是与下一条指令相加的地址）</td>
</tr>
<tr>
<td>取内存地址</td>
<td align="left">leaq -0x18(%rbp), %rax</td>
<td>lea rax, [rbp - 0x181]</td>
<td align="left">将rbp-0x18这个地址值赋值给rax</td>
</tr>
<tr>
<td>jmp指令</td>
<td align="left">jmp *%rdx; jmp 0×4001002; jmp *(%rax)</td>
<td>jmp rdx ;jmp 0×4001002;jmp [rax]</td>
<td align="left">jmp 0×4001002 ，跳到指定内存地址，去执行代码。  jmp *%rdx  间接跳转rdx的地址</td>
</tr>
<tr>
<td>call 指令</td>
<td align="left">call 0x19001632               call *%rdx</td>
<td>callq 0x19001632              call   %rdx</td>
<td align="left">跳转到函数地址进行执行，会和retq(会返回当初callq调用的下一个指令)配和使用，和jmp不同</td>
</tr>
<tr>
<td>操作数长度</td>
<td align="left">movl %eax, %edx; movb $0x10, %al; leaw 0x10(%d×), %ax</td>
<td>mov edx, eax;mov al, 0x10;lea ax, [dx + 0x10]</td>
<td align="left">b = byte (8-bit) ;s = short (16-bit integer or 32-bit floating point) ;W = word (16-bit);I = long (32-bit integer or 64-bit floating point);q = quad (64 bit);t = ten bytes (80-bit floating point)</td>
</tr>
</tbody></table>
<ul>
<li>操作数长度，代表要覆盖的长度，列如<code>movq 0xa, (0x110)</code>,将0xa存放在0x110地址中(考虑大小端存放)，占8字节（q为64位），而<code>movw 0xa, (0x110)</code>,表示占2字节（w为16位）<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3></li>
<li>寄存器命名特点<ul>
<li>r开头：64bit,8字节</li>
<li>e开头: 32bit,4字节</li>
<li>ax,bx,cx: 2字节</li>
<li>ah al:8bit 1字节</li>
</ul>
</li>
<li>iOS中为64位寄存器，但是也有其他低位寄存器，会拿出一半来做4字节及一下的寄存器，其内存是共用的<br><img src="2.png"></li>
<li>寄存器只能存储8个字节的，像对象都是存在堆中的 </li>
<li>常用有16个常用寄存器<ul>
<li>rax、rbx rex、rdx、rsi、rdi、rbp、 rsp</li>
<li>r8.r9. r10.r11、 r12、r13、rl4、r15</li>
</ul>
</li>
<li>寄存器的具体用途<ol>
<li><code>rax</code>、<code>rdx</code>常作为函数返回值使用</li>
<li><code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>等奇存器常用于存放函数参数，参数过多，寄存器不够，则会放到栈中</li>
<li><code>rsp</code>、<code>rbp</code>用于栈操作,用来存在栈空间的地址值<ul>
<li>函数中，一般<code>rbp</code>和<code>rsp</code>之间用来存局部变量的，其他地方（<code>rbp</code>上方x或<code>rsp</code>下方）存放函数参数(在2中寄存器不够了，就会放到栈中)</li>
</ul>
</li>
<li><code>rip</code>作为指令指针<ul>
<li>存储着<code>CPU</code>下一条要执行的指令的地址</li>
<li>，一旦<code>CPU</code>读取一条指令，<code>rip</code>会自动指向下一条指令（存储下一条指令的地址）<h4 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h4></li>
</ul>
</li>
</ol>
</li>
<li>内存地址格式为：<code>0x4bdc(%rip)</code>，一般是全局变量 ，全局区（数据段）</li>
<li>内存地址格式为：<code>-0x78（%rbp</code>），一般是局部变量，栈空间</li>
<li>内存地址格式为：<code>0x10（%rax)</code>，一般是堆空间<h3 id="lldb常用指令"><a href="#lldb常用指令" class="headerlink" title="lldb常用指令"></a>lldb常用指令</h3></li>
<li>读取寄存器的值<ul>
<li>register read rbp ,读取rbp中的值（lldb可以不用加%）</li>
<li>register read/o rbp,读取值，以8进制显示，默认16进制</li>
<li>register read,获取当前所有的寄存器的值</li>
</ul>
</li>
<li>修改寄存器的值<ul>
<li>register write 寄存器名称 数值</li>
<li>register write rax O</li>
</ul>
</li>
<li>读取内存中的值<ul>
<li>x/数量-格式-字节大小 内存地址</li>
<li>x/3xw 0x000010,显示内存中的数据，3组数据，每组4个字节以16进制显示</li>
<li>格式<ul>
<li>x是16进制，</li>
<li>f是浮点，</li>
<li>d是十进制</li>
</ul>
</li>
<li>字节大小<ul>
<li>b-byte 1字节</li>
<li>h-half word 2字节</li>
<li>W-word 4字节</li>
<li>g- giant word 8字节</li>
</ul>
</li>
</ul>
</li>
<li>修改内存中的值<ul>
<li>memory write 内存地址 数值</li>
<li>memory write 0x0000010 10</li>
</ul>
</li>
<li>expression 表达式,可以简写：expr 表达式<ul>
<li>expression Srax</li>
<li>expression $rax = 1</li>
</ul>
</li>
<li>po 表达式<ul>
<li>print 表达式</li>
<li>po/x $rax</li>
<li>po (int)$rax<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3></li>
</ul>
</li>
<li>thread step-over、 next、n（全称和简写）<ul>
<li>单步运行，把子函数当做整体一步执行（源码级别）</li>
</ul>
</li>
<li>thread step-in、 step、s<ul>
<li>单步运行，遇到子函数会进入子函数（源码级别），与si不同，可能会跳过好几句汇编代码</li>
</ul>
</li>
<li>thread step-inst-over、 nexti.ni<ul>
<li>单步运行，把子函数当做整体一步执行（汇编级别）</li>
</ul>
</li>
<li>thread step-inst, stepi. si<ul>
<li>单步运行，遇到子函数会进入子函数（汇编级别）</li>
</ul>
</li>
<li>thread step-out, finish<ul>
<li>直接执行完当前函数的所有代码，返回到上一个函数（遇到断点会卡住）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>枚举内存分析</title>
    <url>/2023/02/25/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="内存查看"><a href="#内存查看" class="headerlink" title="内存查看"></a>内存查看</h3><blockquote>
<p><code>view Memory</code>功能，查看地址中存放的内存</p>
</blockquote>
<ul>
<li><p>查看效果<br><img src="1.png"></p>
</li>
<li><p>地址内存查看方式，iOS是小端模式，高高低低，高地址存高位，低地址存地位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面8个字节实际上是</span><br><span class="line">0x00 00 00 00 00 00 00 05</span><br></pre></td></tr></table></figure></li>
<li><p>获取枚举的地址方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var t = TestNum.test1 </span><br><span class="line">let nums = withUnsafePointer(to: &amp;t) &#123; UnsafeRawPointer($0) &#125; //内存地址 0x000000010000c0b0</span><br></pre></td></tr></table></figure>
<h4 id="普通枚举"><a href="#普通枚举" class="headerlink" title="普通枚举"></a>普通枚举</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum TestNum &#123; </span><br><span class="line">    case test1,test2,test3,test4,test5,test6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.size) // 1</span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.stride) // 1</span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.alignment) // 1</span><br><span class="line"></span><br><span class="line">var t = TestNum.test1</span><br><span class="line">t = .test5</span><br><span class="line">t = .test6</span><br></pre></td></tr></table></figure></li>
<li><p>内存情况,1字节内存,第一个枚举是00,后面依次增加，其内存最大是<code>0xFF</code>预计最大可以有枚举数256个（这么大的数量无需用枚举了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var t = TestNum.test1 // 0x00</span><br><span class="line">t = .test5  // 0x04</span><br><span class="line">t = .test6  // 0x05</span><br></pre></td></tr></table></figure>
<h4 id="带原始值的枚举"><a href="#带原始值的枚举" class="headerlink" title="带原始值的枚举"></a>带原始值的枚举</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum TestNum:Int &#123; </span><br><span class="line">    case test1 = 10,test2,test3,test4,test5,test6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.size) // 1</span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.stride) // 1</span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.alignment) // 1</span><br></pre></td></tr></table></figure></li>
<li><p>内存情况,带有1字节内存。其内存情况和普通枚举类型一样的，其原始值不占有内存空间，类似计算属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var t = TestNum.test1 // 0x00</span><br><span class="line">t = .test5  // 0x04</span><br><span class="line">t = .test6  // 0x05</span><br></pre></td></tr></table></figure>
<h4 id="带关联值的枚举"><a href="#带关联值的枚举" class="headerlink" title="带关联值的枚举"></a>带关联值的枚举</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum TestNum &#123; </span><br><span class="line">    case test1(Int,Int,Int),test2(Int,Int),test3(Int),test4(Bool),test5,test6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.size) // 25</span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.stride) // 32</span><br><span class="line">print(MemoryLayout&lt;TestNum&gt;.alignment) // 8</span><br></pre></td></tr></table></figure></li>
<li><p>内存情况,实际占用25个字节，内存对齐是32个字节。对于存储情况，以最大存储3个Int，位24字节，前面的24个字节均用来存储关联值的（不管当前实际关联值大小是1个字节，还是16个字节），最高位用来存储枚举的类型（普通枚举不一样）。</p>
<ul>
<li>内存从左到右，从上到下，内存地址增加</li>
<li>关联值和非关联值，枚举标志位存放的位置是不一样的，类似共用体<ul>
<li>非关联值在最高位，普通枚举在最低位<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//占用内存情况</span><br><span class="line">//10 00 00 00 00 00 00 00  //实际为 0x10</span><br><span class="line">//02 00 00 00 00 00 00 00  //实际为 0x02</span><br><span class="line">//03 00 00 00 00 00 00 00  //实际为 0x03</span><br><span class="line">//00 </span><br><span class="line">var t = TestNum.test1(16,2,3) </span><br><span class="line">//占用内存情况</span><br><span class="line">//04 00 00 00 00 00 00 00  //实际为 0x04</span><br><span class="line">//05 00 00 00 00 00 00 00  //实际为 0x05</span><br><span class="line">//00 00 00 00 00 00 00 00  </span><br><span class="line">//01                       //实际为 0x01</span><br><span class="line">t = .test2(4, 5) </span><br><span class="line"> //占用内存情况</span><br><span class="line">//01 00 00 00 00 00 00 00  //实际为 0x01</span><br><span class="line">//00 00 00 00 00 00 00 00</span><br><span class="line">//00 00 00 00 00 00 00 00  </span><br><span class="line">//03                       //实际为 0x03</span><br><span class="line">t = .test4(true)</span><br><span class="line">//占用内存情况</span><br><span class="line">//10 00 00 00 00 00 00 00  //第一位标识位是1，表明第二个普通的枚举</span><br><span class="line">//00 00 00 00 00 00 00 00</span><br><span class="line">//00 00 00 00 00 00 00 00  </span><br><span class="line">//04                      //实际为 0x04, 这表明总共有4个关联枚举？</span><br><span class="line">t = .test6</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>最后一个值为bool类型，则实际尺寸仍然是<code>25</code>字节，bool和枚举标识位混用，并且有关联类型的标识符和普通的标识符号顺序不同。但是中间有bool，实际占用是32字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//实际占用25字节</span><br><span class="line">enum TestNum2 &#123;</span><br><span class="line">    case test4(Bool) </span><br><span class="line">    case test5 </span><br><span class="line">    case test1(Int,Int,Int,Bool)</span><br><span class="line">    case test2(Int,Int)</span><br><span class="line">    case test3(Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实际占用32字节</span><br><span class="line">enum TestNum2 &#123;</span><br><span class="line">    case test4(Bool) </span><br><span class="line">    case test5 </span><br><span class="line">    case test1(Int,Int,Bool,Int)</span><br><span class="line">    case test2(Int,Int)</span><br><span class="line">    case test3(Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>注意如果只有一个项的关联值，其内存不会算上枚举自身的1字节<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum TestNUm &#123;</span><br><span class="line">    case test1(Int,Int,Int)</span><br><span class="line">&#125;</span><br><span class="line">print(MemoryLayout&lt;TestNUm&gt;.size) //24</span><br><span class="line">print(MemoryLayout&lt;TestNUm&gt;.stride) //24</span><br><span class="line">print(MemoryLayout&lt;TestNUm&gt;.alignment) //24</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### switch匹配</span><br></pre></td></tr></table></figure>
enum TestNum {<br>  case test1(Int,Int,Int),test2(Int,Int),test3(Int),test4(Bool),test5,test6<br>}</li>
</ul>
<p>//实际大小是25<br>var e = TestEnum.test1(10,20,30)<br>//取出第25个字节去判断<br>switch e {<br>    case let .test1(v1,v2,v3): //判断25位是0，取出前24个字节进行赋值<br>        print(v1,v2,v3)<br>     case let .test2(v1,v2): //判断25位是1，取出前16个字节进行赋值<br>        print(v1,v2,v3)<br>    default:break<br>}</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>swift的枚举、可选项</title>
    <url>/2023/02/23/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E6%9E%9A%E4%B8%BE%E3%80%81%E5%8F%AF%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h3><ul>
<li>递归枚举，必须用<code>indirect</code>修饰<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum ArithExpr&#123;</span><br><span class="line">    case number(Int)</span><br><span class="line">    indirect case sum(ArithExpr,ArithExpr)</span><br><span class="line">    indirect case difference(ArithExpr,ArithExpr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联值和原始值的内存"><a href="#关联值和原始值的内存" class="headerlink" title="关联值和原始值的内存"></a>关联值和原始值的内存</h3></li>
<li>原始值所分配的空间只有1个字节，不管他有无原始值。原始值一开始是决定好的，无法更改，因此没必要存储到内存中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Season1 &#123;</span><br><span class="line">    case spring,summer,autumn,winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Season1&gt;.stride //1  分配占用的空间大小</span><br><span class="line">MemoryLayout&lt;Season1&gt;.size   // 1 实际用到的空间大小</span><br><span class="line">MemoryLayout&lt;Season1&gt;.alignment  // 1 对齐的参数</span><br><span class="line"></span><br><span class="line">enum Season:Int &#123;</span><br><span class="line">    case spring = 100,summer = 200,autumn = 300,winter = 400</span><br><span class="line">&#125;</span><br><span class="line">MemoryLayout&lt;Season&gt;.stride //1  分配占用的空间大小</span><br><span class="line">MemoryLayout&lt;Season&gt;.size   // 1 实际用到的空间大小</span><br><span class="line">MemoryLayout&lt;Season&gt;.alignment  // 1 对齐的参数</span><br></pre></td></tr></table></figure></li>
<li>关联值中，以所占最大的关联值的内存为准。由于将来需要将关联值存储到枚举的<code>内存</code>内，因此需要分配内存。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Password &#123;</span><br><span class="line">    case number(Int,Int,Int,Int) // Int 4字节，加上枚举1个字节，实际33</span><br><span class="line">    case other</span><br><span class="line">    case bigNumer(Int,Int,Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Password&gt;.size // 33</span><br><span class="line">MemoryLayout&lt;Password&gt;.alignment // 8</span><br><span class="line">MemoryLayout&lt;Password&gt;.stride // 40</span><br></pre></td></tr></table></figure>
<h3 id="多重可选项"><a href="#多重可选项" class="headerlink" title="多重可选项"></a>多重可选项</h3></li>
<li>示意图1<br><img src="1.png"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num1:Int? = 10</span><br><span class="line">var num2: Int?? = num4</span><br><span class="line">var num3: Int?? = 10</span><br><span class="line">print(num2 == num3) //true</span><br><span class="line">print(num1 == num2) //true</span><br><span class="line">print(num2 == 10) //true 解包到nil或着值为止</span><br><span class="line">//双重强制解包</span><br><span class="line">num3!! // 10</span><br></pre></td></tr></table></figure></li>
<li>示意图2<br><img src="2.png"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num1:Int? = nil </span><br><span class="line">var num2: Int?? = num1</span><br><span class="line">var num3: Int?? = nil</span><br><span class="line">var num4: Int??? = num2</span><br><span class="line">print(num2 == num3) //false</span><br><span class="line">print(num1 == num2) //true ==会对num1解包的到值后判断</span><br><span class="line">print(num1 == num3) //true 解包到nil或着值为止</span><br><span class="line">(num2 ?? 1) ?? 2 //2  num2解出来不为nil，是num1;num1解出来为nil，赋值2</span><br><span class="line">(num3 ?? 1) ?? 2 //1  num3解出来为nil，则赋值1</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>可以使用lldb指令<code>frame variable -R</code>或者<code>fr v -R</code>查看结构</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>swift的函数</title>
    <url>/2023/02/22/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h2><h3 id="inout的函数，是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）"><a href="#inout的函数，是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）" class="headerlink" title="inout的函数，是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）"></a>inout的函数，是地址传递，而非在是值传递（在函数体内改变之后，在赋值给原来的值）</h3><ul>
<li>汇编验证<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> func test(_ num: Int) &#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> // movq 值传递 %rbp - 0x20的地址中取值,传给方法</span><br><span class="line">0x100003f70 &lt;+64&gt;: movq   -0x20(%rbp), %rdi</span><br><span class="line">0x100003f74 &lt;+68&gt;: callq  0x100003f90               ;  SwiftDText.test(Swift.Int) -&gt; () at main.swift:11</span><br><span class="line">0x100003f79 &lt;+73&gt;: xorl   %eax, %eax</span><br><span class="line">0x100003f7b &lt;+75&gt;: addq   $0x20, %rsp</span><br><span class="line">0x100003f7f &lt;+79&gt;: popq   %rbp</span><br><span class="line">0x100003f80 &lt;+80&gt;: retq </span><br><span class="line"> </span><br><span class="line"> func test(_ num: inout Int) &#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // leaq 地址传递 %rbp - 0x20的地址传到 %rdi,且在callq后面，并没有movq赋值操作</span><br><span class="line"> 0x100003f6c &lt;+44&gt;: leaq   0x408d(%rip), %rdi        ; SwiftDText.num : Swift.Int</span><br><span class="line"> 0x100003f73 &lt;+51&gt;: callq  0x100003f90               ; SwiftDText.test(inout Swift.Int) -&gt; () at main.swift:11</span><br><span class="line">0x100003f78 &lt;+56&gt;: leaq   -0x18(%rbp), %rdi</span><br><span class="line">0x100003f7c &lt;+60&gt;: callq  0x100003fa8               ; symbol stub for: swift_endAccess</span><br><span class="line">0x100003f81 &lt;+65&gt;: xorl   %eax, %eax</span><br><span class="line">0x100003f83 &lt;+67&gt;: addq   $0x20, %rsp</span><br><span class="line">0x100003f87 &lt;+71&gt;: popq   %rbp</span><br><span class="line">0x100003f88 &lt;+72&gt;: retq  </span><br><span class="line"> */</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="inout-函数存在的独占访问权限"><a href="#inout-函数存在的独占访问权限" class="headerlink" title="inout 函数存在的独占访问权限"></a>inout 函数存在的独占访问权限</h3></li>
<li>下面均会出现<code>imultaneous accesses to 0x100008178, but modification requires exclusive access</code>崩溃异常<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--第一种--&gt;</span><br><span class="line">var num = 3</span><br><span class="line">func test(nu: inout Int) &#123;</span><br><span class="line">    nu += 3</span><br><span class="line">    print(num) // 读同一个地址的num会崩溃</span><br><span class="line">    //num += 10 // 写同一个地址的num也会崩溃</span><br><span class="line">&#125;</span><br><span class="line">test(nu: &amp;num)</span><br><span class="line">&lt;!--第二种--&gt;</span><br><span class="line">class TestNum &#123;</span><br><span class="line">    var i:Int = 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let testNum = TestNum()</span><br><span class="line">func test(i: inout Int) &#123; </span><br><span class="line">    i += 3</span><br><span class="line">    print(testNum.i) // 读同一个地址的num会崩溃</span><br><span class="line">    //testNum.i += 10 // 写同一个地址的num也会崩溃</span><br><span class="line">&#125;</span><br><span class="line">test(i: &amp;testNum.i)</span><br></pre></td></tr></table></figure></li>
<li>当一个变量访问同一块内存时，会产生独占内存访问权限冲突<h3 id="计算型属性或者一个具有属性观察器的属性调用inout时"><a href="#计算型属性或者一个具有属性观察器的属性调用inout时" class="headerlink" title="计算型属性或者一个具有属性观察器的属性调用inout时"></a>计算型属性或者一个具有属性观察器的属性调用inout时</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TestNum &#123;</span><br><span class="line">    var j:Int = 0</span><br><span class="line">    var i:Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;get&quot;)</span><br><span class="line">            return j</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;set&quot;)</span><br><span class="line">            j = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test(i:inout Int) &#123;</span><br><span class="line">    print(&quot;开始&quot;)</span><br><span class="line">    i += 3</span><br><span class="line">    actNum.i += 10</span><br><span class="line">    print(actNum.i)</span><br><span class="line">    print(&quot;结束&quot;)</span><br><span class="line">&#125;</span><br><span class="line">test(i: &amp;actNum.i)</span><br><span class="line">print(actNum.i)</span><br><span class="line">/* 输出：</span><br><span class="line">get</span><br><span class="line">开始</span><br><span class="line">get</span><br><span class="line">set</span><br><span class="line">get</span><br><span class="line">10</span><br><span class="line">结束</span><br><span class="line">set</span><br><span class="line">get</span><br><span class="line">3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li>在<code>test</code>方法内部同时使用<code>&amp;actNum.i</code>和<code>actNum.i</code>并未出现<code>独占内存访问权限冲突</code>,并且在方法内部设置的值10，最后输出的时候，仍为3。<ul>
<li>表明方法内部的<code>i</code>,和<code>actNum.i</code>并非同一个，因此没有出现独占内存。并且在方法结束后，会重新赋值给<code>actNum.i</code>这种行为叫做<code>拷入拷出</code>或者<code>值结果调用</code></li>
<li><code>拷入拷出</code>遵循如下规则：<ol>
<li>函数调用时，参数的值被拷贝。</li>
<li>函数体内部，拷贝后的值被修改。</li>
<li>函数返回后，拷贝后的值被赋值给原参数。</li>
</ol>
</li>
<li>可以认为在调用函数前，先创建了一个值x，并将调用<code>get</code>方法将<code>actNum.i</code>赋值给x，这是在函数中进行的<code>inout</code>操作是x，在函数结束后，调用<code>set</code>方法，将x的值赋予给<code>actNum.i</code><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2></li>
</ul>
</li>
<li>规则<ul>
<li>函数名相同</li>
<li>参数个数不同 || 参数类型不同 || 参数标签不同</li>
</ul>
</li>
<li><em>注意</em>,重载和返回值类型无关<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func test(_ num: inout Int) &#123;</span><br><span class="line">    num = 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//会报错</span><br><span class="line">func test(_ num: inout Int) -&gt; Int &#123;</span><br><span class="line">    num = 40</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><em>注意</em>，默认参数和函数重载一起使用产生二义性时，编译器不会报错（在C++中会报错）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func test(_ num: inout Int,type;Bool = false) &#123;</span><br><span class="line">    num = 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func test(_ num: inout Int) -&gt; Int &#123;</span><br><span class="line">    num = 40</span><br><span class="line">&#125;</span><br><span class="line">var num = 0</span><br><span class="line">//会调用test(_ num: inout Int)</span><br><span class="line">test(&amp;num) // num = 40</span><br></pre></td></tr></table></figure></li>
<li><em>注意</em>,可变参数、省略参数标签、函数重载一起使用参数二义性时，编译器有可能会报错（避免这种情况）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一</span><br><span class="line">func test(_ num: Int,num2:Int = 10) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//第二</span><br><span class="line">func test(_ num: Int,_ num2:Int) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">//第三</span><br><span class="line">func test(_ num:Int...) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//编译起报错，但是屏蔽第一个代码，就不会报错了</span><br><span class="line">test(10)</span><br></pre></td></tr></table></figure>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2></li>
<li>如果开启了编译器优化（<code>Release</code>模式默认会开启优化）(<code>buildSetting</code>中的<code>optimization</code>)，编译器会自动将某些函数变成内联函数<ul>
<li>将函数调用展开成函数体</li>
</ul>
</li>
<li>哪些函数不会被自动内联<ul>
<li>函数体比较长</li>
<li>包含递归调用</li>
<li>包含动态派发（无法在编译的时候确定是谁调用的）</li>
</ul>
</li>
<li><code>@inline</code>,内联注解， Apple 的文档中是找不到，不建议使用<ul>
<li><code>@inline(__always) func test(i:Int) &#123;  &#125;</code>,开启编译优化后，即使代码很长也会被内联（递归调用,动态派发除外）</li>
<li><code>@inline(never) func test(i:Int) &#123;  &#125;</code>,永远不会被内联，即使开启了编译器优化（有时不起作用,还是会转为内联）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>swift的基础语法</title>
    <url>/2023/02/20/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>记录下swfit的基础不同的语法</p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul>
<li>只能赋值1次</li>
<li>它的值不要求在编泽时期确定，但使用之前必须赋值1次<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4></li>
<li>标识符（比如常量名、变量名、函数名）几乎可以使用任何字符</li>
<li>标识符不能以数字开头，不能包含空白字符、制表符、節头等特殊字符<h4 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h4><blockquote>
<p>只有值类型和引用类型，以前语言中的<code>Int</code>，<code>Bool</code>均为<em>结构体</em>，而非<em>基础数据类型</em></p>
</blockquote>
</li>
</ul>
<p><img src="1.png"></p>
<ul>
<li>整数类型：Int8、 Int16、 Int32、Int64、UInt8、 UInt16、 UInt32、UInt64</li>
<li>在32bit平台，Int等价于Int32；在64bit平台，Int等价于Int64</li>
<li>整数的最值：UInt8.max、 Int16. min</li>
<li>目一般情况下，都是直接使用Int即可</li>
<li>浮点类型：Float ，32位，精度只有6位；Double，64位，精度至少15位<h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//整数</span><br><span class="line">let intDecimal = 17//十进制</span><br><span class="line">let intBinary = 0b10001 // 二进制</span><br><span class="line">let intoctal = 0o21 //八进制</span><br><span class="line">llet intHexadecimal = 9x11//十六进制</span><br><span class="line"></span><br><span class="line">//浮点数</span><br><span class="line">let doubleDecimal = 125.0 //十进制，等价于1.25e2，日.0125等价于1.25e-2</span><br><span class="line">//只有十六进制可以这么写</span><br><span class="line">let doubleHexadecimal1= 0xFp2 //十六进制，意味着15x2^2，相当于十进制的68.0</span><br><span class="line">let doubleHe xadecima12 =日xFp-2 // 十六进制，意味着15x2^-2，相当于十进制的3.75</span><br></pre></td></tr></table></figure></li>
<li>类型转换<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//字面量可以直接相加，因为数字字面量本身没有明确的类型</span><br><span class="line">let result = 3 + 0.14156 //不会报错</span><br></pre></td></tr></table></figure>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4></li>
<li>for遍历值作为变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//i默认是let，有需要时可以声明为var，但是该变量只能单个for中变化,下一次又会重新赋值</span><br><span class="line">for var i in 1...3 &#123;</span><br><span class="line">    print(i)</span><br><span class="line">    i += 5</span><br><span class="line">&#125;</span><br><span class="line">//输出 1、2、3</span><br></pre></td></tr></table></figure></li>
<li>区间运算<ul>
<li>区间运算<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">for n in names[2...3] &#123;</span><br><span class="line">    print(n)</span><br><span class="line">&#125;</span><br><span class="line">//输出 c d</span><br></pre></td></tr></table></figure></li>
<li>单侧区间:让区间朝一个方向尽可能远<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for n in names[1...] &#123;</span><br><span class="line">    print(n)</span><br><span class="line">&#125;</span><br><span class="line">//输出 c d</span><br><span class="line"></span><br><span class="line">for n in names[..&lt;2] &#123;</span><br><span class="line">    print(n)</span><br><span class="line">&#125;</span><br><span class="line">//输出 a b</span><br><span class="line">//3到正无穷，但是...3不能用for</span><br><span class="line">for i in 3... &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let rang:PartialRangeThrough&lt;Int&gt; = ...3 //负无穷到3，不能用于for</span><br></pre></td></tr></table></figure></li>
<li>字符串、字符也能包含区间，但是不能用于for<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringRang = &quot;cc&quot;...&quot;ff&quot;</span><br><span class="line">stringRang.contains(&quot;dz&quot;) //true</span><br><span class="line">str.contains(&quot;fg&quot;) //false</span><br></pre></td></tr></table></figure></li>
<li>带间隔的区间值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//从4开始，累加2，&lt;=12</span><br><span class="line">for tickMark in stride(from: 4, through: 12, by: 2) &#123;</span><br><span class="line">    print(&quot;1&quot;,tickMark)</span><br><span class="line">&#125;</span><br><span class="line">//输出 4 6 8 10 12</span><br><span class="line">//从4开始，累加2，&lt;12</span><br><span class="line">for tickMark in stride(from: 4, to: 12, by: 2) &#123;</span><br><span class="line">    print(&quot;1&quot;,tickMark)</span><br><span class="line">&#125;</span><br><span class="line">//输出 4 6 8 10</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>swift的编译</title>
    <url>/2023/02/20/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="swift的编译"><a href="#swift的编译" class="headerlink" title="swift的编译"></a>swift的编译</h3><p><img src="2.png"><br><img src="1.png"></p>
<ul>
<li>OC前端采用<code>Clang</code>，<code>swift</code>的前端采用的是<code>swiftc</code>,swift编译时会生成swift的中间代码<code>IL</code>，对代码进行优化之后，在转换成<code>IR</code>,它们的后端均为<code>LLVM</code><h3 id="swiftc"><a href="#swiftc" class="headerlink" title="swiftc"></a>swiftc</h3></li>
<li>一些操作<ul>
<li>生成语法树：<code>swiftc -dump-ast main.swift</code></li>
<li>生成最简洁的SIL代码：<code>swiftc -emit-sil main.swift</code></li>
<li>生成LLVM IR代码：<code>swiftc -emit-ir main.swift -o main.ll</code></li>
<li>口生成汇编代码：<code>swiftc -emit-assembly main.swift -o main.s</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>安装包瘦身</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>安装包（IPA）主要由可执行文件、资源组成</p>
</blockquote>
<ul>
<li>资源（图片、音频、视频等）<ul>
<li>采取无损压缩</li>
<li>去除没有用到的资源： <a href="https://github.com/tinymind/LSUnusedResources">地址</a></li>
</ul>
</li>
<li>可执行文件瘦身<ul>
<li><code>Strip Linked Product</code>、<code>Make Strings Read-Only</code>、<code>Symbols Hidden by Default</code>设置为<code>YES</code></li>
<li>去掉异常支持，<code>Enable C++ Exceptions</code>、<code>Enable Objective-C Exceptions</code>设置为<code>NO</code>， <code>Other C Flags</code>添加<code>-fno-exceptions</code></li>
</ul>
</li>
<li>利用<a href="https://www.jetbrains.com/objc/">AppCode</a>检测未使用的代码：<code>菜单栏 -&gt; Code -&gt; Inspect Code</code></li>
<li>编写<code>LLVM插件</code>检测出重复代码、未被调用的代码</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>启动优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="APP的启动"><a href="#APP的启动" class="headerlink" title="APP的启动"></a>APP的启动</h2><ul>
<li><p>APP的启动可以分为2种</p>
<ul>
<li>冷启动（Cold Launch）：从零开始启动APP</li>
<li>热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP</li>
<li>APP启动时间的优化，主要是针对冷启动进行优化</li>
</ul>
</li>
<li><p>APP的冷启动可以概括为3大阶段</p>
<ul>
<li><code>dyld</code></li>
<li><code>runtime</code></li>
<li><code>main</code><br><img src="1.png"><h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3></li>
</ul>
</li>
<li><p><code>dyld（dynamic link editor）</code>，<code>Apple</code>的动态链接器，可以用来装载<code>Mach-O</code>文件（可执行文件、动态库等）</p>
</li>
<li><p>启动<code>APP</code>时，<code>dyld</code>所做的事情有</p>
<ul>
<li>装载<code>APP</code>的可执行文件，同时会递归加载所有依赖的动态库</li>
<li>当<code>dyld</code>把可执行文件、动态库都装载完毕后，会通知<code>Runtime</code>进行下一步的处理<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3></li>
</ul>
</li>
<li><p>启动APP时，runtime所做的事情有</p>
<ul>
<li>调用<code>map_images</code>进行可执行文件内容的解析和处理<ul>
<li>例如类的解析<code>realizeClassWithoutSwift</code>（重新解析<code>Class</code>，初始化一些<code>flags</code>,初始化<code>class_rw_t</code>(一开始<code>data</code>中存的是<code>class_ro_t</code>,取出存入<code>class_rw_t</code>)并设置<code>data</code>）</li>
</ul>
</li>
<li>在<code>load_images</code>中调用<code>call_load_methods</code>，调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法<ul>
<li>还有<code>attachCategories</code>，将分类中的方法、属性、协议，加到<code>class_rw_t</code>中</li>
</ul>
</li>
<li>进行各种<code>objc</code>结构的初始化（注册<code>Objc</code>类 、初始化类对象等等）</li>
<li>调用<code>C++</code>静态初始化器(结构体的初始化)和<code>__attribute__((constructor))</code>修饰的函数（类似<code>+load</code>，由系统调用）</li>
</ul>
</li>
<li><p>到此为止，可执行文件和动态库中所有的符号<code>(Class，Protocol，Selector，IMP，…)</code>都已经按格式成功加载到内存中，被runtime 所管理</p>
<h3 id="APP的启动-main"><a href="#APP的启动-main" class="headerlink" title="APP的启动 - main"></a>APP的启动 - main</h3></li>
<li><p>对<code>application:didFinishLaunchingWithOptions:</code>方法耗时优化</p>
</li>
<li><p>总的来说</p>
<ul>
<li>APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li>
<li>并由runtime负责加载成objc定义的结构</li>
<li>所有初始化工作结束后，dyld就会调用main函数</li>
<li>接下来就是UIApplicationMain函数，AppDelegate的<code>application:didFinishLaunchingWithOptions:</code>方法<h2 id="APP的启动优化"><a href="#APP的启动优化" class="headerlink" title="APP的启动优化"></a>APP的启动优化</h2></li>
</ul>
</li>
<li><p>按照不同的阶段</p>
<ul>
<li><p>dyld</p>
<ol>
<li>减少动态库、合并一些动态库（定期清理不必要的动态库）</li>
<li>减少<code>Objc</code>类、分类的数量、减少<code>Selector</code>数量（定期清理不必要的类、分类）</li>
<li>减少<code>C++虚函数</code>数量</li>
<li><code>Swift</code>尽量使用<code>struct</code></li>
</ol>
</li>
<li><p>runtime</p>
<ul>
<li>用<code>+initialize</code>方法和<code>dispatch_once</code>取代所有的<code>__attribute__((constructor))</code>、<code>C++静态构造器</code>、<code>ObjC的+load</code></li>
</ul>
</li>
<li><p>main</p>
<ul>
<li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunching</code>方法中按需加载</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>耗电优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><ul>
<li>尽可能降低CPU、GPU功耗</li>
<li>少用定时器</li>
<li>优化I/O操作<ul>
<li>尽量不要频繁写入小数据，最好批量一次性写入</li>
<li>读写大量重要数据时，考虑用<code>dispatch_io</code>，其提供了基于<code>GCD</code>的异步操作文件<code>I/O</code>的<code>API</code>。用<code>dispatch_io</code>系统会优化磁盘访问</li>
<li>数据量比较大的，建议使用数据库（比如<code>SQLite</code>、<code>CoreData</code>）</li>
</ul>
</li>
<li>网络优化<ul>
<li>减少、压缩网络数据</li>
<li>如果多次请求的结果是相同的，尽量使用缓存</li>
<li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li>
<li>网络不可用时，不要尝试执行网络请求</li>
<li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li>
<li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载</li>
</ul>
</li>
<li>定位优化<ul>
<li>如果只是需要快速确定用户位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法。定位完成后，会自动让定位硬件断电</li>
<li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li>
<li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li>
<li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为<code>YES</code>，如果用户不太可能移动的时候系统会自动暂停位置更新</li>
<li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion</code></li>
</ul>
</li>
<li>硬件检测优化<ul>
<li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>卡顿优化</title>
    <url>/2023/02/19/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a>CPU和GPU</h2><blockquote>
<p>在屏幕成像的过程中，CPU和GPU起着至关重要的作用</p>
</blockquote>
<ul>
<li><p><code>CPU</code>（<code>Central Processing Unit</code>，中央处理器）</p>
<ul>
<li>对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（<code>Core Graphics</code>）</li>
</ul>
</li>
<li><p><code>GPU</code>（<code>Graphics Processing Unit</code>，图形处理器）</p>
<ul>
<li>纹理的渲染<br><img src="1.png"></li>
</ul>
</li>
<li><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存</p>
<h3 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因"></a>卡顿产生的原因</h3><p><img src="2.png"></p>
</li>
<li><p>卡顿解决的主要思路</p>
<ul>
<li>尽可能减少CPU、GPU资源消耗</li>
<li>按照60FPS的刷帧率，每隔16ms就会有一次VSync信号<h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3></li>
</ul>
</li>
<li><p>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用<code>CALayer</code>取代<code>UIView</code></p>
</li>
<li><p>不要频繁地调用UIView的相关属性，比如<code>frame</code>、<code>bounds</code>、<code>transform</code>等属性，尽量减少不必要的修改</p>
</li>
<li><p>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</p>
</li>
<li><p><code>Autolayout</code>会比直接设置<code>frame</code>消耗更多的CPU资源</p>
</li>
<li><p>图片的<code>size</code>最好刚好跟<code>UIImageView</code>的<code>size</code>保持一致</p>
</li>
<li><p>控制一下线程的最大并发数量</p>
</li>
<li><p>尽量把耗时的操作放到子线程</p>
<ul>
<li>文本处理（尺寸计算、绘制）</li>
<li>图片处理（解码、绘制）</li>
<li>iOS10以上支持<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIGraphicsImageRendererFormat *uiformat = [[UIGraphicsImageRenderer alloc] init];</span><br><span class="line">uiformat.scale = image.scale;</span><br><span class="line">uiformat.opaque = !hasAlpha;</span><br><span class="line">UIGraphicsImageRenderer *uirenderer = [[UIGraphicsImageRenderer alloc] initWithSize:imageSize format:uiformat];</span><br><span class="line">UIGraphicsImageDrawingActions uiactions = ^(UIGraphicsImageRendererContext *rendererContext) &#123;</span><br><span class="line">    [image drawInRect:CGRectMake(0, 0, imageSize.width, imageSize.height)];</span><br><span class="line">&#125;;</span><br><span class="line">UIImage *decodedImage = [uirenderer imageWithActions:uiactions];</span><br></pre></td></tr></table></figure></li>
<li>iOS10以下支持<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//redraw image using device context</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, YES, 0);</span><br><span class="line">    [image drawInRect:imageView.bounds];</span><br><span class="line">    image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3></li>
</ul>
</li>
<li><p>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</p>
</li>
<li><p><code>GPU</code>能处理的最大纹理尺寸是<code>4096x4096</code>，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</p>
</li>
<li><p>尽量减少视图数量和层次</p>
</li>
<li><p>减少透明的视图（<code>alpha</code>&lt;1），不透明的就设置<code>opaque</code>为YES</p>
</li>
<li><p>尽量避免出现离屏渲染</p>
<h4 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h4></li>
<li><p>在<code>OpenGL</code>中，<code>GPU</code>有2种渲染方式</p>
<ol>
<li><code>On-Screen Rendering</code>：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作</li>
<li><code>Off-Screen Rendering</code>：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
</ol>
</li>
<li><p>离屏渲染消耗性能的原因</p>
<ul>
<li>需要创建新的缓冲区</li>
<li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（<code>On-Screen</code>）切换到离屏（<code>Off-Screen</code>）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕</li>
</ul>
</li>
<li><p>哪些操作会触发离屏渲染？</p>
<ul>
<li><p>光栅化，<code>layer.shouldRasterize = YES</code></p>
</li>
<li><p>遮罩，<code>layer.mask</code></p>
</li>
<li><p>圆角，同时设置<code>layer.masksToBounds = YES</code>、<code>layer.cornerRadius大于0</code></p>
<ul>
<li>考虑通过<code>CoreGraphics</code>绘制裁剪圆角，或者提供圆角图片</li>
</ul>
</li>
</ul>
</li>
<li><p>阴影，<code>layer.shadowXXX</code></p>
<ul>
<li>如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染<h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3></li>
</ul>
</li>
<li><p>平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作</p>
</li>
<li><p>可以添加<code>Observer</code>到主线程<code>RunLoop</code>中，通过监听<code>RunLoop</code>状态切换的耗时，以达到监控卡顿的目的</p>
<ul>
<li>绘制操作基本都在<code>source0</code>和<code>source1</code>中处理,主要监听</li>
<li><code>kCFRunLoopBeforeWaiting</code>,开始休眠之前，处理的事件卡顿</li>
<li><code>kCFRunLoopBeforeSources</code>,处理source0，<code>kCFRunLoopAfterWaiting</code>，被source1唤醒处理的耗时<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)startMonitoring &#123;</span><br><span class="line">    if (_isMonitoring) &#123; return; &#125;</span><br><span class="line">    _isMonitoring = YES;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;</span><br><span class="line">        0,</span><br><span class="line">        (__bridge void *)self,</span><br><span class="line">        NULL,</span><br><span class="line">        NULL</span><br><span class="line">    &#125;;</span><br><span class="line">    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;lxdRunLoopObserverCallback, &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(lxd_event_monitor_queue(), ^&#123;</span><br><span class="line">        while (self.isMonitoring) &#123;</span><br><span class="line">            if (self.currentActivity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">                __block BOOL timeOut = YES;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    timeOut = NO;</span><br><span class="line">                    dispatch_semaphore_signal(self.eventSemphore);</span><br><span class="line">                &#125;);</span><br><span class="line">                //等待1s,看添加到主队列的block是否执行完</span><br><span class="line">                [NSThread sleepForTimeInterval: 1];</span><br><span class="line">                if (timeOut) &#123;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain];//打印堆栈信息</span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_wait(self.eventSemphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(lxd_fluecy_monitor_queue(), ^&#123;</span><br><span class="line">        while (self.isMonitoring) &#123;</span><br><span class="line">        //监听信号量解锁，并进行等待</span><br><span class="line">            long waitTime = dispatch_semaphore_wait(self.semphore, dispatch_time(DISPATCH_TIME_NOW, 200 * NSEC_PER_MSEC));//解锁成功返回0</span><br><span class="line">            if (waitTime != 0) &#123;</span><br><span class="line">                if (!self.observer) &#123;</span><br><span class="line">                    self.timeOut = 0;</span><br><span class="line">                    [self stopMonitoring];</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //是否当前状态一直卡处理source0和休眠唤醒状态，超过5次，就打印</span><br><span class="line">                if (self.currentActivity == kCFRunLoopBeforeSources || self.currentActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    if (++self.timeOut &lt; 5) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain];</span><br><span class="line">                    [NSThread sleepForTimeInterval: 5];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            self.timeOut = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopMonitoring &#123;</span><br><span class="line">    if (!_isMonitoring) &#123; return; &#125;</span><br><span class="line">    _isMonitoring = NO;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(_observer);</span><br><span class="line">    _observer = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void lxdRunLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void * info) &#123;</span><br><span class="line">    [LXDAppFluecyMonitor sharedMonitor].currentActivity = activity;</span><br><span class="line">    //每次变化进行信号量的增加，在监听的队列进行减少</span><br><span class="line">    dispatch_semaphore_signal([LXDAppFluecyMonitor sharedMonitor].semphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>自动释放池</title>
    <url>/2023/02/18/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译后发现,<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    //创建的时候调用构造函数，即 objc_autoreleasePoolPush();</span><br><span class="line">    &#125;</span><br><span class="line">    //代码块结束的时候析构函数,即 objc_autoreleasePoolPop(atautoreleasepoolobj)</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">    //构造函数，在创建结构体的时候调用</span><br><span class="line">  __AtAutoreleasePool() &#123; </span><br><span class="line">  atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">  &#125;</span><br><span class="line">    //析构函数，在结构体销毁的时候调用</span><br><span class="line">  ~__AtAutoreleasePool() &#123;</span><br><span class="line">  objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">  &#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NEVER_INLINE</span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>自动释放池的主要底层数据结构是：<code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code></li>
<li>用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管理的<h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4></li>
<li>主要结构<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AutoreleasePoolPage : private AutoreleasePoolPageData &#123; .... &#125;</span><br><span class="line">struct AutoreleasePoolPageData &#123;</span><br><span class="line">static size_t const SIZE =</span><br><span class="line">#if PROTECT_AUTORELEASEPOOL</span><br><span class="line">		PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class="line">#else</span><br><span class="line">		PAGE_MIN_SIZE;  // size and alignment, power of 2</span><br><span class="line">		//(1 &lt;&lt; 12) //4096</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    magic_t const magic;</span><br><span class="line">	__unsafe_unretained id *next;</span><br><span class="line">	objc_thread_t const thread;</span><br><span class="line">	AutoreleasePoolPage * const parent;</span><br><span class="line">	AutoreleasePoolPage *child;</span><br><span class="line">	uint32_t const depth;</span><br><span class="line">	uint32_t hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量(主要成员大概占用56字节)，剩下的空间用来存放autorelease对象的地址<ul>
<li>剩下空间不够了，则会创建一个新的</li>
</ul>
</li>
<li>所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3></li>
<li>所有的<code>AutoreleasePoolPage</code>对象通过双向链表的形式连接在一起</li>
</ul>
<ol>
<li><code>objc_autoreleasePoolPush</code>调用push方法会将一个<code>POOL_BOUNDARY</code>(实际是个nil)入栈，并且返回其存放的内存地址<ul>
<li>后续调用<code>autorelease</code>加入释放值,也是调用<code>autoreleaseFast</code>方法添加到释放池，page不够，则创建新的，此时新的不用加<code>POOL_BOUNDARY</code>标记<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void *push() </span><br><span class="line">    &#123;</span><br><span class="line">        ReturnAutoreleaseInfo info = getReturnAutoreleaseInfo();</span><br><span class="line">        moveTLSAutoreleaseToPool(info);</span><br><span class="line"></span><br><span class="line">        id *dest;</span><br><span class="line">        if (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">            // Each autorelease pool starts on a new pool page.</span><br><span class="line">            dest = autoreleaseNewPage(POOL_BOUNDARY);//新建的页，第一个地址假上一个POOL_BOUNDARY</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">        &#125;</span><br><span class="line">        ASSERT(dest == (id *)EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">        return dest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>objc_autoreleasePoolPop(atautoreleasepoolobj)</code>,调用pop时，则会对所有添加的值调用<code>release</code>方法，直到遇到<code>POOL_BOUNDARY</code>为止,<code>holdPage</code>为当前页面<br><img src="1.png"><ol>
<li>存放的类型是<code>AutoreleasePoolEntry</code>,<code>ptr</code>是对象地址，<code>count</code>则是释放池内，该对象调用<code>autorelease</code>的次数<ul>
<li>当前页面没了，则会调整到父页，并设置父页面为当前页面，继续<code>release</code>，直到碰到<code>POOL_BOUNDARY</code></li>
<li>id *next指向了下一个能存放<code>autorelease</code>对象地址的区域<br><img src="2.png"></li>
</ul>
</li>
</ol>
</li>
<li><code>autorelease</code>方法实际内部调用的是<code>autoreleaseFast</code>，其传入的值是对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line">        if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">            return page-&gt;add(obj);</span><br><span class="line">        &#125; else if (page) &#123;</span><br><span class="line">            return autoreleaseFullPage(obj, page);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return autoreleaseNoPage(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>add</code>添加到释放值，如果已经存在则增加次数，否则增加一个<code>AutoreleasePoolEntry</code><ul>
<li>这里增加次数只会在4个偏移内，如果超过了这个偏移，则当新的</li>
<li>在找到新存在的后，会将其移动到存储的最后一个<br><img src="3.png"><h3 id="查看释放值信息"><a href="#查看释放值信息" class="headerlink" title="查看释放值信息"></a>查看释放值信息</h3></li>
</ul>
</li>
<li><code>_objc_autoreleasePoolPrint</code>,该方法是一个私有方法,MRC环境下</li>
<li>p1在距离上一个p1在4的范围内，则数量增加1，并且移动到最后<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line">@autoreleasepool &#123;  </span><br><span class="line">    CJPerson *p1 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    CJPerson *p2 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    CJPerson *p3 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    CJPerson *p4 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    [p1 retain];</span><br><span class="line">    [p1 autorelease];</span><br><span class="line">    CJPerson *p5 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    @autoreleasepool &#123; </span><br><span class="line">            CJPerson *p6 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">             _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">objc[5867]: ##############</span><br><span class="line">objc[5867]: AUTORELEASE POOLS for thread 0x7ff856aee640</span><br><span class="line">objc[5867]: 10 releases pending.</span><br><span class="line">objc[5867]: [0x10080b000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[5867]: [0x10080b038]  ################  POOL 0x10080b038</span><br><span class="line">//每个AutoreleasePoolEntry`指针占8位</span><br><span class="line">objc[5867]: [0x10080b040]    0x600000004060  CJPerson</span><br><span class="line">objc[5867]: [0x10080b048]    0x600000004070  CJPerson</span><br><span class="line">objc[5867]: [0x10080b050]    0x600000004080  CJPerson</span><br><span class="line">//移动到最后，并且会打印数量</span><br><span class="line">objc[5867]: [0x10080b058]    0x600000004050  CJPerson  autorelease count 2 </span><br><span class="line">objc[5867]: [0x10080b060]    0x600000004090  CJPerson</span><br><span class="line">objc[5867]: [0x10080b068]  ################  POOL 0x10080b068</span><br><span class="line">objc[5867]: [0x10080b070]    0x6000000040a0  CJPerson</span><br><span class="line">objc[5867]: ##############</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li>p1在距离上一个p1在4的范围之外，则会另新增一个，尽管他们存的内存地址是一样的<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line">@autoreleasepool &#123;  </span><br><span class="line">    CJPerson *p1 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    CJPerson *p2 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    CJPerson *p3 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    CJPerson *p4 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    CJPerson *p5 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">    [p1 retain];</span><br><span class="line">    [p1 autorelease];</span><br><span class="line">    @autoreleasepool &#123; </span><br><span class="line">            CJPerson *p6 = [[[CJPerson alloc] init] autorelease];</span><br><span class="line">             _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">objc[6090]: ##############</span><br><span class="line">objc[6090]: AUTORELEASE POOLS for thread 0x7ff856aee640</span><br><span class="line">objc[6090]: 11 releases pending.</span><br><span class="line">objc[6090]: [0x102009000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[6090]: [0x102009038]  ################  POOL 0x102009038</span><br><span class="line">objc[6090]: [0x102009040]    0x60000000c020  CJPerson</span><br><span class="line">objc[6090]: [0x102009048]    0x60000000c030  CJPerson</span><br><span class="line">objc[6090]: [0x102009050]    0x60000000c040  CJPerson</span><br><span class="line">objc[6090]: [0x102009058]    0x60000000c050  CJPerson</span><br><span class="line">objc[6090]: [0x102009060]    0x60000000c060  CJPerson</span><br><span class="line">objc[6090]: [0x102009068]    0x60000000c020  CJPerson</span><br><span class="line">objc[6090]: [0x102009070]  ################  POOL 0x102009070</span><br><span class="line">objc[6090]: [0x102009078]    0x60000000c070  CJPerson</span><br><span class="line">objc[6090]: [0x102009080]  ################  POOL 0x102009080</span><br><span class="line">objc[6090]: [0x102009088]    0x60000000c080  CJPerson</span><br><span class="line">objc[6090]: ##############</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="autorelease时机"><a href="#autorelease时机" class="headerlink" title="autorelease时机"></a>autorelease时机</h3></li>
<li>iOS在主线程的Runloop中注册了2个Observer<ul>
<li>第1个<code>Observer</code>监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li>
<li>第2个<code>Observer</code>监听了<code>kCFRunLoopBeforeWaiting</code>事件，会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code></li>
<li>  监听了<code>kCFRunLoopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>dealloc</title>
    <url>/2023/02/18/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dealloc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="引用计数存储"><a href="#引用计数存储" class="headerlink" title="引用计数存储"></a>引用计数存储</h3><blockquote>
<ul>
<li>在iOS中，使用引用计数来管理OC对象的内存</li>
<li>一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间</li>
<li>调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1</li>
<li>内存管理的经验总结<ul>
<li>当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它</li>
<li>想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息<ul>
<li>其中has_sidetable_rc为1引用计数器是否过大无法存储在isa中<ul>
<li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</li>
</ul>
</li>
<li>extra_rc里面里面存储的值是引用计数器减1,818源码之前是减1，之后则不是了</li>
</ul>
</li>
</ul>
<p><img src="1.png"></p>
<ul>
<li>SideTable<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts; //refcnts是一个存放着对象引用计数的散列表</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>retainCount<ul>
<li>818源码<br><img src="2.png"></li>
<li>781源码<br><img src="2.png"></li>
<li>根据key从SideTables中获取sidetable，再从refcnts获取迭代器，从中取出引用计数<br>  <img src="4.png"></li>
</ul>
</li>
<li>refcnts，在每次引用计数增减，是一个SIDE_TABLE_RC_ONE<ul>
<li>relese，引用计数释放完了，则会调用delloc方法<br><img src="5.png"></li>
<li>retain<br><img src="6.png"></li>
<li>每次引用计数改变的值<code>0B100</code>，后两位分别判断是否有弱引用，是否正在释放<br><img src="7.png"><h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3></li>
</ul>
</li>
<li>当一个对象要释放时，会自动调用dealloc，接下的调用轨迹是<ol>
<li>dealloc</li>
<li>_objc_rootDealloc</li>
<li>rootDealloc</li>
<li>object_dispose</li>
<li>objc_destructInstance、free</li>
</ol>
</li>
</ul>
<ol>
<li>会判断是否是弱引用、关联对象、c++析构函数、引用计数表，都没有的话直接free释放<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  // fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa().nonpointer                     &amp;&amp;</span><br><span class="line">                 !isa().weakly_referenced             &amp;&amp;</span><br><span class="line">                 !isa().has_assoc                     &amp;&amp;</span><br><span class="line">#if ISA_HAS_CXX_DTOR_BIT</span><br><span class="line">                 !isa().has_cxx_dtor                  &amp;&amp;</span><br><span class="line">#else</span><br><span class="line">                 !isa().getClass(false)-&gt;hasCxxDtor() &amp;&amp;</span><br><span class="line">#endif</span><br><span class="line">                 !isa().has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>按顺序先处理后，再去释放<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *objc_destructInstance(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);//调用c++析构函数</span><br><span class="line">        if (assoc) _object_remove_associations(obj, /*deallocating*/true);//删删除关联对象</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">//清除弱引用和sidetable</span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(!isa().nonpointer)) &#123;</span><br><span class="line">        // Slow path for raw pointer isa.</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (slowpath(isa().weakly_referenced  ||  isa().has_sidetable_rc)) &#123;</span><br><span class="line">        // Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa().nonpointer  &amp;&amp;  (isa().weakly_referenced || isa().has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa().weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this); //清楚弱引用</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa().has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(this); //清楚sidetable</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>weak指针释放<ol>
<li>获取到<code>weak_entry_t</code>，从中获取存放的弱引用指针，将其置为nil<br><img src="8.png"></li>
<li>从<code>weak_table_t</code>，查找的方式，是通过hash表，线性查找的方式<br><img src="9.png"></li>
<li><code>weak_entry_t</code>的结构，会根据数组长度的不同，结构有所不同<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct weak_table_t &#123;</span><br><span class="line">weak_entry_t *weak_entries;</span><br><span class="line">size_t    num_entries;</span><br><span class="line">uintptr_t mask;</span><br><span class="line">uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line"> union &#123;</span><br><span class="line">      struct &#123;</span><br><span class="line">          weak_referrer_t *referrers;</span><br><span class="line">          uintptr_t        out_of_line_ness : 2;</span><br><span class="line">          uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">          uintptr_t        mask;</span><br><span class="line">         uintptr_t        max_hash_displacement;</span><br><span class="line">      &#125;;</span><br><span class="line">     struct &#123;</span><br><span class="line">        // out_of_line_ness field is low bits of inline_referrers[1]</span><br><span class="line">        weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>js的基础学习（二）</title>
    <url>/2023/02/18/js%E7%9A%84%E5%AD%A6%E4%B9%A0/js%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><blockquote>
<p>Math中的方法，都会隐式转换成Number</p>
</blockquote>
<h4 id="max"><a href="#max" class="headerlink" title="max"></a>max</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ar numArr = [1,2,3,4,1]</span><br><span class="line">console.log(Math.max(...numArr)); // 4</span><br><span class="line">console.log(Math.max(0,1,&#x27;张三&#x27;)); // NaN</span><br><span class="line">console.log(Math.max(0,1,&#x27;张三&#x27;)); // -Infinity</span><br></pre></td></tr></table></figure>
<h4 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Math.abs(-0.13));   // 0.13</span><br><span class="line">console.log(Math.abs(&#x27;-0.13&#x27;)); // -0.13隐式转换</span><br><span class="line">console.log(Math.abs(&#x27;数字&#x27;)); // NaN</span><br></pre></td></tr></table></figure>
<h4 id="round"><a href="#round" class="headerlink" title="round"></a>round</h4><blockquote>
<p>四舍五入，其他数字都是四舍五入，但是.5特殊，它是往大了取</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Math.round(1.5)); // 2</span><br><span class="line">console.log(Math.round(&#x27;-1.5&#x27;)); // -1 .5特殊，它是往大了取</span><br><span class="line">console.log(Math.round(-1.4)); // -1</span><br><span class="line">console.log(Math.round(-1.6)); // -2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>js的基础学习（一）</title>
    <url>/2023/02/15/js%E7%9A%84%E5%AD%A6%E4%B9%A0/js%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>只记录js中特殊的写法</p>
</blockquote>
<span id="more"></span>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><table>
<thead>
<tr>
<th>情况</th>
<th align="left">说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>var age ; console.log (age);</td>
<td align="left">只声明 不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td align="left">不声明 不赋值 直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age = 10; console.log (age);</td>
<td align="left">不声明 只赋值</td>
<td>10</td>
</tr>
</tbody></table>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><blockquote>
<p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的 内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会 被自动确定。</p>
</blockquote>
<h3 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h3><ul>
<li>在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。 JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 6; // x 为数字 </span><br><span class="line">var x = &quot;Bill&quot;; // x 为字符串</span><br></pre></td></tr></table></figure>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var num = 10; //全局变量</span><br><span class="line">function fun() &#123;</span><br><span class="line">    var num1 = 20; //局部变量</span><br><span class="line">    num2 = 20;// 也是全局变量，在函数内部，没有声明直接赋值的变量也是全局变量</span><br><span class="line">&#125;</span><br><span class="line">fun(); //必须执行该方法，才可以输出num2</span><br><span class="line">console.log(num2); // 2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><ul>
<li>简单数据类型 (<code>Number</code>,<code>String</code>,<code>Boolean</code>,<code>Undefined</code>,<code>Null</code>)</li>
<li>复杂数据类型 (<code>object</code>)<h4 id="数字型-Number"><a href="#数字型-Number" class="headerlink" title="数字型 Number"></a>数字型 Number</h4></li>
</ul>
</li>
<li>数字型三个特殊值<ul>
<li><code>Infinity</code> ，代表无穷大，大于任何数值</li>
<li><code>-Infinity</code> ，代表无穷小，小于任何数值</li>
<li> <code>NaN</code> ，Not a number，代表一个非数值</li>
</ul>
</li>
<li> 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&#x27;11&#x27; - &#x27;1&#x27;); // 10</span><br><span class="line">alert(&#x27;11&#x27; - &#x27;sss&#x27;); // NaN</span><br><span class="line">alert(&#x27;11&#x27; - undefined); // NaN</span><br></pre></td></tr></table></figure>
<h4 id="字符串型-String"><a href="#字符串型-String" class="headerlink" title="字符串型 String"></a>字符串型 String</h4></li>
<li>字符串拼接<ul>
<li>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 </li>
<li>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&#x27;hello&#x27; + &#x27; &#x27; + &#x27;world&#x27;); // hello world </span><br><span class="line">alert(&#x27;100&#x27; + &#x27;100&#x27;); // 100100</span><br><span class="line">alert(&#x27;11&#x27; + 12); // 1112</span><br><span class="line">alert(&#x27;11&#x27; + undefined); // 11undefined</span><br><span class="line">alert(&#x27;11&#x27; + false); // 11false</span><br></pre></td></tr></table></figure>
<h4 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型 Boolean"></a>布尔型 Boolean</h4><blockquote>
<ul>
<li>布尔类型有两个值:true 和 false ，其中 true 表示真(对)，而 false 表示假(错)。 </li>
<li>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(true + 1); // 2 </span><br><span class="line">console.log(false + 1); // 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>转换为布尔型<ul>
<li>代表空、否定的值会被转换为 false ，如 <code>&#39;&#39;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code></li>
<li>其余值都会被转换为 true<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Boolean(&#x27;&#x27;)); // false </span><br><span class="line">console.log(Boolean(0)); // false </span><br><span class="line">console.log(Boolean(NaN)); // false </span><br><span class="line">console.log(Boolean(null)); // false </span><br><span class="line">console.log(Boolean(undefined)); // false </span><br><span class="line">console.log(Boolean(&#x27;小白&#x27;)); // true </span><br><span class="line">console.log(Boolean(12)); // true</span><br></pre></td></tr></table></figure>
<h4 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h4></li>
</ul>
</li>
<li>一个声明后没有被赋值的变量会有一个默认值 <code>undefined</code> ( 如果进行相连或者相加时，注意结果)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var variable;</span><br><span class="line">console.log(variable); // undefined </span><br><span class="line">console.log(&#x27;你好&#x27; + variable); // 你好undefined </span><br><span class="line">console.log(11 + variable); // NaN </span><br><span class="line">console.log(true + variable); // NaN</span><br></pre></td></tr></table></figure></li>
<li>一个声明变量给 <code>null</code> 值，里面存的值为空<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var vari = null;</span><br><span class="line">console.log(&#x27;你好&#x27; + vari); // 你好null </span><br><span class="line">console.log(11 + vari); // 11 </span><br><span class="line">console.log(true + vari); // 1</span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="短路运算-逻辑中断-，"><a href="#短路运算-逻辑中断-，" class="headerlink" title="短路运算(逻辑中断)，"></a>短路运算(逻辑中断)，</h3><blockquote>
<p>当有多个表达式值时，左边的表达式值可以确定结果时，就不在继续运算右边的表达式的值;</p>
</blockquote>
</li>
</ul>
<ol>
<li>逻辑与<ul>
<li>表达式1 &amp;&amp; 表达式2</li>
<li>如果第一个表达式的值为真，则返回表达式2</li>
<li>如果第一个表达式的值为假，则返回表达式1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(123 &amp;&amp; 456); // 456</span><br><span class="line">console.log(0 &amp;&amp; 456);  // 0</span><br><span class="line">console.log(&quot;&quot; &amp;&amp; 456);  // &quot;&quot;</span><br><span class="line">console.log(123 &amp;&amp; 456 &amp;&amp; 5678);  // 5678</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>逻辑或<ul>
<li>表达式1 || 表达式2</li>
<li>如果第一个表达式的值为真，则返回表达式1</li>
<li>如果第一个表达式的值为假，则返回表达式2<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数和形参匹配"><a href="#函数和形参匹配" class="headerlink" title="函数和形参匹配"></a>函数和形参匹配</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getSum(num1,num2) &#123;</span><br><span class="line">    consloe.log(num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line">getSum(1,2); // 3</span><br><span class="line">//如果实参的个数多于形参的个数，会取到形参的个数</span><br><span class="line">getSum(1,2,3);  // 3</span><br><span class="line">//形参可以看做是不用声明的变量，num2是为Undefined</span><br><span class="line">getSum(1);  // NaN</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getSum(num1,num2) &#123;</span><br><span class="line">    consloe.log(num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line">//没有返回值，返回Undefined</span><br><span class="line">consloe.log(getSum(1,2)); //Undefined</span><br><span class="line">function getSum(num1,num2) &#123;</span><br><span class="line">    return num1，num2;</span><br><span class="line">&#125;</span><br><span class="line">//多个返回值，只会返回最后一个</span><br><span class="line">consloe.log(getSum(1,2)); //2</span><br></pre></td></tr></table></figure>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><blockquote>
<p>js中arguments是函数的内置对象，存储了传递的所有实参</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">         console.log(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(1,2,3,4,5); // 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><blockquote>
<p>js引擎运行js分为两步: 预解析 代码执行</p>
<ul>
<li>预解析 js引擎会把js里面所有的var还有function提升到当前作用域的最前面</li>
<li>代码执行 按照代码书写的顺序从上往下执行</li>
</ul>
</blockquote>
<h3 id="预解析-1"><a href="#预解析-1" class="headerlink" title="预解析"></a>预解析</h3></li>
</ul>
</li>
</ol>
<ul>
<li>变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(num); //输出Undefined，只会提升作用域，不提升赋值</span><br><span class="line">var num = 10;</span><br><span class="line">fun(); //会报错，因不提升赋值</span><br><span class="line">var fun = function() &#123;</span><br><span class="line">var a = b = c = 9; //相当于 var a=9; b = 9;c = 9;b和c是全局变量(在函数内部，没有声明</span><br><span class="line">直接赋值的变量也是全局变量),但是必须执行</span><br><span class="line">//集体赋值是var a=9,b = 9,c = 9;这种都是局部变量</span><br><span class="line">    console.log(num);//输出Undefined,以为当前函数作用域下也有个局部变量num,因此会提升到最前面</span><br><span class="line">    var num = 20;</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br><span class="line">console.log(c); // 9</span><br><span class="line">console.log(b); // 9</span><br><span class="line">console.log(a); // 报错，没有a的全局变量</span><br></pre></td></tr></table></figure></li>
<li>函数提升 就是把所有的函数声明提升到当前作用于的最前面 不调用函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun(); //不会报错，函数提升了</span><br><span class="line">function fun() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li>
<li>字面量创建对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var objc = &#123;</span><br><span class="line">    usanme: &#x27;张三&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line">        console.log(&#x27;hi&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//调用属性</span><br><span class="line">console.log(obj.usname); //张三</span><br><span class="line">console.log(obj[&#x27;usname&#x27;]); //张三</span><br><span class="line">obj.sayHi();</span><br></pre></td></tr></table></figure></li>
<li><code>new Objc</code>创建对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new Object(); //创建一个空的对象</span><br><span class="line">obj.uname = &#x27;张三&#x27;;</span><br><span class="line">obj.age = 18;</span><br><span class="line">obj.sayHi = function() &#123;</span><br><span class="line">    console.log(&#x27;hi&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>构造函数创建一个对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Star(uname,age,sex) &#123;</span><br><span class="line">     this.name = uname;</span><br><span class="line">     this.age = age;</span><br><span class="line">     this.sex = sex;</span><br><span class="line">     this.sayHi = function() &#123;</span><br><span class="line">        console.log(&#x27;sayHi&#x27;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">var star = new Star(&#x27;张三&#x27;,18,&#x27;男&#x27;); //必须new，不加则是方法，返回undefined</span><br></pre></td></tr></table></figure>
<h3 id="new关键词的执行过程"><a href="#new关键词的执行过程" class="headerlink" title="new关键词的执行过程"></a>new关键词的执行过程</h3></li>
</ul>
<ol>
<li><code>new 构造函数</code>可以在内存中创建一个空的对象</li>
<li><code>this</code>就会指向刚才创建的空对象</li>
<li>执行构造函数里面的代码，<code>this.</code>给这个空对象添加属性和方法</li>
<li>返回这个对象（所以构造函数不需要<code>return</code>）<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><blockquote>
<p>用<code>for in</code>对遍历对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (const key in dss) &#123;</span><br><span class="line">   console.log(key); //属性名</span><br><span class="line">   console.log(dss[key]); // 属性内的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Pointer</title>
    <url>/2023/02/15/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/TaggedPointer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h1><blockquote>
<ul>
<li>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储</li>
<li>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值</li>
<li>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中</li>
<li>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</li>
<li><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用开销(因为没有<code>isa</code>存在，不是<code>OC</code>对象，不会走方法调用流程)</li>
</ul>
</blockquote>
<h2 id="如何判断一个指针是否为Tagged-Pointer？"><a href="#如何判断一个指针是否为Tagged-Pointer？" class="headerlink" title="如何判断一个指针是否为Tagged Pointer？"></a>如何判断一个指针是否为Tagged Pointer？</h2><p><img src="1.png"><br><img src="2.png"></p>
<ul>
<li>iOS平台，最高有效位是1（第64bit）</li>
<li>Mac平台，最低有效位是1</li>
</ul>
<h2 id="Tagged-Pointer存储地方思考"><a href="#Tagged-Pointer存储地方思考" class="headerlink" title="Tagged Pointer存储地方思考"></a>Tagged Pointer存储地方思考</h2><ul>
<li>解码<code>extern</code>调用私有函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern uintptr_t objc_debug_taggedpointer_obfuscator;</span><br><span class="line">uintptr_t _objc_decodeTaggedPointer_(const void * _Nullable  ptr) &#123;</span><br><span class="line">    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSNumber *number1 = @4;</span><br><span class="line">NSNumber *number2 = @5;</span><br><span class="line">NSNumber *number3 = @100;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%p  %p  %p&quot;,number1,number2,number3);</span><br><span class="line">///0xc96fede699842146  0xc96fede699842786  0xc96fede699861216</span><br><span class="line">NSLog(@&quot;0x%lx   0x%lx   0x%lx&quot;,_objc_decodeTaggedPointer_((__bridge const void * _Nullable)(number1)),_objc_decodeTaggedPointer_((__bridge const void * _Nullable)(number2)),_objc_decodeTaggedPointer_((__bridge const void * _Nullable)(number3)));</span><br><span class="line">///0xb000000000000042   0xb000000000000052   0xb000000000000642</span><br><span class="line"></span><br><span class="line">NSString *str1 = [NSString stringWithFormat:@&quot;sd&quot;];</span><br><span class="line">NSString *str2 = [NSString stringWithFormat:@&quot;sdadad&quot;];</span><br><span class="line">NSLog(@&quot;%p  %p&quot;,str1,str2);</span><br><span class="line">//0xbaf35d65b6463f52  0xbaf51b73f0563f56</span><br><span class="line">NSLog(@&quot;0x%lx 0x%lx&quot;,_objc_decodeTaggedPointer_((__bridge const void * _Nullable)(str1)),_objc_decodeTaggedPointer_((__bridge const void * _Nullable)(str2)));</span><br><span class="line">//0xa000000000064732   0xa006461646164736</span><br></pre></td></tr></table></figure></li>
<li>分析<ul>
<li>前面的0xb明显是tag,为<code>0xb -&gt; 1011</code>, <code>0xa -&gt; 1010</code>,<ul>
<li>在iOS中最高位为1表明是<code>Tagged Pointer</code></li>
<li>后三位代表数据类型，<code>011</code>代表int（如果是带小数点的无法不会转出tag），<code>010</code>代表字符串</li>
</ul>
</li>
<li><code>42 -&gt; 100 0010</code>,<code>52 -&gt;101 0010</code><ul>
<li>前四位代表存储的内容</li>
<li>后4位代表数据长度(一般是字符串长度)，后四位<code>sd -&gt; 0010</code>长度2、<code>sdadad -&gt; 0110</code>长度6</li>
</ul>
</li>
</ul>
</li>
<li>在iOS中，<code>Tagged Pointer</code>中间56位用来存东西，前4位是tag，后4位是数据长度<h2 id="Tagged-Pointer的题目思考"><a href="#Tagged-Pointer的题目思考" class="headerlink" title="Tagged Pointer的题目思考"></a>Tagged Pointer的题目思考</h2><h3 id="关于野指针的问题"><a href="#关于野指针的问题" class="headerlink" title="关于野指针的问题"></a>关于野指针的问题</h3></li>
<li>崩溃地方在<code>objc_release</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            // 加锁</span><br><span class="line">            self.name = [NSString stringWithFormat:@&quot;abcdefghijk&quot;];</span><br><span class="line">            // 解锁</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            self.name = [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>原因：设置<code>name</code>方法本质为如下方法，（ARC下也会有<code>release</code>引用释放）,因此在多线程下调用很可能会出现野指针问题<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    if (_name != name) &#123;</span><br><span class="line">        [name retain];// 保留新对象</span><br><span class="line">        [_name release];//原先的引用计数减1</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>但实际上，将赋值的对象设置仅为<code>[NSString stringWithFormat:@&quot;abc&quot;]</code>，或者为<code>@&quot;abcdefghijk&quot;</code>字面量时，不会出现野指针的问题。<ul>
<li>原因在于，<code>[NSString stringWithFormat:@&quot;abc&quot;]</code>类型为<code>NSTaggedPointerString</code>,不是OC对象不会有实际的<code>release</code>方法</li>
<li><code>@&quot;abcdefghijk&quot;</code>字面量为<code>__NSCFConstantString</code>，是字符串常量，<code>release</code>不会使其释放</li>
<li><code>[NSString stringWithFormat:@&quot;abcdefghijk&quot;]</code>,在超过<code>Tagged Pointer</code>,数据限制后，其类型为<code>__NSCFString</code>,字符串的OC对象，存在引用计数，因此会出现野指针问题</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>swift类的动态性</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/swift%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="swift类的动态性"><a href="#swift类的动态性" class="headerlink" title="swift类的动态性"></a>swift类的动态性</h1><h2 id="动态方法查询"><a href="#动态方法查询" class="headerlink" title="动态方法查询"></a>动态方法查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">    var methodCount: UInt32 = 0</span><br><span class="line">    let methodList = class_copyMethodList(JPTeacher.self, &amp;methodCount)</span><br><span class="line">    for i in 0..&lt;numericCast(methodCount) &#123;</span><br><span class="line">        if let method = methodList?[i] &#123;</span><br><span class="line">            let methodName = method_getName(method)</span><br><span class="line">            print(&quot;方法列表:\(methodName)&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print(&quot;not found method&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var count:UInt32 = 0</span><br><span class="line">    let proList = class_copyPropertyList(JPTeacher.self, &amp;count)</span><br><span class="line">    for  i in 0..&lt;numericCast(count) &#123;</span><br><span class="line">        if let proerty = proList?[i] &#123;</span><br><span class="line">            let proertyName = String(cString: property_getName(proerty))                      </span><br><span class="line">            print(&quot;成员属性：\(proertyName)&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print(&quot;not found property&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态性"><a href="#静态性" class="headerlink" title="静态性"></a>静态性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class JPTeacher &#123;</span><br><span class="line">    var age:Int = 18</span><br><span class="line">    </span><br><span class="line">    func teach() &#123;</span><br><span class="line">        print(&quot;-------teach&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func test1() &#123;</span><br><span class="line">        print(&quot;------test1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">//什么都不会输出</span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>test()</code>方法，不会输出任何信息。因为，<code>Swift</code>是静态语言，所以没有动态特性。⽅法和属性不加任何修饰符的情况下，不具备所谓的<code>Runtime</code>特性，它的方法调度方式使用<code>V_table</code>函数表调度<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class JPTeacher:NSObject &#123;</span><br><span class="line">    @objc var age:Int = 18</span><br><span class="line">    </span><br><span class="line">    @objc func teach() &#123;</span><br><span class="line">        print(&quot;-------teach&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc func test1() &#123;</span><br><span class="line">        print(&quot;------test1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">/*</span><br><span class="line">方法列表:age</span><br><span class="line">方法列表:setAge:</span><br><span class="line">方法列表:teach</span><br><span class="line">方法列表:test1</span><br><span class="line">方法列表:init</span><br><span class="line">成员属性：age</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li>继承⾃<code>NSObject</code>的类，如果想要动态获取当前⽅法和属性，必须在其声明前添加<code>@objc</code>关键字。<h3 id="Runtime-API交换方法"><a href="#Runtime-API交换方法" class="headerlink" title="Runtime API交换方法"></a>Runtime API交换方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func exchangeMethod() &#123;</span><br><span class="line">    if  let  method1 = class_getInstanceMethod(LGTeacher.self, NSSelectorFromString(&quot;test1&quot;)),</span><br><span class="line">        let  method2 = class_getInstanceMethod(LGTeacher.self, NSSelectorFromString(&quot;teach&quot;)) &#123;</span><br><span class="line">        method_exchangeImplementations(method1, method2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>swift调用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LGTeacher().teach()</span><br><span class="line">exchangeMethod()</span><br><span class="line">LGTeacher().teach()</span><br><span class="line">/*</span><br><span class="line">-------teach</span><br><span class="line">-------teach</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li>oc中调用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[LGTeacher new] teach];</span><br><span class="line">[self  exchangeMethod];</span><br><span class="line">[[LGTeacher new] teach];</span><br><span class="line">/*</span><br><span class="line">-------teach</span><br><span class="line">------test1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li>显然<code>OC</code>中桥接的方法，进行了交互，但是<code>swift</code>中调用的并未进行交换。这是因为swift中的方法，仍然是函数调用，加上<code>@objc</code>后,由打印可知，增加了<code>objc</code>的方法。因此两个调用的方法实际上是不一样的</li>
<li>如果想在<code>swift</code>中可以交换方法，则需要添加<code>dynamic</code>关键字，让它们具备动态特性，例子<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LGTeacher:NSObject &#123;</span><br><span class="line">    @objc var age:Int = 18</span><br><span class="line">    </span><br><span class="line">    @objc dynamic func teach() &#123;</span><br><span class="line">        print(&quot;-------teach&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc dynamic func test1() &#123;</span><br><span class="line">        print(&quot;------test1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LGTeacher().teach()</span><br><span class="line">exchangeMethod()</span><br><span class="line">LGTeacher().teach()</span><br><span class="line">/*</span><br><span class="line">-------teach</span><br><span class="line">------test1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>,如果在方法中不加<code>@objc</code>，只加<code>dynamic</code>,那么在打印的方法中将没有<code>teach</code>和<code>test1</code>方法，也无法交换。</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>定时器</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>定时器通过addTarget添加的时候，会强引用target，如果此时target持有了定时器，则会出现循环引用</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//__weak typeof(self) weakSelf = self;将target的self,换成weakSelf，一样会出现 __weak typeof(self) weakSelf = self；</span><br><span class="line">//和block不一样，block内部会根据weak还是strong，去引用对象</span><br><span class="line"></span><br><span class="line">//而NSTimer中，经过传人的是weakSelf，但其内部，仍然会强引用self</span><br><span class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">//出现循环引用，无法释放</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="NSObjec的代理转发"><a href="#NSObjec的代理转发" class="headerlink" title="NSObjec的代理转发"></a>NSObjec的代理转发</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[JPProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface JPProxy : NSObject</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@property </span><br><span class="line"></span><br><span class="line">@implementation JPProxy</span><br><span class="line"></span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    JPProxy *proxy = [[JPProxy alloc] init];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    return self.target;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>通过一个代理类proxy，弱引用持有self，而定时器的target为该代理类，则可打破该循环引用，并且，定时器在代理类中查询<code>timerTest</code>方法时,会通过消息转发机制，由self来处理</li>
<li><code>CADisplayLink</code>一样的解决方式<h4 id="NSProxy的代理转发"><a href="#NSProxy的代理转发" class="headerlink" title="NSProxy的代理转发"></a>NSProxy的代理转发</h4><blockquote>
<p>NSProxy和NSObject一样，同样是一种基类,NSProxy没有<code>forwardingTargetForSelector:</code>,因此要走<code>methodSignatureForSelector</code>,<code>forwardInvocation:</code>最后一步方法转发流程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface JPProxy : NSProxy</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@property (weak, nonatomic) id target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation JPProxy</span><br><span class="line"></span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    // NSProxy对象不需要调用init，因为它本来就没有init方法</span><br><span class="line">    JPProxy *proxy = [JPProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>继承自NSObject的代理，需要先查询方法-&gt;方法解析-&gt;最后才是方法转发。而继承自NSProxy，会直接走向方法转发，对于转发来说，效率要比NSObject要快。<h3 id="CGD定时器"><a href="#CGD定时器" class="headerlink" title="CGD定时器"></a>CGD定时器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_TIME_NOW, 0, 0, dispatch_get_main_queue());</span><br><span class="line">// 设置时间（start是几秒后开始执行，interval是时间间隔）</span><br><span class="line">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(start * NSEC_PER_SEC)), (uint64_t)(interval * NSEC_PER_SEC), 0);</span><br><span class="line">// 设置回调</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br><span class="line">// 启动定时器</span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
  </entry>
  <entry>
    <title>读写锁</title>
    <url>/2023/02/12/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li>读写锁的应用场景<ul>
<li>同一时间，只能有1个线程进行写的操作</li>
<li>同一时间，允许有多个线程进行读的操作</li>
<li>同一时间，不允许既有写的操作，又有读的操作</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="读写锁的方案"><a href="#读写锁的方案" class="headerlink" title="读写锁的方案"></a>读写锁的方案</h3><ul>
<li>pthread_rwlock：读写锁</li>
<li>dispatch_barrier_async：异步栅栏调用<h3 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote>
<p>读用pthread_rwlock_rdlock，写用pthread_rwlock_wrlock，运行读同时并发进行，写必须按顺序进行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pthread_rwlock_t _lock;</span><br><span class="line">pthread_rwlock_init(&amp;_lock, NULL);</span><br><span class="line"></span><br><span class="line">- (void)read &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">    //读加锁    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)write</span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">     //写加锁    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.queue = dispatch_queue_create(&quot;rw_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(self.queue, ^&#123;</span><br><span class="line">    //读操作</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//使用栅栏添加到队列的任务，会等之前的读任务执行完，再执行该任务，并且之后添加到该队列的读任务，必须等到该任务执行完，才能执行。</span><br><span class="line">dispatch_barrier_async(self.queue, ^&#123;</span><br><span class="line">    //写操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4></li>
<li><strong>注意</strong>，<code>dispatch_barrier_async</code>传入的并发队列必须是自己通过<code>dispatch_queue_cretate</code> 创建的如果传入的是一个<code>串行</code>或是一个<code>全局的并发队列</code>，那这个函数便等同于<code>dispatch_async</code>函数的效果.</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>多线程和锁</title>
    <url>/2023/02/02/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h2><ul>
<li>资源共享<ul>
<li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li>
<li>比如多个线程访问同一个对象、同一个变量、同一个文件</li>
</ul>
</li>
<li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题<h2 id="OS中的线程同步方案"><a href="#OS中的线程同步方案" class="headerlink" title="OS中的线程同步方案"></a>OS中的线程同步方案</h2></li>
</ul>
<ol>
<li>OSSpinLock</li>
<li>os_unfair_lock</li>
<li>pthread_mutex</li>
<li>dispatch_semaphore</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li>@synchronized<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><blockquote>
<p>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p>
<ul>
<li>目前已经不再安全，可能会出现优先级反转问题<ul>
<li>如果等待锁的线程优先级较高，它会一直占用着CPU资源；获得锁的优先级低的线程，没有CPU资源，分配不到时间片，无法执行完，就无法释放锁<ul>
<li>多线程原理是，操作系统通过<code>时间片轮转算法</code>，每次给一个线程一个时间片，让其可以执行,(如果所给的时间片足够短，则看起来是同时执行的</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h4><blockquote>
<p>iOS10以上由于优先级反转的问题，导致被废弃，系统建议使用os_unfair_lock</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="line"></span><br><span class="line">OSSpinLock _lock = OS_SPINLOCK_INIT;//多个线程持有同一个锁</span><br><span class="line"></span><br><span class="line">OSSpinLockLock(&amp;_lock);</span><br><span class="line">//需要同步的代码</span><br><span class="line">OSSpinLockUnlock(&amp;_lock)</span><br></pre></td></tr></table></figure>
<h4 id="自旋锁逻辑查看"><a href="#自旋锁逻辑查看" class="headerlink" title="自旋锁逻辑查看"></a>自旋锁逻辑查看</h4></li>
</ol>
<ul>
<li>汇编源码查看线程等待锁时，所做的事，通过lldb的<code>s</code>是代码级别的,<code>si</code>(stepi)是汇编级别的，一步步查看汇编执行，<code>ni</code>(next)指令遇到函数级别的调用会跳过<ul>
<li>如果可以获取到锁，则不会走<code>_OSSPinLockLockSlow</code>,直接执行同步代码<br><img src="2.png"></li>
<li>如果没有无法获取到锁，则会走<code>_OSSPinLockLockSlow</code>方法中，类似while循环调用，线程不会休眠<br><img src="1.png"></li>
</ul>
</li>
</ul>
<h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><blockquote>
<ul>
<li>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态<ul>
<li>pthread_mutex可以在多个平台上使用(window、linux、macos)都可以使用</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="使用教程-1"><a href="#使用教程-1" class="headerlink" title="使用教程"></a>使用教程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;pthread/pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t _pthreadMutex;</span><br><span class="line">//初始化属性</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">//初始化锁</span><br><span class="line">pthread_mutex_init(&amp;_pthreadMutex, &amp;attr);</span><br><span class="line">//pthread_mutex_init(&amp;_pthreadMutex, NULL);传null为DEFALT，即NORMAL</span><br><span class="line">//销毁属性</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">//不用锁之后需要销毁</span><br><span class="line">pthread_mutex_destroy(&amp;_pthreadMutex);</span><br></pre></td></tr></table></figure>
<h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PTHREAD_MUTEX_NORMAL		0</span><br><span class="line">#define PTHREAD_MUTEX_ERRORCHECK	1</span><br><span class="line">#define PTHREAD_MUTEX_RECURSIVE	  2</span><br></pre></td></tr></table></figure>
<h4 id="递归锁，"><a href="#递归锁，" class="headerlink" title="递归锁，"></a>递归锁，</h4><blockquote>
<p>允许<code>**同一个线程**</code>对<code>**一把锁**</code>重复多次加锁，而不会造成死锁,<br>    - 注意，多个线程访问的话，一个线程持有之后，另一个线程访问，同样会被阻塞，休眠，直到递归锁被释放。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">//初始化递归锁</span><br><span class="line">pthread_mutex_init(&amp;_pthreadMutex, &amp;attr);</span><br></pre></td></tr></table></figure>
<h4 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化条件</span><br><span class="line">pthread_cond_t _cond;</span><br><span class="line">pthread_cond_init(&amp;_cond, NULL);</span><br><span class="line">//销毁</span><br><span class="line">pthread_cond_destroy(&amp;_cond);</span><br><span class="line"></span><br><span class="line">//执行</span><br><span class="line">[[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start];</span><br><span class="line">[[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];</span><br><span class="line">//删除方法</span><br><span class="line">- (void)__remove &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    if (self.data.count == 0) &#123;</span><br><span class="line">      // 等待，线程进行休眠，并且会释放该锁</span><br><span class="line">     pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">     //当被signal唤醒之后，继续加锁，然后由后面unlock进行解锁</span><br><span class="line">    &#125;</span><br><span class="line">    [self.data removeLastObject];</span><br><span class="line">     pthread_mutex_unlock(&amp;_mutex); </span><br><span class="line">&#125;</span><br><span class="line">- (void)__add &#123;</span><br><span class="line">    //添加方法</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    [self.data addObject:@&quot;Test&quot;]; </span><br><span class="line">    // 信号，会唤醒一个等待的线程，让删除方法的线程继续执行</span><br><span class="line">    pthread_cond_signal(&amp;_cond);//放在unlock前面，则wait会先唤醒，并且在等待锁释放</span><br><span class="line">    // 广播，唤醒所有等待的线程</span><br><span class="line">    //pthread_cond_broadcast(&amp;_cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    //pthread_cond_signal(&amp;_cond);//放在unlock后面，则wait唤醒之后，可以立刻获取锁</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="互斥锁逻辑查看"><a href="#互斥锁逻辑查看" class="headerlink" title="互斥锁逻辑查看"></a>互斥锁逻辑查看</h4><ul>
<li>汇编源码查看线程等待锁时，所做的事<ol>
<li>在<code>pthread_mutex_lock</code>方法中,如果可以获取到锁，则会直接retq返回，没有则会执行<code>_pthread_mutex_firstfit_lock_slow</code>方法<br> <img src="6.png"></li>
<li>在这个方法中最总会执行到<code>_pthread_mutex_firstfit_lock_wait</code>方法中<br> <img src="3.png"></li>
<li>调用__psynch_mutexwait方法<br><img src="4.png"></li>
<li>在该方法中，最后会走到<code>**syscall**</code>方法，系统调用方法，<code>si</code>执行终止，由系统调用让线程进入了休眠的状态。<br><img src="5.png"></li>
</ol>
</li>
</ul>
<h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><blockquote>
<ul>
<li>os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持<ul>
<li>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>使用教程<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;os/lock.h&gt;</span><br><span class="line"></span><br><span class="line">os_unfair_lock _lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line"></span><br><span class="line">os_unfair_lock_lock(&amp;_lock);</span><br><span class="line"> //需要同步的代码</span><br><span class="line"> os_unfair_lock_unlock(&amp;_lock);</span><br></pre></td></tr></table></figure></li>
<li>汇编发现是一种互斥锁,和<code>pthread_mutex</code>一样，等待锁会走到<code>**syscall**</code>方法,系统调用使得线程进入休眠状态<br><img src="7.png"><h3 id="NSLOCK、NSRecursiveLock"><a href="#NSLOCK、NSRecursiveLock" class="headerlink" title="NSLOCK、NSRecursiveLock"></a>NSLOCK、NSRecursiveLock</h3><blockquote>
<p>NSLock是对mutex普通锁的封装<br>NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致</p>
</blockquote>
</li>
<li>使用教程<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSLock *_lock = [[NSLock alloc] init];</span><br><span class="line">//NSRecursiveLock *_lock = [[NSRecursiveLock alloc] init];</span><br><span class="line">//均实现了&lt;NSLocking&gt;协议</span><br><span class="line">[_lock lock]</span><br><span class="line">//[_lock tryLock]</span><br><span class="line">[_lock unlock]</span><br></pre></td></tr></table></figure>
<h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><blockquote>
<p>NSCondition是对mutex和cond的封装</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface NSCondition : NSObject &lt;NSLocking&gt;</span><br><span class="line">- (void)wait</span><br><span class="line">- (BOOL)waitUntilDate:(NSDate *)limit N</span><br><span class="line">- (void)signal </span><br><span class="line">- (void)broadcast;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><blockquote>
<p>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值.</p>
<ul>
<li><code>lockWhenCondition:</code>只有满足具体条件值的才能获取到锁，<code>unlockWithCondition:</code>解锁可以重新设定(如果不传值，初始化，默认是0)</li>
<li><code>lock</code>和之前一样直接加锁，不会根据条件值来判断</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="8.png"></p>
<h3 id="dispatch-queue-DISPATCH-QUEUE-SERIAL"><a href="#dispatch-queue-DISPATCH-QUEUE-SERIAL" class="headerlink" title="dispatch_queue(DISPATCH_QUEUE_SERIAL)"></a>dispatch_queue(DISPATCH_QUEUE_SERIAL)</h3><blockquote>
<p>直接使用GCD的串行队列，也是可以实现线程同步的</p>
</blockquote>
<p><img src="9.png"></p>
<h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><blockquote>
<ul>
<li>semaphore叫做”信号量”<ul>
<li>信号量的初始值，可以用来控制线程并发访问的最大数量</li>
<li>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="10.png"></p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><blockquote>
<p>@synchronized是对mutex递归锁的封装,在最新版本中，锁已经改为os_unfair_lock了，但仍可实现递归，（os_unfair_lock是不支持递归的，代码做了优化，未开源）<br>源码查看：objc4中的objc-sync.mm文件<br>@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p>
</blockquote>
<ul>
<li>使用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@synchronized (self) &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重要数据结构<br><img src="11.png"></li>
<li>723以及之前的版本，用的是<code>pthread_mutex_t</code><br><img src="14.png"></li>
<li>723之后的版本，用的是<code>os_unfair_lock</code><br><img src="12.png"><br><img src="13.png"></li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>多线程的问题</title>
    <url>/2023/01/31/iOS%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>多线程原理是，操作系统通过<code>时间片轮转算法</code>，每次给一个线程一个时间片，让其可以执行,(如果所给的时间片足够短，则看起来是同时执行的)，进程也是这种方式</p>
</blockquote>
<h2 id="常见多线程方案"><a href="#常见多线程方案" class="headerlink" title="常见多线程方案"></a>常见多线程方案</h2><table>
<thead>
<tr>
<th align="center">技术方案</th>
<th align="left">简介</th>
<th align="center">语言</th>
<th align="center">线程生命周期</th>
<th align="center">使用频率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pthread</td>
<td align="left">一套通用的多线程API、适用于Unix\Linux\Windows等系统、跨平台\可移植、使用难度大</td>
<td align="center">c</td>
<td align="center">手动管理</td>
<td align="center">几乎不用</td>
</tr>
<tr>
<td align="center">NSThread</td>
<td align="left">使用更加面向对象、简单易用，可直接操作线程对象</td>
<td align="center">OC</td>
<td align="center">手动管理</td>
<td align="center">偶尔使用</td>
</tr>
<tr>
<td align="center">GCD</td>
<td align="left">旨在替代NSThread等线程技术、充分利用设备的多核</td>
<td align="center">c</td>
<td align="center">自动管理</td>
<td align="center">经常使用</td>
</tr>
<tr>
<td align="center">NSOperation</td>
<td align="left">基于GCD（底层是GCD）、比GCD多了一些更简单实用的功能、使用更加面向对象</td>
<td align="center">OC</td>
<td align="center">自动管理</td>
<td align="center">经常使用</td>
</tr>
</tbody></table>
<h2 id="常见的死锁问题"><a href="#常见的死锁问题" class="headerlink" title="常见的死锁问题"></a>常见的死锁问题</h2><ol>
<li>主队列中，用<code>dispatch_sync</code>同步在主队列中执行任务会有死锁，<ul>
<li>原因是<code>sync</code>同步执行会立刻执行<code>任务二</code>，但是在主队列中，已经添加了<code>任务三</code>，必须等<code>任务3</code>(<code>viewDidLoad</code>方法)执行完之后，才能执行<code>任务二</code>,因此造成死锁</li>
<li>改为<code>dispatch_async</code>,则不会出现死锁，会先执行<code>任务三</code>，再执行<code>任务二</code>,按主队列任务添加顺序执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;任务一&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务二&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务三&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>串行队列,和1相同，任务三的执行要求任务四持行完成，而sync要求立刻执行任务三，因此出现死锁<ul>
<li>将任务三放到另一个队列，或者采用<code>async</code>则可以避免<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;任务一&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务二&quot;);</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;任务三&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;任务四&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务五&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果是并发队列，则不会产生死锁<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;任务一&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务二&quot;);</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;任务三&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;任务四&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务五&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p>
</blockquote>
<h2 id="多线程的其他问题"><a href="#多线程的其他问题" class="headerlink" title="多线程的其他问题"></a>多线程的其他问题</h2></li>
<li>下面打印结果实际为，<code>1-&gt;3</code>,其中<code>2</code>并<strong>未打印</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">  NSLog(@&quot;1&quot;);</span><br><span class="line">  [self performSelector:@selector(test) withObject:nil afterDelay:0.0];</span><br><span class="line">  NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接用<code>[self performSelector:@selector(test) withObject:nil];</code>会打印<code>1-&gt;2-&gt;3</code>,因为其源码本质是通过<code>objc_msgSend</code>调用的<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (id)performSelector:(SEL)sel withObject:(id)obj &#123;</span><br><span class="line">         if (!sel) [self doesNotRecognizeSelector:sel];</span><br><span class="line">      return ((id(*)(id, SEL, id))objc_msgSend)(self, sel, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果在主线程中调用,会打印出<code>1-&gt;3-&gt;2</code></li>
<li><strong>原因</strong>:<code>[self performSelector:@selector(test) withObject:nil afterDelay:0.0];</code>的源码是在<code>Runloop</code>相关源码中定义的，其本质是添加了一个<code>Timer</code>到<code>Runloop</code>中的。而在1中通过<code>dispatch_async</code>开了一个子线程，但是实际上，子线程是没有启动<code>runloop</code>的，因此添加到的任务是无效的，因此不会打印<ul>
<li>解决方法,增加runloop，再启动runloop后，则会打印出<code>1-&gt;3-&gt;2</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line">[self performSelector:@selector(test) withObject:nil afterDelay:0.0];</span><br><span class="line">NSLog(@&quot;3&quot;);</span><br><span class="line">[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>源码，<code>NSRunloop</code>不开源，但是可以通过<a href="http://www.gnustep.org/resources/downloads.php%0D">GNU</a>大致了解下源码,虽然GNUstep不是苹果官方源码，但还是具有一定的参考价值</li>
</ul>
<ol start="2">
<li>与1类似的问题,waitUntilDone为YES会崩溃，因为在当执行输出<code>1</code>后，线程已经退出了，不能在线程中执行，如果waitUntilDone为NO，则不会崩溃，但是不会执行<code>test</code>方法<ul>
<li>和1类似，要在里面启动<code>Runloop</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    //解决问题</span><br><span class="line">    //[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    //[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>runloop的运行逻辑</title>
    <url>/2023/01/20/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop%E7%9A%84%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><ol>
<li>通知<code>Observers</code>：进入<code>Loop</code></li>
<li>通知<code>Observers</code>：即将处理<code>Timers</code></li>
<li>通知<code>Observers</code>：即将处理<code>Sources</code><ul>
<li><code>Observers</code>内，实际调用，<code>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</code></li>
</ul>
</li>
<li>处理<code>Blocks</code><ul>
<li>处理通过<code>CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void))</code>添加到<code>runloop</code>的block</li>
<li>实际调用：<code>_CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</code></li>
</ul>
</li>
<li>处理<code>Source0</code>（如果返回结果是true，可能会再次处理<code>Blocks</code>）<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code></li>
</ul>
</li>
<li>如果存在<code>Source1</code>，就跳转到第8步<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code></li>
</ul>
</li>
<li>通知<code>Observers</code>：开始休眠（等待消息唤醒）<ul>
<li><code>__CFRunLoopServiceMachPort</code>内，用户态会下发<code>mach_msg</code>给内核态（只有内核可以真正的休眠线程（而非阻塞线程,忙等），节省CPU），切换到内核态，当内核收到消息后，再唤醒线程，节省CPU资源</li>
</ul>
</li>
<li>通知<code>Observers</code>：结束休眠（被某个消息唤醒）<ol>
<li>处理<code>Timer</code><ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</code></li>
</ul>
</li>
<li>处理<code>GCD Async To Main Queue</code>,GCD异步回到主队列的任务<ul>
<li>实际调用：<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>，注意只有通过<code>dispatch_async(dispatch_get_main_queue(),block);</code>，GCD异步回到主队列，才会有runloop的协助</li>
</ul>
</li>
<li>处理<code>Source1</code><ul>
<li>实际调用：<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code></li>
</ul>
</li>
</ol>
</li>
<li>处理<code>Blocks</code></li>
<li>根据前面的执行结果，决定如何操作<ol>
<li>回到第02步</li>
<li>退出<code>Loop</code></li>
</ol>
</li>
<li>通知Observers：退出Loop<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3></li>
</ol>
<ul>
<li><code>CFRunLoopRunSpecific</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   //通知Observers：进入runLoop</span><br><span class="line">if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">   //具体要做的事</span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">   //通知Observers：退出unLoop</span><br><span class="line">if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br></pre></td></tr></table></figure></li>
<li><code>CFRunLoopRun</code><h3 id="runloop执行方法需要注意的地方"><a href="#runloop执行方法需要注意的地方" class="headerlink" title="runloop执行方法需要注意的地方"></a>runloop执行方法需要注意的地方</h3></li>
</ul>
<ol>
<li><code>- (void)run</code><ul>
<li><code>[[NSRunloop currentRunloop] run]</code>实际上是在一个<code>while(1)</code>中重复调用<code>-(BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate</code>方法,因此通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>只能取消一次<code>runMode:(NSRunLoopMode)mode beforeDate:</code>的调用，</li>
<li>但是在<code>run</code>方法中，还是会循环调用，是无法取消<code>run</code>方法的循环调用的</li>
</ul>
</li>
<li><code>-(BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate</code><ul>
<li> 注意，该方法，在执行完一次runloop的循环之后，则会退出，例如执行一次<code>performSelector:</code>方法便会释放</li>
</ul>
</li>
<li>注意在启动<code>runloop</code>后，要注意<code>_strong typeof(weakSelf) strongSelf = weakSelf</code>的写法，列入通过<code>initWithBlock:</code>设置线程,在runloop运行期间，一直会有一个局部强引用持有<code>self</code>，除非将当前的<code>runloop</code>结束</li>
<li>同时，注意,通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>停止<code>runloop</code>之后,不要在使用，<code>performSelector:onThread:withObject:waitUntilDone:</code>在线程中执行，因为线程和runloop的生命周期是一一对应的，在waitUntilDone为<code>true</code>,不异步执行时，会出现野指针的错误，为<code>false</code>时，异步时可能内部做了处理，不会出现野指针</li>
<li><code>CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</code>,<code>returnAfterSourceHandled</code>为true代表执行完source之后，就退出runloop，类似2中的用法,设置为false则，执行一次source是不会退出的<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>runloop是怎么响应用户操作的，具体流程是什么样的？<ul>
<li>由source1将系统事件捕获，（例如点击屏幕的事件），source1将事件包装成EventQueue，放到source0中处理</li>
</ul>
</li>
<li><code>NSDefaultRunLoopMode</code>、<code>UITrackingRunLoopMode</code>才是真正存在的模式<code>NSRunLoopCommonModes</code>并不是一个真的模式，它只是一个标记</li>
</ol>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>runloop相关的类</title>
    <url>/2023/01/12/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="runloop的结构"><a href="#runloop的结构" class="headerlink" title="runloop的结构"></a>runloop的结构</h2><blockquote>
<ul>
<li>Core Foundation中关于RunLoop的5个类<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h3 id="CFRunLoop"><a href="#CFRunLoop" class="headerlink" title="__CFRunLoop"></a>__CFRunLoop</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;			/* locked for accessing mode list */</span><br><span class="line">    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp </span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread; //相对应地线程</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes; // </span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode; //Mode</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>简化版<br><img src="1.png"></li>
</ul>
<h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0; </span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>简化版<br><img src="2.png"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3></li>
<li>一个runLoop中有很多模式，存在modes中，但是每次只会选择一种模式,作为当前模式<br><img src="3.png"></li>
<li>CFRunLoopModeRef代表RunLoop的运行模式</li>
<li>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer</li>
<li>RunLoop启动时只能选择其中一个Mode，作为currentMode</li>
<li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入<ul>
<li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li>
</ul>
</li>
<li>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出<h2 id="CFRunLoopModeRef-1"><a href="#CFRunLoopModeRef-1" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h2></li>
</ul>
<ol>
<li><code>Source0</code><ul>
<li>触摸事件处理<br><img src="4.png"></li>
<li><code>performSelector:onThread:</code>,线程之前的通信</li>
</ul>
</li>
<li><code>Source1</code><ul>
<li>基于<code>Port</code>的线程间通信,</li>
<li>系统事件捕捉，例如，屏幕点击，最开始是source1</li>
</ul>
</li>
<li><code>Timers</code><ul>
<li><code>NSTimer</code></li>
<li><code>performSelector:withObject:afterDelay:</code>,本质会加到runloop的timer</li>
</ul>
</li>
<li><code>Observers</code><ul>
<li>用于监听<code>RunLoop</code>的状态</li>
<li><code>UI</code>刷新（<code>BeforeWaiting</code>）,在线程休眠之前，设置UI</li>
<li><code>Autorelease pool</code>（<code>BeforeWaiting</code>）,在休眠之前释放自动释放池对象，唤醒后新建新的自动释放池<h2 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h2></li>
</ul>
</li>
</ol>
<ul>
<li><code>RunLoop</code>的状态改变流程<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>监听RunLoop的状态<ul>
<li>切换mode之后，会先<code>kCFRunLoopExit - kCFRunLoopDefaultMode</code>，之后再<code>kCFRunLoopEntry - UITrackingRunLoopMode</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">       case kCFRunLoopEntry:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopEntry&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeTimers:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeTimers&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeSources:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeSources&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeWaiting:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopAfterWaiting:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopAfterWaiting&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopExit:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopExit&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 添加Observer到RunLoop中</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    // 释放</span><br><span class="line">CFRelease(observer);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>runloop</title>
    <url>/2023/01/10/iOS%E5%AD%A6%E4%B9%A0/Runloop%E7%9F%A5%E8%AF%86/runloop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h2><ul>
<li>顾名思义<ul>
<li>运行循环</li>
<li>在程序运行过程中循环做一些事情</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（比如触摸事件、定时器事件等）</li>
<li>节省CPU资源，提高程序性能：该做事时做事，该休息时休息</li>
</ul>
</li>
<li>应用范畴<ul>
<li>定时器（Timer）、PerformSelector</li>
<li>GCD Async Main Queue</li>
<li>事件响应、手势识别、界面刷新</li>
<li>网络请求</li>
<li><code>AutoreleasePool</code></li>
</ul>
</li>
<li><code>RunLoop</code>与线程<ul>
<li>每条线程都有唯一的一个与之对应的RunLoop对象<ul>
<li><code>CFRunLoopGetCurrent()</code>和<code>[NSRunLoop currentRunLoop]</code>,在当前线程中获取runloop</li>
<li>从字典中获取，如果没有的话，则会创建，并存放在字典中，key是线程的指针地址<br><img src="1.png"></li>
</ul>
</li>
<li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li>
<li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li>
<li>RunLoop会在线程结束时销毁</li>
<li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>runloop</category>
      </categories>
  </entry>
  <entry>
    <title>中间代码（IR）</title>
    <url>/2023/01/09/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Objective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation）,ir中间代码代码相比于转成C++更接近底层（但是肯定无法和汇编相比）</p>
</blockquote>
<ul>
<li>可以使用以下命令行指令生成中间代码<ul>
<li><code>clang -emit-llvm -S main.m</code></li>
</ul>
</li>
<li>语法简介<ul>
<li><code>@</code> - 全局变量</li>
<li><code>%</code> - 局部变量</li>
<li><code>alloca</code> - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存</li>
<li><code>i32</code> - 32位4字节的整数</li>
<li><code>align</code> - 对齐</li>
<li><code>load</code> - 读出，<code>store</code> 写入</li>
<li><code>icmp</code> - 两个整数值比较，返回布尔值</li>
<li><code>br</code> - 选择分支，根据条件来转向<code>label</code>，不根据条件跳转的话类似 <code>goto</code></li>
<li><code>label</code> - 代码标签</li>
<li><code>call</code> - 调用函数</li>
</ul>
</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.m</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">int c = a + b;</span><br><span class="line">test(c);</span><br><span class="line">//转成main.ll</span><br><span class="line">  store i32 10, i32* %8, align 4  //将10存储到局部变量 %8</span><br><span class="line">  store i32 20, i32* %9, align 4  //将20存储到局部变量 %9</span><br><span class="line">  %19 = load i32, i32* %8, align 4 //将%8加载到%19</span><br><span class="line">  %20 = load i32, i32* %9, align 4 //将%9加载到%20</span><br><span class="line">  %21 = add nsw i32 %19, %20    // %19和%20的值相加</span><br><span class="line">  store i32 %21, i32* %10, align 4 //将%21的值存储到%10</span><br><span class="line">  %22 = load i32, i32* %10, align 4  //将 %10的值加载到%22</span><br><span class="line">  call void @test(i32 %22) //调用函数，参数是 %22</span><br></pre></td></tr></table></figure></li>
<li><a href="https://llvm.org/docs/LangRef.html">具体文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>runtime特殊问题</title>
    <url>/2023/01/08/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/runtime%E7%89%B9%E6%AE%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Person:NSObject</span><br><span class="line">@property (copy, nonatomic) NSString *name;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">- (void)print</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;my name is %@&quot;, self-&gt;_name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//ViewController中</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //NSString *test = @&quot;123&quot;;如果，前面有这个text对象，则实际会输出my name is 123</span><br><span class="line">    id cls = [Person class];</span><br><span class="line"></span><br><span class="line">    void *obj = &amp;cls;</span><br><span class="line"></span><br><span class="line">    [(__bridge id)obj print];</span><br><span class="line">    //实际输出my name is &lt;ViewController: 0x104b08020&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="print为什么能够调用成功？"><a href="#print为什么能够调用成功？" class="headerlink" title="print为什么能够调用成功？"></a><code>print</code>为什么能够调用成功？</h3><ul>
<li><p>示意图<br><img src="1.jpg"></p>
</li>
<li><p>将<code>[Person class]</code>的类对象cls的地址赋值给obj之后，在obj地址上的<code>前8个字节</code>的东西是cls的类对象的地址。这和正常实例化后的对象person一样，person所指向的地址在内存上前8个字节的地址是isa(类对象的地址)</p>
</li>
<li><p>在调用<code>print</code>方法的时候，就会去obj内存的前8个字节，取出该内存上的对象（正常结构体，则是其内存上前8个字节的isa指针），刚好是类对象，因此最终和调用实例对象方法一样可以调用成功。</p>
</li>
<li><p>在（__bridge id）的时候，实际上讲objc指针，转换成了<code>objc_object</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<h3 id="为什么self-name变成了ViewController等其他内容"><a href="#为什么self-name变成了ViewController等其他内容" class="headerlink" title="为什么self.name变成了ViewController等其他内容"></a>为什么self.name变成了ViewController等其他内容</h3></li>
<li><p>栈上分配的临时对象的地址，是有高向低进行分配的,下面字符串的指针均指向常量区，其指针均相同，但是，栈给对象分配的指针地址，是不同的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 0x0000000100998070 @&quot;123&quot;</span><br><span class="line">NSString *test = @&quot;123&quot;; //&amp;test 0x000000016f46cc20</span><br><span class="line">NSString *test1 = @&quot;123&quot;; // &amp;test1 0x000000016f46cc18</span><br><span class="line">NSString *test2 = @&quot;123&quot;; // &amp;test2 0x000000016f46cc10</span><br></pre></td></tr></table></figure></li>
<li><p>实际分配的示意图<br><img src="2.jpg"></p>
</li>
<li><p><code>Person</code>结构体的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct MJPerson_IMPL</span><br><span class="line"> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">     NSString *_name;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>NSLog(@&quot;my name is %@&quot;, self-&gt;_name);</code>调用该方法的本质，实际<code>person</code>的前8个字节是<code>cls</code>,而在<code>isa上加8个字节</code>后去取_name变量(结构体越往后面的地址会越高)，则根据分配的原则，会取到<code>test</code>,因此加test后，则会输出<code>my name is 123</code></p>
</li>
<li><p>不加局部对象，则会输出<code>my name is &lt;ViewController: 0x104b08020&gt;</code>,是由于<code>[super viewDidLoad]</code>造成的，因此在没有<code>test</code>局部变量后，实际上<code>isa上加8个字节</code>后，取到的是<code>self</code>的地址。最终则会输出<code>my name is &lt;ViewController: 0x104b08020&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //[super viewDidLoad] ,源码实际</span><br><span class="line"> struct abc = &#123;</span><br><span class="line">       self,</span><br><span class="line">       [ViewController class]</span><br><span class="line">   &#125;;</span><br><span class="line">//注意这里调用的是objc_msgSendSuper2，并非objc_msgSendSuper(这个要传入父类对象)</span><br><span class="line">objc_msgSendSuper2(abc, sel_registerName(&quot;viewDidLoad&quot;));</span><br><span class="line">//因此会隐式的生成abc结构体变量，其低地址是self，高地址是[ViewController class]</span><br></pre></td></tr></table></figure></li>
<li><p>注意，如果将<code>[super viewDidLoad]</code>屏蔽，则由于<code>isa地址加8字节后</code>，找不到任何东西，则会出现野指针的错误</p>
</li>
<li><p><code>objc_msgSendSuper2</code>可以通过调试发现,(x/4g,打出$1地址上每8个字节存的东西，打印4个),通过调试发现，后续的内存中,第一个是self，第二个是[ViewController class]，而非父类。</p>
<ul>
<li>但实际在源码中，<code>objc_msgSendSuper2</code>最终还是会取父类去调用</li>
<li>调试汇编<br><img src="5.png"></li>
<li>源码中，还是会取父类去调用<br><img src="4.png"></li>
<li>实际调试代码，确定是用objc_msgSendSuper2<br><img src="3.png"><h2 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h2><blockquote>
<p><code>&lt;objc/runtime.h&gt;</code>的APi</p>
</blockquote>
<h3 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h3></li>
<li>Class object_getClass(id obj)<ul>
<li>获取isa指向的Class</li>
</ul>
</li>
<li>Class object_setClass(id obj, Class cls)<ul>
<li>设置isa指向的Class,<strong>可以更改当前对象指向的isa</strong></li>
</ul>
</li>
<li>BOOL object_isClass(id obj)<ul>
<li>判断一个OC对象是否为Class</li>
</ul>
</li>
<li>BOOL class_isMetaClass(Class cls)<ul>
<li>判断一个Class是否为元类</li>
</ul>
</li>
<li>Class class_getSuperclass(Class cls)<ul>
<li>获取父类<h3 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h3></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</code></p>
<ul>
<li>动态创建一个类（参数：父类，类名，额外的内存空间）</li>
</ul>
</li>
<li><p><code>void objc_registerClassPair(Class cls)</code></p>
<ul>
<li>注册一个类（要在类注册之前添加成员变量），在你需要动态创建的类中，加入方法，协议，成员变量后，再去注册</li>
<li>注意，类注册完之后，类的成员变量会在<code>class_ro_t</code>中是不可变的，而方法，协议是在<code>class_rw_t</code>中，任何时候都是可以添加的<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4></li>
</ul>
</li>
<li><p><code>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</code></p>
<ul>
<li>动态添加成员变量（<strong>已经注册的类是不能动态添加成员变量的</strong>）</li>
<li>例如<code>class_addIvar(newCls, &quot;_age&quot;, 4, 1, @encode(int));</code>添加一个age的成员变量,设置和取值，可以通过kvc实现<code>[dog setValue:@10 forKey:@&quot;_age&quot;];</code><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4></li>
</ul>
</li>
<li><p><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p>
<ul>
<li>动态添加属性</li>
</ul>
</li>
<li><p><code>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p>
<ul>
<li>动态替换属性<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4></li>
</ul>
</li>
<li><p><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code></p>
<ul>
<li>动态添加方法</li>
</ul>
</li>
<li><p><code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code></p>
<ul>
<li>动态替换方法<h3 id="成员变量相关"><a href="#成员变量相关" class="headerlink" title="成员变量相关"></a>成员变量相关</h3></li>
</ul>
</li>
<li><p><code>Ivar class_getInstanceVariable(Class cls, const char *name)</code></p>
<ul>
<li>获取一个实例变量信息</li>
<li>获取成员变量的相关信息<ul>
<li><code>const char *ivar_getName(Ivar v)</code></li>
<li><code>const char *ivar_getTypeEncoding(Ivar v)</code></li>
</ul>
</li>
<li>设置和获取成员变量的值<ul>
<li><code>void object_setIvar(id obj, Ivar ivar, id value)</code><ul>
<li>如果设置基本变量,<code>object_setIvar(person, weightVar, (__bridge id)(void *)20)</code>将基本类型转成对象</li>
</ul>
</li>
<li><code>id object_getIvar(id obj, Ivar ivar)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code></p>
<ul>
<li>拷贝实例变量列表（最后需要调用free释放）<h3 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h3></li>
</ul>
</li>
<li><p><code>objc_property_t class_getProperty(Class cls, const char *name)</code></p>
<ul>
<li>获取一个属性</li>
<li>获取属性的一些信息<ul>
<li><code>const char *property_getName(objc_property_t property)</code></li>
<li><code>const char *property_getAttributes(objc_property_t property)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code></p>
<ul>
<li>拷贝属性列表（最后需要调用free释放）<h3 id="方法相关"><a href="#方法相关" class="headerlink" title="方法相关"></a>方法相关</h3></li>
</ul>
</li>
<li><p>获得一个实例方法、类方法</p>
<ul>
<li><code>Method class_getInstanceMethod(Class cls, SEL name)</code></li>
<li><code>Method class_getClassMethod(Class cls, SEL name)</code></li>
<li>获取方法的相关信息（带有copy的需要调用free去释放）<ul>
<li><code>SEL method_getName(Method m)</code></li>
<li><code>IMP method_getImplementation(Method m)</code></li>
<li><code>const char *method_getTypeEncoding(Method m)</code></li>
<li><code>unsigned int method_getNumberOfArguments(Method m)</code></li>
<li><code>char *method_copyReturnType(Method m)</code></li>
<li><code>char *method_copyArgumentType(Method m, unsigned int index)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>方法实现相关操作</p>
<ul>
<li><code>IMP class_getMethodImplementation(Class cls, SEL name) </code></li>
<li><code>IMP method_setImplementation(Method m, IMP imp)</code></li>
<li><code>void method_exchangeImplementations(Method m1, Method m2) </code><ul>
<li>源码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void method_exchangeImplementations(Method m1Signed, Method m2Signed)</span><br><span class="line">&#123;</span><br><span class="line"> if (!m1Signed  ||  !m2Signed) return;</span><br><span class="line"></span><br><span class="line">method_t *m1 = _method_auth(m1Signed);</span><br><span class="line"> method_t *m2 = _method_auth(m2Signed);</span><br><span class="line"></span><br><span class="line">mutex_locker_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">//进行imp的交换</span><br><span class="line">IMP imp1 = m1-&gt;imp(false);</span><br><span class="line">IMP imp2 = m2-&gt;imp(false);</span><br><span class="line">SEL sel1 = m1-&gt;name();</span><br><span class="line">SEL sel2 = m2-&gt;name();</span><br><span class="line"></span><br><span class="line">m1-&gt;setImp(imp2);</span><br><span class="line">m2-&gt;setImp(imp1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// RR/AWZ updates are slow because class is unknown</span><br><span class="line">// Cache updates are slow because class is unknown</span><br><span class="line">// fixme build list of classes whose Methods are known externally?</span><br><span class="line">//这里会清除方法内的所有缓存</span><br><span class="line">flushCaches(nil, __func__, [sel1, sel2, imp1, imp2](Class c)&#123;</span><br><span class="line">  return c-&gt;cache.shouldFlush(sel1, imp1) || c-         &gt;cache.shouldFlush(sel2, imp2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">adjustCustomFlagsForMethodChange(nil, m1);</span><br><span class="line">adjustCustomFlagsForMethodChange(nil, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>拷贝方法列表（最后需要调用free释放）</p>
</li>
<li><p><code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code></p>
</li>
<li><p>选择器相关</p>
<ul>
<li><code>const char *sel_getName(SEL sel)</code></li>
<li><code>SEL sel_registerName(const char *str)</code></li>
</ul>
</li>
<li><p>用block作为方法实现</p>
<ul>
<li><code>IMP imp_implementationWithBlock(id block)</code></li>
<li><code>id imp_getBlock(IMP anImp)</code></li>
<li><code>BOOL imp_removeBlock(IMP anImp)</code><h3 id="runtime面试题"><a href="#runtime面试题" class="headerlink" title="runtime面试题"></a>runtime面试题</h3></li>
</ul>
</li>
</ul>
<ol>
<li>什么是Runtime<ul>
<li>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行OC的动态性就是由Runtime来支撑和实现的，<code>Runtime</code>是一套C语言的API，封装了很多动态性相关的函数平时编写的OC代码，底层都是转换成了<code>Runtime API</code>进行调用</li>
</ul>
</li>
<li>具体应用<ol>
<li>利用关联对象（AssociatedObject）给分类添加属性</li>
<li>遍历类的所有成员变量（利用kvc修改私有属性，字典转模型，自动归档接档）</li>
<li>交换方法实现（交换系统的方法）</li>
<li>利用消息转发机制解决方法找不到的异常问题，(重写<code>forwardInvocation:</code>实现)</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>isKindofClass和isMemberofClass</title>
    <url>/2023/01/08/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/isKindofclass%E5%92%8CisMemberofClass/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<ul>
<li>isKindofClass是判断是否是当前类,或者其子类</li>
<li>isMemberOfClass是否是当前类</li>
</ul>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断是否是元类成员</span><br><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    //取出元类</span><br><span class="line">    return self-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断元类</span><br><span class="line">// [LGPerson isKindOfClass:object_getClass([LGPerson class])] 返回true</span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    //取出元类，取出元类</span><br><span class="line">    for (Class tcls = self-&gt;ISA(); tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// [[LGPerson new] isKindOfClass:[LGPerson class]] 返回true</span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Person:NSObject</span><br><span class="line">@end</span><br><span class="line">@interface Student:Person</span><br><span class="line">@end</span><br><span class="line">[Student isKindofClass:[Person class]] //false,类对象是元类的类型（isa指向），并不是类的类型</span><br><span class="line">[Student isKindofClass:object_class([Person class])] // true,类对象是元类(类的类)的类型</span><br><span class="line">[[Student new] isKindofClass:[Person class]] //true，实例对象的父类是，Person</span><br><span class="line">//不管方法调用者，不管是实例对象还是类对象，都是返回true，（只要是NSObject体系下的）</span><br><span class="line">[Student isKindofClass:[NSObject class]] //true，基元类的父类是NSObject，所以是成立的</span><br><span class="line"></span><br><span class="line">[Person isMemberOfClass:[NSObject class]] //false，是直接判断isa指针的</span><br><span class="line">[Person isMemberOfClass:object_class([Sturdent class])] //false</span><br><span class="line">[Person isMemberOfClass:object_class([Person class])] //true</span><br><span class="line">[[Person new] isMemberOfClass:[Person class]] //true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>super</title>
    <url>/2023/01/06/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/super/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>方法中子类调用<code>[super class]</code>实际输出还是子类的对象，和一般语言中的有所不同<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Student:Person</span><br><span class="line">@implementation Student</span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;[self class] = %@&quot;, [self class]); // Student</span><br><span class="line">        NSLog(@&quot;[self superclass] = %@&quot;, [self superclass]); // Person</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;[super class] = %@&quot;, [super class]); // 实际输出 Student</span><br><span class="line">        NSLog(@&quot;[super superclass] = %@&quot;, [super superclass]); // MJPerson</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="原因解答"><a href="#原因解答" class="headerlink" title="原因解答"></a>原因解答</h2></li>
<li>调用super方法，其实际会调用,方法<ul>
<li>实际调用的方法,<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Sends a message with a simple return value to the superclass of an instance of a class.</span><br><span class="line"> * </span><br><span class="line"> * @param super A pointer to an \c objc_super data structure. Pass values identifying the</span><br><span class="line"> *  context the message was sent to, including the instance of the class that is to receive the</span><br><span class="line"> *  message and the superclass at which to start searching for the method implementation.</span><br><span class="line"> * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.</span><br><span class="line"> * @param ...</span><br><span class="line"> *   A variable argument list containing the arguments to the method.</span><br><span class="line"> * </span><br><span class="line"> * @return The return value of the method identified by \e op.</span><br><span class="line"> * </span><br><span class="line"> * @see objc_msgSend</span><br><span class="line"> */</span><br><span class="line">objc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></figure></li>
<li>objc_super的结构体是<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">/// Specifies an instance of a class.</span><br><span class="line">__unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">/// Specifies the particular superclass of the instance to message. </span><br><span class="line">__unsafe_unretained _Nonnull Class super_class;</span><br><span class="line"></span><br><span class="line">/* super_class is the first class to search */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>编译后的代码,其方法的实际<code>receiver</code>，实际上仍然是self<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objc_msgSendSuper((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;class&quot;)));</span><br></pre></td></tr></table></figure></li>
<li>也就是[super message]的底层实现<ol>
<li>其消息接收者仍然是子类对象，</li>
<li>是从父类开始查找方法的实现</li>
</ol>
</li>
</ul>
</li>
<li><code>- (Class)class</code>方法是在<code>NSObject</code>上实现的，因此不管是<code>[self class]</code>,还是<code>[super class]</code>从父类开始查找方法，实际上都是在<code>NSObject</code>上实现的，因此最终和<code>[self class]</code>一样，还是会返回<code>Student</code></li>
<li>注意在查看汇编时，实际调用的是<code>objc_msgSendSuper2</code>,其第二个参数是当前类对象，而非父类对象，但是在实际源码中<code>objc_msgSendSuper2</code>内，最终还是会取父类去调用。因此最终和编译后的<code>objc_msgSendSuper</code>实现实际是一样的<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct abc = &#123;</span><br><span class="line">      self,</span><br><span class="line">      [ViewController class]</span><br><span class="line">  &#125;;</span><br><span class="line">objc_msgSendSuper2(abc, sel_registerName(&quot;viewDidLoad&quot;));</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>objc_msgSend</title>
    <url>/2023/01/02/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/objc-msgSend/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h1><blockquote>
<ul>
<li>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</li>
<li>objc_msgSend的执行流程可以分为3大阶段<ul>
<li>消息发送</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="objc-msgSend源码866执行流程"><a href="#objc-msgSend源码866执行流程" class="headerlink" title="objc_msgSend源码866执行流程"></a>objc_msgSend源码866执行流程</h2><h3 id="objc-msg-arm64-s"><a href="#objc-msg-arm64-s" class="headerlink" title="objc-msg-arm64.s"></a>objc-msg-arm64.s</h3><ul>
<li>objc-msg-arm64.s<ol>
<li>MSG_ENTRY _objc_msgSend <ul>
<li>到 END_ENTRY _objc_msgSend，objc_msgSend的定义</li>
</ul>
</li>
<li>b.le    LNilOrTagged<ul>
<li>首先会判断是否时nil，为nil，则会跳转到LReturnZero直接返回，</li>
</ul>
</li>
<li>CacheLookup NORMAL<ul>
<li>不是nil,去查找缓存</li>
</ul>
</li>
<li>.macro <code>CacheLookup</code><ul>
<li>缓存命中CacheHit，直接返回IMP</li>
</ul>
</li>
<li>缓存未命中，__objc_msgLookup_uncached<ul>
<li>没找到方法，则会调用<code>MethodTableLookup</code>去查找，MethodTableLookup</li>
<li>最终调用的是C函数的方法是<code>lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</code>（注意汇编中的比C函数方法多一个<code>_</code>）<h3 id="第一阶段，消息发送"><a href="#第一阶段，消息发送" class="headerlink" title="第一阶段，消息发送"></a>第一阶段，消息发送</h3></li>
</ul>
</li>
</ol>
</li>
<li>在<code>objc-runtime-new.mm</code>文件中，<code>第一个阶段</code>，查找方法<ol>
<li><code>lookUpImpOrForward</code>,未从缓存中查找的逻辑</li>
<li><code>realizeAndInitializeIfNeeded_locked</code><ul>
<li>确保类已经<code>realize</code>了</li>
</ul>
</li>
<li>for循环进行遍历查找类<code>cls</code>中方法，有个最大的数进行记录，防止陷入死循环<ol>
<li>先去<code>cache_getImp</code>从缓存中获取<ul>
<li>在查找中间的方法过程中，可能会有新方法在中间添加进来，会先加到缓存中</li>
</ul>
</li>
<li><code>getMethodNoSuper_nolock</code>、<code>search_method_list_inline</code>、<code>log_and_fill_cache</code><ol>
<li>从<code>class_rw_t的methods</code>中找到所有类和分类的方法，遍历<code>method_list_t</code>查找，因此需要类先realize</li>
<li>是排好序列的，<code>findMethodInSortedMethodList</code>中去查找方法,根据方法名查找，已经排序，<code>二分查找</code>的方式<ul>
<li>如果有相同的有很多，会倒序查找，找到排序的第一个方法</li>
<li>排序，会在<code>prepareMethodLists</code>中调用<code>fixupMethodList</code>方法<ul>
<li>method_t中方法类型有big、small、bigSigned<ul>
<li>big是默认的，大方法，其值为指针，其类型包括<code>SEL name;const char *types;MethodListIMP imp;</code></li>
<li>small，小方法，其值表示为相对每个字段的额外地址，其结构是<code>RelativePointer&lt;const void *&gt; name;RelativePointer&lt;const char *&gt; types;RelativePointer&lt;IMP, /*isNullable*/false&gt; imp;</code>,其引用的选择器在(共享缓存)或者是在磁盘上，考虑<code>相关动态库的系统方法</code>,该方法是只读内存，因此small的是无法修改的。其是否是small方法，是由编译器决定，进行设置的</li>
<li>bigSigned,和big相同，但是其name已经签名，该方法是由运行时添加的，类似<code>class_addMethod</code>方法添加的</li>
</ul>
</li>
<li>对方法排序，只会对非small的方法进行排序,排序是根据方法名<code>SEL</code>的地址由低到高排序的<br><img src="4.png"></li>
<li>排序的方式采用的是<code>**归并排序**</code><br><img src="5.png"></li>
</ul>
</li>
</ul>
</li>
<li>不是排好序的<code>findMethodInUnsortedMethodList</code>，<code>线性遍历查找</code>，找到第一个方法名相同的，后，返回</li>
<li><code>log_and_fill_cache(cls, imp, sel, inst, curClass)</code>,查找到方法后，调用void cache_t::insert,去插入到缓存中,保存的类是最开始查找的类方法<code>cls</code>中,而并非当前的类。</li>
<li>当前<code>curClass</code>中没有找到，则会去父类遍历查找<code>curClass = curClass-&gt;getSuperclass()) == nil</code><ul>
<li>如果找到最后的父类，都没有找到方法，则会设置当前<code>imp = _objc_msgForward_impcache</code></li>
<li>或者从缓存中取到的方法，等于<code>_objc_msgForward_impcache</code>,则会跳出循环</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>消息发送流程<br><img src="1.png"><h3 id="第二阶段，动态方法解析"><a href="#第二阶段，动态方法解析" class="headerlink" title="第二阶段，动态方法解析"></a>第二阶段，动态方法解析</h3></li>
<li>log_and_fill_cache，<code>第二个阶段</code>，动态方法解析<ul>
<li><code>(behavior &amp; LOOKUP_RESOLVER) == 0</code>由最开始汇编中，传入，需要进行方法解析，则进入方法解析流程<ol>
<li> <code>behavior ^= LOOKUP_RESOLVER</code>,解析之后，就不需要了</li>
<li> <code>resolveMethod_locked(inst, sel, cls, behavior)</code>,进入方法解析流程</li>
<li>不是元类，则走<code>resolveInstanceMethod</code>方法<ol>
<li>会先去找<code>resolveInstanceMethod</code>,<code>_lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(true))</code>先去,其isa，也就是其类类对象，缓存中找，找不到，则走<code>阶段一</code>的方法查找，这次的<code>behavior</code>不包含<code>LOOKUP_RESOLVER</code>,不会去走动态方法解析<ul>
<li> 其中NSObject中<code>+(BOOL)resolveInstanceMethod</code>会有基础实现</li>
<li> 因为后续会同步再去查询方法，因此是否返回true，不影响实际结果，但是安规范，实现了返回true</li>
</ul>
</li>
<li> 会用<code>objc_msgSend</code>调用方法</li>
<li>会再调用<code>lookUpImpOrNilTryCache(inst, sel, cls)</code>,去查找，一开始寻找的方法</li>
<li>方法的返回，最后通过调用<code>lookUpImpOrForwardTryCache</code>去查找<ul>
<li><strong>注意</strong>，用<code>lookUpImpOrNilTryCache</code>传入的<code>behavior</code>包括<code>LOOKUP_NIL</code>，即没有搜索到，会返回nil,不会出现找不到方法的异常</li>
</ul>
</li>
</ol>
</li>
<li>是元类，则会查找<code>resolveClassMethod</code>，同时，如果调用<code>lookUpImpOrNilTryCache</code>,没有找到，也会去走<code>resolveInstanceMethod</code>方法，即上面的流程(注意，此时他回去元类的isa指针，找方法，而元类的isa指针，实际上是基元类，也就是NSObjec类方法中)，解析类的方法和实例方法流程一样<ol>
<li>同样会先去找方法<code>resolveClassMethod</code>，其在NSObject中也已实现</li>
<li>会用<code>objc_msgSend</code>的方式调用</li>
<li>最终用<code>lookUpImpOrForwardTryCache</code>去查找方法</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>实现代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void c_other(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;c_other - %@ - %@&quot;, self, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br><span class="line">- (void)other &#123;</span><br><span class="line"> NSLog(@&quot;other - %@ - %s&quot;, self, __func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(test)) &#123;</span><br><span class="line">        // 第一个参数是object_getClass(self)</span><br><span class="line">       // c函数 class_addMethod(object_getClass(self), sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br><span class="line">       Method method = class_getInstanceMethod(self, @selector(other));</span><br><span class="line">        class_addMethod(</span><br><span class="line">        object_getClass(self), </span><br><span class="line">        sel,</span><br><span class="line">        method_getImplementation(method), </span><br><span class="line">        method_getTypeEncoding(method));</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>动态解析流程<br><img src="2.png"><h3 id="第三阶段，消息转发"><a href="#第三阶段，消息转发" class="headerlink" title="第三阶段，消息转发"></a>第三阶段，消息转发</h3></li>
<li>在<code>第二阶段</code>中，最终会用<code>lookUpImpOrForwardTryCache</code>,再去查找一次方法，这次，如果动态解析方法添加到了，则直接返回，否则不会再走解析流程，其中设置imp为<code>_objc_msgForward_impcache</code>,会跳转到该方法的实现上，该方法在<code>objc-msg-arm64.s</code>文件内，属于汇编<ul>
<li>ENTRY __objc_msgForward</li>
<li>Core Foundation</li>
<li>__forwarding__（不开源)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// __forwarding__伪代码</span><br><span class="line">int __forwarding__(void *frameStackPointer, int isStret) &#123;</span><br><span class="line">    id receiver = *(id *)frameStackPointer;</span><br><span class="line">    SEL sel = *(SEL *)(frameStackPointer + 8);</span><br><span class="line">    const char *selName = sel_getName(sel);</span><br><span class="line">    Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">    // 调用 forwardingTargetForSelector:</span><br><span class="line">    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        id forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        if (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</span><br><span class="line">            if (isStret == 1) &#123;</span><br><span class="line">                int ret;</span><br><span class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">                return ret;</span><br><span class="line">            &#125;</span><br><span class="line">            return objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 僵尸对象</span><br><span class="line">    const char *className = class_getName(receiverClass);</span><br><span class="line">    const char *zombiePrefix = &quot;_NSZombie_&quot;;</span><br><span class="line">    size_t prefixLen = strlen(zombiePrefix); // 0xa</span><br><span class="line">    if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123;</span><br><span class="line">        CFLog(kCFLogLevelError,</span><br><span class="line">              @&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;,</span><br><span class="line">              className + prefixLen,</span><br><span class="line">              selName,</span><br><span class="line">              receiver);</span><br><span class="line">        &lt;breakpoint-interrupt&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span><br><span class="line">    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">        if (methodSignature) &#123;</span><br><span class="line">            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">            if (signatureIsStret != isStret) &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#x27;%s&#x27;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</span><br><span class="line">                      selName,</span><br><span class="line">                      signatureIsStret ? &quot;&quot; : not,</span><br><span class="line">                      isStret ? &quot;&quot; : not);</span><br><span class="line">            &#125;</span><br><span class="line">            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line">                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">                [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">                void *returnValue = NULL;</span><br><span class="line">                [invocation getReturnValue:&amp;value];</span><br><span class="line">                return returnValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement forwardInvocation: -- dropping message&quot;,</span><br><span class="line">                      receiver,</span><br><span class="line">                      className);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL *registeredSel = sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">    // selector 是否已经在 Runtime 注册过</span><br><span class="line">    if (sel != registeredSel) &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @&quot;*** NSForwarding: warning: selector (%p) for message &#x27;%s&#x27; does not match selector known to Objective C runtime (%p)-- abort&quot;,</span><br><span class="line">              sel,</span><br><span class="line">              selName,</span><br><span class="line">              registeredSel);</span><br><span class="line">    &#125; // doesNotRecognizeSelector</span><br><span class="line">    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement doesNotRecognizeSelector: -- abort&quot;,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The point of no return.</span><br><span class="line">    kill(getpid(), 9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>实际实现,类方法也有消息转发处理<ol>
<li><code>-(id)forwardingTargetForSelector:</code>返回可以转发该方法的对象，如果是类方法则是+<ul>
<li>注意，也可以再该实例方法中返回类，可以响应的类对象（如果类方法支持的话）</li>
</ul>
</li>
<li>1中返回的是该对象本身，则会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>,先获取方法签名<ul>
<li>注意方法签名，会决定<code>NSInvocation</code>中的参数和返回值</li>
</ul>
</li>
<li>2中获取了方法签名之后，再会调用<code>forwardInvocation:(NSInvocation *)anInvocation</code>方法</li>
<li>如果最后还是没有实现方法3，则会走<code>doesNotRecognizeSelector </code>方法，发出未找到方法的错误<ul>
<li>注意，只要方法3实现了，就算没有任何实现，那么也不会去，走到<code>doesNotRecognizeSelector</code>的流程，要<strong>注意</strong><code>NSObjec</code>中<code>forwardInvocation:</code>的默认实现,如果没实际实现转发的方法，还是会触发<code>doesNotRecognizeSelector </code></li>
</ul>
</li>
</ol>
</li>
<li>注意，消息转发成功之后，在当前类的方法中是不会缓存方法的，但是在转发的类中会缓存;因此，无法从缓存中获取，每次调用该方法，都会重新走消息转发流程。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果是类方法则是+</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(text)) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8i20&quot;];</span><br><span class="line">        //不带数字位置也是可以的，v-&gt;void、@-&gt;self、:-&gt;SEL、i-&gt;int</span><br><span class="line">        // return [NSMethodSignature signatureWithObjCTypes:&quot;v@:i&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    return  [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br><span class="line">//如果是类方法则是+</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[LGPersonText alloc] init]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>NSObject</code>中的内部实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法转发流程<br><img src="3.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
<li>OC的消息机制<ul>
<li>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver发送一条消息（selector方法）</li>
<li>objc_msgSend底层有3大阶段<ul>
<li>消息发送（当前类、父类中查找），动态方法解析，消息转发</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>objc_class</title>
    <url>/2023/01/01/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/objc-class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h2><p><img src="1.png"></p>
<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><blockquote>
<p>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</p>
</blockquote>
<p><img src="2.png"></p>
<h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><blockquote>
<p>class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</p>
</blockquote>
<p><img src="3.png"></p>
<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><blockquote>
<p>method_t是对方法\函数的封装</p>
</blockquote>
<p><img src="4.png"></p>
<ul>
<li>IMP代表函数的具体实现<ul>
<li><code>typedef id _Nullable (*IMP)(id _Nonnull,SEL _Nonnull,...)</code></li>
</ul>
</li>
<li>SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似 <ul>
<li>可以通过@selector()和sel_registerName()获得</li>
<li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的 </li>
</ul>
</li>
<li>types包含了函数返回值、参数编码的字符串<ul>
<li>方法位objc_msgSend(id self,SEL,…)</li>
<li>i-&gt;int,@-&gt;id,@-&gt;SEL,f-&gt;float</li>
<li>24参数总字节，0从0字节开始，8从第8字节开始…<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">types:i24@0:8i16f20</span><br><span class="line"> i 24 @ 0 : 8 i 16 f 20</span><br><span class="line">- (int)test:(int)age height:(float)height;</span><br></pre></td></tr></table></figure>
<h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><blockquote>
<p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p>
</blockquote>
</li>
</ul>
</li>
<li>mask存储的是散列表的长度减1<br><img src="5.png"></li>
<li>缓存查找<ul>
<li><code>objc-cache.mm</code></li>
<li><code>void cache_t::insert(SEL sel, IMP imp, id receiver)</code></li>
</ul>
</li>
<li>插入之前，会先判断是否需要扩容，扩容为条件为，大于之前的3/4倍,扩容为2倍扩容，不超过最大缓存尺寸<br><img src="8.png"></li>
<li>当扩容时，会清除之前缓存的方法，也就是说，之前缓存的方法，不过传给新的扩容缓存，会全部释放。新缓存又重新开始计数<br><img src="9.png"></li>
<li>向缓存中插入方法<br><img src="6.png"></li>
<li>hash的方式，直接用SEL &amp; mask得到key的方式,会存在，冲突，根据取到的sel判断是不是同一方法<br><img src="10.png"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bucket_t *buckets = cache._buckets;</span><br><span class="line">bucket_t bucket = buckets[(long long)@selector(studentTest) &amp; cache._mask];</span><br><span class="line">//即可拿到缓存中的选择器，和实现，可能会有hash冲突，源码中会根据拿到的sel看是不是一致的</span><br><span class="line">NSLog(@&quot;%s %p&quot;, bucket._key, bucket._imp);</span><br></pre></td></tr></table></figure></li>
<li>解决hash冲突的方式，开放地址法，线性探测<br><img src="7.png"></li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>isa</title>
    <url>/2023/01/01/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/Runtime/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><blockquote>
<ul>
<li>objective-C的动态性是由runtime API来支撑的</li>
<li>runtime API提供的接口基本都是C语言的，源码又C\C++\汇编语言编写</li>
</ul>
</blockquote>
<h2 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h2><blockquote>
<ul>
<li>在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址</li>
<li>从arm64架构开始，对isa进行了优化，变成了一个共用体（<code>union</code>）(结构体和数据共用的一个内存地址，实际共用体中的结构体，只做展示作用)结构，使用位域来存储更多信息</li>
</ul>
</blockquote>
<h3 id="isa结构"><a href="#isa结构" class="headerlink" title="isa结构"></a>isa结构</h3><ol>
<li>共用体（<code>union</code>）结构(结构体和数据共用的一个内存地址，实际数据存储在bits中，共用体中的结构体，只做展示作用)<br><img src="1.png"><img src="2.png"><h3 id="从内存地址，从上往下，即地址从右边，往左"><a href="#从内存地址，从上往下，即地址从右边，往左" class="headerlink" title="从内存地址，从上往下，即地址从右边，往左"></a>从内存地址，从上往下，即地址从右边，往左</h3></li>
</ol>
<ul>
<li>nonpointer<ul>
<li>0,代表普通的指针，存储着Class、Meta—Class对象的内存地址</li>
<li>1,代表优化过，使用位域存储更多的信息</li>
</ul>
</li>
<li>has_assoc<ul>
<li>是否又设置过关联对象，如果没有，释放会更快</li>
</ul>
</li>
<li>has_cxx_dtor<ul>
<li>是否有C++的析构函数（.cxx_destruct),如果没有，释放会更快</li>
</ul>
</li>
<li>shiftcls<ul>
<li>存储着Class、Meta-Class对象的内存地址信息</li>
<li>ios中mask为<code>0x0000000ffffffff8</code>,因此，很多类以及元类的地址是以8和0结尾的，因为最后三位均是000.</li>
</ul>
</li>
<li>magic<ul>
<li>用于在调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li>weakly_referenced<ul>
<li>是否有被弱引用指向过，如果没有,释放时会更快</li>
</ul>
</li>
<li>deallocating/unused(818版本之后)<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li>extra_rc<ul>
<li>里面存储的值是引用计数器减1</li>
</ul>
</li>
<li>has_sidetable_rc<ul>
<li>引用计数器是否过大无法存储在isa中，如果为1，那么引用计数会存储在一个叫<code>SideTable</code>的类的属性中</li>
</ul>
</li>
</ul>
<p>注意，这里的都是是否有设置过，就像关联对象，就算最后将所有的关联对象删除，仍是1，如果有这些，在销毁的时候，会做额外工作<br><img src="16725690610032.png"></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
  </entry>
  <entry>
    <title>initialize</title>
    <url>/2022/12/27/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/initialize/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ol>
<li>在查找方法前，进行initialize的调用<br><img src="16721352310424.png"><img src="16721353684859.png"></li>
</ol>
<ul>
<li>类没有初始化，则去调用初始化<br><img src="16721354586849.png"></li>
<li>先查看有没有父类，且父类，没有初始化，则先初始化父类的initial<br><img src="16721355384202.png"></li>
<li>采用的是objc_msSend去调用initialize方法<br><img src="16721356497584.png"></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>initialize和load的很大区别是，initize是通过objc_msgSend进行调用的。而load是拿到函数地址后直接调用的<ul>
<li>如果子类没有实现initialize，会调用父类的initialize（所以父类的initialize可能会调用多次）</li>
<li>如果分类实现了initialize，就会覆盖本身的initialize调用</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/2022/12/27/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ol>
<li>通过runtime动态将分类的方法合并到类对象、元类对象中，并非编译</li>
<li>一个分类文件的编译后的结构体实际为<br><img src="16719733229400.png"><ul>
<li>由runtime在运行时，将分类的方法合并到类对象、元类对象中</li>
<li>编译成cpp，MJPerson(Eat)生成的 <code>_category_t</code>的静态结构体变量，其是单独的静态变量，编译时并未合入到类对象中<br><img src="16719737845768.png"></li>
</ul>
</li>
</ol>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul>
<li><p>objc4源码解读过程：objc-os.mm</p>
<ol>
<li><p>_objc_init</p>
</li>
<li><p>load_images</p>
</li>
<li><p>prepare_load_methods</p>
<ul>
<li>schedule_class_load</li>
<li>add_class_to_loadable_list</li>
<li>add_category_to_loadable_list</li>
</ul>
</li>
<li><p>call_load_methods</p>
<ul>
<li>call_class_loads</li>
<li>call_category_loads</li>
<li>(*load_method)(cls, SEL_load)</li>
</ul>
</li>
</ol>
</li>
<li><p>load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</p>
<h3 id="在runtime运行后，添加到class-rw-t的method-array-t二维方法数组中"><a href="#在runtime运行后，添加到class-rw-t的method-array-t二维方法数组中" class="headerlink" title="在runtime运行后，添加到class_rw_t的method_array_t二维方法数组中"></a>在runtime运行后，添加到class_rw_t的method_array_t二维方法数组中</h3></li>
<li><p>类的realize方法，可以看到class_rw_t实际上是在现在创建的，此前类中的bits中保存的是class_ro_t相关数据，才在这里realize，创建class_rw_t数据，并将其赋给bits中<br><img src="2.png" alt="截屏2023-01-01 23.10.16"></p>
</li>
<li><p>加载分类的方法，保证类realize完成后，再去加载分类<br><img src="1.png" alt="截屏2023-01-01 23.10.16"></p>
</li>
<li><p>核心添加方法 <code>attachLists</code></p>
</li>
<li><p>objc838版本，在构建分类大数组是，最后编译的分类，放到最前面，将所有的分类方法、属性、协议数据合并到一个大数组中<br><img src="16720409049409.png"></p>
</li>
<li><p>构建一个新数组，由后往前添加<br><img src="16720258260842.png"></p>
</li>
<li><p>objc750方法，</p>
</li>
<li><p>最后编译的分类，放到最前面，最终所有的分类方法、属性、协议数据合并到一个大数组中</p>
</li>
<li><p><img src="16720410519764.png"> </p>
</li>
<li><p>会通过memmove（内存挪动）(会根据方向挪动位置，保证数据完整性)将原来的方法列表，往后移动相应增加分类容量的位置。前面空出来的位置，用memcpy（内存拷贝）（只会从小地址，开始拷贝），添加在方法列表前面。也就是分类的方法，会在原方法的前面<br><img src="16720259301593.png"></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>为什么两个版本的，方法数组的组合方式会不一样</li>
<li>Category的实现原理<ul>
<li>Category编译之后的底层结构是struct category_t,里面吗存储着分类的对象方法、类方法、属性、协议信息</li>
<li>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</li>
</ul>
</li>
<li>Category和Class EXtension的区别是什么<ul>
<li>Class Extension在编译的时候，他的数据已经包含在类信息中</li>
<li>Category是在运行时，才会将数据合并到类信息中</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Load</title>
    <url>/2022/12/26/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Load/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Load方法"><a href="#Load方法" class="headerlink" title="Load方法"></a>Load方法</h1><ul>
<li>+load方法会在runtime加载类、分类时调用</li>
<li>每个类、分类的+load，在程序运行过程中只调用一次<ul>
<li>flags标识位保证类只会加载一次</li>
<li>这里有递归，首选会先将父类添加到数组，后将自己加进去数组，因此最后，先父类，再执行子类的load方法</li>
<li>最开始的关系时按照编译的顺序来</li>
</ul>
</li>
<li>尽管load中方法在源码中只会调用一次，但实际上主动<code>[Class load]</code>也会触发load,因此在调用<code>method_exchangeImplementations</code>做hook时，会加上<code>dispatch_once</code>，保证只会执行一次。<br><img src="16720649726860.png"><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2></li>
</ul>
<ol>
<li><p>在<code>load_images</code>中加载,首先会在<code>prepare_load_methods</code>方法中，找到类和分类的所有load方法<br><img src="16720646359112.png"></p>
</li>
<li><p>构建有类load方法的数组，以及有分类load方法的数组，整个添加顺序是</p>
<ol>
<li>类先按编译的顺序进行添加，其中父类会比子类先添加到数组中</li>
<li>分类按编译的顺序进行添加的<br><img src="16720651219179.png"></li>
</ol>
</li>
<li><p>先调用类中的load方法，再调用分类中的<br>load方法<br><img src="16720639325952.png"></p>
</li>
<li><p>再找到类中的load方法（load方法事前找到），用函数调用的方式执行，分类也是这样的，不是通过isa指针的方式（消息机制）<br><img src="16720641861246.png"></p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>调用顺序</li>
</ul>
<ol>
<li><p>先带哦用类的+load</p>
<ol>
<li>按照编译先后顺序调用，先编译，先调用</li>
<li>调用子类的+load之前会先调用父类的+load</li>
</ol>
</li>
<li><p>再调用分类的+load</p>
<ol>
<li>按照编译先后顺序调用，先编译，先调用</li>
</ol>
</li>
</ol>
<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO</title>
    <url>/2022/12/25/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/KVO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><h3 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h3><ul>
<li>未使用<code>KVO</code>监听，其<code>isa</code>指针指向的是其<code>class</code>对象，（<code>isa</code>指针、<code>superclass</code>指针、实例方法、协议列表、属性列表、成员变量）</li>
<li>使用KVO监听，其isa指向为<code>NSKVONotifying_class</code>一个全新的class对象,有<code>runtime</code>运行时，动态创建的类,<ul>
<li>该类实现为其<code>class对象</code>的子类，其内部实现了<code>class</code>、<code>delloc</code>、<code>_isKVOA</code>，以及重新了相关的set方法</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[self.person1 addObserver:self forKeyPath:@&quot;height&quot; options:options context:@&quot;456&quot;];</span><br><span class="line">    int num;</span><br><span class="line">    //=注意，这里如果用[self.person1 class]拿不到，被重写了，不会拿到实际的类</span><br><span class="line">    Method * list = class_copyMethodList(object_getClass(self.person1), &amp;num);</span><br><span class="line">    for(int i = 0;i &lt; num;i++) &#123;</span><br><span class="line">        Method method = list[i];</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromSelector(method_getName(method)));</span><br><span class="line">    &#125;</span><br><span class="line">    free(list);</span><br><span class="line">    /*</span><br><span class="line">    输出setHeight:、setAge:、class、dealloc、_isKVOA</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>

<ul>
<li>在调用set方法后实际调用了<code>_NSSetIntValueAndNotify();</code>(整型所以是int，如果是double则是<code>_NSSetDoubleValueAndNotify()</code>)</li>
<li><code>_NSSetIntValueAndNotify()</code>内，类似实现,伪代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSKVONotifying_MJPerson中</span><br><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">    _NSSetIntValueAndNotify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetIntValueAndNotify() &#123;</span><br><span class="line">    [self willChangeValueForKey:&quot;age&quot;]</span><br><span class="line">    [super setAge:age]</span><br><span class="line">    [self didChangeValueForKey:&quot;age&quot;] //里面调用监听器的方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    [observer observeValueForKeyPath:key ofObject: change: content:]//通知观察者</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果内存中有个<code>NSKVONotifying_xxx</code>类，则相应的kvo无法实现</li>
<li>通过<code>[self.person1 methodForSelector:@selector(setAge:)]</code>找到对应方法的实现，在lldb中根据内存，用<code>p (IMP)0x7ff800bde9cb</code>即可找到实际实现的方法<code>Foundation _NSSetIntValueAndNotify</code></li>
<li>被kvo的对象，其元类对象也是不同的</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>KVO的本质是什么</li>
</ol>
<ul>
<li>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</li>
<li>当修改instance对象的属性时，会调用Foundation的_NSSetxxxValueAndNotif函数<ul>
<li>willchangValueForKey</li>
<li>父类原来的setter</li>
<li>didChangeValueForKey<ul>
<li>其内部会触发监听器Obserser的监听方法（observeValueForKeyPath:ofObject:change:）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>KVO的本质是什么</li>
</ol>
<ul>
<li>设置方法时，自动触发</li>
<li>手动调用willChangeForKey：和didChangeForKey： </li>
</ul>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC</title>
    <url>/2022/12/25/iOS%E5%AD%A6%E4%B9%A0/Runtime%E7%9F%A5%E8%AF%86/KVC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><ol>
<li>通过KVC修改属性会触发KVO，例如age属性,<ul>
<li>注意，就是age属性没有实现set的方法，只有<code>成员变量</code>，通过<code>KVC</code>设置，同样会触发KVO</li>
<li>表明KVC内部实际上有调用willchangForkey、以及didChangeForKey:方法<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><img src="16719622557599.png"></li>
</ul>
</li>
<li>根据setAge:,_setAge:的顺序找到，找到则调用,设置</li>
<li>如果1没找到，查看<code>accessInstanceVariablesDirectly</code>（是否可直接查找成员变量）是否返回true，为No，直接报没找到key的异常</li>
<li>如果为true，则按照_age,_isAge,age,isAge的顺序查找成员变量，找到直接赋值<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><img src="%E6%88%AA%E5%B1%8F2022-12-25%2020.15.39.png" alt="截屏2022-12-25 20.15.39"></li>
</ol>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title>load、initialize方法的区别</title>
    <url>/2022/12/23/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/load%E3%80%81initialize%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="load、initialize方法的区别"><a href="#load、initialize方法的区别" class="headerlink" title="load、initialize方法的区别"></a>load、initialize方法的区别</h1><ol>
<li><p>调用方式</p>
<ul>
<li> load是根据函数地址直接调用</li>
<li> initialize是通过objc_msgSend调用</li>
</ul>
</li>
<li><p>调用时刻</p>
<ul>
<li>load是runtime加载类、分类的时候调用（只会调用1次）</li>
<li>initialize是累第一次接收到消息的时候调用，每个类只会initialize一次（父类的initialize方法可能会被调用多次）</li>
</ul>
</li>
<li><p>load、initialize的调用顺序</p>
<ol>
<li>load<ul>
<li>先调用类的load<ul>
<li>先编译的类，优先调用load</li>
<li>调用子类的load之前，会先调用父类的load</li>
</ul>
</li>
<li>再调用分类的load<ul>
<li>先编译的分类，优先调用load</li>
</ul>
</li>
</ul>
</li>
<li>initialize<ul>
<li>在，第一次使用的时候调用，先初始化父类，</li>
<li>再初始化子类（可能最终调用的是父类的）</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>load、initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>objc_class的结构</title>
    <url>/2022/12/21/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/objc_class%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="objc-class的结构"><a href="#objc-class的结构" class="headerlink" title="objc_class的结构"></a>objc_class的结构</h1><p><img src="16715558479895.png"></p>
<ul>
<li>如何去查看<code>objc_class</code>的源码在真实项目中用，吧objc_class结构体，在函数类直接写出来，用桥接的方式实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef MJClassInfo_h</span><br><span class="line">#define MJClassInfo_h</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br><span class="line">typedef uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cache_t &#123;</span><br><span class="line">    bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_list_t : entsize_list_tt &#123;</span><br><span class="line">    method_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_t &#123;</span><br><span class="line">    int32_t *offset;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *type;</span><br><span class="line">    uint32_t alignment_raw;</span><br><span class="line">    uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_list_t : entsize_list_tt &#123;</span><br><span class="line">    ivar_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_list_t : entsize_list_tt &#123;</span><br><span class="line">    property_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct chained_property_list &#123;</span><br><span class="line">    chained_property_list *next;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    property_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;</span><br><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;  // 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;  // 成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_list_t * methods;    // 方法列表</span><br><span class="line">    property_list_t *properties;    // 属性列表</span><br><span class="line">    const protocol_list_t * protocols;  // 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* OC对象 */</span><br><span class="line">struct mj_objc_object &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 类对象 */</span><br><span class="line">struct mj_objc_class : mj_objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mj_objc_class* metaClass() &#123;</span><br><span class="line">        return (mj_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* MJClassInfo_h */</span><br></pre></td></tr></table></figure></li>
<li>实际使用,即可查看相关类<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        MJStudent *stu = [[MJStudent alloc] init];</span><br><span class="line">        stu-&gt;_weight = 10;</span><br><span class="line">        </span><br><span class="line">        mj_objc_class *studentClass = (__bridge mj_objc_class *)([MJStudent class]);</span><br><span class="line">        mj_objc_class *personClass = (__bridge mj_objc_class *)([MJPerson class]);</span><br><span class="line">        </span><br><span class="line">        class_rw_t *studentClassData = studentClass-&gt;data();</span><br><span class="line">        class_rw_t *personClassData = personClass-&gt;data();</span><br><span class="line">        </span><br><span class="line">        class_rw_t *studentMetaClassData = studentClass-&gt;metaClass()-&gt;data();</span><br><span class="line">        class_rw_t *personMetaClassData = personClass-&gt;metaClass()-&gt;data();</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;1111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>isa指针</title>
    <url>/2022/12/19/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/isa%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h1><ul>
<li>从64bit开始，isa需要进行一次位运算，才能计算出真实地址,<code>isa &amp; ISA_MASK</code>即为实际的isas地址<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#     define ISA_MASK   0x0000000ffffffff8ULL</span><br><span class="line">elif __x86_64__</span><br><span class="line"># define ISA_MASK        0x00007ffffffffff8ULL</span><br></pre></td></tr></table></figure></li>
<li>Class中的isa指针没有暴露出来，可以通过构建一个相同的结构体，通过桥接得到<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">&#125;;</span><br><span class="line">struct objc_class *personClass = (__bridge struct objc_class *)([Person class]);</span><br></pre></td></tr></table></figure></li>
<li>superclass直接指向父类，不需要转换</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>OC对象的分类</title>
    <url>/2022/12/18/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h1><p>主要分为3种</p>
<ol>
<li><code>instance</code>对象，实例对象 </li>
<li><code>class</code>对象，类对象</li>
<li><code>meta-class</code>对象，元类对象<h2 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h2>通过类alloc出来的对象，instance对象在内存种存储的信息（只有成员变量）包括</li>
</ol>
<ul>
<li>isa指针</li>
<li>其他成员变量</li>
</ul>
<p>isa指针始终在对象结构体的前面，因此，isa指针的地址即实例对象的地址</p>
<h2 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h2><ul>
<li><code>[objec class]</code>、<code>[NSObject class]</code>、<code>object_getClass(object)</code>都是获取<code>NSobject</code>的<code>class</code>对象</li>
<li>它们都是同一个对象，在内存中有且只有一个class对象</li>
<li>class对象在内存中存储的信息主要包括</li>
</ul>
<ol>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的属性信息（@property）、类的<code>对象方法</code>信息（instance method）</li>
<li>类的协议信息（protocol）、类的成员变量信息（ivar）<ol>
<li>ivar并非成员变量的值，成员变量的值有instance决定</li>
<li>ivar实际存储的类型，名称等描述信息<h2 id="元类对象"><a href="#元类对象" class="headerlink" title="元类对象"></a>元类对象</h2><code>object_getClass([NSObject class])</code>获取元类对象，元类对象结构和类结构一样都是<code>class</code>,其结构相同，不过元类对象中除isa指针、superclass指针、类方法信息外，其他均为null<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系<img src="16713605118546.png"></h3></li>
</ol>
</li>
<li>instance的isa指向class</li>
<li>class的isa指向meta-class</li>
<li>meta-class的isa指向基类的meta-class</li>
<li>class的superclass指向父类的class<ol>
<li>如果没有父类，superclass指针为nil</li>
</ol>
</li>
<li>meta-class的superclass指向父类的meta-class<ol>
<li>基类的meta-class的superclass指向基类的class</li>
</ol>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>NSObject</title>
    <url>/2022/12/17/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16708614441261/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个NSObject对象占用多少内存？"><a href="#一个NSObject对象占用多少内存？" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个<code>NSObject</code>对象占用多少内存？</h1><h3 id="一个NSObject对象占用多少内存？-1"><a href="#一个NSObject对象占用多少内存？-1" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个<code>NSObject</code>对象占用多少内存？</h3><ul>
<li>系统分配了16个字节给<code>NSObject</code>对象（通过<code>malloc_size</code>函数获得）</li>
<li>但<code>NSObject</code>对象内部只使用了8个字节（<code>isa</code>指针）的空间（64bit环境下，可以通过<code>class_getInstanceSize</code>函数（经过内存对齐过的值）获得<ol>
<li>用<code>clang -rewrite-objc main.m -o main.cpp</code>编译成<code>C++</code>文件（全平台），</li>
<li><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code>(推荐)编译成指定平台的</li>
<li>16字节而不是8字节的原因,源码中可以看到，是<code>Foundation</code>框架规定的，最小16字节<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)</span><br><span class="line">&#123;</span><br><span class="line">    void *bytes;</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    // Can&#x27;t create something for nothing</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line"></span><br><span class="line">    // Allocate and initialize</span><br><span class="line">    size = cls-&gt;alignedInstanceSize() + extraBytes;</span><br><span class="line"></span><br><span class="line">    // CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size = 16;</span><br><span class="line"></span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        bytes = malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bytes = calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return objc_constructInstance(cls, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>扩展例子<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @interface student: NSObject &#123;</span><br><span class="line"> int _no;</span><br><span class="line"> int _age;</span><br><span class="line"> &#125; </span><br><span class="line"> @end</span><br><span class="line"> </span><br><span class="line"> 实际为</span><br><span class="line">struct Student_IMPL &#123;</span><br><span class="line">Class isa; //8字节，（注意NSObect会分配16字节，但是isa结构体是8字节）</span><br><span class="line">int _no; //4字节</span><br><span class="line">int _age; //4 字节</span><br><span class="line">&#125;</span><br><span class="line">内存对齐: 结构体的大小必须是最大成员大小的倍数</span><br></pre></td></tr></table></figure></li>
<li>注意，ios操作系统的内存对齐，是按16倍为来进行分配的， 例如<code>class_getInstanceSize</code>计算<strong>只需(至少)<strong>24位大小，但是用<code>malloc_size</code>计算</strong>实际</strong>分配的确实32位 </li>
<li>注意，<code>sizeof</code>实际上是运算符，并不是函数，和以上两个函数有区别，在编译的时候，就会决定了，例如<code>sizeof(指针)</code>，在编译就设置为8，实际不知道内存中的大小<h3 id="常用LLDB指令"><a href="#常用LLDB指令" class="headerlink" title="常用LLDB指令"></a>常用LLDB指令</h3></li>
</ul>
<ol>
<li><code>print、p</code>：打印</li>
<li><code>po</code>: 打印对象</li>
<li>读取内存<ol>
<li><code>memory red/数量格式字节数 内存地址</code>:`memory red/3xw 0x10010</li>
<li><code>x/数量格式字节数 内存地址</code>: x/3xw 0x10010</li>
<li>格式: x-16进制，d是10进制</li>
<li>字节大小:b 1字节，h 2字节，w 4字节，g 8字节</li>
</ol>
</li>
<li>修改内存中的值，<code>memory write 内存地址 数值</code>：memory write 0x0000010 10</li>
<li><h3 id="对象的isa指针指向哪里"><a href="#对象的isa指针指向哪里" class="headerlink" title="对象的isa指针指向哪里"></a>对象的isa指针指向哪里</h3></li>
</ol>
<ul>
<li>instance对象的isa指针指向类对象</li>
<li>类对象的isa指针指向元类对象</li>
<li>元类对象的isa指针指向基类的元类对象<h3 id="OC的类信息存放在哪里"><a href="#OC的类信息存放在哪里" class="headerlink" title="OC的类信息存放在哪里"></a>OC的类信息存放在哪里</h3></li>
<li>对象的方法、属性、协议信息、成员变量，存放在类对象</li>
<li>类方法存放在元类对象</li>
<li>成员变量的具体值，存放在instance</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title>NSObject</title>
    <url>/2022/12/17/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/NSObject/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个NSObject对象占用多少内存？"><a href="#一个NSObject对象占用多少内存？" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个<code>NSObject</code>对象占用多少内存？</h1><h3 id="一个NSObject对象占用多少内存？-1"><a href="#一个NSObject对象占用多少内存？-1" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个<code>NSObject</code>对象占用多少内存？</h3><ul>
<li>系统分配了16个字节给<code>NSObject</code>对象（通过<code>malloc_size</code>函数获得）</li>
<li>但<code>NSObject</code>对象内部只使用了8个字节（<code>isa</code>指针）的空间（64bit环境下，可以通过<code>class_getInstanceSize</code>函数（经过内存对齐过的值）获得<ol>
<li>用<code>clang -rewrite-objc main.m -o main.cpp</code>编译成<code>C++</code>文件（全平台），</li>
<li><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code>(推荐)编译成指定平台的</li>
<li>16字节而不是8字节的原因,源码中可以看到，是<code>Foundation</code>框架规定的，最小16字节<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)</span><br><span class="line">&#123;</span><br><span class="line">    void *bytes;</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    // Can&#x27;t create something for nothing</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line"></span><br><span class="line">    // Allocate and initialize</span><br><span class="line">    size = cls-&gt;alignedInstanceSize() + extraBytes;</span><br><span class="line"></span><br><span class="line">    // CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size = 16;</span><br><span class="line"></span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        bytes = malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bytes = calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return objc_constructInstance(cls, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>扩展例子<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @interface student: NSObject &#123;</span><br><span class="line"> int _no;</span><br><span class="line"> int _age;</span><br><span class="line"> int _height; </span><br><span class="line"> &#125; </span><br><span class="line"> @end</span><br><span class="line"> </span><br><span class="line"> 实际为</span><br><span class="line">struct Student_IMPL &#123;</span><br><span class="line">Class isa; //8字节，（注意NSObect会分配16字节，但是isa结构体是8字节）</span><br><span class="line">int _no; //4字节</span><br><span class="line">int _age; //4 字节</span><br><span class="line">int _height; // 4 字节</span><br><span class="line">&#125;</span><br><span class="line">内存对齐: 结构体的大小必须是最大成员大小的倍数,实际为24字节，但是用`malloc_size`计算分配是32</span><br></pre></td></tr></table></figure></li>
<li>注意，ios操作系统的内存对齐，是按16倍为来进行分配的， 例如<code>class_getInstanceSize</code>计算<strong>只需(至少)<strong>24位大小，但是用<code>malloc_size</code>计算</strong>实际</strong>分配的确实32位 </li>
<li>注意，<code>sizeof</code>实际上是运算符，并不是函数，和以上两个函数有区别，在编译的时候，就会决定了，例如<code>sizeof(指针)</code>，在编译就设置为8，实际不知道内存中的大小<h3 id="常用LLDB指令"><a href="#常用LLDB指令" class="headerlink" title="常用LLDB指令"></a>常用LLDB指令</h3></li>
</ul>
<ol>
<li><code>print、p</code>：打印</li>
<li><code>po</code>: 打印对象</li>
<li>读取内存<ol>
<li><code>memory red/数量格式字节数 内存地址</code>:`memory red/3xw 0x10010</li>
<li><code>x/数量格式字节数 内存地址</code>: x/3xw 0x10010</li>
<li>格式: x-16进制，d是10进制</li>
<li>字节大小:b 1字节，h 2字节，w 4字节，g 8字节</li>
</ol>
</li>
<li>修改内存中的值，<code>memory write 内存地址 数值</code>：memory write 0x0000010 10</li>
</ol>
<h3 id="对象的isa指针指向哪里"><a href="#对象的isa指针指向哪里" class="headerlink" title="对象的isa指针指向哪里"></a>对象的isa指针指向哪里</h3><ul>
<li>instance对象的isa指针指向类对象</li>
<li>类对象的isa指针指向元类对象</li>
<li>元类对象的isa指针指向基类的元类对象<h3 id="OC的类信息存放在哪里"><a href="#OC的类信息存放在哪里" class="headerlink" title="OC的类信息存放在哪里"></a>OC的类信息存放在哪里</h3></li>
<li>对象的方法、属性、协议信息、成员变量，存放在类对象</li>
<li>类方法存放在元类对象</li>
<li>成员变量的具体值，存放在instance</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>类的结构</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/09/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16706010476870/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FishHook"><a href="#FishHook" class="headerlink" title="FishHook"></a>FishHook</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS中通过<code>Method Swizzling</code>实现<code>hook</code>，其原理是利用OC的<code>Runtime</code>特性，动态改变<code>SEL</code>（方法编号）和<code>IMP</code>（方法实现）的对应关系，达到OC方法交换的目的。然而只适用于动态的OC方法，对于C函数Hook，可以引用fishHook，通过修改machO文件中<code>la_symbol_ptr</code>和<code>non_la_symbol_ptr</code>两个表的指针达到C函数HOOK的目的。</p>
<h2 id="框架地址"><a href="#框架地址" class="headerlink" title="框架地址"></a>框架地址</h2><p><code>fishhook</code>是一个非常简单的库，可以在模拟器和设备上运行在iOS上的Mach-O二进制文件中动态重新绑定符号,代码地址<a href="https://github.com/facebook/fishhook">https://github.com/facebook/fishhook</a></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>头文件导入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &quot;fishhook.h&quot;</span><br></pre></td></tr></table></figure></li>
<li>交换制定的C函数,构建<code>rebinding</code>结构体<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct rebinding rebindSend;</span><br><span class="line">rebindSend.name = &quot;NSLog&quot;;</span><br><span class="line">rebindSend.replacement = (void *)hook_Objc_nslog;</span><br><span class="line">rebindSend.replaced = (void **)&amp;orig_objc_nslog;</span><br></pre></td></tr></table></figure></li>
<li><code>rebind_symbols</code>重新绑定符号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct rebinding rebs[] = &#123;rebindSend&#125;;</span><br><span class="line">rebind_symbols(rebs, 1);</span><br></pre></td></tr></table></figure></li>
<li>完整使用用例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  FishHooklViewController.m</span><br><span class="line">//  transitionController</span><br><span class="line">//</span><br><span class="line">//  Created by 陈晶泊 on 2022/8/10.</span><br><span class="line">//</span><br><span class="line">#import &quot;fishhook.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#import &quot;FishHooklViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface FishHooklViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FishHooklViewController</span><br><span class="line">__unused static void(*orig_objc_nslog)(NSString *format, ...);</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = UIColor.whiteColor;</span><br><span class="line">    struct rebinding rebindSend;</span><br><span class="line">    rebindSend.name = &quot;NSLog&quot;;</span><br><span class="line">    rebindSend.replacement = (void *)hook_Objc_nslog;</span><br><span class="line">    rebindSend.replaced = (void **)&amp;orig_objc_nslog;</span><br><span class="line">    struct rebinding rebs[] = &#123;rebindSend&#125;;</span><br><span class="line">    rebind_symbols(rebs, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hook_Objc_nslog(NSString *format, ...) &#123;</span><br><span class="line">    format = [format stringByAppendingFormat:@&quot;已hook&quot;];</span><br><span class="line">    orig_objc_nslog(format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;FishHooklViewController&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><code>MachO</code>文件的静态链接在编译的时候，就确定了方法地址，位于代码段模，是不可写的，因此静态链接的函数方法，在运行时是无法更改的。<br>然而动态链接，是在运行时进行方法链接的，在<code>MachO</code>文件中，访问动态库里的数据符号地址放在<code>got</code>(也称<code>Non-Lazy Symbol Pointers</code>)数据段，调用动态库的函数的地址放在<code>la_symbol_ptr</code>数据段的数据段中，是可读写的，因此可以在程序运行期间修改<code>got</code>(<code>non_la_symbol_ptr</code>)和<code>la_symbol_ptr</code>数据段，来替换函数跟全局变量的地址。<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-传入需要替换的函数"><a href="#1-传入需要替换的函数" class="headerlink" title="1. 传入需要替换的函数"></a>1. 传入需要替换的函数<img src="16706010476870/16706577321150.png"></h4> <code>rebindings_head</code>的<code>next</code>为nil是第一次调用；去注册方法，其中<code>_dyld_register_func_for_add_image</code>做了2件事，1.是跟<code>else</code>里面一样，为每个image(镜像)调用<code>_rebind_symbols_for_image</code>，2.是当<code>dyld</code>后面加载镜像时候，也为这个新镜像调用<code>_rebind_symbols_for_image</code>。<br> <code>rebindings_head</code>采用的链表结构，具体如下:<br><img src="16706010476870/16706578333010.jpg"><h4 id="2-计算地址"><a href="#2-计算地址" class="headerlink" title="2. 计算地址"></a>2. 计算地址</h4><code>rebind_symbols_for_image</code>方法的目的，主要是计算基址，找到符号表、字符串表、间接符号表、<code>nl_symbol_ptr(got)</code>以及<code>la_symbol_ptr</code>数据段的地址。</li>
<li>首先遍历加载命令，获得<code>MachO</code>文件中符号表、间接符号表、<code>LINKEDIT</code>三个加载命令<br><img src="16706010476870/16706583225213.png"></li>
<li>根据<code>LINKEDIT</code>获取的真实基址，根据第一步中得到的加载命令，确定符号表、间接符号表、字符串表的虚拟内存地址<br><img src="16706010476870/16706584145390.png"></li>
<li>遍历加载命令，找到数据段，在从数据段的<code>section</code>中找到<code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code></li>
</ol>
<p><img src="16706010476870/16706586123063.png"></p>
<h4 id="3-方法替换"><a href="#3-方法替换" class="headerlink" title="3. 方法替换"></a>3. 方法替换</h4><p>最后遍历<code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code>可修改的变量和数据地址，并结合间接符号表、符号表、以及字符串表，得到地址对应的函数，变量名称，找到相同的名称，即可进行地址的替换。<br><img src="16706010476870/16706587741784.png"></p>
<h2 id="通过MachOView分析"><a href="#通过MachOView分析" class="headerlink" title="通过MachOView分析"></a>通过MachOView分析</h2><ol>
<li>计算出符号表、间接符号表、字符串表的地址<br><img src="16706010476870/%E6%88%AA%E5%B1%8F2022-12-10%2016.07.46.png" alt="截屏2022-12-10 16.07.46"></li>
<li><code>nl_symbol_ptr(got)</code>/<code>la_symbol_ptr</code>可修改的变量和函数数据地址，其中<code>reserved1</code>即为数据段中的函数在间接符号表中的位置<br><img src="16706010476870/%E6%88%AA%E5%B1%8F2022-12-10%2016.16.25.png" alt="截屏2022-12-10 16.16.25"></li>
<li>间接符号表中的地址，和实际数据段地址是对应的，其中间接符号表中的数据，实际对应的是符号表中的索引。<br><img src="16706010476870/%E6%88%AA%E5%B1%8F2022-12-10%2016.20.04.png" alt="截屏2022-12-10 16.20.04"></li>
</ol>
<p><img src="16706010476870/16706604848859.png"><br>4. 符号表中，关联由字符串表，从而知道函数的名称，因此，最终，根据名称，从间接符号表中拿到原始函数地址，从而完成了方法的替换。<br><img src="16706010476870/%E6%88%AA%E5%B1%8F2022-12-10%2016.24.10.png" alt="截屏2022-12-10 16.24.10"></p>
<h2 id="FishHook应用实例"><a href="#FishHook应用实例" class="headerlink" title="FishHook应用实例"></a>FishHook应用实例</h2><p><code>SMCallTrace</code>通过hook<code>objc_msgSend</code>方法，hook了所有OC的方法，在hook方法中通过汇编语言来计算方法的耗时，可以用来项目中方法的执行情况。在需要检测耗时时间的地方调用 <code>[SMCallTrace start]</code>，结束时调用 <code>stop</code> 和 <code>save</code> 就可以打印出方法的调用层级和耗时了。还可以设置最大深度和最小耗时检测，来过滤不需要看到的信息。<a href="https://github.com/ming1016/GCDFetchFeed">源码地址</a><br>具体使用后的效果<img src="16706010476870/IMG_963F24C3F87F-1.jpeg" alt="IMG_963F24C3F87F-1"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/06/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16703379364755/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="theos-tweak原理"><a href="#theos-tweak原理" class="headerlink" title="theos-tweak原理"></a>theos-tweak原理</h1><ol>
<li><code>make</code>指令实际上是将<code>Tweak.xm</code>的代码编译成动态库</li>
<li><code>make packpage</code>指令，将动态库文件打包成了<code>deb</code>文件，插件安装包</li>
<li><code>make install</code>指令，远程登录手机安装插件到app内，<code>Makefile</code>文件内配置<ol>
<li>安装完的包会在<code>/Library/MobileSubstrate/DynamicLibraries</code>文件夹内,包含动态库，以及相关的<code>.plist</code>文件(里面由相关应用的bundlId)</li>
<li>该文件夹由Cydia管理</li>
</ol>
</li>
<li>对应bundlId的应用打开后，会加载相关插件的动态库到内存中（不会缓存，每次重新打开，都会加载），去做交换方法的操作</li>
<li>实际上没次动态修改，并为修改代码<h3 id="过程图"><a href="#过程图" class="headerlink" title="过程图"></a>过程图</h3><img src="16703379364755/16703398332015.png"></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/22/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16690971923137/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IPC时间推送"><a href="#IPC时间推送" class="headerlink" title="IPC时间推送"></a>IPC时间推送</h1><p>1、消息列表点击事件消息不再弹出购买套餐提示，消息列表点击事件消息，统一跳转至对应事件的播放器页面弹出相对应的提示<br>2、事件播放器页面App判断事件列表里是否存在视频URL，若视频URL不为空，则表示事件上报时用户购买了套餐，则App可以直接播放视频，如视频无法播放则提示「该视频已过期」<br>3、若视频URL为空，则App调用支付平台接口判断用户当前是否购买套餐，若用户当前已购买套餐，则在APP的事件播放器页面提示「因该视频生成时未购买云套餐，无法支持其播放」<br>4、若视频URL为空，并且用户当前没有购买套餐，则在APP的事件播放器页面去弹框引导用户购买套餐</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/06/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16677424889825/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="练习一-喜玛拉广告去除"><a href="#练习一-喜玛拉广告去除" class="headerlink" title="练习一 喜玛拉广告去除"></a>练习一 喜玛拉广告去除</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><code>Revel</code>中查看广告的图层信息，通过Cycript<code>[#0x12333 removeFromSuperlayer]</code>只能暂时将广告屏蔽</li>
<li>用<code>CLutch</code>脱壳应用，<code>class-dump</code>指令拿到头文件信息，查看相关视图图层的信息，通过hook的方式去去除广告<h1 id="练习二，桌面更新数字去除"><a href="#练习二，桌面更新数字去除" class="headerlink" title="练习二，桌面更新数字去除"></a>练习二，桌面更新数字去除</h1></li>
</ol>
<ul>
<li>iOS桌面为<code>springboard</code>，位置在<code>/System/Library/CoreServices/SpringBoard.app</code></li>
<li><code>springboard</code>无法通过<code>revel</code>的方式查看，需要用<code>cycript</code>的方式查看</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/05/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16676513774655/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="用theos去hook"><a href="#用theos去hook" class="headerlink" title="用theos去hook"></a>用theos去hook</h1><ol>
<li>安装threos<a href="media/16676513774655/07-theos%E7%9A%84%E5%89%AF%E6%9C%AC.pdf">theos安装教程</a></li>
<li><code>nic.pl</code>指令选择创建<code>iphone/tweak</code>项目,（自己的bundId，和越狱app的bundId）<ol>
<li>在生成的Makefile文件内，增加端口信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export THEOS_DEVICE_IP = localhost</span><br><span class="line">export THEOS_DEVICE_PORT = 100010</span><br><span class="line">include $(THEOS)/makefiles/common.mk</span><br><span class="line">TWEAK_NAME = tingweak</span><br></pre></td></tr></table></figure>
<ul>
<li><code>THES_DEVICE_IP</code>,<code>THEOS_DEVICE_PORT</code>可以配置到.bash_profile的文件下,全局配置</li>
</ul>
</li>
<li>实际在Tweak.x文件内进行hook，找到相应的view，然后写hook后的方法.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  #import &lt;UIKit/UIView.h&gt;</span><br><span class="line"> %hook XMNowPlayingADView</span><br><span class="line">   - (id)initWithFrame:(struct CGRect)arg1 &#123;</span><br><span class="line">       return nil;</span><br><span class="line">   &#125;</span><br><span class="line"> %end</span><br><span class="line"> ///%orig(arg1,arg2);调用原始方法</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>make</code> 自动编译makefile中的文件</li>
<li><code>make package</code>打包成越狱插件</li>
<li><code>make install</code>默认安装到手机上</li>
<li>手机重启，则会看到修改后的程序，注入的包位置在<code>/library/MobileSubstrate/DynamicLibraries</code>位置，删除，则无效果了（Cydia中也有该插件）<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2></li>
</ol>
</li>
<li>在生成的Tweak.x文件中的方法，一般均会被认为是要hook替换的，如果没有的话，则不会生效。如果是新方法的话，需要在方法前加<code>%new</code></li>
<li><code>%orig</code>为原始方法</li>
<li>资源文件，<ol>
<li>内部图片，则放到<code>对应应用内</code>,</li>
<li>如果加载自己的，则用<code>imageWithContentsOfFile:</code>加载图片路径，例如，<code>/text.png</code>则在文件根目录</li>
<li>在theos中直接打包资源文件，在中，构建一个<code>layout</code>文件夹(实际放在<code>根目录</code>下)，将资源放进去，一般会放到<code>layout/Library/PreferenceLoader/Preferences</code>目录下（偏好设置），其他的可以放到<code>layout/Library/Caches</code>文件中</li>
</ol>
</li>
<li>注意<code>theos</code>将其他类型认为是id，因此直接用<code>self.view</code>是会报错的，要用<code>[self view]</code></li>
<li>可以像OC项目一样,多文件开发，建立相关的.h和.m文件，然后在<code>Tweak.x</code>文件中按正常的#import导入(注意文件夹)即可，此外在<code>Makefile</code>中要指定编译的文件<code>tweaksp_FILES = xxx/Tweak.x xxx/xxxx.m</code>，也可以通过<code>tweaksp_FILES = xxx/*.x</code>导入，但是无法用<code>xxx/**/*.x</code>的方式,必须指定文件夹</li>
<li>生成<code>Realease</code>版本，<code>make package debug=0</code></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/03/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Mach-o%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mach-o文件"><a href="#Mach-o文件" class="headerlink" title="Mach-o文件"></a>Mach-o文件</h1><ul>
<li>一个Mach-O文件包含3个主要区域<ul>
<li>Header <ul>
<li>文件类型、目标架构类型等</li>
</ul>
</li>
<li>Load commands<ul>
<li>描述文件在虚拟内存中的逻辑结构、布局</li>
</ul>
</li>
<li>Raw segment data<ul>
<li>在Load commands中定义的Segment的原始数据<br><img src="16674865436160.jpg"><h2 id="常见的Mach-o文件"><a href="#常见的Mach-o文件" class="headerlink" title="常见的Mach-o文件"></a>常见的Mach-o文件</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>MH_OBJECT<ul>
<li>目标文件（.o）</li>
<li>静态库文件(.a），静态库其实就是N个.o合并在一起</li>
</ul>
</li>
<li>MH_EXECUTE：可执行文件<ul>
<li>.app/xx</li>
</ul>
</li>
<li>MH_DYLIB：动态库文件<ul>
<li>.dylib</li>
<li>.framework/xx</li>
</ul>
</li>
<li>MH_DYLINKER：动态链接编辑器<ul>
<li>/usr/lib/dyld</li>
</ul>
</li>
<li>MH_DSYM：存储着二进制文件符号信息的文件<ul>
<li>.dSYM/Contents/Resources/DWARF/xx（常用于分析APP的崩溃信息）</li>
</ul>
</li>
</ol>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="file："><a href="#file：" class="headerlink" title="file："></a>file：</h3><ul>
<li>查看Mach-O的文件类型</li>
<li><code>file  文件路径</code><h3 id="otool："><a href="#otool：" class="headerlink" title="otool："></a>otool：</h3></li>
<li>查看Mach-O特定部分和段的内容<ul>
<li><code>otool -L 文件路径</code>查看依赖的库</li>
<li><code>otool -h 文件路径</code>mach中head的信息</li>
<li><code>otool -l 文件路径</code>mach中loadcommand的信息<h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3></li>
</ul>
</li>
<li><code>dyld</code>是mach-o文件（MH_DYLINKER），但是它也能加载mach-o文件，但是只能加载<ul>
<li><code>MH_EXEUTE</code>，可执行文件</li>
<li><code>MH_DYLIB</code>,动态库</li>
<li><code>MH_BUNDLE</code></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/01/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16673137289641/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hopper"><a href="#Hopper" class="headerlink" title="Hopper"></a>Hopper</h1><h2 id="Mach-o"><a href="#Mach-o" class="headerlink" title="Mach-o"></a>Mach-o</h2><ul>
<li>机器码可以反编译成汇编，但是汇编很难反编译成OC<h2 id="ios系统Mach-o文件在手机上"><a href="#ios系统Mach-o文件在手机上" class="headerlink" title="ios系统Mach-o文件在手机上"></a>ios系统Mach-o文件在手机上</h2></li>
<li>从iOS3.1开始，为了提高性能，绝大部分的系统动态库文件都打包存放到了一个缓存文件中（<code>dyld shared cache</code>）<ol>
<li>缓存文件路径：<code>/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armX</code></li>
<li>绝大部分的系统动态库都放在共享缓存中，一个文件中，（多个动态库<code>mach</code>会有多个描述信息，因此降低内存，放到了一个文件中，也就是mach文件中<code>dlyld</code>(命令在/usr/lib中)加载指令(通过这个指令去加载动态库)，只会加载到一处）</li>
<li>用<code>[[NSBundle bundleWithPath:&quot;/System/Library/Frameworks/UIKit.framework&quot;] load]</code>去加载动态库，实际上是调用2.中<code>dlyld</code>去判断是否在缓存中，有则去1.位置处的共享缓存去加载<code>UIKit.framework</code></li>
<li><a href="https://opensource.apple.com/tarballs/dyld/">dyld源码 </a></li>
<li><code>dlyld</code>中的<code>dsc_extractor</code>文件可以，将1中缓存文件抽取出压缩在里面的库<ol>
<li>先用<code>clang++</code>编译,`clang++ -o dsc_extractor dsc_extractor.cpp</li>
<li><code>/dsc_extractor dyld_shared_cache_armv7s armv7s</code>所有动态库在呵rmv7s文件夹中<br>`</li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/01/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16672327206592/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h1><pre><code>-它的作用就是把Mach-O文件的class信息给dump出来（把类信息给导出来），生成对应的.h头文件
</code></pre>
<hr>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>将命令放大/usr/local/bin目录下(mac下不能放到/usr/bin下)</li>
<li><code>class-dump  -H  Mach-O文件路径  -o  头文件存放目录</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/10/29/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16670400106477/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SSH常用指令"><a href="#SSH常用指令" class="headerlink" title="SSH常用指令"></a>SSH常用指令</h1><ul>
<li>ssh <a href="mailto:&#x72;&#111;&#x6f;&#x74;&#64;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#46;&#x31;&#46;&#x31;&#x34;">&#x72;&#111;&#x6f;&#x74;&#64;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#46;&#x31;&#46;&#x31;&#x34;</a>,跳转到指定ip的命令</li>
<li>ssh-keygen -R 192.168.1.14,删除ip保存的公钥<h2 id="客户端认证密钥"><a href="#客户端认证密钥" class="headerlink" title="客户端认证密钥"></a>客户端认证密钥</h2></li>
</ul>
<ol>
<li>ssh-keygen -t rsa,生成公钥和私钥,认证密钥，下次不用输入密码<ul>
<li>公钥追加到服务器授权文件（.ssh/authorized_keys）的尾部，ssh-copy-id <a href="mailto:&#114;&#111;&#x6f;&#116;&#x40;&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#56;&#46;&#49;&#46;&#x31;&#x34;">&#114;&#111;&#x6f;&#116;&#x40;&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#56;&#46;&#49;&#46;&#x31;&#x34;</a>，追加到当前ip服务器授权文件的尾部</li>
</ul>
</li>
<li>scp <del>/.ssh/id_rsa.pub <a href="mailto:&#x72;&#x6f;&#111;&#116;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#56;&#46;&#49;&#x2e;&#x31;&#52;">&#x72;&#x6f;&#111;&#116;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#56;&#46;&#49;&#x2e;&#x31;&#52;</a>:</del>/.ssh，基于SSH登录进行安全的远程文件拷贝命令,将id_rsa.pub文件拷贝到.ssh文件下<ul>
<li>cat id_rsa.pub &gt;&gt; authorized_keys,将id_rsa.pub内容加到authorized_keys中(同样可以实现认证密钥，不用输入密码)<h2 id="权限赋予"><a href="#权限赋予" class="headerlink" title="权限赋予"></a>权限赋予</h2></li>
</ul>
</li>
</ol>
<ul>
<li>chmod 755 ~/.ssh 给文件夹赋予权限，755含义<ul>
<li>读（r=4），写（w=2），执行（x=1）</li>
<li>文件所有者可读可写可执行                                   –7</li>
<li>与文件所有者同属一个用户组的其他用户可读可执行                 –5 </li>
<li>其它用户组可读可执行                                       –5<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2></li>
</ul>
</li>
<li>每个端口都有个端口号，（范围是0～65535，公2^16）</li>
<li>21端口，FTP服务</li>
<li>80端口，http服务</li>
<li>22端口，ssh服务<h2 id="通过USB进行SSH登录"><a href="#通过USB进行SSH登录" class="headerlink" title="通过USB进行SSH登录"></a>通过USB进行SSH登录</h2></li>
<li>默认会用网络登录，USB登录的方式是，先用SSH登录MAC上的10010端口(非保留端口均可)，在通过usbmuxd连接22端口</li>
<li>将iPhone的22端口（SSH端口）映射到Mac本地的10010端口</li>
<li>用python脚本，将mac上10010映射到22，python3 tcprelay.py -t 22:10010</li>
<li>ssh root@localhost -p 10010,直接连接本地的10010接口</li>
<li>scp -P 10010 <del>/.ssh/id_rsa.pub root@localhost:</del>,拷贝的方法</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/09/11/iOS%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/16629071383706/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Flutter-常用指令"><a href="#Flutter-常用指令" class="headerlink" title="Flutter 常用指令"></a>Flutter 常用指令</h1><ul>
<li>flutter run –no-sound-null-safety  解决flutter插件旧版本兼容问题</li>
<li>flutter create –template=package hello 创建pakcage</li>
<li>flutter create -t module flutter_module 创建fluttermodule</li>
<li>flutter create example 创建flutter项目<h1 id="Flutter包发布指令"><a href="#Flutter包发布指令" class="headerlink" title="Flutter包发布指令"></a>Flutter包发布指令</h1></li>
<li>flutter packages pub publish –dry-run 检查发布前需要准备什么</li>
<li>flutter packages pub publish 直接发布，需要外网，还有授权（注意不要设置代理使用国内镜像）<h1 id="flutter插件"><a href="#flutter插件" class="headerlink" title="flutter插件"></a>flutter插件</h1></li>
<li>flutter create –org com.flutter_plugine –template=plugin –platforms=ios,macos -i swift flutter_plugin  插件新建</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>详解iOS的presentViewController</title>
    <url>/2021/07/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E8%AF%A6%E8%A7%A3iOS%E7%9A%84presentViewController/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS中显示ViewController的方式有两种push和modal，modal也叫模态，模态显示VC是iOS的重要特性之一，其主要用于有以下场景：</p>
<ol>
<li>收集用户输入信息 </li>
<li> 临时呈现一些内容 </li>
<li>临时改变工作模式 </li>
<li>相应设备方向变化（用于针对不同方向分别是想两个ViewController的情况）</li>
<li> 显示一个新的view层级</li>
</ol>
<p>这些场景都会暂时中断APP的正常执行流程，主要作用是收集信息以及显示一些重要的提示等。当VCA模态的弹出了VCB，那么VCA就是<code>presenting view controller</code>，VCB就是<code>presented view controller</code></p>
</blockquote>
<h3 id="ModalPresentationStyle-amp-Presentation-Context"><a href="#ModalPresentationStyle-amp-Presentation-Context" class="headerlink" title="ModalPresentationStyle &amp; Presentation Context"></a>ModalPresentationStyle &amp; Presentation Context</h3><h4 id="ModalPresentationStyle"><a href="#ModalPresentationStyle" class="headerlink" title="ModalPresentationStyle"></a>ModalPresentationStyle</h4><p>​        <code>presented VC </code>的<code>modalPresentationStyle</code>属性决定了此次<code>presentation</code>的行为方式及UIKit寻找<code>presentation context</code>的方法，iOS提供了以下几种常用的<code>presentation style</code></p>
<ol>
<li><p><strong>UIModalPresentationFullScreen</strong></p>
<p>UIKit默认的<code>presentation style</code>。 使用这种模式时，<code>presented VC</code>的宽高与屏幕相同，并且UIKit会直接使用<code>rootViewController</code>做为<code>presentation context</code>，在此次presentation完成之后，UIKit会将<code>presentation context及其子VC</code>都移出UI栈，这时候观察VC的层级关系，会发现UIWindow下只有<code>presented VC</code>（视图层级下UIWindow上只有presented VC）.</p>
</li>
<li><p><strong>UIModalPresentationCurrentContext</strong></p>
<p>使用这种方式<code>present VC</code>时，<code>presented VC</code>的宽高取决于<code>presentation context</code>的宽高，并且UIKit会寻找属性<code>definesPresentationContext</code>为YES的VC作为<code>presentation context</code> 。当此次<code>presentation</code>完成之后，<code>presentation context</code>及其子VC都将被暂时移出当前的UI栈。</p>
</li>
<li><p><strong>UIModalPresentationCustom</strong></p>
<p>自定义模式，需要实现UIViewControllerTransitioningDelegate的相关方法，并将presented VC的transitioningDelegate 设置为实现了UIViewControllerTransitioningDelegate协议的对象。</p>
</li>
<li><p><strong>UIModalPresentationOverFullScreen</strong></p>
<p>与<code>UIModalPresentationFullScreen</code>的唯一<strong>区别</strong>在于，UIWindow下除了<code>presented VC</code>，还有其他正常的VC层级关系。也就是说该模式下，UIKit以<code>rootViewController</code>为<code>presentation context</code>，但presentation完成之后不会将<code>rootViewController移出当前的UI栈</code>。</p>
</li>
<li><p><strong>UIModalPresentationOverCurrentContext</strong></p>
<p>寻找<code>presentation context</code>的方式与<code>UIModalPresentationCurrentContext</code>相同，所不同的是<code>presentation</code>完成之后，不会将<code>context及其子VC移出当前UI栈</code>。但是，这种方式只<strong>适用于transition style为UIModalTransitionStyleCoverVertical的情况</strong>(UIKit默认就是这种transition style)。其他transition style下使用这种方式将会触发异常。</p>
</li>
<li><p><strong>UIModalPresentationBlurOverFullScreen</strong></p>
<p><code>presentation</code>完成之后，如果<code>presented VC</code>的背景有透明部分，会看到presented VC下面的VC会变得模糊，其他与<code>UIModalPresentationOverFullScreen</code>模式没有区别。</p>
</li>
<li><p><strong>UIModalPresentationPageSheet</strong></p>
<p>在常规型设备（大屏手机，例如plus系列以及iPad系列）的水平方向，<code>presented VC</code>的高为当前屏幕的高度，宽为该设备竖直方向屏幕的宽度，其余部分用透明背景做填充。对于紧凑型设备（小屏手机）的水平方向及所有设备的竖直方向，其显示效果与<code>UIModalPresentationFullScreen</code>相同。</p>
</li>
<li><p><strong>UIModalPresentationFormSheet</strong></p>
<p>在常规型设备的水平方向，<code>presented VC</code>的宽高均小于屏幕尺寸，其余部分用透明背景填充。对于紧凑型设备的水平方向及所有设备的竖直方向，其显示效果与<code>UIModalPresentationFullScreen</code>相同</p>
</li>
</ol>
<p><code>UIModalPresentationFullScreen</code>、<code>UIModalPresentationCurrentContext</code>在转场完成后会将<code>context及其子VC移出当前UI栈</code>,因此转场结束后是无法看到presenting的视图的，而其他情况下的style是可以看到的</p>
<h4 id="presentation-context"><a href="#presentation-context" class="headerlink" title="presentation context"></a>presentation context</h4><blockquote>
<p><code>presentation context</code>是指为本次<code>present</code>提供上下文环境的类，需要指出的是，<code>presenting VC</code>通常并不是<code>presentation context</code></p>
</blockquote>
<p>​        当我们需要<code>present VC</code>的时候，除非我们指定了<code>context</code>，否则UIKit会优先选择<code>presenting VC</code>所属的容器类做为<code>presentation context</code>，如果没有容器类，那么会选择<code>rootViewController</code>。但是，UIKit搜索context的方式还与<code>presented VC</code>的<code>modalPresentationStyle</code>属性有关，当<code>modalPresentationStyle</code>为<code>UIModalPresentationFullScreen</code>、<code>UIModalPresentationOverFullScreen</code>等模式时，UIKit会直接选择<code>rootViewController</code>做为<code>context</code>。当<code>modalPresentationStyle</code>为<code>UIModalPresentationOverCurrentContext</code>、<code>UIModalPresentationCurrentContext</code>模式时，UIKit搜索<code>context</code>的方式如下：</p>
<ul>
<li><p><code>UIModalPresentationOverCurrentContext</code>、<code>UIModalPresentationCurrentContext</code>模式下，一个VC能否成为<code>presentation context</code> 是由VC的<code>definesPresentationContext</code>属性决定的，这是一个<code>BOOL</code>值，默认<code>UIViewController的definesPresentationContext</code>属性值是<code>NO</code>，而<strong>container view controller</strong>（容器控制器）的<code>definesPresentationContext</code>默认值是<code>YES</code>，这也是上文中，UIKit总是将<code>container view controller</code>做为<code>presentation context</code>的原因。如果我们想指定<code>presenting VC</code>做为<code>context</code>，只需要在<code>presenting VC</code>的<code>viewDidLoad</code>方法里添加如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.definesPresentationContext = YES</span><br></pre></td></tr></table></figure></li>
</ul>
<p>UIKit搜索<code>presentation context</code>的顺序为： </p>
<ol>
<li><code>presenting VC</code> </li>
<li><code>presenting VC</code> 的<code>父VC </code></li>
<li><code>presenting VC</code> 所属的<code>container VC </code></li>
<li><code>rootViewController</code></li>
</ol>
<h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><blockquote>
<p><strong>presented VC 总是与 presentation context 处于同一层级，而与presenting VC所在的层级无关，且同一个presentation context同时只能有一个presented VC。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>协议注意的点</title>
    <url>/2021/07/10/iOS%E5%AD%A6%E4%B9%A0/Swift%E7%AC%94%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="协议注意的点"><a href="#协议注意的点" class="headerlink" title="协议注意的点"></a>协议注意的点</h1><h2 id="已重写的限制条件会在某些泛型上下文中失效"><a href="#已重写的限制条件会在某些泛型上下文中失效" class="headerlink" title="已重写的限制条件会在某些泛型上下文中失效"></a>已重写的限制条件会在某些泛型上下文中失效</h2><p>对于一些通过条件遵循获得了特定行为的类型，在某些泛型上下文中，并不能够确保能够使用协议限制中的特定实现。为了说明这个行为，下面的例子中定义了两个协议以及一个有条件地遵循两个协议的泛型类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protocol Loggable &#123;</span><br><span class="line">    func log()</span><br><span class="line">&#125;</span><br><span class="line">extension Loggable &#123;</span><br><span class="line">    func log() &#123;</span><br><span class="line">        print(self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol TitledLoggable: Loggable &#123;</span><br><span class="line">    static var logTitle: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">extension TitledLoggable &#123;</span><br><span class="line">    func log() &#123;</span><br><span class="line">        print(&quot;\(Self.logTitle): \(self)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Pair&lt;T&gt;: CustomStringConvertible &#123;</span><br><span class="line">    let first: T</span><br><span class="line">    let second: T</span><br><span class="line">    var description: String &#123;</span><br><span class="line">        return &quot;(\(first), \(second))&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Pair: Loggable where T: Loggable &#123; &#125;</span><br><span class="line">extension Pair: TitledLoggable where T: TitledLoggable &#123;</span><br><span class="line">    static var logTitle: String &#123;</span><br><span class="line">        return &quot;Pair of &#x27;\(T.logTitle)&#x27;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension String: TitledLoggable &#123;</span><br><span class="line">    static var logTitle: String &#123;</span><br><span class="line">        return &quot;String&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当其泛型类型遵循<code>Loggable</code> 协议以及 <code>TitleLoggale</code> 协议时，结构体 <code>Pair</code> 遵循 <code>Loggable</code> 协议以及 <code>TitleLoggale</code> 协议。下面的例子中，<code>oneAndTwo</code> 是 <code>Pair&lt;String&gt; </code>的一个实例。因为 <code>String</code> 遵循 <code>TitleLoggable</code>，因此 <code>oneAndTwo</code> 也遵循此协议。当 <code>log()</code> 方法被 <code>oneAndTwo</code> 直接调用时，此方法使用的是包含标题的特定版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let oneAndTwo = Pair(first: &quot;one&quot;, second: &quot;two&quot;)</span><br><span class="line">oneAndTwo.log()</span><br><span class="line">// Prints &quot;Pair of &#x27;String&#x27;: (one, two)&quot;</span><br></pre></td></tr></table></figure>
<p>虽然如此，当<code>oneAndTwo</code> 在泛型上下文中使用，或者它是 <code>Loggable/TitledLoggable</code> 类型的实例时，包含标题的特定版本 <code>log()</code> 方法不会被使用。<strong>Swift 只会根据这样的规则来选择 log() 的实现版本—— <code>Pair 遵循 Loggable 所需要的最少的限制条件</code>。因此 Loggable 所提供的默认实现版本会被使用</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let oneAndTwo:Loggable = Pair(first: &quot;one&quot;, second: &quot;two&quot;)</span><br><span class="line">oneAndTwo.log()</span><br><span class="line">// Prints &quot;(one, two)&quot;</span><br><span class="line">let oneAndTwo:TitledLoggable = Pair(first: &quot;one&quot;, second: &quot;two&quot;)</span><br><span class="line">oneAndTwo.log()</span><br><span class="line">// Prints &quot;(one, two)&quot;</span><br></pre></td></tr></table></figure>
<h2 id="协议的动态派发"><a href="#协议的动态派发" class="headerlink" title="协议的动态派发"></a>协议的动态派发</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protocol Chef &#123;</span><br><span class="line">    func makeFood()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Chef &#123;</span><br><span class="line">    func makeFood() &#123;</span><br><span class="line">        print(&quot;makeFood&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct SeafoodChef: chef &#123;</span><br><span class="line">    func makeFood() &#123;</span><br><span class="line">        print(&quot;Cook Seafood&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Chef &#123;</span><br><span class="line">    func makeFood()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Chef &#123;</span><br><span class="line">    func makeFood() &#123;</span><br><span class="line">        print(&quot;makeFood&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct SeafoodChef: Chef &#123;</span><br><span class="line">    func makeFood() &#123;</span><br><span class="line">        print(&quot;Cook Seafood&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let chefone:Chef = SeafoodChef()</span><br><span class="line">let cheftwo:SeafoodChef =  SeafoodChef()</span><br><span class="line">chefone.makeFood() //Cook Seafood</span><br><span class="line">cheftwo.makeFood() //Cook Seafood</span><br></pre></td></tr></table></figure>
<ul>
<li>上述的结果均为<code>Cook Seafood</code>，因为协议中是动态派发、扩展中是静态派发，如果是协议的方法会根据对象的实际类型进行调用</li>
<li>如果将协议中的<code>makeFood()</code>方法去掉，则会打印<code>makeFood Cook Seafood</code>,如果没有协议方法，则会根据声明类型进行调用。</li>
</ul>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
  </entry>
  <entry>
    <title>碰到的一些问题</title>
    <url>/2021/07/10/iOS%E5%AD%A6%E4%B9%A0/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="场景图片的问题"><a href="#场景图片的问题" class="headerlink" title="场景图片的问题"></a>场景图片的问题</h3><ol>
<li>从相册中导出全场景图片存在的问题<ol>
<li>压缩图片的质量</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[PHCachingImageManager defaultManager]</span><br><span class="line">        requestImageDataForAsset:mAsset</span><br><span class="line">                         options:nil</span><br><span class="line">                   resultHandler:^(NSData *_Nullable imageData, NSString *_Nullable dataUTI, UIImageOrientation orientation, NSDictionary *_Nullable info) &#123;</span><br><span class="line">                     UIImage *resultImage = [UIImage imageWithData:imageData];</span><br><span class="line">                     //获得的image要转换为正确的方向</span><br><span class="line">                    // 然后将该image导入到本地文件中</span><br><span class="line">                     //注意要用jpg的形式导入本地，否则，图片文件的大小会激增，有4M多变成90Mb（原因未知）</span><br><span class="line">                      BOOL result = [UIImageJPEGRepresentation(image, 0.5) writeToFile:filePath atomically:YES];</span><br><span class="line">                     //采用png的形式保存场景图片，会出现存储图片内存激增</span><br><span class="line">                     BOOL result = [UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];</span><br><span class="line">                   &#125;];</span><br></pre></td></tr></table></figure>

<p>​        2. 全场景图片一般为十几万✖️几千的分辨率，上述压缩的方式可以使全场景图片在iphone6plus上显示，没有卡顿现象，但是这样的图片在iphone6上仍有有明显的卡顿，</p>
<h3 id="单例block引用导致内存泄漏的问题"><a href="#单例block引用导致内存泄漏的问题" class="headerlink" title="单例block引用导致内存泄漏的问题"></a>单例block引用导致内存泄漏的问题</h3><ol>
<li>注意如果block为单例的属性，那么在该block中要注意内存泄露的问题，因为单例会一直无法释放，会一直持有属性，而属性会一直持有block中的对象，那么就会导致block中捕获的对象，造成对象无法释放</li>
<li>如果是方法中的block，那么方法在执行完毕之后，便会释放block，不会一直持有，不用担心内存泄露的问题</li>
</ol>
]]></content>
      <categories>
        <category>零碎知识点</category>
      </categories>
  </entry>
  <entry>
    <title>iOS视图控制器转场详解</title>
    <url>/2021/07/02/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/iOS%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BD%AC%E5%9C%BA%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>视图控制器中的视图显示在屏幕上有两种方式：</p>
<ol>
<li>最主要的方式是内嵌在容器控制器中，比如<code>UINavigationController</code>（<code>push</code>或<code>pop</code>一个<code>viewController</code>），<code>UITabBarController</code>（切换到其他<code>viewController</code>）, <code>UISplitController</code>；</li>
<li>由另一个视图控制器显示它，也就是模态(<code>Modal</code>)显示(以Model方式显示另一个<code>viewController</code>)</li>
</ol>
<p>在 <code>storyboard</code> 里，每个<code>View Controller</code>是一个<code> Scene</code>，<code>View Controller Transition </code>便是从一个 <code>Scene</code> 转换到另外一个 <code>Scene</code>。</p>
<p>在iOS7之前，只能使用系统提供的转场效果，iOS7之后开放相关API运行对转场效果进行定制</p>
</blockquote>
<span id="more"></span>

<h3 id="Transition-解释"><a href="#Transition-解释" class="headerlink" title="Transition 解释"></a>Transition 解释</h3><p>转场时视图控制器和其对应的视图在结构上的变化：</p>
<p><img src="1.png" alt="1.png"></p>
<p>​        转场过程中，作为容器的父 VC 维护着多个子 VC，但在视图结构上，只保留一个子 VC 的视图，所以转场的本质是下一场景(子 VC)的视图替换当前场景(子 VC)的视图以及相应的控制器(子 VC)的替换，表现为当前视图消失和下一视图出现。</p>
<h3 id="系统自带的方式"><a href="#系统自带的方式" class="headerlink" title="系统自带的方式"></a>系统自带的方式</h3><h4 id="CATransition"><a href="#CATransition" class="headerlink" title="CATransition"></a>CATransition</h4><p><code>CATransition</code>是<code>CAAnimation</code>的子类，用于过渡动画或转场动画。为视图层移入移除屏幕提供转场动画。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CATransition *animation = [CATransition animation];</span><br><span class="line">animation.type = type;</span><br><span class="line">animation.subtype = kCATransitionFromRight;</span><br><span class="line">animation.duration = 1.0;</span><br><span class="line">[vc.view.window.layer addAnimation:animation forKey:kCATransition];</span><br></pre></td></tr></table></figure>

<ul>
<li>type：转场动画的类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fade=1,                   //淡入淡出</span><br><span class="line">  pageCurl,                 //翻页</span><br><span class="line">  push,                     //推挤</span><br><span class="line">  pageUnCurl,               //反翻页</span><br><span class="line">  reveal,                   //揭开</span><br><span class="line">  cameraIrisHollowOpen,     //开镜头</span><br><span class="line">  moveIn,                   //覆盖</span><br><span class="line">  cameraIrisHolowClose,     //关镜头</span><br><span class="line">  cube,                     //立方体</span><br><span class="line">  suckEffect,               //吮吸</span><br><span class="line">  oglFlip,                  //翻转</span><br><span class="line">  rippleEffect,             //波纹</span><br></pre></td></tr></table></figure>

<ul>
<li>subtype：动画类型的方向，4个方向上下左右</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kCATransitionFromRight,</span><br><span class="line">kCATransitionFromLeft,</span><br><span class="line">kCATransitionFromTop,</span><br><span class="line">kCATransitionFromBottom</span><br></pre></td></tr></table></figure>

<h4 id="TransitionFromViewController"><a href="#TransitionFromViewController" class="headerlink" title="TransitionFromViewController"></a>TransitionFromViewController</h4><ul>
<li>同一页面显示多个视图的方式，采用<code>UIViewController</code>自带的方法：<code>transitionFromViewController:toViewController:duration:options:animations:completion:</code>这种转场动画是在当一个父视图控制器中有几个<code>childViewController</code>，当要在这个几个子视图控制器之间切换时可以用这个方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1. 在一个控制器内加入多个子控制器</span><br><span class="line">[self addChildViewCOntroller:fristVc];</span><br><span class="line">[self addChildViewCOntroller:secondVc];</span><br><span class="line">//2. 当前控制器显示的视图</span><br><span class="line">[self.view addSubview:[self.childViewControllers[0] view]];</span><br><span class="line">//3. 多视图的转换</span><br><span class="line">/*</span><br><span class="line">     *  fromViewController      当前显示在父视图控制器中的子视图控制器</span><br><span class="line">     *  toViewController        将要显示的姿势图控制器</span><br><span class="line">     *  duration                动画时间(这个属性,old friend 了 O(∩_∩)O)</span><br><span class="line">     *  options                 动画效果(渐变,从下往上等等,具体查看API)</span><br><span class="line">     *  animations              转换过程中的动画</span><br><span class="line">     *  completion              转换完成</span><br><span class="line">*/</span><br><span class="line">[self transitionFromViewController:self.childViewControllers[0] toViewController:self.childViewControllers[1] duration:0.5 options:UIViewAnimationOptionTransitionCurlUp animations:^&#123;</span><br><span class="line">        </span><br><span class="line"> &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="Transition-Animation（自定义转场动画的实现）"><a href="#Transition-Animation（自定义转场动画的实现）" class="headerlink" title="Transition Animation（自定义转场动画的实现）"></a>Transition Animation（自定义转场动画的实现）</h4><p>官方支持以下几种方式的自定义转场：</p>
<ol>
<li><code>UINavigationController</code> 中<code> push</code> 和 <code>pop</code></li>
<li><code> UITabBarController</code> 中切换 <code>Tab</code></li>
<li><code>Modal</code>转场：<code>presentation</code> 和 <code>dismissal</code>，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code> 这两种模式;</li>
<li><code>UICollectionViewController</code> 的布局转场：<code>UICollectionViewController </code>与 <code>UINavigationController </code>结合的转场方式</li>
</ol>
<p>转场协议由5种协议组成，实际中只需要提供其中的两个或者三个便能实现绝大部分的转场动画</p>
<h5 id="转场代理（Transition-Delegate）"><a href="#转场代理（Transition-Delegate）" class="headerlink" title="转场代理（Transition Delegate）"></a>转场代理（<strong>Transition Delegate</strong>）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。</span><br><span class="line">&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。</span><br><span class="line">&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。</span><br></pre></td></tr></table></figure>

<ul>
<li>转场发生时，<code>UIKit </code>将要求转场代理将提供转场动画的核心构件：动画控制器和交互控制器(可选的)；由我们实现。</li>
</ul>
<h5 id="动画控制器-Animation-Controller-："><a href="#动画控制器-Animation-Controller-：" class="headerlink" title="动画控制器(Animation Controller)："></a>动画控制器(Animation Controller)：</h5><ul>
<li>最重要的部分，负责添加视图以及执行动画；遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议。</li>
</ul>
<h5 id="交互控制器-Interaction-Controller-："><a href="#交互控制器-Interaction-Controller-：" class="headerlink" title="交互控制器(Interaction Controller)："></a>交互控制器(Interaction Controller)：</h5><p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议；系统已经打包好现成的类供我们使用。</p>
<h5 id="转场环境-Transition-Context"><a href="#转场环境-Transition-Context" class="headerlink" title="转场环境(Transition Context):"></a>转场环境(Transition Context):</h5><p>提供转场中需要的数据；遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议；由 <code>UIKit </code>在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</p>
<h5 id="转场协调器-Transition-Coordinator-："><a href="#转场协调器-Transition-Coordinator-：" class="headerlink" title="转场协调器(Transition Coordinator)："></a>转场协调器(Transition Coordinator)：</h5><p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<code>&lt;UIViewCOntrollerTrabsitionCoordinator&gt;</code>协议；由<code> UIKit</code> 在转场时生成，<code>UIViewController</code> 在 iOS 7 中新增了方法<code> transitionCoordinator()</code>返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</p>
<h3 id="阶段一：非交互转场"><a href="#阶段一：非交互转场" class="headerlink" title="阶段一：非交互转场"></a>阶段一：非交互转场</h3><blockquote>
<p>这个阶段要做两件事，提供转场代理并由代理提供动画控制器。在转场代理协议里动画控制器和交互控制器都是可选实现的，没有实现或者返回 nil 的话则使用默认的转场效果。动画控制器是表现转场效果的核心部分</p>
</blockquote>
<h4 id="动画控制器协议"><a href="#动画控制器协议" class="headerlink" title="动画控制器协议"></a>动画控制器协议</h4><ol>
<li>动画控制器实现代理<code>&lt;UIViewControllerAnimatedTransitioning&gt;</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; </span><br><span class="line">  //1. </span><br><span class="line">  UIView *container = [transitionContext containerView];</span><br><span class="line">  </span><br><span class="line">  //2. </span><br><span class="line"> if ([transitionContext respondsToSelector:@selector(viewForKey:)]) &#123;</span><br><span class="line">        // iOS8以上新增加API获取参与转场的视图，能精确获取参与转场的视图</span><br><span class="line">        fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line">        toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">   		//获取参与转场的控制器视图</span><br><span class="line">        fromView = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey].view;</span><br><span class="line">        toView = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey].view;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  //3. </span><br><span class="line">  [container addSubview:toView];</span><br><span class="line">  ......</span><br><span class="line">  [UIView animateWithDuration:[self transitionDuration:transitionContext] 					animations:^&#123;</span><br><span class="line">  				  ......</span><br><span class="line">        &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">    //4. </span><br><span class="line">   					BOOL isCancelled = [transitionContext transitionWasCancelled];</span><br><span class="line">            [transitionContext completeTransition:!isCancelled];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>返回容器视图，也就是转场动画发生的地方</li>
<li>通过<code>viewForKey:</code>获取的视图是<code>viewControllerForKey:</code>返回的控制器的根视图，或者<code> nil</code>。<code>viewForKey:</code>方法返回<code> nil</code> 只有一种情况：<code> UIModalPresentationCustom</code>以及 <code> UIModalPresentationOverFullScreen</code>等模式下的<code> Modal</code> 转场 （这些转场结束后不会移除<code>preserting</code>），通过此方法获取 <code>presentingView </code>时得到的将是 nil。</li>
<li>将<code>toView</code>添加到容器视图中，使得<code>toView</code>在屏幕上显示（<code>Modal</code>转场中此点稍有不同）</li>
<li>正确地结束转场过程。转场的结果有两种：完成或取消。非交互转场的结果只有完成一种情况，不过交互式转场需要考虑取消的情况。如何结束取决于转场的进度，通过<code>transitionWasCancelled</code>方法来获取转场的状态，使用<code>completeTransition:</code>来完成或取消转场</li>
</ol>
<p>​    转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的场景的视图为<code> fromView</code>，对应的视图控制器为<code> fromVC</code>，即将出现的视图为 <code>toView</code>，对应的视图控制器称之为<code> toVC</code>。几种转场方式的转场操作都是可逆的，一种操作里的<code> fromView</code> 和 <code>toView</code> 在逆向操作里的角色互换成对方，<code>fromVC</code> 和<code>toVC</code>也是如此。在动画控制器里，参与转场的视图只有 <code>fromView </code>和<code> toView</code> 之分，与转场方式无关。</p>
<p>​    实际上无论是简单的转场动画，还是那些很复杂的转场动画在转场的部分要做的事情都是上面提到的4个过程，它们的区别主要在于动画的部分。</p>
<h5 id="逐帧播放的动画方式"><a href="#逐帧播放的动画方式" class="headerlink" title="逐帧播放的动画方式"></a>逐帧播放的动画方式</h5><blockquote>
<p>与原来的动画相比能在动画里面，在通过帧率逐帧的实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView animateKeyframesWithDuration:self.duration delay:0 options:0 animations:^&#123;</span><br><span class="line">            [UIView addKeyframeWithRelativeStartTime:0 relativeDuration:0.9 animations:^&#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;];</span><br><span class="line">            [UIView addKeyframeWithRelativeStartTime:0.9 relativeDuration:0.1 animations:^&#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">            [imageView removeFromSuperview];</span><br><span class="line">            BOOL wasCancelled = [transitionContext transitionWasCancelled];</span><br><span class="line">            [transitionContext completeTransition:!wasCancelled];</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure>

<h4 id="特殊的Modal转场"><a href="#特殊的Modal转场" class="headerlink" title="特殊的Modal转场"></a>特殊的Modal转场</h4><blockquote>
<p>Modal 转场中需要做的事情和两种容器 VC 的转场一样，但在细节上有些差异。</p>
</blockquote>
<p><img src="2.png" alt="2.png"></p>
<ol>
<li>根视图是否参与转场</li>
</ol>
<p>​        <code>   UINavigationController</code>和<code>UITabBarController</code>这两个容器 <code>VC</code> 的根视图在屏幕上是不可见的(或者说是透明的)，可见的只是内嵌在这两者中的<code>子 VC </code>中的视图，转场是从<code>子 VC </code>的视图转换到另外一个<code>子 VC </code>的视图，其根视图并未参与转场；而<code>Modal</code>转场，以 <code>presentation </code>为例，是从 <code>presentingView </code>转换到 <code>presentedView</code>，根视图 <code>presentingView </code>也就是<code>fromView</code>参与了转场。而且 <code>NavigationController</code> 和 <code>TabBarController</code> 转场中的<code> containerView</code> 也并非这两者的根视图。</p>
<ol start="2">
<li>转场后的<code>fromView</code>是否依然可见</li>
</ol>
<p>​        <code>Modal </code>转场结束后 <code>presentingView </code>可能依然可见，除<code>UIModalPresentationFullScreen</code>之外，其他模式就是这样。这种不同导致了 <code>Modal </code>转场和<code>容器 VC</code> 的转场对 <code>fromView</code> 的处理差异：<code>容器 VC</code> 的转场结束后 <code>fromView </code>会被主动移出视图结构，这是可预见的结果，我们也可以在转场结束前手动移除；而<code>Modal</code> 转场中，<code>presentation</code> 结束后 <code>presentingView(fromView) </code>并未主动被从视图结构中移除。准确来说，是 <code>UIModalPresentationCustom </code>这种模式下的 <code>Modal</code> 转场结束时<code>fromView</code>并未从视图结构中移除；<code>UIModalPresentationFullScreen </code>模式的<code> Modal</code> 转场结束后<code>fromView</code>依然主动被从视图结构中移除了。这种差异导致在处理<code> dismissal</code> 转场的时候很容易出现问题，没有意识到这个不同点的话出错时就会毫无头绪。</p>
<p>​        下面来看看 <code>dismissal</code> 转场时的场景：</p>
<ol>
<li><code>UIModalPresentationFullScreen </code>模式：:转场时 <code>containerView </code>并不管理 <code>presentingView</code> ，<code>presentation</code> 后，<code>presentingView </code>被主动移出视图结构，在 <code>dismissal</code> 中<code> presentingView</code> 是 <code>toView</code> 的角色，其将会重新加入<code>containerView</code>中，实际上，我们不主动将其加入，<code>UIKit </code>也会这么做，前面的两种容器控制器的转场里不是这样处理的，不过这个差异基本没什么影响。</li>
<li><code>UIModalPresentationCustom 模式</code>:转场时 <code>containerView </code>并不担任 <code>presentingView</code> 的父视图，后者由 <code>UIKit</code> 另行管理。在 <code>presentation</code> 后，<code>fromView(presentingView) </code>未被移出视图结构，在 <code>dismissal </code>中，注意不要像其他转场中那样将 <code>toView(presentingView)</code> 加入 <code>containerView </code>中，否则本来可见的<code> presentingView</code> 将会被移除出自身所处的视图结构消失不见<ol>
<li>这里注意：如果采用<code>viewForKey</code>直接获取视图，那么<code>custon模式</code>下，**present时，<code>fromView（presentingView）为nil</code>，而<code>dimissal</code>时，<code>toView（presentingView）为nil</code>**，也就是用这种方式获取的视图，添加到containerView中，<code>dismissal</code>不会出问题。但是如果通过<code>viewControllerForKey</code>直接获取控制器中的<code>View</code>则不会为nil，这时候添加则会出现问题</li>
</ol>
</li>
</ol>
<h4 id="实现代理"><a href="#实现代理" class="headerlink" title="实现代理"></a>实现代理</h4><ol>
<li><code>UINavigationController</code>转场动画的实现，实现代理 <code>&lt;UINavigationControllerDelegate&gt;</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//self.navigationController.delegate = self;</span><br><span class="line"></span><br><span class="line">-(id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; </span><br><span class="line">  ....</span><br><span class="line">    //返回自定义的动画控制器，push和pop都在这个方法中返回</span><br><span class="line">  switch (operation) &#123;</span><br><span class="line">        case UINavigationControllerOperationPush:</span><br><span class="line">            animationController.type = AnimationTypePush;</span><br><span class="line">            return  animationController;</span><br><span class="line">        case UINavigationControllerOperationPop:</span><br><span class="line">            animationController.type = AnimationTypePop;</span><br><span class="line">            return animationController;</span><br><span class="line">        default: return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>presenting</code>出的视图</li>
</ol>
<h3 id="阶段二：交互式转场"><a href="#阶段二：交互式转场" class="headerlink" title="阶段二：交互式转场"></a>阶段二：交互式转场</h3><blockquote>
<p>实现交互化，在非交互转场的基础上将之交互化需要两个条件：</p>
</blockquote>
<ol>
<li>由转场代理提供交互控制器，这是一个遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。</li>
<li>交互控制器还需要交互手段的配合，最常见的是使用手势</li>
</ol>
<p>正确的提供交互控制器:</p>
<p>​    转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程（比如手势），转场过程将一直处于开始阶段无法结束，应用界面也会失去响应：在<code>NavigationController </code>中点击 <code>NavigationBar </code>也能实现 <code>pop </code>返回操作，但此时没有了交互手段的支持，转场过程卡壳；在 <code>TabBarController </code>的代理里提供交互控制器存在同样的问题，点击 <code>TabBar</code> 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。、</p>
<h4 id="UINavigationControllerDelegaate的交互转场"><a href="#UINavigationControllerDelegaate的交互转场" class="headerlink" title="UINavigationControllerDelegaate的交互转场"></a>UINavigationControllerDelegaate的交互转场</h4><ol>
<li>实现代理方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController</span><br><span class="line">                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController &#123;</span><br><span class="line">    //注意没有手势的时候要返回nil，否则无法通过点击导航栏左边的item正常退出                        </span><br><span class="line">    if (self.interactiveAnimation.isInteractive) &#123;</span><br><span class="line">        return self.interactiveAnimation;</span><br><span class="line">    &#125;</span><br><span class="line">    return  nil</span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure>

<h4 id="modal弹窗显示交互手势"><a href="#modal弹窗显示交互手势" class="headerlink" title="modal弹窗显示交互手势"></a>modal弹窗显示交互手势</h4><ol>
<li>实现代理</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123;</span><br><span class="line">    if (self.interactiveAnimation.isInteractive) &#123;</span><br><span class="line">        return self.interactiveAnimation;</span><br><span class="line">    &#125;</span><br><span class="line">    return  nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="交互控制器的实现"><a href="#交互控制器的实现" class="headerlink" title="交互控制器的实现"></a>交互控制器的实现</h4><p>交互控制器为继承<code>UIPercentDrivenInteractiveTransition</code>的类，主要结合边缘滑动手势</p>
<p><code>UIScreenEdgePanGestureRecognizer</code>，其中主要依靠的方法</p>
<ol>
<li><p><code>[self updateInteractiveTransition:_percent]</code>,更新交互转场完成的百分比;</p>
</li>
<li><p><code>[self finishInteractiveTransition]</code>完成交互转场</p>
</li>
<li><p><code>[self cancelInteractiveTransition];</code>取消交互转场</p>
</li>
</ol>
<h5 id="具体的实现"><a href="#具体的实现" class="headerlink" title="具体的实现"></a>具体的实现</h5><ol>
<li>给页面添加边缘滑动手势</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIScreenEdgePanGestureRecognizer *interactiveTransitionRecognizer  = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(panAction:)];</span><br><span class="line">interactiveTransitionRecognizer.edges = UIRectEdgeLeft;</span><br><span class="line">[vc.view addGestureRecognizer:interactiveTransitionRecognizer];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>找到转场动画的容器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)startInteractiveTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">    [super startInteractiveTransition:transitionContext];</span><br><span class="line">    self.transitionContext = transitionContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实际手势的实现</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)panAction:(UIPanGestureRecognizer *)pan&#123;</span><br><span class="line">    _percent = 0.0;</span><br><span class="line">    //UIView *transitionContainerView = pan.view;从手势中也可以获取手势滑动的view，但是转场动画中涉及3d变化的动画操作，那么将无法从手势中获取相应变换的相对位置</span><br><span class="line">    UIView *transitionContainerView = self.transitionContext.containerView;</span><br><span class="line">    CGFloat totalWidth  = CGRectGetWidth(transitionContainerView.bounds);</span><br><span class="line">    CGFloat totalHeight = CGRectGetHeight(transitionContainerView.bounds);</span><br><span class="line">  	CGFloat x = [pan translationInView:transitionContainerView].x;</span><br><span class="line">            _percent = -x/totalWidth;</span><br><span class="line">  switch (pan.state) &#123;</span><br><span class="line">        case UIGestureRecognizerStateBegan:</span><br><span class="line">            _isInter = YES;</span><br><span class="line">            [self.vc.navigationController popViewControllerAnimated:YES];</span><br><span class="line">    			//  [self.vc dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">            break;</span><br><span class="line">        case UIGestureRecognizerStateChanged:</span><br><span class="line">            [self updateInteractiveTransition:_percent];</span><br><span class="line">            break;</span><br><span class="line">        case UIGestureRecognizerStateEnded:</span><br><span class="line">            _isInter = NO;</span><br><span class="line">            [self continueAction];</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>手势结束后动画UI的变化，</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//采用gui定时器的方式来处理转场动画变换</span><br><span class="line">- (void)continueAction&#123;</span><br><span class="line">    if (_displayLink) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(UIChange)];</span><br><span class="line">    [_displayLink  addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//转场uI的变换</span><br><span class="line">- (void)UIChange &#123;</span><br><span class="line">    CGFloat timeDistance = 2.0/60;</span><br><span class="line">    if (_percent &gt; 0.4) &#123;</span><br><span class="line">        _percent += timeDistance;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        _percent -= timeDistance;</span><br><span class="line">    &#125;</span><br><span class="line">    [self updateInteractiveTransition:_percent];</span><br><span class="line">    if (_percent &gt;= 1.0) &#123;</span><br><span class="line">        [self finishInteractiveTransition];</span><br><span class="line">        [self stopDisplayLink];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_percent &lt;= 0.0) &#123;</span><br><span class="line">        [self stopDisplayLink];</span><br><span class="line">        [self cancelInteractiveTransition];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        </p>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>图层视觉效果</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%B1%82%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图层蒙板"><a href="#图层蒙板" class="headerlink" title="图层蒙板"></a>图层蒙板</h2><blockquote>
<p><code>CALayer</code>有一个属性叫做<code>mask</code>可以解决这个问题，这个属性本身就是个<code>CALayer</code>类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，不同于那些绘制在父图层中的子图层，<code>mask</code>图层定义了父图层的部分可见区域。</p>
</blockquote>
<ul>
<li><code>mask</code>图层的Color属性是无关紧要的，真正重要的是图层的轮廓。其显示的轮廓即为图层能显示的区域</li>
</ul>
<span id="more"></span>

<h2 id="拉伸过滤算法"><a href="#拉伸过滤算法" class="headerlink" title="拉伸过滤算法"></a>拉伸过滤算法</h2><blockquote>
<p>当图片需要显示不同的大小的时候<code>minificationFilter</code>和<code>magnificationFilter</code>属性。，有一种叫做拉伸过滤的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
</blockquote>
<ul>
<li>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。<code>CALayer</code>为此提供了三种拉伸过滤方法，他们是：<ol>
<li> kCAFilterLinear</li>
<li> kCAFilterNearest</li>
<li> kCAFilterTrilinear</li>
</ol>
</li>
</ul>
<h3 id="kCAFilterLinear和kCAFilterTrilinear"><a href="#kCAFilterLinear和kCAFilterTrilinear" class="headerlink" title="kCAFilterLinear和kCAFilterTrilinear"></a><code>kCAFilterLinear</code>和<code>kCAFilterTrilinear</code></h3><ul>
<li><p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是<code>kCAFilterLinear</code>，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。</p>
</li>
<li><p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<h3 id="kCAFilterNearest"><a href="#kCAFilterNearest" class="headerlink" title="kCAFilterNearest"></a><code>kCAFilterNearest</code></h3></li>
<li><p><code>kCAFilterNearest</code>是一种比较武断的方法,这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3></li>
<li><p>总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。因此对于大图来说，双线性滤波和三线性滤波表现得更出色,而对于没有斜线的小图来说，最近过滤算法要好很多。</p>
</li>
<li><p>用法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对于小图片极少斜线的图，用最近的放大算法较好</span><br><span class="line">view.layer.magnificationFilter = kCAFilterNearest;</span><br></pre></td></tr></table></figure>
<h2 id="组透明"><a href="#组透明" class="headerlink" title="组透明"></a>组透明</h2><blockquote>
<p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
</blockquote>
<ul>
<li>下图展示了一个内嵌UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</li>
</ul>
<p><img src="1.png" alt="1.png"></p>
<ul>
<li>这是由透明度混合叠加造成的，当你显示一个个50%透明度的图层时，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来自图层本身的颜色，另外的25%则来自背景色。所以合起来中间标签可见度为75%</li>
<li>处理方法<ul>
<li>可以设置CALayer的一个叫做<code>shouldRasterize</code>属性来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了.</li>
<li>为了启用<code>shouldRasterize</code>属性，我们设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了<code>shouldRasterize</code>属性，你就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕(Retina的像素比和一般屏幕不一样)像素化的问题。</li>
<li>代码</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">button2.layer.shouldRasterize = YES;</span><br><span class="line">button2.layer.rasterizationScale = [UIScreen mainScreen].scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>视频H264硬编码</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E8%A7%86%E9%A2%91H264%E7%A1%AC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>像素的大小是8bit，一张1920✖️1080的图片需要1920✖️1080✖️8✖️3bit / (1024✖️1024) = 47Mbit = 5.8MB；在观看30FPS的视频时，1s需要30张图片，也就是需要47 ✖️ 30 = 1.4Gbit，也就是1.4Gbit的带宽；以我们现在的网络带宽远远不够。所以必须进行视频源压缩编码。</p>
</blockquote>
<span id="more"></span>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS视频采集的格式类型</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/iOS%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86%E7%9A%84%E6%A0%BC%E5%BC%8F%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS定义了很多的视频格式，这里简单介绍一下它的命名规则，具体还需要看开发文档。</p>
</blockquote>
<span id="more"></span>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>在视频采集中，设置视频输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPYNSDictionary *videoSetting = @&#123;(id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;</span><br><span class="line"></span><br><span class="line">self.videoPutData = [[AVCaptureVideoDataOutput alloc] init];</span><br><span class="line">self.videoPutData.videoSettings = videoSetting;</span><br></pre></td></tr></table></figure>

<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol>
<li>命名规则</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPYkCVPixelFormatType_&#123;长度|序列&#125;&#123;颜色空间&#125;&#123;Planar|BiPlanar&#125;&#123;VideoRange|FullRange&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Planar</code>：平面；<code>BiPlanar</code>：双平面</p>
<ul>
<li>平面/双平面主要用在<code>YUV</code>上。<code>UV</code>分开存储为<code>Planar</code>，反之是<code>BiPlanar</code>。所以：<ul>
<li><code>kCVPixelFormatType_420YpCbCr8PlanarFullRange</code>是420p</li>
<li><code>kCVPixelFormatType_420YpCbCr8BiPlanarFullRange</code>是nv12</li>
</ul>
</li>
</ul>
</li>
<li><p><code>VideoRange</code>和<code>FullRange</code> 的区别在于数值的范围，<code>FullRange</code>比<code>VideoRange</code>大一些，颜色也更丰富一些</p>
<ul>
<li>如果没有指定颜色范围，默认都是<code>FullRange</code>。但有一种情况除外，例如:<ul>
<li><code>kCVPixelFormatType_420YpCbCr8Planar</code>和<code>kCVPixelFormatType_420YpCbCr8PlanarFullRange</code>,因为已经有FullRange了，所以未指定的应该为<code>VideoRange</code></li>
</ul>
</li>
</ul>
</li>
<li><p>颜色空间对应的就是它在内存中的顺序。比如<code>  kCVPixelFormatType_32BGRA</code>，内存中的顺序是<code>B G R A B G R A B…</code>。</p>
<ul>
<li>也有一些特别的，比如<code>kCVPixelFormatType_16BE555</code>，这里需要用BE或LE指定字节顺序。其后面还带有一种数字，用于表示bit长度</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS拍摄流程</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/iOS%E6%8B%8D%E6%91%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>iOS相机拍摄所需框架为&lt;ACFoundation/AVFoundation.h&gt;，该框架中基本上包含了视频中所需的全部方法。</p>
</blockquote>
<span id="more"></span>

<h2 id="拍摄的流程"><a href="#拍摄的流程" class="headerlink" title="拍摄的流程"></a>拍摄的流程</h2><h3 id="session-初始化"><a href="#session-初始化" class="headerlink" title="session 初始化"></a>session 初始化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AVCaptureSession alloc] init]</span><br></pre></td></tr></table></figure>

<h3 id="Input初始化"><a href="#Input初始化" class="headerlink" title="Input初始化"></a>Input初始化</h3><ol>
<li>device初始化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//音频设备初始化，AVMediaTypeAudio替换为AVMediaTypeVideo即为视频，默认为后置摄像头</span><br><span class="line">[AVCaptureDeviceInput deviceInputWithDevice:[AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio] error:&amp;error];</span><br><span class="line">//视频设置初始化，详细版</span><br><span class="line">AVCaptureDeviceDiscoverySession *captureDeviceDiscoverySession =</span><br><span class="line">            [AVCaptureDeviceDiscoverySession discoverySessionWithDeviceTypes:@[ AVCaptureDeviceTypeBuiltInWideAngleCamera ] mediaType:AVMediaTypeVideo position:AVCaptureDevicePositionBack];//发现所有后置视频设备的会话</span><br><span class="line">[[AVCaptureDeviceDiscoverySession devices] enumeratObjectsUsingBlock:^(AVCaptureDevice *camera, NSUInteger idx, BOOL *_Nonnull stop) &#123;</span><br><span class="line">            if (camera.position == AVCaptureDevicePositionBack) &#123;</span><br><span class="line">                backCamera = camera;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];//遍历会话获取后置设备，可以对设备进行一些属性设置，例如曝光模式，但是，要调用lockForConfiguration:调用完之后使用unlockForConfiguration方法解锁，</span><br><span class="line">[AVCaptureDeviceInput deviceInputWithDevice:backCamera error:nil];//同样的方式初始化设备输入</span><br></pre></td></tr></table></figure>

<ol>
<li>然后通过<code>canAddInput</code>来判断是否能在会话中，通过<code>addInput</code>将input添加到会话中，视频要添加2个会话，视频输入以及语音输入</li>
<li>如果要切换摄像头<ol>
<li>在<code>session</code>的<code>beginConfiguration</code>和<code>commitConfiguration</code>之间重新设置摄像头，</li>
<li><code>removeInput</code>删除原来的媒体设备输入</li>
<li>获取后置的摄像头的设备<code>AVCaptureDevice</code></li>
<li><code>[AVCaptureDeviceInput deviceInputWithDevice:swithToDevice error:**nil**];</code>重新设置摄像头，并将其添加到<code>session</code>中</li>
<li><strong>注意</strong>，如果为前置摄像头，遍历会话中的<code>outputs</code>，将其输入和输出的连接会话<code>AVCaptureConnection</code>的视频镜像属性<code>videoMirrored</code>，设为<code>YES</code></li>
</ol>
</li>
</ol>
<h3 id="output初始化"><a href="#output初始化" class="headerlink" title="output初始化"></a>output初始化</h3><ol>
<li><p><code>AVCaptureMovieFileOutput</code> 输出视频，</p>
<ol>
<li><p>只用初始化<code>AVCaptureMovieFileOutput</code>，将视频输出加到会话当中</p>
</li>
<li><p>调用<code>startRecordingToOutputFileURl:recordingDelegate:</code>处理输出的视频，通过调用<code>stopRecod</code>停止录屏</p>
</li>
<li><p>实现<code>AVCaptureFileOutputRecordingDelegate</code></p>
<ol>
<li><code>captureOutput:didStartRecordingToOutputFileAtURL:fromConnections:</code>开始写入视频文件时调用</li>
<li><code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>写入完成时调用</li>
</ol>
</li>
</ol>
</li>
<li><p><code>AVAssetWriter</code>输出数据，见第2节</p>
</li>
</ol>
<h3 id="初始化预览层AVCaptureVideoPreviewLayer"><a href="#初始化预览层AVCaptureVideoPreviewLayer" class="headerlink" title="初始化预览层AVCaptureVideoPreviewLayer"></a>初始化预览层AVCaptureVideoPreviewLayer</h3><ol>
<li>根据媒体会话初始化视图层，也就是预览层，该属性可以添加到相应图层的子层中</li>
<li><code>[AVCaptureVideoPreviewLayer layerWithSession:self.captureSession];</code>获取一个预览图层</li>
<li><code>addSublayer</code>加到要显示的视图图层内</li>
</ol>
<h3 id="开始录制"><a href="#开始录制" class="headerlink" title="开始录制"></a>开始录制</h3><ol>
<li><code>[session StartRunning]</code>，会话开始，开始录制（每次录制都需要<code>StartRunning</code>）</li>
</ol>
<h2 id="AVAssetWriter实现拍摄"><a href="#AVAssetWriter实现拍摄" class="headerlink" title="AVAssetWriter实现拍摄"></a>AVAssetWriter实现拍摄</h2><h3 id="初始化视频-音频数据输出"><a href="#初始化视频-音频数据输出" class="headerlink" title="初始化视频/音频数据输出"></a>初始化视频/音频数据输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSDictionary *videoSetting = @&#123;(id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;//32BGRA像素格式，和后面要取的视频帧数据对应</span><br><span class="line">self.videoPutData = [[AVCaptureVideoDataOutput alloc] init];</span><br><span class="line">self.videoPutData.videoSettings = videoSetting;</span><br><span class="line"></span><br><span class="line">[[AVCaptureAudioDataOutput alloc] init];</span><br></pre></td></tr></table></figure>

<p>在<code>canAddOutput</code>判断后，通过<code>addOutput</code>添加到session中</p>
<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>通过<code>setSampleBufferDelegate:queue: </code>设置应该调用回调的缓冲区委托和队列,获取视频流</p>
<h3 id="配置AVAssetWriter"><a href="#配置AVAssetWriter" class="headerlink" title="配置AVAssetWriter"></a>配置AVAssetWriter</h3><ol>
<li><p>配置并发队列，<code>dispatch_async</code>异步执行</p>
</li>
<li><p>在队列中配置<code>AVAssetWriter</code>，用<code>[AVAsswtWriter assWriterWithURL:文件输出地址 fileType:AVFileTypeMPEG4 error:&amp;error]</code>初始化<code>AVAssetWriter</code>;</p>
</li>
<li><p>配置详细参数，视频硬编码参数</p>
<ol>
<li><p>码率和帧率的设置</p>
<ol>
<li><p><code>AVVideoAverageBitRateKey</code>：指单位时间内处理的数据位数，单位是 b/s 。码率=视频文件大小/视频时长。数值越大，显示越精细</p>
</li>
<li><p><code>AVVideoMaxKeyFrameIntervalKey</code>：关键帧最大间隔，1为每个都是关键帧，数值越大压缩率越高，也就是文件越大（如果画面包含大量场景变换或迅速移动的动作或动画，那么减少关键帧距离将会提高图像的整体品质。一个较小的关键帧距离对应于一个较大的输出文件。注意减少了关键帧间距，注意增大比特率也就是码率，保证视频质量）</p>
</li>
<li><p><code>AVVideoProfileLevelKey</code>：H.264专用参数，代表画质级别，从低到高分贝为BP、EP、MP、HP</p>
<ol>
<li><p>而H264最大的优势就是低码率情况下提供高质量的视频图像，总的来说编码流程可以分为五部分：帧间和帧内预测（Estimation）、变换（Transform）和反变换、量化（Quantization）和反量化、环路滤波（Loop Filter）、熵编码（Entropy Coding）</p>
</li>
<li><p>H264为了满足不同设备不同场景的需要（比如直播注重实时性，存储注重压缩比）定义了多种编码层次也就是Profile，具体如下</p>
<ol>
<li><p><code>BaslineProfile</code>：支持I/P 帧，只支持无交错（Progressive）和CAVLC</p>
</li>
<li><p><code>Extended Profile</code>：支持I/P/B/SP/SI 帧，只支持无交错（Progressive）和CAVLC</p>
</li>
<li><p><code>MainProfile</code>：提供I/P/B 帧，支持无交错（Progressive）和交错（Interlaced），也支持CAVLC 和CABAC</p>
</li>
<li><p><code>High Profile</code>：在mainProfile 的基础上增加了8x8内部预测、自定义量化、 无损视频编码和更多的YUV 格式；</p>
</li>
<li><p>视频压缩很重要的一个就是帧间预测，也就是视频相邻的几帧有很大的相关性，变化不会太大，所以存在很多冗余信息，压缩要做的就是去除这些冗余信息。帧类型主要有以下几种</p>
<ol>
<li>I帧表示关键帧，这一帧保留完整的画面数据，解码时只需要本帧数据就可以完成</li>
<li>P帧，前向预测帧，表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前的画面叠加上本帧定义的差别，生成最终画面。</li>
<li>B帧是双向预测帧，也就是B帧记录的是本帧与前后帧的差别，要解码B帧，不仅要取得之前的画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时比较耗费CPU 。</li>
</ol>
</li>
<li><p><code>Profile</code> 越高，压缩比就越高，但是编码、解码时要求的设备性能也就越高，编码、解码的效率也就越低。</p>
</li>
<li><p>这里的<code>level</code>就是对每个<code>profile</code>的能力细分。</p>
<ol>
<li>实时直播</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY低清Baseline Level 1.3</span><br><span class="line">标清Baseline Level 3</span><br><span class="line">半高清Baseline Level 3.1</span><br><span class="line">全高清Baseline Level 4.1</span><br></pre></td></tr></table></figure>

<ol>
<li>存储媒体</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低清 Main Level 1.3</span><br><span class="line">标清 Main Level 3</span><br><span class="line">半高清 Main Level 3.1</span><br><span class="line">全高清 Main Level 4.1</span><br></pre></td></tr></table></figure>

<ol>
<li>高清存储</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">半高清 High Level 3.1</span><br><span class="line">全高清 High Level 4.1</span><br></pre></td></tr></table></figure>

<ol>
<li>iPad 支持：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Baseline Level 1-3.1</span><br><span class="line">Main Level 1-3.1</span><br><span class="line">High Level 1-3.1</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p><code>AVVideoExpectedSourceFrameRateKey</code>：预期的源帧速率，不用于控制帧速率，作为提示提供给视频编码器的，如果使用率自动级别的AVVideoProfileLevelKey，或者源内容的帧率高于30fps，则应设置此项。如果没有指定的话，编码器可能必须丢弃帧以满足位流要求</p>
</li>
</ol>
</li>
<li><p>视频属性设置</p>
<ol>
<li><code>AVVideoCodecKey</code>:用于压缩视频的编码器的名称，这里用的是硬编码AVVideoCodecTypeH264</li>
<li><code>AVVideoWidthKey</code>、AVVideoHeightKey：设定视频的宽高</li>
<li><code>AVVideoScalingModeKey</code>：视频压缩填充的方式，AVVideoScalingModeResizeAspectFill</li>
<li><code>AVVideoCompressionPropertiesKey</code>：视频压缩编码器，压缩的属性字典，即1中码率和帧率的设置</li>
</ol>
</li>
<li><p>音频设置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSDictionary *audioSetting =</span><br><span class="line">                @&#123;AVEncoderBitRatePerChannelKey : @(28000),//声道采样率</span><br><span class="line">                  AVFormatIDKey : @(kAudioFormatMPEG4AAC),//音频格式，在视频中也是mp4格式</span><br><span class="line">                  AVNumberOfChannelsKey : @(1),//声道数</span><br><span class="line">                  AVSampleRateKey : @(22050)&#125;;//采样率</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化视频采集<code>AVAssetWriterInput</code>，采用方法<code>[AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSetting:视频设置]</code>，也用同样方式设置音频采集<code>AVAssetWriterInput</code></li>
<li>对于视频采集，可以通过视频采集的transform来调整视频流的方向，横屏还是竖屏，拍摄完默认是横的，要调整transform属性，<code>self.writerVideoInput.transform = CGAffineTransformMakeRotation(-M_PI / 2.0);</code></li>
<li>最后将视频采集和声音采集，通过<code>canAddInput</code>判断，<code>addInput</code>添加到创建的写入<code>AVAssetWrite</code>中</li>
</ol>
</li>
</ol>
<h3 id="代理实现"><a href="#代理实现" class="headerlink" title="代理实现"></a>代理实现</h3><p>实现<code>AVCaptureAudioDataOutSampleBufferDelegate</code>、<code>AVCaptureVideoDataOutSampleBufferDelegate</code>，具体是在<code>captureOutput:didOutputSampleBuffer:fromConnection:</code>方法中实现（每当输出捕获和输出新视频帧时，委托将接收此消息，并按照其<code>videoSetting</code>属性指定对其进行解码或重新编码，该方法在输出的<code>sampleBufferCallbackQueue</code>属性指定的调度队列上调用，为周期性的调用）</p>
<ol>
<li><p><code>CMSampleBufferRef</code>，是相关媒体流数据，可以获取媒体流的类型为语音还是视频流以及资源的时间戳</p>
</li>
<li><p>在媒体流属性为视频里(确保写入的第一帧为视频图像，保证不会出现有声音但无画面的情况)，调用（AVAssetWriter）的<code>startWriting</code>方法开始写入，从视频流中获取最早时间戳，调用<code>startSessionAtSourceTime</code>，开始写入</p>
<ol>
<li>视频和音频开始写入的判断<code>canWritting</code>（Bool）放在<code>startSessionAtSourceTime</code>下，会导致视频前几帧相同，因为调用<code>startSessionAtSourceTime````就开始录制了，所以要放在startsessionAtSourceTime</code>的上面</li>
</ol>
</li>
<li><p>配置中初始化的视频采集以及声音采集<code>AVAssetWriterInput</code>，在其属性<code>readyForMoreMediaData</code>（输入准备好接收更多数据），调用apppendSampleBuffer:方法，将<code>CMSampleBufferRef</code>添加进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - AVCaptureVideoDataOutputSampleBufferDelegate method</span><br><span class="line">- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123;</span><br><span class="line">    if (!self.videoRecording) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CMFormatDescriptionRef desMedia = CMSampleBufferGetFormatDescription(sampleBuffer);</span><br><span class="line">    CMMediaType mediaType = CMFormatDescriptionGetMediaType(desMedia);</span><br><span class="line"></span><br><span class="line">    if (mediaType == kCMMediaType_Video) &#123;</span><br><span class="line">        if (!self.canWritting) &#123;</span><br><span class="line">            [self.writer startWriting];</span><br><span class="line"></span><br><span class="line">            CMTime timestamp = CMSampleBufferGetPresentationTimeStamp(sampleBuffer);</span><br><span class="line"></span><br><span class="line">            self.canWritting = YES;</span><br><span class="line">            [self.writer startSessionAtSourceTime:timestamp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (self.canWritting) &#123;</span><br><span class="line">        if (mediaType == kCMMediaType_Video) &#123;</span><br><span class="line">            if (self.writerVideoInput.readyForMoreMediaData) &#123;</span><br><span class="line">                BOOL success = [self.writerVideoInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                if (!success) &#123;</span><br><span class="line">                    LOG_DEBUG(@&quot;video write failed&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else if (mediaType == kCMMediaType_Audio &amp;&amp; self.canWritting) &#123;</span><br><span class="line">            if (self.writerAudioInput.readyForMoreMediaData) &#123;</span><br><span class="line">                BOOL success = [self.writerAudioInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                if (!success) &#123;</span><br><span class="line">                    LOG_DEBUG(@&quot;audio write failed&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="录制完成"><a href="#录制完成" class="headerlink" title="录制完成"></a>录制完成</h3><p>AVCaptureSession的startRunning方法是个耗时操作，如果在主线程调用的话会卡UI。完成写入，AVAssetWriter的状态为正在写入，则调用<code>finishWritingWithCompletionHandler:</code>完成数据的写入</p>
<h2 id="AVAssetWriter实现视频压缩"><a href="#AVAssetWriter实现视频压缩" class="headerlink" title="AVAssetWriter实现视频压缩"></a>AVAssetWriter实现视频压缩</h2><h3 id="传统视频压缩的方式"><a href="#传统视频压缩的方式" class="headerlink" title="传统视频压缩的方式"></a>传统视频压缩的方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVURLAsset *avAsset = [AVURLAsset URLAssetWithURL:inputURL options:nil];</span><br><span class="line">AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:avAsset presetName:AVAssetExportPresetMediumQuality];//视频压缩的类型，还有AVAssetExportPresset960x540具体压缩的分辨率</span><br><span class="line">   exportSession.outputURL = outputURL;</span><br><span class="line">   exportSession.outputFileType = AVFileTypeMPEG4;</span><br><span class="line">   exportSession.shouldOptimizeForNetworkUse = YES;</span><br><span class="line">   [exportSession exportAsynchronouslyWithCompletionHandler:^(void) &#123;</span><br><span class="line">       switch(exportSession.status) &#123;</span><br><span class="line">         case AVAssetExportSessionStatusCompleted://压缩完成</span><br><span class="line">         case AVAssetExportSessionStatusFailed://压缩失败</span><br><span class="line">         default:</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>

<p>绝大多数的情况下可以通过传统的压缩方式对视频进行压缩。为了获得最大的视频压缩率(最低的码率)最好的方式是</p>
<ol>
<li>指定high的<code>profile</code></li>
<li>降低帧率</li>
<li>适当降低分辨率</li>
</ol>
<p>但是传统的压缩方式不支持指定profile，帧率和码率，所以只有通过其他方式来实现。可以在相机录像时需要将拍摄的每一帧<code>sampleBuffer</code>（音频或者视频）传给<code>AVassetWriter</code>，并制定压缩参数。</p>
<h3 id="AVAassetWriter实现视频压缩"><a href="#AVAassetWriter实现视频压缩" class="headerlink" title="AVAassetWriter实现视频压缩"></a>AVAassetWriter实现视频压缩</h3><h4 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h4><p><img src="1.png" alt="img"></p>
<h4 id="代码的实现"><a href="#代码的实现" class="headerlink" title="代码的实现"></a>代码的实现</h4><ol>
<li>初始化<code>reader</code>，<code>writer</code>，<code>video/audio track</code>, <code>video/audio input</code>, <code>video/audio output</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)comppressVideoUrl:(NSURL *) videoUrl withOutputUrl:(NSURL *)outputUrl &#123;</span><br><span class="line">    AVAsset *asset = [AVAsset assetWithURL:videoUrl];</span><br><span class="line">    AVAssetReader *reader = [AVAssetReader assetReaderWithAsset:asset error:nil];</span><br><span class="line">    AVAssetWriter *writer = [AVAssetWriter assetWriterWithURL:outputUrl fileType:AVFileTypeMPEG4 error:nil];</span><br><span class="line">    </span><br><span class="line">    AVAssetTrack *videoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] firstObject];//获取轨道，一般视频至少两个轨道，一个播放声音的一个播放画面的</span><br><span class="line">    </span><br><span class="line">    //视频输出源</span><br><span class="line">    NSDictionary *videoOuptSetting = @&#123;(id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;</span><br><span class="line">    AVAssetReaderTrackOutput *videoOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:videoTrack outputSettings:videoOuptSetting];</span><br><span class="line">    </span><br><span class="line">    //视频采集输入设置，</span><br><span class="line">    // 码率和帧率设置</span><br><span class="line">    NSDictionary *compressionProperties = @&#123;</span><br><span class="line">        AVVideoAverageBitRateKey : @(DSScreenWidth() * DSScreenHeight()*12),</span><br><span class="line">        AVVideoExpectedSourceFrameRateKey : @(15),</span><br><span class="line">        AVVideoMaxKeyFrameIntervalKey : @(10),</span><br><span class="line">        AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //视频属性</span><br><span class="line">    NSDictionary *videoSetting = @&#123;</span><br><span class="line">        AVVideoCodecKey : AVVideoCodecTypeH264,</span><br><span class="line">        AVVideoWidthKey : @(DSScreenHeight() * 2),</span><br><span class="line">        AVVideoHeightKey : @(DSScreenWidth() * 2),</span><br><span class="line">        AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill,</span><br><span class="line">        AVVideoCompressionPropertiesKey : compressionProperties</span><br><span class="line">    &#125;;</span><br><span class="line">    AVAssetWriterInput *videoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:videoSetting];</span><br><span class="line">  //注意要设置视频的方向，每个视频都有方向，这里先获取视频的方向</span><br><span class="line">  int degress = [self degressFromVideoFileWithAsset:asset];</span><br><span class="line">    videoInput.transform = CGAffineTransformMakeRotation(M_PI * (degress / 180.0));</span><br><span class="line">    if([reader canAddOutput:videoOutput])&#123;</span><br><span class="line">        [reader addOutput:videoOutput];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([writer canAddInput:videoInput]) &#123;</span><br><span class="line">        [writer addInput:videoInput];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //音频部分</span><br><span class="line">  //音频输出设置，和视频拍摄不一样，视频拍摄时，指点了缓存流的格式，而文件压缩的时候则没有因此视频和音频一定要设置输出格式</span><br><span class="line">  NSDictionary *readerOutputSettings = @&#123;AVFormatIDKey: @(kAudioFormatLinearPCM)&#125;;</span><br><span class="line">    AVAssetTrack *audioTrack = [[asset tracksWithMediaType:AVMediaTypeAudio] firstObject];</span><br><span class="line">    AVAssetReaderTrackOutput *audioOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:audioTrack outputSettings:readerOutputSettings];</span><br><span class="line">    //声音采集设置</span><br><span class="line">    NSDictionary *audioSetting =</span><br><span class="line">        @&#123;AVEncoderBitRatePerChannelKey : @(28000),</span><br><span class="line">          AVFormatIDKey : @(kAudioFormatMPEG4AAC),</span><br><span class="line">          AVNumberOfChannelsKey : @(1),</span><br><span class="line">          AVSampleRateKey : @(22050)&#125;;</span><br><span class="line">    AVAssetWriterInput *audioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:audioSetting];</span><br><span class="line">    if ([reader canAddOutput:audioOutput]) &#123;</span><br><span class="line">        [reader addOutput:audioOutput];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([writer canAddInput:audioInput]) &#123;</span><br><span class="line">        [writer addInput:audioInput];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取视频的方向</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// 获取视频的方向</span><br><span class="line">+ (int)degressFromVideoFileWithAsset:(AVAsset *)asset &#123;</span><br><span class="line">    int degress = 0;</span><br><span class="line">    NSArray *tracks = [asset tracksWithMediaType:AVMediaTypeVideo];</span><br><span class="line">    if ([tracks count] &gt; 0) &#123;</span><br><span class="line">        AVAssetTrack *videoTrack = [tracks objectAtIndex:0];</span><br><span class="line">        CGAffineTransform t = videoTrack.preferredTransform;</span><br><span class="line">        if (t.a == 0 &amp;&amp; t.b == 1.0 &amp;&amp; t.c == -1.0 &amp;&amp; t.d == 0) &#123;</span><br><span class="line">            // Portrait</span><br><span class="line">            degress = 90;</span><br><span class="line">        &#125; else if (t.a == 0 &amp;&amp; t.b == -1.0 &amp;&amp; t.c == 1.0 &amp;&amp; t.d == 0) &#123;</span><br><span class="line">            // PortraitUpsideDown</span><br><span class="line">            degress = 270;</span><br><span class="line">        &#125; else if (t.a == 1.0 &amp;&amp; t.b == 0 &amp;&amp; t.c == 0 &amp;&amp; t.d == 1.0) &#123;</span><br><span class="line">            // LandscapeRight</span><br><span class="line">            degress = 0;</span><br><span class="line">        &#125; else if (t.a == -1.0 &amp;&amp; t.b == 0 &amp;&amp; t.c == 0 &amp;&amp; t.d == -1.0) &#123;</span><br><span class="line">            // LandscapeLeft</span><br><span class="line">            degress = 180;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return degress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>开始读写</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY[reader startReading];</span><br><span class="line">[writer startWriting];</span><br><span class="line">[writer startSessionAtSourceTime:KCMTimeZero];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设置写入的队列，注意音频、视频写入的队列要一样的，并且是FIFO队列。因为是写入同一个writer，如果用并发，会出现reader的状态不对，导致崩溃</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t writeQueueCreate = dispatch_queue_create(&quot;writeQueueCreate&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>视频逐帧写入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[videoInout requestMediaDataWhenReadyOnQueue:  usingBlock:^&#123;</span><br><span class="line">  while ([videoInput isReadyForMoreMediaData]) &#123;</span><br><span class="line">    CMSampleBufferRef sampleBuffer;</span><br><span class="line">    if ([reader status] == AVAssetReaderStatusReading &amp;&amp; (sampleBuffer = [videoOutput copyNextSampleBuffer]))&#123;</span><br><span class="line">      BOOL result = [videoInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">      CFRelease(sampleBuffer);</span><br><span class="line">      if (!result) &#123;</span><br><span class="line">        [reader cancelReading];</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [videoInput markAsFinished];</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>音频逐帧写入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span><br><span class="line">[audioInout requestMediaDataWhenReadyOnQueue:  usingBlock:^&#123;</span><br><span class="line">  while ([audioInput isReadyForMoreMediaData]) &#123;</span><br><span class="line">    CMSampleBufferRef sampleBuffer;</span><br><span class="line">    if ([reader status] == AVAssetReaderStatusReading &amp;&amp; (sampleBuffer = [audioOutput copyNextSampleBuffer]))&#123;</span><br><span class="line">      BOOL result = [audioInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">      CFRelease(sampleBuffer);</span><br><span class="line">      if (!result) &#123;</span><br><span class="line">        [reader cancelReading];</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [audioInput markAsFinished];</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>完成压缩</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_group_notify(group,dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAYLT,0),^&#123;</span><br><span class="line">  if ([reader status] == AVAssetReaderStatusReading)&#123;</span><br><span class="line">    [reader cancelReading];</span><br><span class="line">  &#125;</span><br><span class="line">  switch (writer.status) &#123;</span><br><span class="line">    case AVAssetWriterStatusWriting:</span><br><span class="line">      &#123;</span><br><span class="line">        [writer finishWritingWithCompletionHandler:^&#123;</span><br><span class="line">          </span><br><span class="line">        &#125;];</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    default:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频学习</category>
      </categories>
  </entry>
  <entry>
    <title>图层几何学</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%B1%82%E5%87%A0%E4%BD%95%E5%AD%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图层布局"><a href="#图层布局" class="headerlink" title="图层布局"></a>图层布局</h2><blockquote>
<p>UIView有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，CALayer对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。<code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>（也可以理解为中心）所在的位置。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>下图显示了这些属性是如何展示的：<br><img src="1.png" alt="img"></p>
</li>
<li><p>视图的<code>frame</code> ，<code>bounds</code>和<code>center</code>属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<ul>
<li>对于视图或者图层而言，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，<code>frame</code>都会变化。相反，改变frame的值同样会影响到他们当中的值</li>
<li>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了,具体见下图</li>
</ul>
</li>
</ul>
<p><img src="2.png" alt="img"></p>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><blockquote>
<p>视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置。默认来说<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。对于UIView而言，没有暴露<code>anchorPoint</code>,只有center；而图层的暴露出来了，<code>anchorPoint</code>可以被移动。anchorPoint为单位坐标</p>
</blockquote>
<p><img src="3.png" alt="img"></p>
<ul>
<li>改变<code>anchorPoint</code>，图层的内容会向右下角的<code>position</code>方向移动，而并不是居中了;图中当改变anchorPoint，position是<code>anchorPoint</code>与父图层的位置，由于锚点的变化，相对位置的基础点，发生改变（从原来中心点，变成了右上角），图层右下角移动，frame改变了。</li>
<li><code>anchorPoint</code>属性为锚点，一般在<code>transform</code>图层旋转中常用到，作为旋转的基点.</li>
</ul>
<h3 id="Z坐标轴"><a href="#Z坐标轴" class="headerlink" title="Z坐标轴"></a>Z坐标轴</h3><blockquote>
<p>和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了<code>position</code>和<code>anchorPoint</code>属性之外，CALayer还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
</blockquote>
<ul>
<li><code>zPosition</code>常用的地方<ul>
<li><code>CATransform3D</code>,在三维空间移动和旋转图层</li>
<li>改变图层的显示顺序<ul>
<li>通常，图层是根据它们子图层的sublayers出现的顺序来类绘制的，后被绘制上的图层将会遮盖住之前的图层。</li>
<li>但是通过增加图层的<code>zPosition</code>,可以把图层前置显示，在其他图层的前面，（图层是很薄的，在这里只用提高一个像素即可实现前置）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图层中常用的方法"><a href="#图层中常用的方法" class="headerlink" title="图层中常用的方法"></a>图层中常用的方法</h2><blockquote>
<p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。这里有两个常见的方法帮处理事件：</p>
<ol>
<li><code>-containsPoint:</code></li>
<li><code>-hitTest:</code></li>
</ol>
</blockquote>
<ul>
<li><code>-containsPoint:</code>,接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层frame范围内就返回YES</li>
<li><code>-hitTest:</code>,方法同样接受一个<code>CGPoint</code>类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。<ul>
<li><code>注意</code>当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上<code>图层的顺序</code>，但不能改变<code>事件传递的顺序</code>。</li>
<li>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。</li>
</ul>
</li>
</ul>
<h2 id="图层的视觉效果展示"><a href="#图层的视觉效果展示" class="headerlink" title="图层的视觉效果展示"></a>图层的视觉效果展示</h2><blockquote>
<p>一些常用的视觉显示所需要的图层属性</p>
</blockquote>
<ol>
<li><p>圆角:</p>
<ol>
<li><code>cornerRadius</code>,控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角）</li>
<li><code> masksToBounds</code>,默认情况下，<code>cornerRadius</code>只影响背景颜色而不影响背景图片或是子图层,把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会受到影响，被截取。</li>
</ol>
</li>
<li><p>图层边框</p>
<ol>
<li><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0</li>
<li><code>borderColor</code>定义了边框的颜色，默认为黑色。(CGColorRef类型，而不是UIColor)</li>
</ol>
</li>
<li><p>阴影</p>
<ol>
<li><code>shadowOpacity</code>:给<code>shadowOpacity</code>属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下</li>
<li><code>shadowColor</code>属性控制着阴影的颜色,(CGColorRef),默认是黑色</li>
<li><code>shadowOffset</code>属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。默认值是 {0, -3}(Mac与iphone的y轴颠倒的，因此在mac上是向下，而iphone是向上)</li>
<li><code>shadowRadius</code>属性控制着阴影的模糊度，为0的时候，阴影就和视图一样有一个非常确定的边界线，当值越来越大的时候，边界线看上去就会越来越模糊和自然。<ol>
<li>注意，阴影通常就是在layer的边界之外，如果开启masksToBounds属性，所有从图层中突出来的内容都会被裁剪掉，阴影也就不存在了</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="shadowPath属性"><a href="#shadowPath属性" class="headerlink" title="shadowPath属性"></a><code>shadowPath</code>属性</h3><blockquote>
<p><code>shadowPath</code>属性,图层阴影是从图层内容的形状继承而来,实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候</p>
</blockquote>
<ol>
<li>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。<ol>
<li><code>shadowPath</code>是一个<code>CGPathRef</code>类型(一个指向CGPath的指针)。CGPath是一个<code>Core Graphics</code>对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</li>
<li>代码</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//enable layer shadows</span><br><span class="line">  self.layerView1.layer.shadowOpacity = 0.5f;</span><br><span class="line">  self.layerView2.layer.shadowOpacity = 0.5f;</span><br><span class="line"></span><br><span class="line">  //方形的阴影</span><br><span class="line">  CGMutablePathRef squarePath = CGPathCreateMutable();</span><br><span class="line">  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);</span><br><span class="line">  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);</span><br><span class="line"></span><br><span class="line">  ￼//圆形的阴影</span><br><span class="line">  CGMutablePathRef circlePath = CGPathCreateMutable();</span><br><span class="line">  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);</span><br><span class="line">  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>iOS核心动画技巧</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/iOS%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CALayer和UIView的区别"><a href="#CALayer和UIView的区别" class="headerlink" title="CALayer和UIView的区别"></a>CALayer和UIView的区别</h2><blockquote>
<p><code>CALayer</code>类在概念上和<code>UIView</code>类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和<code>UIView</code>最大的不同是<code>CALayer</code>不处理用户的交互。<code>CALayer</code>并不清楚具体的<em>响应链</em>（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
</blockquote>
<span id="more"></span>

<h3 id="平行层级关系"><a href="#平行层级关系" class="headerlink" title="平行层级关系"></a>平行层级关系</h3><ul>
<li><p>每一个<code>UIview</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<em>backing layer</em>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作</p>
</li>
<li><p>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，<code>UIView</code>仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
</li>
<li><p>但是为什么iOS要基于<code>UIView</code> 和 <code>CALayer</code></p>
<p>提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？</p>
<ul>
<li>原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和<code>UIView</code>，但是Mac OS有AppKit和<code>NSView</code>的原因。他们功能上很相似，但是在实现上有着显著的区别。</li>
<li>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</li>
</ul>
</li>
<li><p>图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些<code>UIView</code>没有暴露出来的CALayer的功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
</li>
</ul>
<h3 id="CALayer一些特殊属性"><a href="#CALayer一些特殊属性" class="headerlink" title="CALayer一些特殊属性"></a>CALayer一些特殊属性</h3><h3 id="contents属性"><a href="#contents属性" class="headerlink" title="contents属性"></a>contents属性</h3><ul>
<li>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</li>
<li>事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的<code>contents</code>，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象(OC对象)，而是一个Core Foundation类型。实际要用<code>layer.contents = (__bridge id)image.CGImage;</code></li>
</ul>
<h3 id="contentsGravity"><a href="#contentsGravity" class="headerlink" title="contentsGravity"></a>contentsGravity</h3><blockquote>
<p>对于加载的图片无法适应视图时，对于UIimageView有一个contentMode属性，<code>view.contentMode = UIViewContentModeScaleAspectFit;</code>，而CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。</p>
</blockquote>
<ul>
<li><code>self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</code>，<code>kCAGravityResizeAspect</code>，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</li>
</ul>
<h3 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h3><blockquote>
<p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。它的优先级要低于了<code>contentsGravity</code>。</p>
</blockquote>
<ul>
<li><code>contentsScale</code>属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置<code>contentsGravity</code>属性）。UIView有一个类似功能但是非常少用到的<code>contentScaleFactor</code>属性。</li>
<li>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕</li>
<li>这并不会对我们在使用<code>kCAGravityResizeAspect</code>时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把<code>contentsGravity</code>设置为<code>kCAGravityCenter</code>（这个值并不会拉伸图片）。</li>
<li>和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。可以通过设置<code>self.layerView.layer.contentsScale = image.scale;</code></li>
</ul>
<h3 id="maskToBounds"><a href="#maskToBounds" class="headerlink" title="maskToBounds"></a>maskToBounds</h3><blockquote>
<p>默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。UIView有一个叫做<code>clipsToBounds</code>的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做<code>masksToBounds</code>。</p>
</blockquote>
<h3 id="contentsRect"><a href="#contentsRect" class="headerlink" title="contentsRect"></a>contentsRect</h3><blockquote>
<p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比<code>contentsGravity</code>灵活多了和<code>bounds</code>，<code>frame</code>不同，<code>contentsRect</code>不是按点来计算的，它使用了<em>单位坐标</em>，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。</p>
</blockquote>
<ul>
<li>iOS使用了以下的坐标系统：<ol>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ol>
</li>
<li>默认的<code>contentsRect</code>是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪。事实上给<code>contentsRect</code>设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</li>
<li>可以通过<code>contentsRect</code>从大图中截取小图，分给其他的视图（1个image，分给不同的视图显示），因为单张大图比多张小图载入地更快，可以有效地提高了载入性能</li>
</ul>
<h3 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h3><blockquote>
<p><code>contentsCenter</code>其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
</blockquote>
<ul>
<li>默认情况下，<code>contentsCenter</code>是{0, 0, 1, 1}，这意味着如果大小（由<code>conttensGravity</code>决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。下图展示了<code>contentsCenter</code>设置为{0.25, 0.25, 0.5, 0.5}的效果。</li>
</ul>
<p><img src="1.png" alt="img"></p>
<h2 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h2><blockquote>
<p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
</blockquote>
<ul>
<li><p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
</li>
<li><p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费。这为屏外渲染而非GPU渲染</p>
</li>
<li><p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来(屏外渲染的缓存区)直到它需要被更新（通常是因为开发者调用了<code>-setNeedsDisplay</code>方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
</li>
<li><p>CALayer有一个可选的<code>delegate</code>属性，实现了<code>CALayerDelegate</code> 协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议（凡是NSObject或其子类的类别，都是非正式协议）。其代理方法有：</p>
<ul>
<li><code>- (void)displayLayer:(CALayerCALayer *)layer;</code></li>
<li><code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</code></li>
<li>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</li>
</ul>
</li>
<li><p>当使用寄宿了视图的图层的时候，你也不必实现<code>-displayLayer:</code>和<code>-drawLayer:inContext:</code>方法来绘制你的寄宿图。通常做法是实现UIView的<code>-drawRect:</code>方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用<code>-display</code>方法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS动画学习</category>
      </categories>
  </entry>
  <entry>
    <title>Block的类型</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Block%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h1><table>
<thead>
<tr>
<th>block类型</th>
<th>环境</th>
</tr>
</thead>
<tbody><tr>
<td><em>NSGlobalBlock</em></td>
<td>没有访问auto变量</td>
</tr>
<tr>
<td><em>NSStackBlock</em></td>
<td>访问了auto变量</td>
</tr>
<tr>
<td><em>NSMallocBlock</em></td>
<td>_NSStackBlock_调用了copy</td>
</tr>
</tbody></table>
<ul>
<li>注意在非ARC环境下是准确的，如果在ARC环境下,编译器会根据情况，将栈上的block,变成<code>NSMalloCBlock</code></li>
<li>每一种block调用copy后的结果如图所示</li>
</ul>
<table>
<thead>
<tr>
<th>block的类</th>
<th>副本源的配置存储域</th>
<th>赋值效果</th>
</tr>
</thead>
<tbody><tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody></table>
<ul>
<li><p>在ARC环境下，编译器会根据情况，将栈上的block,拷贝到堆上,有以下情况</p>
<ol>
<li><code>block</code>作为函数的返回值时</li>
<li>将<code>block</code>赋值给<code>__strong</code>引指针</li>
<li><code>block</code>作为<code>Cocoa api</code>名含有<code>usingBlock</code>的方法参数输入时</li>
<li><code>block</code>作为<code>GCD API</code>的方法参数时</li>
</ol>
</li>
<li><p>在将有_weak的方法，使用clang转换OC为C++代码时，注意支持ARC、以及指定运行时系统版本</p>
<ul>
<li><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-16.0.0 main.m -o main.cpp</code></li>
</ul>
</li>
</ul>
<h2 id="当block内部访问了对象类型的auto变量时"><a href="#当block内部访问了对象类型的auto变量时" class="headerlink" title="当block内部访问了对象类型的auto变量时"></a>当block内部访问了对象类型的auto变量时</h2><ul>
<li><p>如果block是在栈上，将不会对auto变量产生强引用</p>
</li>
<li><p>如果block是在堆上</p>
<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_objc_assign函数</li>
<li>_Block_objc_assign函数会根据auto变量的修饰符（_string、_weak、_unsafe_unretained）做出相应的操作，类似于retain（形成强引用、弱引用）<h2 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="block的内存管理"></a>block的内存管理</h2></li>
</ul>
</li>
<li><p><strong>当block在栈上</strong>时，并不会对<code>__block</code>变量，以及<code>auto</code>的对象产生强引用</p>
</li>
<li><p>当block被copy到堆时</p>
<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会对_block变量形成强引用,会区分是auto对象（会区分是_weak还是_strong），还是_block对象（强引用）</li>
</ul>
</li>
<li><p>当block从堆移除</p>
<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放引用的_block变量</li>
</ul>
</li>
<li><ul>
<li>当<code>__block</code>修饰对象时，其构建的_block变量内，也会有copy方法和dispose方法<ul>
<li>其内copy方法，同样也有<code>_Block_object_assign</code>,以及<code>_Block_object_dispose</code>,对其内修饰的对象进行内存管理（跟外围是_strong还是_weak有一定关系）<ul>
<li> <strong>但是注意，该内存管理只会在ARC下生效，如果在MRC下，在_block不会增加其内对象的引用，属于unowned关系</strong></li>
<li> <strong>如果不是__block,而是直接引用了auto对象，则和此前一样，block直接引用对象(mrc下，copy时，内部也会对auto增加引用)，而非通过__block间接引用</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>_block的生成的对象，通过fowarding去指向的原因</p>
<ul>
<li>在栈上的时候，指针指向自己</li>
<li>而赋值到堆上时，栈上的指向堆上复制的，栈上赋值时，其值是保存堆上的值，从而保证了，无论是在栈上还是堆上修改，最后值都会保存的堆上。最终使用的是堆上的block</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>碎片化笔记</title>
    <url>/2021/06/23/iOS%E5%AD%A6%E4%B9%A0/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A2%8E%E7%89%87%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>记录偶尔发现有用的知识点</p>
</blockquote>
<span id="more"></span>

<h2 id="delegate能一对多吗"><a href="#delegate能一对多吗" class="headerlink" title="delegate能一对多吗"></a>delegate能一对多吗</h2><ul>
<li><p>在不同控制页面实现同一代理，并且执行代理的类为单例执行；代码验证时发现</p>
<ul>
<li>尽管为单例，但是其属性<code>delegate</code>为唯一，与当前控制页是相互持有关系，因此，在页面1时，只会执行页面1上的代理方法；</li>
<li>当从页面1进入页面2后，<code>delegate</code>的对象变成了页面2，因此，在页面2时，只会执行页面1上的代理方法</li>
<li>当从页面2退到页面1后，页面1销毁，由于为weak，弱引用，在页面1上也不会执行代理方法，被销毁的页面2上更不会执行了</li>
</ul>
</li>
<li><p>通过相关的设计也可以实现一对多的关系</p>
<ol>
<li><p>用多播代理的方式，多播代理相比一般的只是多了一个中间层，由中间层实现代理，获取数据；中间层与控制器之间</p>
<ol>
<li>用一个block数组，作为中间层单例的属性</li>
<li>在其他控制器中，都设置一个回调的block，并将该block添加到数组中</li>
<li>在中间层实现代理获取数据的时候，遍历这个blcok数组，将数据进行分发</li>
</ol>
</li>
<li><p>1个代理在多个页面内实现，</p>
<ol>
<li><p>关键点在于</p>
<ol>
<li>协议名称和对象构成一个健值对，形成1-1对应关系</li>
<li><code>NSPointerArray</code>的使用，使得弱引用对象，且在对象释放时自动删除<code>NSPointerArray</code>中的元素。</li>
</ol>
</li>
<li><p>使用</p>
<ol>
<li><p>将其他页面要实现的代理同样均设为一个单例消息分发中心，有一个字典数据(键为协议，值为<code>NSPointerArray</code>，数组中存有各个页面的对象)</p>
</li>
<li><p>在一个页面触发代理后，首先会实现代理的消息分发中心是否实现了，在这里是没有实现相关的代理方法的，</p>
<ol>
<li><p>借助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>

<p>，判断本管理对象是否可以响应方法</p>
<ol>
<li>如果存的<code>pointArray</code>中可以响应方法则返回YES</li>
</ol>
</li>
<li><p>下面有两种方式实现</p>
<ol>
<li>借助<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</code>以及<code>-(void)forwardInvocation:(NSInvocation *)anInvocation;</code>（这两个方法是一起的）。可以实现在多个未销毁页面中，同时实现代理，达成通知的效果，实现消息的分发</li>
<li>也可以单独实现<code>- (id)forwardingTargetForSelector:(SEL)aSelector;</code>（返回未识别消息应首先指向的对象（本来默认是向上传的）），但这是在相应的NSPointArray中找到能实现该方法的对象，只能实现消息的转发，在多个页面的对象中找到真正一个能响应该方法的</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><hr>
<blockquote>
<p>众所周知，当某个对象持有着一个Block的时候，如果在Block内部使用强引用反过来持有这个对象，就会导致引用循环。为了避免引用循环，可以使用__weak修饰符。</p>
</blockquote>
<h4 id="block中的引用"><a href="#block中的引用" class="headerlink" title="block中的引用"></a>block中的引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">  _strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>C语言编译后可以发现，<code>Block</code>本身对<code>self</code>的引用仍然只是弱引用，并不造成引用循环</li>
<li><code>strongSelf</code>只存在于Block对应的函数里，它的生命周期只在这个函数执行的过程中，函数执行前它不会存在，函数执行完它立刻就被释放了.因此<ol>
<li>如果函数执行前self变为nil了，那么函数不会执行，没有任何引用循环发生；</li>
<li>如果函数执行过程中self变为nil了，那么函数一开始声明的strongSelf会暂时持有着self，此时会有一个暂时的引用循环。当函数执行完（即是Block执行完），strongSelf超出作用域被释放，引用循环从这里开始打破。接下来，由于没有任何强引用持有self了，于是self被释放，最后Block也因为没有任何强引用持有它也被释放了。所有对象就都被顺利释放了。</li>
</ol>
</li>
</ol>
<h5 id="解决block循环引用"><a href="#解决block循环引用" class="headerlink" title="解决block循环引用"></a>解决block循环引用</h5><ol>
<li>通过Weak修饰的方式来处理的。 weak是弱引用，用weak来修饰、描述所引用对象的计数器并不会加1，weak会在引用对象被释放的时候自动置为nil</li>
<li><code>__block</code>修饰变量，依赖于中介者模式，属于手动释放。其实现是通过<code>__block</code>修饰对象，因为<code>__block</code>修饰的对象是可以改变的，可以在block中手动的释放掉引用的对象</li>
<li>直接将对象作为参数，直接将对象作为参数传入了block中，block中并没有对对象进行持有，因此也不会造出循环引用的问题</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef void(^TBlock)(ViewController *); </span><br><span class="line">@property(nonatomic, copy) TBlock tBlock; </span><br><span class="line">self.tBlock = ^(ViewController *vc)&#123; </span><br><span class="line">  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(),    ^&#123; </span><br><span class="line">       NSLog(@&quot;%@&quot;,vc.name);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;; </span><br><span class="line">self.tBlock(self);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>NSProxy</code>转发消息打破循环引用，实际上也是使用了<code>weak</code>修饰,在<code>NSProxt</code>中使用了<code>weak</code>来修饰对象属性</li>
</ol>
<h4 id="block中变量捕获"><a href="#block中变量捕获" class="headerlink" title="block中变量捕获"></a>block中变量捕获</h4><ol>
<li>局部变量捕获瞬时值,局部静态变量捕获指针。</li>
<li>全局变量、全局静态变量直接使用不捕获</li>
<li>成员变量是指针捕获</li>
<li>_block修饰自动变量，会将本来传值的，变为地址</li>
</ol>
<h3 id="UIView用weak修饰还是strong修饰"><a href="#UIView用weak修饰还是strong修饰" class="headerlink" title="UIView用weak修饰还是strong修饰"></a>UIView用weak修饰还是strong修饰</h3><hr>
<ol>
<li>从stroryboard中拖出来的控件一般用weak来修饰，这么做的原因是因为stroryboard已经持有控件的，引用计数已经加1了，不需要在用strong时引用数加1，但是用strong修饰也可以，因为在控制器销毁后，不管是strong还是weak，引用计数都会变为0。</li>
<li>在控制器中手写UI也可以用weak修饰，因为subViews为copy修饰的强引用数组，因为会持有控件，但是要注意一定要在addSubview作用范围内进行赋值属性，否则出来作用范围，由于用weak修饰，属性的引用计数为0，会销毁掉；同样用strong修饰的话也可以，在控制器销毁后，不管是strong还是weak，引用计数都会变为0<ol>
<li>注意这里的不能直接对成员变量进行赋值，否则会直接提醒无引用计数，要设置一个临时变量，这样临时变量会暂时持有，等addsubview添加后，由控制器持有</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>零碎知识点</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2017/03/23/iOS%E5%AD%A6%E4%B9%A0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/LXDAppFluecyMonitor-master/LXDAppFluecyMonitor/Assets.xcassets/AppIcon.appiconset/Contents/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>{"images":[{"idiom":"iphone","size":"29x29","scale":"2x"},{"idiom":"iphone","size":"29x29","scale":"3x"},{"idiom":"iphone","size":"40x40","scale":"2x"},{"idiom":"iphone","size":"40x40","scale":"3x"},{"idiom":"iphone","size":"60x60","scale":"2x"},{"idiom":"iphone","size":"60x60","scale":"3x"}],"info":{"version":1,"author":"xcode"}}]]></content>
  </entry>
</search>
