<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>c++面向对像(1) | Ayer</title><meta name="author" content="jingbo"><meta name="copyright" content="jingbo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="类 c++可以适用struct、class来定义一个类。c语言是没有class的。class是c++中的概念  以前c中结构体是无法定义函数的，只能通过函数指针的方式。现在c++中结构体视为类，且能定义方法了    struct和class.(除了权限外，在c++中基本没区别) struct的默认成员权限public class的默认成员权限private    12345678910111213">
<meta property="og:type" content="article">
<meta property="og:title" content="c++面向对像(1)">
<meta property="og:url" content="http://example.com/2023/12/24/C++%E5%AD%A6%E4%B9%A0/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E5%83%8F(1)/index.html">
<meta property="og:site_name" content="Ayer">
<meta property="og:description" content="类 c++可以适用struct、class来定义一个类。c语言是没有class的。class是c++中的概念  以前c中结构体是无法定义函数的，只能通过函数指针的方式。现在c++中结构体视为类，且能定义方法了    struct和class.(除了权限外，在c++中基本没区别) struct的默认成员权限public class的默认成员权限private    12345678910111213">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/banner/banner_46.jpeg">
<meta property="article:published_time" content="2023-12-24T13:26:25.000Z">
<meta property="article:modified_time" content="2024-01-22T04:19:28.334Z">
<meta property="article:author" content="jingbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/banner/banner_46.jpeg"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="http://example.com/2023/12/24/C++%E5%AD%A6%E4%B9%A0/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E5%83%8F(1)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'c++面向对像(1)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-22 12:19:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Ayer" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">133</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">20</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/banner/banner_46.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Ayer"><span class="site-name">Ayer</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">c++面向对像(1)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-12-24T13:26:25.000Z" title="Created 2023-12-24 21:26:25">2023-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-01-22T04:19:28.334Z" title="Updated 2024-01-22 12:19:28">2024-01-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E5%AD%A6%E4%B9%A0/">C++学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="c++面向对像(1)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><blockquote>
<p><code>c++</code>可以适用<code>struct</code>、<code>class</code>来定义一个类。<code>c</code>语言是没有<code>class</code>的。<code>class</code>是<code>c++</code>中的概念</p>
<ul>
<li>以前<code>c</code>中结构体是无法定义函数的，只能通过函数指针的方式。现在<code>c++</code>中结构体视为类，且能定义方法了</li>
</ul>
</blockquote>
<ul>
<li><code>struct</code>和<code>class</code>.(除了权限外，在<code>c++</code>中基本没区别)<ul>
<li><code>struct</code>的默认成员权限<code>public</code></li>
<li><code>class</code>的默认成员权限<code>private</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><br>Person person; <span class="hljs-comment">//创建，对象在栈空间</span><br>person.age = <span class="hljs-number">20</span>;<br>person.<span class="hljs-built_in">run</span>();<br><br>Person *p = &amp;person;<br>p-&gt;age = <span class="hljs-number">20</span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>案例,在汇编中<code>0xcc</code>起到断点的作用，为了防止栈空间中指针指向其他地方，会给栈空间填满<code>0xCC</code>的数据，因此，这里<code>height</code>上的数据，也是<code>0xcccccccc</code>四个字节<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">Person person;<br>person.id = <span class="hljs-number">10</span>;<br>person.age = <span class="hljs-number">20</span>;<br>person.hegiht = <span class="hljs-number">30</span>;<br><br>Person *p = (Person *) &amp;person.age;<br>p-&gt;id = <span class="hljs-number">40</span>;<br>p -&gt;age = <span class="hljs-number">50</span><br><span class="hljs-comment">// 打印当前的 id = 10,age = 40,height = 50;</span><br>person.<span class="hljs-built_in">description</span>(); <br><span class="hljs-comment">// 打印指针p的 id = 40,age = 50,height = 0xcccccccc</span><br>p-&gt;<span class="hljs-built_in">description</span>();<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="存储的位置"><a href="#存储的位置" class="headerlink" title="存储的位置"></a>存储的位置</h2><blockquote>
<p><code>c++</code>中的对象的内存可以存放在</p>
<ul>
<li>全局区（数据段）：全局变量</li>
<li>栈空间：函数里面的局部变量（类中的对象，均在栈）</li>
<li>堆空间：动态申请内存</li>
</ul>
</blockquote>
<h1 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><ul>
<li><p><code>free</code>释放的是对应<code>malloc</code>生成的指针，是不管是生成的<code>char *</code>数组，还是单个的<code>int *</code>。放入指针，均能释放</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *n = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br>*n = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// char 1个字节的</span><br><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  *p = 10;</span><br><span class="hljs-comment">  *(p + 1) = 11;</span><br><span class="hljs-comment">  *(p + 2) = 12;</span><br><span class="hljs-comment">  *(p + 3) = 13;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 两者等价</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>p[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<br>p[<span class="hljs-number">2</span>] = <span class="hljs-number">12</span>;<br>p[<span class="hljs-number">3</span>] = <span class="hljs-number">13</span>;<br><span class="hljs-built_in">free</span>(n);<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure></li>
<li><p><code>malloc</code>生成的对象最开始是不会进行初始化的。</p>
<ul>
<li>推荐初始化方法，赋值，但下面只能对<code>int</code>4字节清零，初始化  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br>*p = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li>
<li><code>memset(p,num,size)</code>(大部分用于将数据结构清零)，从<code>p</code>开始对<code>size</code>内的每一个字节都设置成<code>num</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> size = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">10</span><br><span class="hljs-keyword">int</span> *p = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(size);<br><span class="hljs-comment">// 从p开始，将每一个字节都设置为0</span><br><span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,size);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><ul>
<li><p>申请和释放必须是1对1的关系，不然可能会存在内存泄漏</p>
<ul>
<li>注意<code>new</code>一定要和<code>delete</code>用，不能用<code>free</code></li>
<li>注意，如果是<code>new []</code>,要和<code>delete[]</code>一起用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br>*p = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-comment">// 申请4个字节，类比(char *) malloc(4)</span><br><span class="hljs-keyword">char</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">4</span>];<br><br><br><span class="hljs-keyword">delete</span>[] p1;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p0 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>; <span class="hljs-comment">//不会初始化（不同平台可能会有差异，可能会初始化）</span><br><span class="hljs-keyword">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(); <span class="hljs-comment">// 初始化为0</span><br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 初始化为5</span><br><br><span class="hljs-keyword">int</span> *p3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//数组元素未被初始化</span><br><span class="hljs-keyword">int</span> *p4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>](); <span class="hljs-comment">// 3个数组元素都被初始化为0</span><br><span class="hljs-keyword">int</span> *p5 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]&#123;&#125;;<span class="hljs-comment">// 3个数组元素都被初始化为0</span><br><span class="hljs-keyword">int</span> *p6 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]&#123; <span class="hljs-number">5</span> &#125;; <span class="hljs-comment">// 数组首元素 初始化为5，其他为0</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><blockquote>
<p>构造函数（也叫构造器），在对象创建的时候自动调用，一般用于完成对象的初始化工作</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>函数名与类同名，无返回值（<code>void</code>都不能写），可以有参数，可以重载，可以有多个构造函数</p>
</li>
<li><p>一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象</p>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>通过<code>malloc</code>分配的对象不会调用构造函数</li>
</ul>
</li>
<li><p><strong>注意</strong>,全局区的<code>Person p2();</code>实际是函数声明，不会调用构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Person p1; <span class="hljs-comment">// 调用Person()</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 实际是函数声明</span><br>Person p2&#123;&#125;; <span class="hljs-comment">//调用默认Person()</span><br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 调用Person(Int)</span><br>Person *p4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(); <span class="hljs-comment">// 调用Person()</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="默认情况下"><a href="#默认情况下" class="headerlink" title="默认情况下"></a>默认情况下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-comment">// 全局区初始化变量为0，（全局区默认初始化为0）</span><br>Person g_person;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 栈空间：没有初始化成员变量</span><br>    Person person;<br>    <br>    <span class="hljs-comment">//堆空间 没有初始化成员变量</span><br>    Person *po = <span class="hljs-keyword">new</span> Person;<br>    <span class="hljs-comment">// 堆空间 初始化成员变量为0</span><br>    Person *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>    <span class="hljs-comment">// 3个person对象，不会初始化</span><br>    Person *p2 = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 3个person对象，初始化为0</span><br>    Person *p3 = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">3</span>]();<br>    <span class="hljs-comment">// 3个person对象，初始化为0</span><br>    Person *p4 = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">3</span>]&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="有构造函数"><a href="#有构造函数" class="headerlink" title="有构造函数"></a>有构造函数</h3><blockquote>
<p>如果自定义了构造函数，除了全局区，其他内存空间的成员变量默认都不会被初始化，需要开发人员手动初始化</p>
</blockquote>
<h4 id="空的实现"><a href="#空的实现" class="headerlink" title="空的实现"></a>空的实现</h4><ul>
<li>初始化一个空的构造函数，用<code>new Person()</code>,不会帮忙初始化为<code>0</code>，全局区仍然有数据<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-built_in">Person</span>() &#123;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 全局区初始化变量为0，（全局区默认初始化为0）</span><br>Person g_person;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 栈空间：没有初始化成员变量</span><br>    Person person;<br>    <br>    <span class="hljs-comment">//堆空间 没有初始化成员变量</span><br>    Person *po = <span class="hljs-keyword">new</span> Person;<br>    <span class="hljs-comment">// 堆空间 没有初始化成员变量</span><br>    Person *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>    <span class="hljs-comment">// 堆空间 没有初始化成员变量</span><br>    Person *p1 = <span class="hljs-keyword">new</span> Person&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="初始化方法建议"><a href="#初始化方法建议" class="headerlink" title="初始化方法建议"></a>初始化方法建议</h3><ul>
<li>初始化清理<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Person</span>() &#123;<br>    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Person));<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><ul>
<li><p>特点</p>
<ul>
<li>一种便捷的初始化成员变量的方式</li>
<li>只能用在构造函数中</li>
<li>初始化顺序只跟成员变量的声明顺序有关,(下面<code>age</code>先声明，先赋值<code>age</code>，就算方法列表是<code>height(height),age(age)</code>，仍然先初始化<code>age</code>)<ul>
<li>类比<code>height(myheight()),age(myage())</code>,里面有方法，也是<code>myage()</code>先调用</li>
</ul>
</li>
</ul>
</li>
<li><p>下面两种写法等价，汇编也是一致的,方法列表中，可以放<code>表达式</code>，<code>函数</code>..。（<code>this-&gt;age = x</code>,<code>x</code>可以是什么,<code>age(x)</code>中的<code>x</code>也可以是）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> height):<span class="hljs-built_in">age</span>(age),<span class="hljs-built_in">height</span>(height) &#123;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Person(int age,int height)&#123;</span><br><span class="hljs-comment">            this-&gt;age = age;</span><br><span class="hljs-comment">            this-&gt;height = height;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>默认参数，方法列表赋值的顺序,下面，最终<code>age</code>为<code>10</code>,方法列表中的赋值，是放在函数内执行代码之前的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> height = <span class="hljs-number">0</span>):<span class="hljs-built_in">age</span>(age),<span class="hljs-built_in">height</span>(height) &#123;<br>    age = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>,如果函数声明和实现是分离的</p>
<ul>
<li><strong>初始化列表</strong>只能写在函数的<code>实现</code>中（本质在实现中插入代码，因此必须在<strong>实现</strong>中）</li>
<li><strong>默认参数</strong>只能写在函数的<code>声明</code>中.(声明和实现可能会在不同的地方，编译器，需要根据声明去判断是否有默认参数)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> height = <span class="hljs-number">0</span>);<br>&#125;;<br><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> height):<span class="hljs-built_in">age</span>(age),<span class="hljs-built_in">height</span>(height) &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="构造函数调用构造函数"><a href="#构造函数调用构造函数" class="headerlink" title="构造函数调用构造函数"></a>构造函数调用构造函数</h3><blockquote>
<p>构造函数调用构造函数<strong>必须</strong>是在<code>初始化列表</code>中调用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        Person() &#123; //无法赋值成功</span><br><span class="hljs-comment">             Person(10,20); //这种等于创建了一个临时变量，里面赋值的this和当前的不同</span><br><span class="hljs-comment">         &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) &#123;<span class="hljs-comment">//初始化列表，会把当前的this赋值给Person(10,20)中的this，因此能赋值成功</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> height) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>        <span class="hljs-keyword">this</span>-&gt;heigh = height;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="父类的构造函数"><a href="#父类的构造函数" class="headerlink" title="父类的构造函数"></a>父类的构造函数</h3><ul>
<li>子类的构造函数默认会调用父类的<code>无参构造函数</code></li>
<li>如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数</li>
<li>如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>   <span class="hljs-keyword">int</span> age;<br>   <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">Person</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>   <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age):<span class="hljs-built_in">age</span>(age)&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>:</span> Person &#123;<br>    <span class="hljs-keyword">int</span> no;<br>    <span class="hljs-built_in">Student</span>(): <span class="hljs-built_in">Student</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> no): <span class="hljs-built_in">Person</span>(age),<span class="hljs-built_in">no</span>(no)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><blockquote>
<p>析构函数（也叫析构器），在对象销毁的时候自动调用，一般用于完成对象的清理工作</p>
</blockquote>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li> 函数名以<code>~</code>开头，与类同名，无返回值（<code>void</code>都不能写），无参，不可以重载，有且只有一个析构函数</li>
<li><strong>注意</strong><ul>
<li> 通过<code>malloc</code>分配的对象<code>free</code>的时候不会<strong>调用析构函数</strong></li>
</ul>
</li>
<li>构造函数、析构函数要声明为<code>public</code>，才能被外界正常使用</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Car</span> &#123;</span><br>    <span class="hljs-keyword">int</span> price;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    Car *car;<br>    Car car1; <span class="hljs-comment">//对象car和age在同一空间，不用单独delete释放</span><br>    <span class="hljs-built_in">Person</span>() &#123;<br>        car = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>     <span class="hljs-keyword">delete</span> car;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="构造、析构顺序"><a href="#构造、析构顺序" class="headerlink" title="构造、析构顺序"></a>构造、析构顺序</h1><ul>
<li><strong>注意</strong>，构造是<code>先</code>父类，<code>再</code>子类，而析构是<code>先</code>子类，<code>再</code>父类。析构的顺序和<code>Swift</code>以及<code>OC</code>不同</li>
</ul>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><blockquote>
<p>命名空间可以用来避免命名冲突。命名空间不影响内存布局</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> N &#123;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    &#125;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    N::age = <span class="hljs-number">2</span>;<br>    N::Person *p = <span class="hljs-keyword">new</span> N::<span class="hljs-built_in">Person</span>();<br>    N::<span class="hljs-built_in">test</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>快捷使用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> N;<br>age = <span class="hljs-number">2</span>;<br>Person *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br><span class="hljs-built_in">test</span>();<br></code></pre></td></tr></table></figure></li>
<li>使用单个<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> N:age;<br>age = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="命名空间的嵌套"><a href="#命名空间的嵌套" class="headerlink" title="命名空间的嵌套"></a>命名空间的嵌套</h2><blockquote>
<p>有个默认的全局命名空间，我们创建的命名空间默认都嵌套在它里面</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> N &#123;<br>    <span class="hljs-keyword">namespace</span> M &#123;<br>        <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> age;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ::N::M::age = <span class="hljs-number">10</span>;<br>    N::M::age = <span class="hljs-number">10</span>;<br>    ::age = <span class="hljs-number">20</span>;<span class="hljs-comment">// 用默认命令空间访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote>
<p>继承，可以让子类拥有父类的所有成员（变量\函数）</p>
<ul>
<li><code>c++</code>中，<code>struct</code>和<code>class</code>都是对象，因此都可以继承</li>
<li><code>C++</code>中没有像<code>Java</code>、<code>Objective-C</code>的基类<ul>
<li><code>Java</code>：<code>java.lang.Object</code></li>
<li><code>Objective-C</code>：<code>NSObject</code></li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>:</span> Person &#123;<br>    <span class="hljs-keyword">int</span> no;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="成员访问权限"><a href="#成员访问权限" class="headerlink" title="成员访问权限"></a>成员访问权限</h2><ul>
<li><p>成员访问权限、继承方式有3种</p>
<ul>
<li><code>public</code>：公共的，任何地方都可以访问（<code>struct</code>默认）</li>
<li><code>protected</code>：子类内部、当前类内部可以访问.(外部不行)</li>
<li><code>private</code>：私有的，只有当前类内部可以访问（<code>class</code>默认）</li>
</ul>
</li>
<li><p>子类内部访问父类成员的权限，是以下2项中权限最小的那个</p>
<ul>
<li> 成员本身的访问权限</li>
<li> 上一级父类的继承方式</li>
</ul>
</li>
</ul>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><blockquote>
<p>一般继承方式用<code>Public</code>，这样可以把父类对象中的权限完美继承下来</p>
<ul>
<li>开发中用的最多的继承方式是<code>public</code>，这样能保留父类原来的成员访问权限</li>
</ul>
</blockquote>
<ul>
<li><p><strong>注意</strong>，访问权限不影响对象的内存布局，<code>Student2</code>无法访问<code>no</code>但是还是会继承下来。</p>
<ul>
<li>这样设计的目的是，尽管无法通过成员变量直接访问，但是可以通过<code>set</code>方法设置，实现封装的目的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setNo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        no = num;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> no;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>:</span> <span class="hljs-keyword">private</span> Person &#123; <br><span class="hljs-comment">//以私有的方式继承Person，person中的age，在student中是privare的。等价下面的</span><br><span class="hljs-comment">// private：</span><br><span class="hljs-comment">//    int age;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student2</span>:</span> Public Person &#123; <br>    <span class="hljs-comment">// 访问权限不影响对象的内存布局,Student2会继承 no,但是无法访问no</span><br>    <span class="hljs-comment">// 但是可以通过setNo设置，getNo访问</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>注意</strong>，<code>class</code>默认是<code>private</code>继承（写的时候，注意加上<code>public</code>），<code>struct</code>默认是<code>public</code>继承</p>
</li>
<li><p><code>c++</code>中<code>class</code>和<code>struct</code>只有访问权限的区别，其他基本一致，甚至可以互相继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span> <br>    <span class="hljs-keyword">int</span> age<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>:</span> Public Person &#123;  <span class="hljs-comment">//这样写是没有问题的 </span><br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>多态是面向对象非常重要的一个特性<ul>
<li>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果</li>
<li>在运行时，可以识别出真正的对象类型，调用对应子类中的函数</li>
</ul>
</li>
<li>多态的要素<ul>
<li>子类重写父类的成员函数（override）</li>
<li>父类指针指向子类对象</li>
<li>利用父类指针调用重写的成员函数</li>
</ul>
</li>
</ul>
<h2 id="父类指针、子类指针"><a href="#父类指针、子类指针" class="headerlink" title="父类指针、子类指针"></a>父类指针、子类指针</h2><ul>
<li>父类指针可以指向子类对象，是安全的，开发中经常用到（继承方式必须是<code>public</code>,如果是<code>private</code>则无法指向，编译器会报错）</li>
<li>子类指针指向父类对象(强转实现)是不安全的,访问未知内存</li>
</ul>
<h2 id="默认情况下-1"><a href="#默认情况下-1" class="headerlink" title="默认情况下"></a>默认情况下</h2><blockquote>
<p> 默认情况下，C++编译器只会根据指针类型调用对应的函数，不存在多态</p>
</blockquote>
<ul>
<li>下面，编译器，再编译的时候，根据指针，直接写死了调用的方法，并不会去查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Dog::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">liu</span><span class="hljs-params">(Animal *p)</span> </span>&#123;<br>    p-&gt;<span class="hljs-built_in">speak</span>();<br>    <br>&#125;<br><br><span class="hljs-built_in">liu</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>()); <span class="hljs-comment">// 实际输出&quot;Animal::speak&quot;，而非重写后的&quot;Dog::speak&quot;</span><br>Cat *p = (Cat *)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br>p-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// 实际输出&quot;Cat::speak&quot;,只看指针类型</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote>
<p><code>C++</code>中的多态通过虚函数（<code>virtual function</code>）来实现</p>
</blockquote>
<ul>
<li>虚函数：被<code>virtual</code>修饰的成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Dog::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">liu</span><span class="hljs-params">(Animal *p)</span> </span>&#123;<br>    p-&gt;<span class="hljs-built_in">speak</span>();<br>    <br>&#125;<br><br><span class="hljs-built_in">liu</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>()); <span class="hljs-comment">// 实际输出&quot;Dog::speak&quot;</span><br> <br>p-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// 实际输出&quot;Dog::speak&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数（也就是说子类中可以省略<code>virtual</code>关键字）</p>
<ul>
<li>下面<code>Animal</code>没有虚表，从<code>Cat1</code>开始存在虚表，</li>
<li>编译器还是看指针类型的，如果指针类型中没有虚表，则不会去查<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat1</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat1::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat2</span>:</span> Cat1 &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat2::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>Cat1 *p = (Cat1 *)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat2</span>();<br>Animal *p1 = (Animal *)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat2</span>();<br>p-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// &quot;Cat2::speak&quot;</span><br>p1-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">//&quot;Animal::speak&quot; ,这里不会调用虚表</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调用父类的成员函数的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat2</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        Cat1::<span class="hljs-built_in">speak</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat2::speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><blockquote>
<p>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表</p>
</blockquote>
<ul>
<li>有虚函数的类，会多占<code>4</code>个字节(不同环境下有所不同)，其前<code>4</code>个字节存放虚表地址。虚表地址开始中，每<code>4</code>个字节存放相映虚函数的地址。（在<code>xcode</code>中时<code>8</code>个，windo的<code>x86</code>是<code>4</code>字节）</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><blockquote>
<p>编译器还是根据指针类型的，如果指针类型中没有虚表，则不会去查。那么如果存在父类指针指向子类对象的情况，应该将析构函数声明为虚函数（虚析构函数）。否则，销毁时，只会调用父类的析构函数，而导致实际子类析构函数不会调用，释放不完整</p>
</blockquote>
<ul>
<li><code>delete</code>父类指针时，才会调用子类的析构函数，保证析构的完整性<ul>
<li>下面，如果<code>Animal</code>的析构函数不是虚函数，那么只会调用<code>~Animal</code>,而<code>Cat2</code>中的析构函数不会释放，会出现内存问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    Animal *p = (Animal *)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat2</span>();<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><blockquote>
<p>纯虚函数：没有函数体且初始化为<code>0</code>的虚函数，用来定义接口规范</p>
</blockquote>
<ul>
<li>抽象类（<code>Abstract Class</code>）<ul>
<li>含有纯虚函数的类，不可以实例化（不可以创建对象）</li>
<li>抽象类也可以包含非纯虚函数、成员变量</li>
<li>如果父类是抽象类，子类没有<code>完全重写``纯虚函数</code>，那么这个子类依然是抽象类</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span> <br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runAndSpeak</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;;<br><span class="hljs-comment">//  Animal p;抽象类无法实例</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span>:</span> Animal &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br><span class="hljs-comment">// Dog;speak没有重写，也是抽象类</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog2</span>:</span> Dog &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br><span class="hljs-comment">// Dog2;不是抽象类</span><br>Dog2 dog;<br></code></pre></td></tr></table></figure>

<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><blockquote>
<p><code>C++</code>允许一个类可以有多个父类（不建议使用，会增加程序设计复杂度）</p>
</blockquote>
<ul>
<li><p>多继承子类的内存的分布，看谁先继承，下面中先是<code>student</code>中的变量，再<code>worker</code>,最后是<code>Undergraduate</code>内的(这也是相应构造函数的调用顺序)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span><br>    <span class="hljs-keyword">int</span> score;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span><br>    <span class="hljs-keyword">int</span> salary;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 看先继承谁，谁的内存放在前面</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Undergraduate</span>:</span> <span class="hljs-keyword">public</span> student,<span class="hljs-keyword">private</span> worker &#123;<br>    <span class="hljs-keyword">int</span> grade;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br>Undergraduate ug;<br>ug.score = <span class="hljs-number">100</span>;<br>ug.salary = <span class="hljs-number">100</span>;<br>ug.grade = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>,如果子类继承的多个父类都有<code>虚函数</code>，那么子类对象就会产生对应的<code>多张虚表</code>(其内存会增加，n * 虚表大小的内存)，进行分别管理。</p>
</li>
</ul>
<h3 id="同名函数"><a href="#同名函数" class="headerlink" title="同名函数"></a>同名函数</h3><ul>
<li>多继承，子类中有父类相同的同名函数，选择调用父类中的同名函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Undergraduate ug;<br>ug.worker::<span class="hljs-built_in">work</span>(); <span class="hljs-comment">//调用父类worker中的work函数</span><br>ug.student::<span class="hljs-built_in">study</span>();<span class="hljs-comment">// 调用父类student中的study函数</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="同名成员变量"><a href="#同名成员变量" class="headerlink" title="同名成员变量"></a>同名成员变量</h3><ul>
<li><code>c++</code>支持，继承的时候，父类成员变量和子类成员变量同名，也会将父类同名的成员变量加到子类中(会包含父类同名的内存，和子类的同名的一同存在)。并且均可以存值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span><br>    <span class="hljs-keyword">int</span> score;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span><br>    <span class="hljs-keyword">int</span> salary;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Undergraduate</span>:</span> <span class="hljs-keyword">public</span> student,<span class="hljs-keyword">private</span> worker &#123;<br>    <span class="hljs-keyword">int</span> score; <span class="hljs-comment">//运行同名，在子类和父类同时存在</span><br>    <span class="hljs-keyword">int</span> salary;<br>&#125;;<br><br>Undergraduate ug;<br>ug.worker::salary = <span class="hljs-number">100</span>; <span class="hljs-comment">//给父类的salary赋值</span><br>ug.salary = <span class="hljs-number">10000</span>; <span class="hljs-comment">// 给当前类的salary赋值</span><br><span class="hljs-comment">// 100  10000</span><br>std::cout &lt;&lt; ug.worker::salary &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; ug.salary;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><blockquote>
<p>多继承会出现菱形继承，导致出现二义性</p>
</blockquote>
<ul>
<li><p>这里<code>Undergraduate</code>(占<code>16</code>字节)里面变量为(同时出现了<code>2</code>个<code>age</code>):</p>
<ul>
<li><code>age</code>,<code>score</code>(来自<code>student</code>)</li>
<li><code>age</code>,<code>salary</code>(来自<code>worker</code>)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>:</span> Person &#123;<br>    <span class="hljs-keyword">int</span> score;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span>:</span> Person&#123;<br>    <span class="hljs-keyword">int</span> salary;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Undergraduate</span>:</span> student,worker &#123;<br>&#125;;<br><span class="hljs-comment">// ug.age = 10;报错，出现二义性</span><br><span class="hljs-comment">// 可以成功赋值</span><br>ug.student::age = <span class="hljs-number">20</span>;<br>ug.worker::age = <span class="hljs-number">30</span>;<br><span class="hljs-comment">// 20  30</span><br>std::cout &lt;&lt; ug.student::age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ug.worker::age &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>菱形继承带来的问题</p>
<ul>
<li>最底下子类从基类继承的成员变量冗余、重复</li>
<li>最底下子类无法访问基类的成员，有二义性</li>
</ul>
</li>
</ul>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><ul>
<li>虚继承可以解决菱形继承带来的问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>:</span> <span class="hljs-keyword">virtual</span> Person &#123;<br>    <span class="hljs-keyword">int</span> score = <span class="hljs-number">2</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span>:</span> <span class="hljs-keyword">virtual</span> Person&#123;<br>    <span class="hljs-keyword">int</span> salary = <span class="hljs-number">3</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Undergraduate</span>:</span> student,worker &#123;<br>&#125;;<br><br>ug.age = <span class="hljs-number">10</span>;<span class="hljs-comment">//可以成功赋值，且采用同名成员变量赋值，是同一个</span><br>ug.student::age = <span class="hljs-number">20</span>;<br>ug.worker::age = <span class="hljs-number">30</span>; <br><span class="hljs-comment">// 30   30</span><br>std::cout &lt;&lt; ug.student::age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ug.worker::age &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>Person</code>类被称为虚基类</p>
</li>
<li><p>虚继承之后，会出现虚表指针(切虚基类中的成员变量会放到最后)，虚表指针中存放:</p>
<ul>
<li>虚表指针与本类起始的偏移量（一般是<code>0</code>）</li>
<li>虚基类第一个成员变量与本类起始的偏移量</li>
</ul>
</li>
<li><p>虚继承后的结构类型,这里是<code>Student</code>和<code>worker</code>内存情况。<code>虚基类</code>的成员变量放在最后面<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png"></p>
</li>
<li><p>这是<code>Undergraduate</code>的内存情况。注意虚表指针，指的是本类的起始的偏移量(这里在<code>Undergraduate</code>,也是相对于本类<code>student</code>和<code>worker</code>的位置也是0).<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png"></p>
</li>
</ul>
<h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><ul>
<li>静态成员：被<code>static</code>修饰的成员变量\函数<ul>
<li> 可以通过对象（对象.静态成员）、对象指针（对象指针-&gt;静态成员）、类访问（类名::静态成员）</li>
</ul>
</li>
<li>静态成员变量<ul>
<li>存储在数据段（全局区，类似于全局变量），整个程序运行过程中只有一份内存</li>
<li>对比全局变量，它可以设定访问权限（<code>public</code>、<code>protected</code>、<code>private</code>），达到局部共享的目的</li>
<li>必须初始化，必须在类外面初始化，初始化时不能带<code>static</code>，如果类的声明和实现分离（在实现<code>.cpp</code>中初始化）</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>内部不能使用<code>this</code>指针（<code>this</code>指针只能用在非静态成员函数内部）</li>
<li>不能是虚函数（虚函数只能是非静态成员函数）</li>
<li>内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数</li>
<li>非静态成员函数内部可以访问静态成员变量\函数</li>
<li>构造函数、析构函数不能是静态</li>
<li>当声明和实现分离时，实现部分不能带<code>static</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> price;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">int</span> Car::price = <span class="hljs-number">1</span>; <span class="hljs-comment">//必须在类外面初始化,实现部分，不带static</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Car::run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//当声明和实现分离时（不一定要在外面声明），实现部分不能带`static`，</span><br>    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoMiCar</span>:</span> <span class="hljs-keyword">public</span> Car &#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiCar</span>:</span> <span class="hljs-keyword">public</span> Car &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> price;<br>&#125;;<br><span class="hljs-keyword">int</span> HuaWeiCar::price = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 指针，类名，对象都可以访问，访问的同一个变量</span><br>    Car *car = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>();<br>    car-&gt;price = <span class="hljs-number">1</span>;<br>    car-&gt;<span class="hljs-built_in">run</span>();<br>    <br>    Car::price = <span class="hljs-number">2</span>;<br>    Car::<span class="hljs-built_in">run</span>();<br>    <br>    Car c;<br>    c.price = <span class="hljs-number">3</span>;<br>    c.<span class="hljs-built_in">run</span>();<br>    <br>    <span class="hljs-comment">// XiaoMiCar继承Car，但是和Car中静态变量是同一份内存</span><br>    XiaoMiCar::<span class="hljs-built_in">run</span>();<br>    XiaoMiCar::price = <span class="hljs-number">20</span>;<br>    HuaWeiCar::price = <span class="hljs-number">40</span>; <span class="hljs-comment">// 重新声明的，和Car中不同</span><br>    cout &lt;&lt; Car::price &lt;&lt; endl; <span class="hljs-comment">// 输出20</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>单例模式一般用指针，而不是对象。方便可以回收。</li>
<li>注意和<code>swift</code>静态变量是线程安全不同，<code>c++</code>中是线程不安全的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rocket</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Rocket</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Rocket</span>() &#123;&#125;<br>    <span class="hljs-keyword">static</span> Rocket *_rocket;<br>    <span class="hljs-built_in">Rocket</span>(<span class="hljs-keyword">const</span> Rocket &amp;rocket) &#123;&#125; <span class="hljs-comment">//禁止拷贝构造</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Rocket&amp;rocket)&#123;&#125; <span class="hljs-comment">//禁止赋值</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Rocket *<span class="hljs-built_in">sharedInstance</span>() &#123;<br>        <span class="hljs-keyword">if</span> (_rocket == <span class="hljs-literal">NULL</span>) &#123;<br>            _rocket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rocket</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> _rocket;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteRocket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_rocket != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> _rocket;<br>            _rocket = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 静态变量必须在外面初始化</span><br>Rocket * Rocket::_rocket = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="cost成员"><a href="#cost成员" class="headerlink" title="cost成员"></a>cost成员</h1><blockquote>
<p><code>const</code>成员：被<code>const</code>修饰的成员变量、非静态成员函数</p>
</blockquote>
<ul>
<li><p><code>const</code>成员变量</p>
<ul>
<li>必须初始化（类内部初始化），可以在声明的时候直接初始化赋值</li>
<li>非<code>static</code>的<code>const</code>成员变量还可以在初始化列表中初始化</li>
</ul>
</li>
<li><p><code>const</code>成员函数（非静态）</p>
<ul>
<li><code>const</code>关键字写在参数列表后面，函数的<code>声明</code>和<code>实现</code>都必须带<code>const</code></li>
<li>内部不能修改非<code>static</code>成员变量</li>
<li>内部只能调用<code>const</code>成员函数、<code>static</code>成员函数</li>
<li><code>非const</code>成员函数可以调用<code>const</code>成员函数</li>
<li> <code>const</code>成员函数和<code>非const</code>成员函数构成重载</li>
<li> <code>非const</code>对象（指针）优先调用<code>非const</code>成员函数</li>
<li> <code>const</code>对象（指针）只能调用<code>const</code>成员函数、<code>static</code>成员函数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> price = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Phone</span>():<span class="hljs-built_in">price</span>(<span class="hljs-number">30</span>)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;const run()&quot;</span> &lt;&lt; price &lt;&lt; endl;<br>        Phone::num += <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//test();无法调用</span><br><span class="hljs-comment">//        age += 1; 无法修改非static成员变量</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;run()&quot;</span> &lt;&lt; price &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> Phone::num = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Phone iphonex;<br>    <span class="hljs-comment">// 可以调用const函数和非const函数，优先调用非const函数</span><br>    iphonex.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">//run() 30</span><br>    <span class="hljs-keyword">const</span> Phone iphone;<br>    <span class="hljs-comment">// const只能调用const函数</span><br>    iphone.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// const run() 30</span><br>    <span class="hljs-comment">// 这种只是，指针常量，可以访问const函数和非const函数，优先调用非const函数</span><br>    Phone * <span class="hljs-keyword">const</span> iphone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Phone</span>();<br>    iphone-&gt;<span class="hljs-built_in">run</span>();<br>    <span class="hljs-comment">// const对象，只能调用const函数</span><br>    <span class="hljs-keyword">const</span> Phone * iphone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Phone</span>();<br>    iphone-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="引用类型成员"><a href="#引用类型成员" class="headerlink" title="引用类型成员"></a>引用类型成员</h1><ul>
<li>引用类型成员变量必须初始化（不考虑<code>static</code>情况）<ul>
<li>在声明的时候直接初始化</li>
<li>通过初始化列表初始化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> &amp;price = age;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>(<span class="hljs-keyword">int</span> &amp;price):<span class="hljs-built_in">price</span>(price)&#123; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">jingbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/24/C++%E5%AD%A6%E4%B9%A0/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E5%83%8F(1)/">http://example.com/2023/12/24/C++%E5%AD%A6%E4%B9%A0/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E5%83%8F(1)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/banner/banner_46.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/26/js%E7%9A%84%E5%AD%A6%E4%B9%A0/JavaScriptCore%20/" title="iOS中的JavaScriptCore"><img class="cover" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/banner/banner_55.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">iOS中的JavaScriptCore</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/28/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/%E8%A7%86%E9%A2%91%E8%A7%A3%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/" title="视频解封装格式"><img class="cover" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/banner/banner_48.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">视频解封装格式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">jingbo</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">133</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cjpcxz" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1337811967@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来的bo的博客<div class="twopeople"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text">存储的位置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">堆空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc"><span class="toc-number">2.1.</span> <span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cdelete"><span class="toc-number">2.2.</span> <span class="toc-text">new和delete</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">默认情况下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">有构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">空的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.2.3.</span> <span class="toc-text">初始化方法建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">构造函数调用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">父类的构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">4.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">构造、析构顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">6.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">6.1.</span> <span class="toc-text">命名空间的嵌套</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">7.1.</span> <span class="toc-text">成员访问权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">继承方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%E3%80%81%E5%AD%90%E7%B1%BB%E6%8C%87%E9%92%88"><span class="toc-number">8.1.</span> <span class="toc-text">父类指针、子类指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B-1"><span class="toc-number">8.2.</span> <span class="toc-text">默认情况下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E8%A1%A8"><span class="toc-number">8.3.1.</span> <span class="toc-text">虚表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.2.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.3.</span> <span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">8.4.</span> <span class="toc-text">多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.1.</span> <span class="toc-text">同名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">8.4.2.</span> <span class="toc-text">同名成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">8.4.3.</span> <span class="toc-text">菱形继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">8.4.3.1.</span> <span class="toc-text">虚继承</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">9.</span> <span class="toc-text">静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">单例模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cost%E6%88%90%E5%91%98"><span class="toc-number">10.</span> <span class="toc-text">cost成员</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">11.</span> <span class="toc-text">引用类型成员</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/15/OpenGL/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="基础语法"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/banner/banner_60.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础语法"/></a><div class="content"><a class="title" href="/2024/02/15/OpenGL/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="基础语法">基础语法</a><time datetime="2024-02-15T13:33:35.000Z" title="Created 2024-02-15 21:33:35">2024-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/31/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE/" title="其他协议"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/banner/banner_54.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="其他协议"/></a><div class="content"><a class="title" href="/2024/01/31/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE/" title="其他协议">其他协议</a><time datetime="2024-01-31T15:35:21.000Z" title="Created 2024-01-31 23:35:21">2024-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/29/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http_%E7%9A%84%E5%8D%87%E7%BA%A7%E6%94%B9%E8%BF%9B/" title="http的升级改进"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/banner/banner_48.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="http的升级改进"/></a><div class="content"><a class="title" href="/2024/01/29/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http_%E7%9A%84%E5%8D%87%E7%BA%A7%E6%94%B9%E8%BF%9B/" title="http的升级改进">http的升级改进</a><time datetime="2024-01-29T13:59:43.000Z" title="Created 2024-01-29 21:59:43">2024-01-29</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By jingbo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async src="/js/title.js"></script><script async src="/scripts/modify.js"></script><script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2dw"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 3,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>